{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
catch_amalgamated.cpp\par \pard\plain 
{\tc\tcl2 \v test/catch_amalgamated.cpp}
{\xe \v test/catch_amalgamated.cpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Ir para a documentação desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //              Copyright Catch2 Authors}\par
3 {\cf20 // Distributed under the Boost Software License, Version 1.0.}\par
4 {\cf20 //   (See accompanying file LICENSE.txt or copy at}\par
5 {\cf20 //        https://www.boost.org/LICENSE_1_0.txt)}\par
6 \par
7 {\cf20 // SPDX-License-Identifier: BSL-1.0}\par
8 \par
9 {\cf20 //  Catch v3.6.0}\par
10 {\cf20 //  Generated: 2024-05-05 20:53:27.562886}\par
11 {\cf20 //  ----------------------------------------------------------}\par
12 {\cf20 //  This file is an amalgamation of multiple different files.}\par
13 {\cf20 //  You probably shouldn't edit it directly.}\par
14 {\cf20 //  ----------------------------------------------------------}\par
15 \par
16 {\cf21 #include "catch_amalgamated.hpp"}\par
17 \par
18 \par
19 {\cf21 #ifndef CATCH_WINDOWS_H_PROXY_HPP_INCLUDED}\par
20 {\cf21 #define CATCH_WINDOWS_H_PROXY_HPP_INCLUDED}\par
21 \par
22 \par
23 {\cf21 #if defined(CATCH_PLATFORM_WINDOWS)}\par
24 \par
25 {\cf20 // We might end up with the define made globally through the compiler,}\par
26 {\cf20 // and we don't want to trigger warnings for this}\par
27 {\cf21 #if !defined(NOMINMAX)}\par
28 {\cf21 #  define NOMINMAX}\par
29 {\cf21 #endif}\par
30 {\cf21 #if !defined(WIN32_LEAN_AND_MEAN)}\par
31 {\cf21 #  define WIN32_LEAN_AND_MEAN}\par
32 {\cf21 #endif}\par
33 \par
34 {\cf21 #include <windows.h>}\par
35 \par
36 {\cf21 #endif }{\cf20 // defined(CATCH_PLATFORM_WINDOWS)}\par
37 \par
38 {\cf21 #endif }{\cf20 // CATCH_WINDOWS_H_PROXY_HPP_INCLUDED}\par
39 \par
40 \par
41 \par
42 \par
43 {\cf17 namespace }Catch \{\par
44     {\cf17 namespace }Benchmark \{\par
45         {\cf17 namespace }Detail \{\par
46             ChronometerConcept::~ChronometerConcept() = {\cf19 default};\par
47         \} {\cf20 // namespace Detail}\par
48     \} {\cf20 // namespace Benchmark}\par
49 \} {\cf20 // namespace Catch}\par
50 \par
51 \par
52 {\cf20 // Adapted from donated nonius code.}\par
53 \par
54 \par
55 {\cf21 #include <vector>}\par
56 \par
57 {\cf17 namespace }Catch \{\par
58     {\cf17 namespace }Benchmark \{\par
59         {\cf17 namespace }Detail \{\par
60             SampleAnalysis analyse({\cf17 const} IConfig &cfg, FDuration* first, FDuration* last) \{\par
61                 {\cf19 if} (!cfg.benchmarkNoAnalysis()) \{\par
62                     std::vector<double> samples;\par
63                     samples.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(last - first));\par
64                     {\cf19 for} ({\cf17 auto} current = first; current != last; ++current) \{\par
65                         samples.push_back( current->count() );\par
66                     \}\par
67 \par
68                     {\cf17 auto} analysis = Catch::Benchmark::Detail::analyse_samples(\par
69                         cfg.benchmarkConfidenceInterval(),\par
70                         cfg.benchmarkResamples(),\par
71                         samples.data(),\par
72                         samples.data() + samples.size() );\par
73                     {\cf17 auto} outliers = Catch::Benchmark::Detail::classify_outliers(\par
74                         samples.data(), samples.data() + samples.size() );\par
75 \par
76                     {\cf17 auto} wrap_estimate = [](Estimate<double> e) \{\par
77                         {\cf19 return} Estimate<FDuration> \{\par
78                             FDuration(e.point),\par
79                                 FDuration(e.lower_bound),\par
80                                 FDuration(e.upper_bound),\par
81                                 e.confidence_interval,\par
82                         \};\par
83                     \};\par
84                     std::vector<FDuration> samples2;\par
85                     samples2.reserve(samples.size());\par
86                     {\cf19 for} ({\cf17 auto} s : samples) \{\par
87                         samples2.push_back( FDuration( s ) );\par
88                     \}\par
89 \par
90                     {\cf19 return} \{\par
91                         CATCH_MOVE(samples2),\par
92                         wrap_estimate(analysis.mean),\par
93                         wrap_estimate(analysis.standard_deviation),\par
94                         outliers,\par
95                         analysis.outlier_variance,\par
96                     \};\par
97                 \} {\cf19 else} \{\par
98                     std::vector<FDuration> samples;\par
99                     samples.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(last - first));\par
100 \par
101                     FDuration mean = FDuration(0);\par
102                     {\cf18 int} i = 0;\par
103                     {\cf19 for} ({\cf17 auto} it = first; it < last; ++it, ++i) \{\par
104                         samples.push_back(*it);\par
105                         mean += *it;\par
106                     \}\par
107                     mean /= i;\par
108 \par
109                     {\cf19 return} SampleAnalysis\{\par
110                         CATCH_MOVE(samples),\par
111                         Estimate<FDuration>\{ mean, mean, mean, 0.0 \},\par
112                         Estimate<FDuration>\{ FDuration( 0 ),\par
113                                              FDuration( 0 ),\par
114                                              FDuration( 0 ),\par
115                                              0.0 \},\par
116                         OutlierClassification\{\},\par
117                         0.0\par
118                     \};\par
119                 \}\par
120             \}\par
121         \} {\cf20 // namespace Detail}\par
122     \} {\cf20 // namespace Benchmark}\par
123 \} {\cf20 // namespace Catch}\par
124 \par
125 \par
126 \par
127 \par
128 {\cf17 namespace }Catch \{\par
129     {\cf17 namespace }Benchmark \{\par
130         {\cf17 namespace }Detail \{\par
131             BenchmarkFunction::callable::~callable() = {\cf19 default};\par
132         \} {\cf20 // namespace Detail}\par
133     \} {\cf20 // namespace Benchmark}\par
134 \} {\cf20 // namespace Catch}\par
135 \par
136 \par
137 \par
138 \par
139 {\cf21 #include <exception>}\par
140 \par
141 {\cf17 namespace }Catch \{\par
142     {\cf17 namespace }Benchmark \{\par
143         {\cf17 namespace }Detail \{\par
144             {\cf17 struct }optimized_away_error : std::exception \{\par
145                 {\cf17 const} {\cf18 char}* what() const noexcept override;\par
146             \};\par
147 \par
148             const {\cf18 char}* optimized_away_error::what() const noexcept \{\par
149                 {\cf19 return} {\cf22 "could not measure benchmark, maybe it was optimized away"};\par
150             \}\par
151 \par
152             {\cf18 void} throw_optimized_away_error() \{\par
153                 Catch::throw_exception(optimized_away_error\{\});\par
154             \}\par
155 \par
156         \} {\cf20 // namespace Detail}\par
157     \} {\cf20 // namespace Benchmark}\par
158 \} {\cf20 // namespace Catch}\par
159 \par
160 \par
161 {\cf20 // Adapted from donated nonius code.}\par
162 \par
163 \par
164 \par
165 {\cf21 #include <algorithm>}\par
166 {\cf21 #include <cassert>}\par
167 {\cf21 #include <cmath>}\par
168 {\cf21 #include <cstddef>}\par
169 {\cf21 #include <numeric>}\par
170 {\cf21 #include <random>}\par
171 \par
172 \par
173 {\cf21 #if defined(CATCH_CONFIG_USE_ASYNC)}\par
174 {\cf21 #include <future>}\par
175 {\cf21 #endif}\par
176 \par
177 {\cf17 namespace }Catch \{\par
178     {\cf17 namespace }Benchmark \{\par
179         {\cf17 namespace }Detail \{\par
180             {\cf17 namespace }\{\par
181 \par
182                 {\cf17 template} <{\cf17 typename} URng, {\cf17 typename} Estimator>\par
183                 {\cf17 static} sample\par
184                 resample( URng& rng,\par
185                           {\cf18 unsigned} {\cf18 int} resamples,\par
186                           {\cf18 double} {\cf17 const}* first,\par
187                           {\cf18 double} {\cf17 const}* last,\par
188                           Estimator& estimator ) \{\par
189                     {\cf17 auto} n = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( last - first );\par
190                     Catch::uniform_integer_distribution<size_t> dist( 0, n - 1 );\par
191 \par
192                     sample out;\par
193                     out.reserve( resamples );\par
194                     std::vector<double> resampled;\par
195                     resampled.reserve( n );\par
196                     {\cf19 for} ( {\cf18 size_t} i = 0; i < resamples; ++i ) \{\par
197                         resampled.clear();\par
198                         {\cf19 for} ( {\cf18 size_t} s = 0; s < n; ++s ) \{\par
199                             resampled.push_back( first[dist( rng )] );\par
200                         \}\par
201                         {\cf17 const} {\cf17 auto} estimate =\par
202                             estimator( resampled.data(), resampled.data() + resampled.size() );\par
203                         out.push_back( estimate );\par
204                     \}\par
205                     std::sort( out.begin(), out.end() );\par
206                     {\cf19 return} out;\par
207                 \}\par
208 \par
209                 {\cf17 static} {\cf18 double} outlier_variance( Estimate<double> mean,\par
210                                                 Estimate<double> stddev,\par
211                                                 {\cf18 int} n ) \{\par
212                     {\cf18 double} sb = stddev.point;\par
213                     {\cf18 double} mn = mean.point / n;\par
214                     {\cf18 double} mg_min = mn / 2.;\par
215                     {\cf18 double} sg = (std::min)( mg_min / 4., sb / std::sqrt( n ) );\par
216                     {\cf18 double} sg2 = sg * sg;\par
217                     {\cf18 double} sb2 = sb * sb;\par
218 \par
219                     {\cf17 auto} c_max = [n, mn, sb2, sg2]( {\cf18 double} x ) -> {\cf18 double} \{\par
220                         {\cf18 double} k = mn - x;\par
221                         {\cf18 double} d = k * k;\par
222                         {\cf18 double} nd = n * d;\par
223                         {\cf18 double} k0 = -n * nd;\par
224                         {\cf18 double} k1 = sb2 - n * sg2 + nd;\par
225                         {\cf18 double} det = k1 * k1 - 4 * sg2 * k0;\par
226                         {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}( -2. * k0 /\par
227                                                  ( k1 + std::sqrt( det ) ) );\par
228                     \};\par
229 \par
230                     {\cf17 auto} var_out = [n, sb2, sg2]( {\cf18 double} c ) \{\par
231                         {\cf18 double} nc = n - c;\par
232                         {\cf19 return} ( nc / n ) * ( sb2 - nc * sg2 );\par
233                     \};\par
234 \par
235                     {\cf19 return} (std::min)( var_out( 1 ),\par
236                                        var_out(\par
237                                            (std::min)( c_max( 0. ),\par
238                                                        c_max( mg_min ) ) ) ) /\par
239                            sb2;\par
240                 \}\par
241 \par
242                 {\cf17 static} {\cf18 double} erf_inv( {\cf18 double} x ) \{\par
243                     {\cf20 // Code accompanying the article "Approximating the erfinv}\par
244                     {\cf20 // function" in GPU Computing Gems, Volume 2}\par
245                     {\cf18 double} w, p;\par
246 \par
247                     w = -log( ( 1.0 - x ) * ( 1.0 + x ) );\par
248 \par
249                     {\cf19 if} ( w < 6.250000 ) \{\par
250                         w = w - 3.125000;\par
251                         p = -3.6444120640178196996e-21;\par
252                         p = -1.685059138182016589e-19 + p * w;\par
253                         p = 1.2858480715256400167e-18 + p * w;\par
254                         p = 1.115787767802518096e-17 + p * w;\par
255                         p = -1.333171662854620906e-16 + p * w;\par
256                         p = 2.0972767875968561637e-17 + p * w;\par
257                         p = 6.6376381343583238325e-15 + p * w;\par
258                         p = -4.0545662729752068639e-14 + p * w;\par
259                         p = -8.1519341976054721522e-14 + p * w;\par
260                         p = 2.6335093153082322977e-12 + p * w;\par
261                         p = -1.2975133253453532498e-11 + p * w;\par
262                         p = -5.4154120542946279317e-11 + p * w;\par
263                         p = 1.051212273321532285e-09 + p * w;\par
264                         p = -4.1126339803469836976e-09 + p * w;\par
265                         p = -2.9070369957882005086e-08 + p * w;\par
266                         p = 4.2347877827932403518e-07 + p * w;\par
267                         p = -1.3654692000834678645e-06 + p * w;\par
268                         p = -1.3882523362786468719e-05 + p * w;\par
269                         p = 0.0001867342080340571352 + p * w;\par
270                         p = -0.00074070253416626697512 + p * w;\par
271                         p = -0.0060336708714301490533 + p * w;\par
272                         p = 0.24015818242558961693 + p * w;\par
273                         p = 1.6536545626831027356 + p * w;\par
274                     \} {\cf19 else} {\cf19 if} ( w < 16.000000 ) \{\par
275                         w = sqrt( w ) - 3.250000;\par
276                         p = 2.2137376921775787049e-09;\par
277                         p = 9.0756561938885390979e-08 + p * w;\par
278                         p = -2.7517406297064545428e-07 + p * w;\par
279                         p = 1.8239629214389227755e-08 + p * w;\par
280                         p = 1.5027403968909827627e-06 + p * w;\par
281                         p = -4.013867526981545969e-06 + p * w;\par
282                         p = 2.9234449089955446044e-06 + p * w;\par
283                         p = 1.2475304481671778723e-05 + p * w;\par
284                         p = -4.7318229009055733981e-05 + p * w;\par
285                         p = 6.8284851459573175448e-05 + p * w;\par
286                         p = 2.4031110387097893999e-05 + p * w;\par
287                         p = -0.0003550375203628474796 + p * w;\par
288                         p = 0.00095328937973738049703 + p * w;\par
289                         p = -0.0016882755560235047313 + p * w;\par
290                         p = 0.0024914420961078508066 + p * w;\par
291                         p = -0.0037512085075692412107 + p * w;\par
292                         p = 0.005370914553590063617 + p * w;\par
293                         p = 1.0052589676941592334 + p * w;\par
294                         p = 3.0838856104922207635 + p * w;\par
295                     \} {\cf19 else} \{\par
296                         w = sqrt( w ) - 5.000000;\par
297                         p = -2.7109920616438573243e-11;\par
298                         p = -2.5556418169965252055e-10 + p * w;\par
299                         p = 1.5076572693500548083e-09 + p * w;\par
300                         p = -3.7894654401267369937e-09 + p * w;\par
301                         p = 7.6157012080783393804e-09 + p * w;\par
302                         p = -1.4960026627149240478e-08 + p * w;\par
303                         p = 2.9147953450901080826e-08 + p * w;\par
304                         p = -6.7711997758452339498e-08 + p * w;\par
305                         p = 2.2900482228026654717e-07 + p * w;\par
306                         p = -9.9298272942317002539e-07 + p * w;\par
307                         p = 4.5260625972231537039e-06 + p * w;\par
308                         p = -1.9681778105531670567e-05 + p * w;\par
309                         p = 7.5995277030017761139e-05 + p * w;\par
310                         p = -0.00021503011930044477347 + p * w;\par
311                         p = -0.00013871931833623122026 + p * w;\par
312                         p = 1.0103004648645343977 + p * w;\par
313                         p = 4.8499064014085844221 + p * w;\par
314                     \}\par
315                     {\cf19 return} p * x;\par
316                 \}\par
317 \par
318                 {\cf17 static} {\cf18 double}\par
319                 standard_deviation( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last ) \{\par
320                     {\cf17 auto} m = Catch::Benchmark::Detail::mean( first, last );\par
321                     {\cf18 double} variance =\par
322                         std::accumulate( first,\par
323                                          last,\par
324                                          0.,\par
325                                          [m]( {\cf18 double} a, {\cf18 double} b ) \{\par
326                                              {\cf18 double} diff = b - m;\par
327                                              {\cf19 return} a + diff * diff;\par
328                                          \} ) /\par
329                         ( last - first );\par
330                     {\cf19 return} std::sqrt( variance );\par
331                 \}\par
332 \par
333                 {\cf17 static} sample jackknife( {\cf18 double} ( *estimator )( {\cf18 double} {\cf17 const}*,\par
334                                                                 {\cf18 double} {\cf17 const}* ),\par
335                                          {\cf18 double}* first,\par
336                                          {\cf18 double}* last ) \{\par
337                     {\cf17 const} {\cf17 auto} second = first + 1;\par
338                     sample results;\par
339                     results.reserve( {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( last - first ) );\par
340 \par
341                     {\cf19 for} ( {\cf17 auto} it = first; it != last; ++it ) \{\par
342                         std::iter_swap( it, first );\par
343                         results.push_back( estimator( second, last ) );\par
344                     \}\par
345 \par
346                     {\cf19 return} results;\par
347                 \}\par
348 \par
349 \par
350             \} {\cf20 // namespace}\par
351         \}     {\cf20 // namespace Detail}\par
352     \}         {\cf20 // namespace Benchmark}\par
353 \} {\cf20 // namespace Catch}\par
354 \par
355 {\cf17 namespace }Catch \{\par
356     {\cf17 namespace }Benchmark \{\par
357         {\cf17 namespace }Detail \{\par
358 \par
359             {\cf18 double} weighted_average_quantile( {\cf18 int} k,\par
360                                               {\cf18 int} q,\par
361                                               {\cf18 double}* first,\par
362                                               {\cf18 double}* last ) \{\par
363                 {\cf17 auto} count = last - first;\par
364                 {\cf18 double} idx = (count - 1) * k / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(q);\par
365                 {\cf18 int} j = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(idx);\par
366                 {\cf18 double} g = idx - j;\par
367                 std::nth_element(first, first + j, last);\par
368                 {\cf17 auto} xj = first[j];\par
369                 {\cf19 if} ( Catch::Detail::directCompare( g, 0 ) ) \{\par
370                     {\cf19 return} xj;\par
371                 \}\par
372 \par
373                 {\cf17 auto} xj1 = *std::min_element(first + (j + 1), last);\par
374                 {\cf19 return} xj + g * (xj1 - xj);\par
375             \}\par
376 \par
377             OutlierClassification\par
378             classify_outliers( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last ) \{\par
379                 std::vector<double> copy( first, last );\par
380 \par
381                 {\cf17 auto} q1 = weighted_average_quantile( 1, 4, copy.data(), copy.data() + copy.size() );\par
382                 {\cf17 auto} q3 = weighted_average_quantile( 3, 4, copy.data(), copy.data() + copy.size() );\par
383                 {\cf17 auto} iqr = q3 - q1;\par
384                 {\cf17 auto} los = q1 - ( iqr * 3. );\par
385                 {\cf17 auto} lom = q1 - ( iqr * 1.5 );\par
386                 {\cf17 auto} him = q3 + ( iqr * 1.5 );\par
387                 {\cf17 auto} his = q3 + ( iqr * 3. );\par
388 \par
389                 OutlierClassification o;\par
390                 {\cf19 for} ( ; first != last; ++first ) \{\par
391                     {\cf17 const} {\cf18 double} t = *first;\par
392                     {\cf19 if} ( t < los ) \{\par
393                         ++o.low_severe;\par
394                     \} {\cf19 else} {\cf19 if} ( t < lom ) \{\par
395                         ++o.low_mild;\par
396                     \} {\cf19 else} {\cf19 if} ( t > his ) \{\par
397                         ++o.high_severe;\par
398                     \} {\cf19 else} {\cf19 if} ( t > him ) \{\par
399                         ++o.high_mild;\par
400                     \}\par
401                     ++o.samples_seen;\par
402                 \}\par
403                 {\cf19 return} o;\par
404             \}\par
405 \par
406             {\cf18 double} mean( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last ) \{\par
407                 {\cf17 auto} count = last - first;\par
408                 {\cf18 double} sum = 0.;\par
409                 {\cf19 while} (first != last) \{\par
410                     sum += *first;\par
411                     ++first;\par
412                 \}\par
413                 {\cf19 return} sum / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(count);\par
414             \}\par
415 \par
416             {\cf18 double} normal_cdf( {\cf18 double} x ) \{\par
417                 {\cf19 return} std::erfc( -x / std::sqrt( 2.0 ) ) / 2.0;\par
418             \}\par
419 \par
420             {\cf18 double} erfc_inv({\cf18 double} x) \{\par
421                 {\cf19 return} erf_inv(1.0 - x);\par
422             \}\par
423 \par
424             {\cf18 double} normal_quantile({\cf18 double} p) \{\par
425                 {\cf17 static} {\cf17 const} {\cf18 double} ROOT_TWO = std::sqrt(2.0);\par
426 \par
427                 {\cf18 double} result = 0.0;\par
428                 assert(p >= 0 && p <= 1);\par
429                 {\cf19 if} (p < 0 || p > 1) \{\par
430                     {\cf19 return} result;\par
431                 \}\par
432 \par
433                 result = -erfc_inv(2.0 * p);\par
434                 {\cf20 // result *= normal distribution standard deviation (1.0) * sqrt(2)}\par
435                 result *= {\cf20 /*sd * */} ROOT_TWO;\par
436                 {\cf20 // result += normal disttribution mean (0)}\par
437                 {\cf19 return} result;\par
438             \}\par
439 \par
440             Estimate<double>\par
441             bootstrap( {\cf18 double} confidence_level,\par
442                        {\cf18 double}* first,\par
443                        {\cf18 double}* last,\par
444                        sample {\cf17 const}& resample,\par
445                        {\cf18 double} ( *estimator )( {\cf18 double} {\cf17 const}*, {\cf18 double} {\cf17 const}* ) ) \{\par
446                 {\cf17 auto} n_samples = last - first;\par
447 \par
448                 {\cf18 double} point = estimator( first, last );\par
449                 {\cf20 // Degenerate case with a single sample}\par
450                 {\cf19 if} ( n_samples == 1 )\par
451                     {\cf19 return} \{ point, point, point, confidence_level \};\par
452 \par
453                 sample jack = jackknife( estimator, first, last );\par
454                 {\cf18 double} jack_mean =\par
455                     mean( jack.data(), jack.data() + jack.size() );\par
456                 {\cf18 double} sum_squares = 0, sum_cubes = 0;\par
457                 {\cf19 for} ( {\cf18 double} x : jack ) \{\par
458                     {\cf17 auto} difference = jack_mean - x;\par
459                     {\cf17 auto} square = difference * difference;\par
460                     {\cf17 auto} cube = square * difference;\par
461                     sum_squares += square;\par
462                     sum_cubes += cube;\par
463                 \}\par
464 \par
465                 {\cf18 double} accel = sum_cubes / ( 6 * std::pow( sum_squares, 1.5 ) );\par
466                 {\cf18 long} n = {\cf17 static_cast<}{\cf18 long}{\cf17 >}( resample.size() );\par
467                 {\cf18 double} prob_n =\par
468                     std::count_if( resample.begin(),\par
469                                    resample.end(),\par
470                                    [point]( {\cf18 double} x ) \{ return x < point; \} ) /\par
471                     {\cf17 static_cast<}{\cf18 double}{\cf17 >}( n );\par
472                 {\cf20 // degenerate case with uniform samples}\par
473                 {\cf19 if} ( Catch::Detail::directCompare( prob_n, 0. ) ) \{\par
474                     {\cf19 return} \{ point, point, point, confidence_level \};\par
475                 \}\par
476 \par
477                 {\cf18 double} bias = normal_quantile( prob_n );\par
478                 {\cf18 double} z1 = normal_quantile( ( 1. - confidence_level ) / 2. );\par
479 \par
480                 {\cf17 auto} cumn = [n]( {\cf18 double} x ) -> {\cf18 long} \{\par
481                     {\cf19 return} std::lround( normal_cdf( x ) *\par
482                                         {\cf17 static_cast<}{\cf18 double}{\cf17 >}( n ) );\par
483                 \};\par
484                 {\cf17 auto} a = [bias, accel]( {\cf18 double} b ) \{\par
485                     {\cf19 return} bias + b / ( 1. - accel * b );\par
486                 \};\par
487                 {\cf18 double} b1 = bias + z1;\par
488                 {\cf18 double} b2 = bias - z1;\par
489                 {\cf18 double} a1 = a( b1 );\par
490                 {\cf18 double} a2 = a( b2 );\par
491                 {\cf17 auto} lo = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( (std::max)( cumn( a1 ), 0l ) );\par
492                 {\cf17 auto} hi =\par
493                     {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( (std::min)( cumn( a2 ), n - 1 ) );\par
494 \par
495                 {\cf19 return} \{ point, resample[lo], resample[hi], confidence_level \};\par
496             \}\par
497 \par
498             bootstrap_analysis analyse_samples({\cf18 double} confidence_level,\par
499                                                {\cf18 unsigned} {\cf18 int} n_resamples,\par
500                                                {\cf18 double}* first,\par
501                                                {\cf18 double}* last) \{\par
502                 {\cf17 auto} mean = &Detail::mean;\par
503                 {\cf17 auto} stddev = &standard_deviation;\par
504 \par
505 {\cf21 #if defined(CATCH_CONFIG_USE_ASYNC)}\par
506                 {\cf17 auto} Estimate = [=](double(*f)({\cf18 double} {\cf17 const}*, {\cf18 double} {\cf17 const}*)) \{\par
507                     std::random_device rd;\par
508                     {\cf17 auto} seed = rd();\par
509                     {\cf19 return} std::async(std::launch::async, [=] \{\par
510                         SimplePcg32 rng( seed );\par
511                         {\cf17 auto} resampled = resample(rng, n_resamples, first, last, f);\par
512                         {\cf19 return} bootstrap(confidence_level, first, last, resampled, f);\par
513                     \});\par
514                 \};\par
515 \par
516                 {\cf17 auto} mean_future = Estimate(mean);\par
517                 {\cf17 auto} stddev_future = Estimate(stddev);\par
518 \par
519                 {\cf17 auto} mean_estimate = mean_future.get();\par
520                 {\cf17 auto} stddev_estimate = stddev_future.get();\par
521 {\cf21 #else}\par
522                 {\cf17 auto} Estimate = [=](double(*f)({\cf18 double} {\cf17 const}* , {\cf18 double} {\cf17 const}*)) \{\par
523                     std::random_device rd;\par
524                     {\cf17 auto} seed = rd();\par
525                     SimplePcg32 rng( seed );\par
526                     {\cf17 auto} resampled = resample(rng, n_resamples, first, last, f);\par
527                     {\cf19 return} bootstrap(confidence_level, first, last, resampled, f);\par
528                 \};\par
529 \par
530                 {\cf17 auto} mean_estimate = Estimate(mean);\par
531                 {\cf17 auto} stddev_estimate = Estimate(stddev);\par
532 {\cf21 #endif }{\cf20 // CATCH_USE_ASYNC}\par
533 \par
534                 {\cf17 auto} n = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(last - first); {\cf20 // seriously, one can't use integral types without hell in C++}\par
535                 {\cf18 double} outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);\par
536 \par
537                 {\cf19 return} \{ mean_estimate, stddev_estimate, outlier_variance \};\par
538             \}\par
539         \} {\cf20 // namespace Detail}\par
540     \} {\cf20 // namespace Benchmark}\par
541 \} {\cf20 // namespace Catch}\par
542 \par
543 \par
544 \par
545 {\cf21 #include <cmath>}\par
546 {\cf21 #include <limits>}\par
547 \par
548 {\cf17 namespace }\{\par
549 \par
550 {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
551 {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
552 {\cf18 bool} marginComparison({\cf18 double} lhs, {\cf18 double} rhs, {\cf18 double} margin) \{\par
553     {\cf19 return} (lhs + margin >= rhs) && (rhs + margin >= lhs);\par
554 \}\par
555 \par
556 \}\par
557 \par
558 {\cf17 namespace }Catch \{\par
559 \par
560     Approx::Approx ( {\cf18 double} value )\par
561     :   m_epsilon( static_cast<double>(std::numeric_limits<float>::epsilon())*100. ),\par
562         m_margin( 0.0 ),\par
563         m_scale( 0.0 ),\par
564         m_value( value )\par
565     \{\}\par
566 \par
567     Approx Approx::custom() \{\par
568         {\cf19 return} Approx( 0 );\par
569     \}\par
570 \par
571     Approx Approx::operator-(){\cf17  const }\{\par
572         {\cf17 auto} temp(*{\cf17 this});\par
573         temp.m_value = -temp.m_value;\par
574         {\cf19 return} temp;\par
575     \}\par
576 \par
577 \par
578     std::string Approx::toString(){\cf17  const }\{\par
579         ReusableStringStream rss;\par
580         rss << {\cf22 "Approx( "} << ::Catch::Detail::stringify( m_value ) << {\cf22 " )"};\par
581         {\cf19 return} rss.str();\par
582     \}\par
583 \par
584     {\cf18 bool} Approx::equalityComparisonImpl({\cf17 const} {\cf18 double} other){\cf17  const }\{\par
585         {\cf20 // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value}\par
586         {\cf20 // Thanks to Richard Harris for his help refining the scaled margin value}\par
587         {\cf19 return} marginComparison(m_value, other, m_margin)\par
588             || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(std::isinf(m_value)? 0 : m_value)));\par
589     \}\par
590 \par
591     {\cf18 void} Approx::setMargin({\cf18 double} newMargin) \{\par
592         CATCH_ENFORCE(newMargin >= 0,\par
593             {\cf22 "Invalid Approx::margin: "} << newMargin << {\cf23 '.'}\par
594             << {\cf22 " Approx::Margin has to be non-negative."});\par
595         m_margin = newMargin;\par
596     \}\par
597 \par
598     {\cf18 void} Approx::setEpsilon({\cf18 double} newEpsilon) \{\par
599         CATCH_ENFORCE(newEpsilon >= 0 && newEpsilon <= 1.0,\par
600             {\cf22 "Invalid Approx::epsilon: "} << newEpsilon << {\cf23 '.'}\par
601             << {\cf22 " Approx::epsilon has to be in [0, 1]"});\par
602         m_epsilon = newEpsilon;\par
603     \}\par
604 \par
605 {\cf17 namespace }literals \{\par
606     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 long} {\cf18 double} val) \{\par
607         {\cf19 return} Approx(val);\par
608     \}\par
609     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 unsigned} {\cf18 long} {\cf18 long} val) \{\par
610         {\cf19 return} Approx(val);\par
611     \}\par
612 \} {\cf20 // end namespace literals}\par
613 \par
614 std::string StringMaker<Catch::Approx>::convert(Catch::Approx {\cf17 const}& value) \{\par
615     {\cf19 return} value.toString();\par
616 \}\par
617 \par
618 \} {\cf20 // end namespace Catch}\par
619 \par
620 \par
621 \par
622 {\cf17 namespace }Catch \{\par
623 \par
624     AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression {\cf17 const} & _lazyExpression):\par
625         lazyExpression(_lazyExpression),\par
626         resultType(_resultType) \{\}\par
627 \par
628     std::string AssertionResultData::reconstructExpression(){\cf17  const }\{\par
629 \par
630         {\cf19 if}( reconstructedExpression.empty() ) \{\par
631             {\cf19 if}( lazyExpression ) \{\par
632                 ReusableStringStream rss;\par
633                 rss << lazyExpression;\par
634                 reconstructedExpression = rss.str();\par
635             \}\par
636         \}\par
637         {\cf19 return} reconstructedExpression;\par
638     \}\par
639 \par
640     AssertionResult::AssertionResult( AssertionInfo {\cf17 const}& info, AssertionResultData&& data )\par
641     :   m_info( info ),\par
642         m_resultData( CATCH_MOVE(data) )\par
643     \{\}\par
644 \par
645     {\cf20 // Result was a success}\par
646     {\cf18 bool} AssertionResult::succeeded(){\cf17  const }\{\par
647         {\cf19 return} Catch::isOk( m_resultData.resultType );\par
648     \}\par
649 \par
650     {\cf20 // Result was a success, or failure is suppressed}\par
651     {\cf18 bool} AssertionResult::isOk(){\cf17  const }\{\par
652         {\cf19 return} Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );\par
653     \}\par
654 \par
655     ResultWas::OfType AssertionResult::getResultType(){\cf17  const }\{\par
656         {\cf19 return} m_resultData.resultType;\par
657     \}\par
658 \par
659     {\cf18 bool} AssertionResult::hasExpression(){\cf17  const }\{\par
660         {\cf19 return} !m_info.capturedExpression.empty();\par
661     \}\par
662 \par
663     {\cf18 bool} AssertionResult::hasMessage(){\cf17  const }\{\par
664         {\cf19 return} !m_resultData.message.empty();\par
665     \}\par
666 \par
667     std::string AssertionResult::getExpression(){\cf17  const }\{\par
668         {\cf20 // Possibly overallocating by 3 characters should be basically free}\par
669         std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);\par
670         {\cf19 if} (isFalseTest(m_info.resultDisposition)) \{\par
671             expr += {\cf22 "!("};\par
672         \}\par
673         expr += m_info.capturedExpression;\par
674         {\cf19 if} (isFalseTest(m_info.resultDisposition)) \{\par
675             expr += {\cf23 ')'};\par
676         \}\par
677         {\cf19 return} expr;\par
678     \}\par
679 \par
680     std::string AssertionResult::getExpressionInMacro(){\cf17  const }\{\par
681         {\cf19 if} ( m_info.macroName.empty() ) \{\par
682             {\cf19 return} {\cf17 static_cast<}std::string{\cf17 >}( m_info.capturedExpression );\par
683         \}\par
684         std::string expr;\par
685         expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );\par
686         expr += m_info.macroName;\par
687         expr += {\cf22 "( "};\par
688         expr += m_info.capturedExpression;\par
689         expr += {\cf22 " )"};\par
690         {\cf19 return} expr;\par
691     \}\par
692 \par
693     {\cf18 bool} AssertionResult::hasExpandedExpression(){\cf17  const }\{\par
694         {\cf19 return} hasExpression() && getExpandedExpression() != getExpression();\par
695     \}\par
696 \par
697     std::string AssertionResult::getExpandedExpression(){\cf17  const }\{\par
698         std::string expr = m_resultData.reconstructExpression();\par
699         {\cf19 return} expr.empty()\par
700                 ? getExpression()\par
701                 : expr;\par
702     \}\par
703 \par
704     StringRef AssertionResult::getMessage(){\cf17  const }\{\par
705         {\cf19 return} m_resultData.message;\par
706     \}\par
707     SourceLineInfo AssertionResult::getSourceInfo(){\cf17  const }\{\par
708         {\cf19 return} m_info.lineInfo;\par
709     \}\par
710 \par
711     StringRef AssertionResult::getTestMacroName(){\cf17  const }\{\par
712         {\cf19 return} m_info.macroName;\par
713     \}\par
714 \par
715 \} {\cf20 // end namespace Catch}\par
716 \par
717 \par
718 \par
719 {\cf21 #include <fstream>}\par
720 \par
721 {\cf17 namespace }Catch \{\par
722 \par
723     {\cf17 namespace }\{\par
724         {\cf17 static} {\cf18 bool} enableBazelEnvSupport() \{\par
725 {\cf21 #if defined( CATCH_CONFIG_BAZEL_SUPPORT )}\par
726             {\cf19 return} {\cf17 true};\par
727 {\cf21 #else}\par
728             {\cf19 return} Detail::getEnv( {\cf22 "BAZEL_TEST"} ) != {\cf17 nullptr};\par
729 {\cf21 #endif}\par
730         \}\par
731 \par
732         {\cf17 struct }bazelShardingOptions \{\par
733             {\cf18 unsigned} {\cf18 int} shardIndex, shardCount;\par
734             std::string shardFilePath;\par
735         \};\par
736 \par
737         {\cf17 static} Optional<bazelShardingOptions> readBazelShardingOptions() \{\par
738             {\cf17 const} {\cf17 auto} bazelShardIndex = Detail::getEnv( {\cf22 "TEST_SHARD_INDEX"} );\par
739             {\cf17 const} {\cf17 auto} bazelShardTotal = Detail::getEnv( {\cf22 "TEST_TOTAL_SHARDS"} );\par
740             {\cf17 const} {\cf17 auto} bazelShardInfoFile = Detail::getEnv( {\cf22 "TEST_SHARD_STATUS_FILE"} );\par
741 \par
742 \par
743             {\cf17 const} {\cf18 bool} has_all =\par
744                 bazelShardIndex && bazelShardTotal && bazelShardInfoFile;\par
745             {\cf19 if} ( !has_all ) \{\par
746                 {\cf20 // We provide nice warning message if the input is}\par
747                 {\cf20 // misconfigured.}\par
748                 {\cf17 auto} warn = []( {\cf17 const} {\cf18 char}* env_var ) \{\par
749                     Catch::cerr()\par
750                         << {\cf22 "Warning: Bazel shard configuration is missing '"}\par
751                         << env_var << {\cf22 "'. Shard configuration is skipped.\\n"};\par
752                 \};\par
753                 {\cf19 if} ( !bazelShardIndex ) \{\par
754                     warn( {\cf22 "TEST_SHARD_INDEX"} );\par
755                 \}\par
756                 {\cf19 if} ( !bazelShardTotal ) \{\par
757                     warn( {\cf22 "TEST_TOTAL_SHARDS"} );\par
758                 \}\par
759                 {\cf19 if} ( !bazelShardInfoFile ) \{\par
760                     warn( {\cf22 "TEST_SHARD_STATUS_FILE"} );\par
761                 \}\par
762                 {\cf19 return} \{\};\par
763             \}\par
764 \par
765             {\cf17 auto} shardIndex = parseUInt( bazelShardIndex );\par
766             {\cf19 if} ( !shardIndex ) \{\par
767                 Catch::cerr()\par
768                     << {\cf22 "Warning: could not parse 'TEST_SHARD_INDEX' ('"} << bazelShardIndex\par
769                     << {\cf22 "') as unsigned int.\\n"};\par
770                 {\cf19 return} \{\};\par
771             \}\par
772             {\cf17 auto} shardTotal = parseUInt( bazelShardTotal );\par
773             {\cf19 if} ( !shardTotal ) \{\par
774                 Catch::cerr()\par
775                     << {\cf22 "Warning: could not parse 'TEST_TOTAL_SHARD' ('"}\par
776                     << bazelShardTotal << {\cf22 "') as unsigned int.\\n"};\par
777                 {\cf19 return} \{\};\par
778             \}\par
779 \par
780             {\cf19 return} bazelShardingOptions\{\par
781                 *shardIndex, *shardTotal, bazelShardInfoFile \};\par
782 \par
783         \}\par
784     \} {\cf20 // end namespace}\par
785 \par
786 \par
787     {\cf18 bool} operator==( ProcessedReporterSpec {\cf17 const}& lhs,\par
788                      ProcessedReporterSpec {\cf17 const}& rhs ) \{\par
789         {\cf19 return} lhs.name == rhs.name &&\par
790                lhs.outputFilename == rhs.outputFilename &&\par
791                lhs.colourMode == rhs.colourMode &&\par
792                lhs.customOptions == rhs.customOptions;\par
793     \}\par
794 \par
795     Config::Config( ConfigData {\cf17 const}& data ):\par
796         m_data( data ) \{\par
797         {\cf20 // We need to trim filter specs to avoid trouble with superfluous}\par
798         {\cf20 // whitespace (esp. important for bdd macros, as those are manually}\par
799         {\cf20 // aligned with whitespace).}\par
800 \par
801         {\cf19 for} ({\cf17 auto}& elem : m_data.testsOrTags) \{\par
802             elem = trim(elem);\par
803         \}\par
804         for ({\cf17 auto}& elem : m_data.sectionsToRun) \{\par
805             elem = trim(elem);\par
806         \}\par
807 \par
808         {\cf20 // Insert the default reporter if user hasn't asked for a specific one}\par
809         if ( m_data.reporterSpecifications.empty() ) \{\par
810 #if defined( CATCH_CONFIG_DEFAULT_REPORTER )\par
811             const auto default_spec = CATCH_CONFIG_DEFAULT_REPORTER;\par
812 #else\par
813             const auto default_spec = {\cf22 "console"};\par
814 #endif\par
815             auto parsed = parseReporterSpec(default_spec);\par
816             CATCH_ENFORCE( parsed,\par
817                            {\cf22 "Cannot parse the provided default reporter spec: '"}\par
818                                << default_spec << {\cf22 '\\''} );\par
819             m_data.reporterSpecifications.push_back( std::move( *parsed ) );\par
820         \}\par
821 \par
822         if ( enableBazelEnvSupport() ) \{\par
823             readBazelEnvVars();\par
824         \}\par
825 \par
826         {\cf20 // Bazel support can modify the test specs, so parsing has to happen}\par
827         {\cf20 // after reading Bazel env vars.}\par
828         TestSpecParser parser( ITagAliasRegistry::get() );\par
829         {\cf19 if} ( !m_data.testsOrTags.empty() ) \{\par
830             m_hasTestFilters = {\cf17 true};\par
831             {\cf19 for} ( {\cf17 auto} {\cf17 const}& testOrTags : m_data.testsOrTags ) \{\par
832                 parser.parse( testOrTags );\par
833             \}\par
834         \}\par
835         m_testSpec = parser.testSpec();\par
836 \par
837 \par
838         {\cf20 // We now fixup the reporter specs to handle default output spec,}\par
839         {\cf20 // default colour spec, etc}\par
840         {\cf18 bool} defaultOutputUsed = {\cf17 false};\par
841         {\cf19 for} ( {\cf17 auto} {\cf17 const}& reporterSpec : m_data.reporterSpecifications ) \{\par
842             {\cf20 // We do the default-output check separately, while always}\par
843             {\cf20 // using the default output below to make the code simpler}\par
844             {\cf20 // and avoid superfluous copies.}\par
845             {\cf19 if} ( reporterSpec.outputFile().none() ) \{\par
846                 CATCH_ENFORCE( !defaultOutputUsed,\par
847                                {\cf22 "Internal error: cannot use default output for "}\par
848                                {\cf22 "multiple reporters"} );\par
849                 defaultOutputUsed = {\cf17 true};\par
850             \}\par
851 \par
852             m_processedReporterSpecs.push_back( ProcessedReporterSpec\{\par
853                 reporterSpec.name(),\par
854                 reporterSpec.outputFile() ? *reporterSpec.outputFile()\par
855                                           : data.defaultOutputFilename,\par
856                 reporterSpec.colourMode().valueOr( data.defaultColourMode ),\par
857                 reporterSpec.customOptions() \} );\par
858         \}\par
859     \}\par
860 \par
861     Config::~Config() = {\cf19 default};\par
862 \par
863 \par
864     {\cf18 bool} Config::listTests(){\cf17  const          }\{ {\cf19 return} m_data.listTests; \}\par
865     {\cf18 bool} Config::listTags(){\cf17  const           }\{ {\cf19 return} m_data.listTags; \}\par
866     {\cf18 bool} Config::listReporters(){\cf17  const      }\{ {\cf19 return} m_data.listReporters; \}\par
867     {\cf18 bool} Config::listListeners(){\cf17  const      }\{ {\cf19 return} m_data.listListeners; \}\par
868 \par
869     std::vector<std::string> {\cf17 const}& Config::getTestsOrTags(){\cf17  const }\{ {\cf19 return} m_data.testsOrTags; \}\par
870     std::vector<std::string> {\cf17 const}& Config::getSectionsToRun(){\cf17  const }\{ {\cf19 return} m_data.sectionsToRun; \}\par
871 \par
872     std::vector<ReporterSpec> {\cf17 const}& Config::getReporterSpecs(){\cf17  const }\{\par
873         {\cf19 return} m_data.reporterSpecifications;\par
874     \}\par
875 \par
876     std::vector<ProcessedReporterSpec> {\cf17 const}&\par
877     Config::getProcessedReporterSpecs(){\cf17  const }\{\par
878         {\cf19 return} m_processedReporterSpecs;\par
879     \}\par
880 \par
881     TestSpec {\cf17 const}& Config::testSpec(){\cf17  const }\{ {\cf19 return} m_testSpec; \}\par
882     {\cf18 bool} Config::hasTestFilters(){\cf17  const }\{ {\cf19 return} m_hasTestFilters; \}\par
883 \par
884     {\cf18 bool} Config::showHelp(){\cf17  const }\{ {\cf19 return} m_data.showHelp; \}\par
885 \par
886     {\cf20 // IConfig interface}\par
887     {\cf18 bool} Config::allowThrows(){\cf17  const                   }\{ {\cf19 return} !m_data.noThrow; \}\par
888     StringRef Config::name(){\cf17  const }\{ {\cf19 return} m_data.name.empty() ? m_data.processName : m_data.name; \}\par
889     {\cf18 bool} Config::includeSuccessfulResults(){\cf17  const      }\{ {\cf19 return} m_data.showSuccessfulTests; \}\par
890     {\cf18 bool} Config::warnAboutMissingAssertions(){\cf17  const }\{\par
891         {\cf19 return} !!( m_data.warnings & WarnAbout::NoAssertions );\par
892     \}\par
893     {\cf18 bool} Config::warnAboutUnmatchedTestSpecs(){\cf17  const }\{\par
894         {\cf19 return} !!( m_data.warnings & WarnAbout::UnmatchedTestSpec );\par
895     \}\par
896     {\cf18 bool} Config::zeroTestsCountAsSuccess(){\cf17  const       }\{ {\cf19 return} m_data.allowZeroTests; \}\par
897     ShowDurations Config::showDurations(){\cf17  const        }\{ {\cf19 return} m_data.showDurations; \}\par
898     {\cf18 double} Config::minDuration(){\cf17  const                 }\{ {\cf19 return} m_data.minDuration; \}\par
899     TestRunOrder Config::runOrder(){\cf17  const              }\{ {\cf19 return} m_data.runOrder; \}\par
900     uint32_t Config::rngSeed(){\cf17  const                   }\{ {\cf19 return} m_data.rngSeed; \}\par
901     {\cf18 unsigned} {\cf18 int} Config::shardCount(){\cf17  const            }\{ {\cf19 return} m_data.shardCount; \}\par
902     {\cf18 unsigned} {\cf18 int} Config::shardIndex(){\cf17  const            }\{ {\cf19 return} m_data.shardIndex; \}\par
903     ColourMode Config::defaultColourMode(){\cf17  const       }\{ {\cf19 return} m_data.defaultColourMode; \}\par
904     {\cf18 bool} Config::shouldDebugBreak(){\cf17  const              }\{ {\cf19 return} m_data.shouldDebugBreak; \}\par
905     {\cf18 int} Config::abortAfter(){\cf17  const                     }\{ {\cf19 return} m_data.abortAfter; \}\par
906     {\cf18 bool} Config::showInvisibles(){\cf17  const                }\{ {\cf19 return} m_data.showInvisibles; \}\par
907     Verbosity Config::verbosity(){\cf17  const                }\{ {\cf19 return} m_data.verbosity; \}\par
908 \par
909     {\cf18 bool} Config::skipBenchmarks(){\cf17  const                           }\{ {\cf19 return} m_data.skipBenchmarks; \}\par
910     {\cf18 bool} Config::benchmarkNoAnalysis(){\cf17  const                      }\{ {\cf19 return} m_data.benchmarkNoAnalysis; \}\par
911     {\cf18 unsigned} {\cf18 int} Config::benchmarkSamples(){\cf17  const                 }\{ {\cf19 return} m_data.benchmarkSamples; \}\par
912     {\cf18 double} Config::benchmarkConfidenceInterval(){\cf17  const            }\{ {\cf19 return} m_data.benchmarkConfidenceInterval; \}\par
913     {\cf18 unsigned} {\cf18 int} Config::benchmarkResamples(){\cf17  const               }\{ {\cf19 return} m_data.benchmarkResamples; \}\par
914     std::chrono::milliseconds Config::benchmarkWarmupTime(){\cf17  const }\{ {\cf19 return} std::chrono::milliseconds(m_data.benchmarkWarmupTime); \}\par
915 \par
916     {\cf18 void} Config::readBazelEnvVars() \{\par
917         {\cf20 // Register a JUnit reporter for Bazel. Bazel sets an environment}\par
918         {\cf20 // variable with the path to XML output. If this file is written to}\par
919         {\cf20 // during test, Bazel will not generate a default XML output.}\par
920         {\cf20 // This allows the XML output file to contain higher level of detail}\par
921         {\cf20 // than what is possible otherwise.}\par
922         {\cf17 const} {\cf17 auto} bazelOutputFile = Detail::getEnv( {\cf22 "XML_OUTPUT_FILE"} );\par
923 \par
924         {\cf19 if} ( bazelOutputFile ) \{\par
925             m_data.reporterSpecifications.push_back(\par
926                 \{ {\cf22 "junit"}, std::string( bazelOutputFile ), \{\}, \{\} \} );\par
927         \}\par
928 \par
929         {\cf17 const} {\cf17 auto} bazelTestSpec = Detail::getEnv( {\cf22 "TESTBRIDGE_TEST_ONLY"} );\par
930         {\cf19 if} ( bazelTestSpec ) \{\par
931             {\cf20 // Presumably the test spec from environment should overwrite}\par
932             {\cf20 // the one we got from CLI (if we got any)}\par
933             m_data.testsOrTags.clear();\par
934             m_data.testsOrTags.push_back( bazelTestSpec );\par
935         \}\par
936 \par
937         {\cf17 const} {\cf17 auto} bazelShardOptions = readBazelShardingOptions();\par
938         {\cf19 if} ( bazelShardOptions ) \{\par
939             std::ofstream f( bazelShardOptions->shardFilePath,\par
940                              std::ios_base::out | std::ios_base::trunc );\par
941             {\cf19 if} ( f.is_open() ) \{\par
942                 f << {\cf22 ""};\par
943                 m_data.shardIndex = bazelShardOptions->shardIndex;\par
944                 m_data.shardCount = bazelShardOptions->shardCount;\par
945             \}\par
946         \}\par
947     \}\par
948 \par
949 \} {\cf20 // end namespace Catch}\par
950 \par
951 \par
952 \par
953 \par
954 \par
955 {\cf17 namespace }Catch \{\par
956     std::uint32_t getSeed() \{\par
957         {\cf19 return} getCurrentContext().getConfig()->rngSeed();\par
958     \}\par
959 \}\par
960 \par
961 \par
962 \par
963 {\cf21 #include <cassert>}\par
964 {\cf21 #include <stack>}\par
965 \par
966 {\cf17 namespace }Catch \{\par
967 \par
969 \par
970 \par
971     ScopedMessage::ScopedMessage( MessageBuilder&& builder ):\par
972         m_info( CATCH_MOVE(builder.m_info) ) \{\par
973         m_info.message = builder.m_stream.str();\par
974         getResultCapture().pushScopedMessage( m_info );\par
975     \}\par
976 \par
977     ScopedMessage::ScopedMessage( ScopedMessage&& old ) {\cf17 noexcept}:\par
978         m_info( CATCH_MOVE( old.m_info ) ) \{\par
979         old.m_moved = {\cf17 true};\par
980     \}\par
981 \par
982     ScopedMessage::~ScopedMessage() \{\par
983         {\cf19 if} ( !uncaught_exceptions() && !m_moved )\{\par
984             getResultCapture().popScopedMessage(m_info);\par
985         \}\par
986     \}\par
987 \par
988 \par
989     Capturer::Capturer( StringRef macroName,\par
990                         SourceLineInfo {\cf17 const}& lineInfo,\par
991                         ResultWas::OfType resultType,\par
992                         StringRef names ):\par
993         m_resultCapture( getResultCapture() ) \{\par
994         {\cf17 auto} trimmed = [&] ({\cf18 size_t} start, {\cf18 size_t} end) \{\par
995             {\cf19 while} (names[start] == {\cf23 ','} || isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(names[start]))) \{\par
996                 ++start;\par
997             \}\par
998             {\cf19 while} (names[end] == {\cf23 ','} || isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(names[end]))) \{\par
999                 --end;\par
1000             \}\par
1001             {\cf19 return} names.substr(start, end - start + 1);\par
1002         \};\par
1003         {\cf17 auto} skipq = [&] ({\cf18 size_t} start, {\cf18 char} quote) \{\par
1004             {\cf19 for} ({\cf17 auto} i = start + 1; i < names.size() ; ++i) \{\par
1005                 {\cf19 if} (names[i] == quote)\par
1006                     {\cf19 return} i;\par
1007                 {\cf19 if} (names[i] == {\cf23 '\\\\'})\par
1008                     ++i;\par
1009             \}\par
1010             CATCH_INTERNAL_ERROR({\cf22 "CAPTURE parsing encountered unmatched quote"});\par
1011         \};\par
1012 \par
1013         {\cf18 size_t} start = 0;\par
1014         std::stack<char> openings;\par
1015         {\cf19 for} ({\cf18 size_t} pos = 0; pos < names.size(); ++pos) \{\par
1016             {\cf18 char} c = names[pos];\par
1017             {\cf19 switch} (c) \{\par
1018             {\cf19 case} {\cf23 '['}:\par
1019             {\cf19 case} {\cf23 '\{'}:\par
1020             {\cf19 case} {\cf23 '('}:\par
1021             {\cf20 // It is basically impossible to disambiguate between}\par
1022             {\cf20 // comparison and start of template args in this context}\par
1023 {\cf20 //            case '<':}\par
1024                 openings.push(c);\par
1025                 {\cf19 break};\par
1026             {\cf19 case} {\cf23 ']'}:\par
1027             {\cf19 case} {\cf23 '\}'}:\par
1028             {\cf19 case} {\cf23 ')'}:\par
1029 {\cf20 //           case '>':}\par
1030                 openings.pop();\par
1031                 {\cf19 break};\par
1032             {\cf19 case} {\cf23 '"'}:\par
1033             {\cf19 case} {\cf23 '\\''}:\par
1034                 pos = skipq(pos, c);\par
1035                 {\cf19 break};\par
1036             {\cf19 case} {\cf23 ','}:\par
1037                 {\cf19 if} (start != pos && openings.empty()) \{\par
1038                     m_messages.emplace_back(macroName, lineInfo, resultType);\par
1039                     m_messages.back().message = {\cf17 static_cast<}std::string{\cf17 >}(trimmed(start, pos));\par
1040                     m_messages.back().message += {\cf22 " := "};\par
1041                     start = pos;\par
1042                 \}\par
1043             {\cf19 default}:; {\cf20 // noop}\par
1044             \}\par
1045         \}\par
1046         assert(openings.empty() && {\cf22 "Mismatched openings"});\par
1047         m_messages.emplace_back(macroName, lineInfo, resultType);\par
1048         m_messages.back().message = {\cf17 static_cast<}std::string{\cf17 >}(trimmed(start, names.size() - 1));\par
1049         m_messages.back().message += {\cf22 " := "};\par
1050     \}\par
1051     Capturer::~Capturer() \{\par
1052         {\cf19 if} ( !uncaught_exceptions() )\{\par
1053             assert( m_captured == m_messages.size() );\par
1054             {\cf19 for}( {\cf18 size_t} i = 0; i < m_captured; ++i  )\par
1055                 m_resultCapture.popScopedMessage( m_messages[i] );\par
1056         \}\par
1057     \}\par
1058 \par
1059     {\cf18 void} Capturer::captureValue( {\cf18 size_t} index, std::string {\cf17 const}& value ) \{\par
1060         assert( index < m_messages.size() );\par
1061         m_messages[index].message += value;\par
1062         m_resultCapture.pushScopedMessage( m_messages[index] );\par
1063         m_captured++;\par
1064     \}\par
1065 \par
1066 \} {\cf20 // end namespace Catch}\par
1067 \par
1068 \par
1069 \par
1070 \par
1071 {\cf21 #include <exception>}\par
1072 \par
1073 {\cf17 namespace }Catch \{\par
1074 \par
1075     {\cf17 namespace }\{\par
1076 \par
1077         {\cf17 class }RegistryHub : {\cf17 public} IRegistryHub,\par
1078                             {\cf17 public} IMutableRegistryHub,\par
1079                             {\cf17 private} Detail::NonCopyable \{\par
1080 \par
1081         {\cf17 public}: {\cf20 // IRegistryHub}\par
1082             RegistryHub() = {\cf19 default};\par
1083             ReporterRegistry {\cf17 const}& getReporterRegistry(){\cf17  const override }\{\par
1084                 {\cf19 return} m_reporterRegistry;\par
1085             \}\par
1086             ITestCaseRegistry {\cf17 const}& getTestCaseRegistry(){\cf17  const override }\{\par
1087                 {\cf19 return} m_testCaseRegistry;\par
1088             \}\par
1089             IExceptionTranslatorRegistry {\cf17 const}& getExceptionTranslatorRegistry(){\cf17  const override }\{\par
1090                 {\cf19 return} m_exceptionTranslatorRegistry;\par
1091             \}\par
1092             ITagAliasRegistry {\cf17 const}& getTagAliasRegistry(){\cf17  const override }\{\par
1093                 {\cf19 return} m_tagAliasRegistry;\par
1094             \}\par
1095             StartupExceptionRegistry {\cf17 const}& getStartupExceptionRegistry(){\cf17  const override }\{\par
1096                 {\cf19 return} m_exceptionRegistry;\par
1097             \}\par
1098 \par
1099         {\cf17 public}: {\cf20 // IMutableRegistryHub}\par
1100             {\cf18 void} registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr factory ){\cf17  override }\{\par
1101                 m_reporterRegistry.registerReporter( name, CATCH_MOVE(factory) );\par
1102             \}\par
1103             {\cf18 void} registerListener( Detail::unique_ptr<EventListenerFactory> factory ){\cf17  override }\{\par
1104                 m_reporterRegistry.registerListener( CATCH_MOVE(factory) );\par
1105             \}\par
1106             {\cf18 void} registerTest( Detail::unique_ptr<TestCaseInfo>&& testInfo, Detail::unique_ptr<ITestInvoker>&& invoker ){\cf17  override }\{\par
1107                 m_testCaseRegistry.registerTest( CATCH_MOVE(testInfo), CATCH_MOVE(invoker) );\par
1108             \}\par
1109             {\cf18 void} registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator ){\cf17  override }\{\par
1110                 m_exceptionTranslatorRegistry.registerTranslator( CATCH_MOVE(translator) );\par
1111             \}\par
1112             {\cf18 void} registerTagAlias( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ){\cf17  override }\{\par
1113                 m_tagAliasRegistry.add( alias, tag, lineInfo );\par
1114             \}\par
1115             {\cf18 void} registerStartupException() noexcept{\cf17  override }\{\par
1116 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
1117                 m_exceptionRegistry.add(std::current_exception());\par
1118 {\cf21 #else}\par
1119                 CATCH_INTERNAL_ERROR({\cf22 "Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!"});\par
1120 {\cf21 #endif}\par
1121             \}\par
1122             IMutableEnumValuesRegistry& getMutableEnumValuesRegistry(){\cf17  override }\{\par
1123                 {\cf19 return} m_enumValuesRegistry;\par
1124             \}\par
1125 \par
1126         {\cf17 private}:\par
1127             TestRegistry m_testCaseRegistry;\par
1128             ReporterRegistry m_reporterRegistry;\par
1129             ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\par
1130             TagAliasRegistry m_tagAliasRegistry;\par
1131             StartupExceptionRegistry m_exceptionRegistry;\par
1132             Detail::EnumValuesRegistry m_enumValuesRegistry;\par
1133         \};\par
1134     \}\par
1135 \par
1136     {\cf17 using }RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;\par
1137 \par
1138     IRegistryHub {\cf17 const}& getRegistryHub() \{\par
1139         {\cf19 return} RegistryHubSingleton::get();\par
1140     \}\par
1141     IMutableRegistryHub& getMutableRegistryHub() \{\par
1142         {\cf19 return} RegistryHubSingleton::getMutable();\par
1143     \}\par
1144     {\cf18 void} cleanUp() \{\par
1145         cleanupSingletons();\par
1146         cleanUpContext();\par
1147     \}\par
1148     std::string translateActiveException() \{\par
1149         {\cf19 return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();\par
1150     \}\par
1151 \par
1152 \par
1153 \} {\cf20 // end namespace Catch}\par
1154 \par
1155 \par
1156 \par
1157 {\cf21 #include <algorithm>}\par
1158 {\cf21 #include <cassert>}\par
1159 {\cf21 #include <exception>}\par
1160 {\cf21 #include <iomanip>}\par
1161 {\cf21 #include <set>}\par
1162 \par
1163 {\cf17 namespace }Catch \{\par
1164 \par
1165     {\cf17 namespace }\{\par
1166         {\cf17 const} {\cf18 int} MaxExitCode = 255;\par
1167 \par
1168         IEventListenerPtr createReporter(std::string {\cf17 const}& reporterName, ReporterConfig&& config) \{\par
1169             {\cf17 auto} reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, CATCH_MOVE(config));\par
1170             CATCH_ENFORCE(reporter, {\cf22 "No reporter registered with name: '"} << reporterName << {\cf23 '\\''});\par
1171 \par
1172             {\cf19 return} reporter;\par
1173         \}\par
1174 \par
1175         IEventListenerPtr prepareReporters(Config {\cf17 const}* config) \{\par
1176             {\cf19 if} (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()\par
1177                     && config->getProcessedReporterSpecs().size() == 1) \{\par
1178                 {\cf17 auto} {\cf17 const}& spec = config->getProcessedReporterSpecs()[0];\par
1179                 {\cf19 return} createReporter(\par
1180                     spec.name,\par
1181                     ReporterConfig( config,\par
1182                                     makeStream( spec.outputFilename ),\par
1183                                     spec.colourMode,\par
1184                                     spec.customOptions ) );\par
1185             \}\par
1186 \par
1187             {\cf17 auto} multi = Detail::make_unique<MultiReporter>(config);\par
1188 \par
1189             {\cf17 auto} {\cf17 const}& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\par
1190             {\cf19 for} ({\cf17 auto} {\cf17 const}& listener : listeners) \{\par
1191                 multi->addListener(listener->create(config));\par
1192             \}\par
1193 \par
1194             {\cf19 for} ( {\cf17 auto} {\cf17 const}& reporterSpec : config->getProcessedReporterSpecs() ) \{\par
1195                 multi->addReporter( createReporter(\par
1196                     reporterSpec.name,\par
1197                     ReporterConfig( config,\par
1198                                     makeStream( reporterSpec.outputFilename ),\par
1199                                     reporterSpec.colourMode,\par
1200                                     reporterSpec.customOptions ) ) );\par
1201             \}\par
1202 \par
1203             {\cf19 return} multi;\par
1204         \}\par
1205 \par
1206         {\cf17 class }TestGroup \{\par
1207         {\cf17 public}:\par
1208             {\cf17 explicit} TestGroup(IEventListenerPtr&& reporter, Config {\cf17 const}* config):\par
1209                 m_reporter(reporter.get()),\par
1210                 m_config\{config\},\par
1211                 m_context\{config, CATCH_MOVE(reporter)\} \{\par
1212 \par
1213                 assert( m_config->testSpec().getInvalidSpecs().empty() &&\par
1214                         {\cf22 "Invalid test specs should be handled before running tests"} );\par
1215 \par
1216                 {\cf17 auto} {\cf17 const}& allTestCases = getAllTestCasesSorted(*m_config);\par
1217                 {\cf17 auto} {\cf17 const}& testSpec = m_config->testSpec();\par
1218                 {\cf19 if} ( !testSpec.hasFilters() ) \{\par
1219                     {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : allTestCases ) \{\par
1220                         {\cf19 if} ( !test.getTestCaseInfo().isHidden() ) \{\par
1221                             m_tests.emplace( &test );\par
1222                         \}\par
1223                     \}\par
1224                 \} {\cf19 else} \{\par
1225                     m_matches =\par
1226                         testSpec.matchesByFilter( allTestCases, *m_config );\par
1227                     {\cf19 for} ( {\cf17 auto} {\cf17 const}& match : m_matches ) \{\par
1228                         m_tests.insert( match.tests.begin(),\par
1229                                         match.tests.end() );\par
1230                     \}\par
1231                 \}\par
1232 \par
1233                 m_tests = createShard(m_tests, m_config->shardCount(), m_config->shardIndex());\par
1234             \}\par
1235 \par
1236             Totals execute() \{\par
1237                 Totals totals;\par
1238                 {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : m_tests) \{\par
1239                     {\cf19 if} (!m_context.aborting())\par
1240                         totals += m_context.runTest(*testCase);\par
1241                     {\cf19 else}\par
1242                         m_reporter->skipTest(testCase->getTestCaseInfo());\par
1243                 \}\par
1244 \par
1245                 {\cf19 for} ({\cf17 auto} {\cf17 const}& match : m_matches) \{\par
1246                     {\cf19 if} (match.tests.empty()) \{\par
1247                         m_unmatchedTestSpecs = {\cf17 true};\par
1248                         m_reporter->noMatchingTestCases( match.name );\par
1249                     \}\par
1250                 \}\par
1251 \par
1252                 {\cf19 return} totals;\par
1253             \}\par
1254 \par
1255             {\cf18 bool} hadUnmatchedTestSpecs(){\cf17  const }\{\par
1256                 {\cf19 return} m_unmatchedTestSpecs;\par
1257             \}\par
1258 \par
1259 \par
1260         {\cf17 private}:\par
1261             IEventListener* m_reporter;\par
1262             Config {\cf17 const}* m_config;\par
1263             RunContext m_context;\par
1264             std::set<TestCaseHandle const*> m_tests;\par
1265             TestSpec::Matches m_matches;\par
1266             {\cf18 bool} m_unmatchedTestSpecs = {\cf17 false};\par
1267         \};\par
1268 \par
1269         {\cf18 void} applyFilenamesAsTags() \{\par
1270             {\cf19 for} ({\cf17 auto} {\cf17 const}& testInfo : getRegistryHub().getTestCaseRegistry().getAllInfos()) \{\par
1271                 testInfo->addFilenameTag();\par
1272             \}\par
1273         \}\par
1274 \par
1275     \} {\cf20 // anon namespace}\par
1276 \par
1277     Session::Session() \{\par
1278         {\cf17 static} {\cf18 bool} alreadyInstantiated = {\cf17 false};\par
1279         {\cf19 if}( alreadyInstantiated ) \{\par
1280             CATCH_TRY \{ CATCH_INTERNAL_ERROR( {\cf22 "Only one instance of Catch::Session can ever be used"} ); \}\par
1281             CATCH_CATCH_ALL \{ getMutableRegistryHub().registerStartupException(); \}\par
1282         \}\par
1283 \par
1284         {\cf20 // There cannot be exceptions at startup in no-exception mode.}\par
1285 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
1286         {\cf17 const} {\cf17 auto}& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();\par
1287         {\cf19 if} ( !exceptions.empty() ) \{\par
1288             config();\par
1289             getCurrentMutableContext().setConfig(m_config.get());\par
1290 \par
1291             m_startupExceptions = {\cf17 true};\par
1292             {\cf17 auto} errStream = makeStream( {\cf22 "%stderr"} );\par
1293             {\cf17 auto} colourImpl = makeColourImpl(\par
1294                 ColourMode::PlatformDefault, errStream.get() );\par
1295             {\cf17 auto} guard = colourImpl->guardColour( Colour::Red );\par
1296             errStream->stream() << {\cf22 "Errors occurred during startup!"} << {\cf23 '\\n'};\par
1297             {\cf20 // iterate over all exceptions and notify user}\par
1298             {\cf19 for} ( {\cf17 const} {\cf17 auto}& ex_ptr : exceptions ) \{\par
1299                 {\cf19 try} \{\par
1300                     std::rethrow_exception(ex_ptr);\par
1301                 \} {\cf19 catch} ( std::exception {\cf17 const}& ex ) \{\par
1302                     errStream->stream() << TextFlow::Column( ex.what() ).indent(2) << {\cf23 '\\n'};\par
1303                 \}\par
1304             \}\par
1305         \}\par
1306 {\cf21 #endif}\par
1307 \par
1308         alreadyInstantiated = {\cf17 true};\par
1309         m_cli = makeCommandLineParser( m_configData );\par
1310     \}\par
1311     Session::~Session() \{\par
1312         Catch::cleanUp();\par
1313     \}\par
1314 \par
1315     {\cf18 void} Session::showHelp(){\cf17  const }\{\par
1316         Catch::cout()\par
1317                 << {\cf22 "\\nCatch2 v"} << libraryVersion() << {\cf23 '\\n'}\par
1318                 << m_cli << {\cf23 '\\n'}\par
1319                 << {\cf22 "For more detailed usage please see the project docs\\n\\n"} << std::flush;\par
1320     \}\par
1321     {\cf18 void} Session::libIdentify() \{\par
1322         Catch::cout()\par
1323                 << std::left << std::setw(16) << {\cf22 "description: "} << {\cf22 "A Catch2 test executable\\n"}\par
1324                 << std::left << std::setw(16) << {\cf22 "category: "} << {\cf22 "testframework\\n"}\par
1325                 << std::left << std::setw(16) << {\cf22 "framework: "} << {\cf22 "Catch2\\n"}\par
1326                 << std::left << std::setw(16) << {\cf22 "version: "} << libraryVersion() << {\cf23 '\\n'} << std::flush;\par
1327     \}\par
1328 \par
1329     {\cf18 int} Session::applyCommandLine( {\cf18 int} argc, {\cf18 char} {\cf17 const} * {\cf17 const} * argv ) \{\par
1330         {\cf19 if}( m_startupExceptions )\par
1331             {\cf19 return} 1;\par
1332 \par
1333         {\cf17 auto} result = m_cli.parse( Clara::Args( argc, argv ) );\par
1334 \par
1335         {\cf19 if}( !result ) \{\par
1336             config();\par
1337             getCurrentMutableContext().setConfig(m_config.get());\par
1338             {\cf17 auto} errStream = makeStream( {\cf22 "%stderr"} );\par
1339             {\cf17 auto} colour = makeColourImpl( ColourMode::PlatformDefault, errStream.get() );\par
1340 \par
1341             errStream->stream()\par
1342                 << colour->guardColour( Colour::Red )\par
1343                 << {\cf22 "\\nError(s) in input:\\n"}\par
1344                 << TextFlow::Column( result.errorMessage() ).indent( 2 )\par
1345                 << {\cf22 "\\n\\n"};\par
1346             errStream->stream() << {\cf22 "Run with -? for usage\\n\\n"} << std::flush;\par
1347             {\cf19 return} MaxExitCode;\par
1348         \}\par
1349 \par
1350         {\cf19 if}( m_configData.showHelp )\par
1351             showHelp();\par
1352         {\cf19 if}( m_configData.libIdentify )\par
1353             libIdentify();\par
1354 \par
1355         m_config.reset();\par
1356         {\cf19 return} 0;\par
1357     \}\par
1358 \par
1359 {\cf21 #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)}\par
1360     {\cf18 int} Session::applyCommandLine( {\cf18 int} argc, {\cf18 wchar_t} {\cf17 const} * {\cf17 const} * argv ) \{\par
1361 \par
1362         {\cf18 char} **utf8Argv = {\cf17 new} {\cf18 char} *[ argc ];\par
1363 \par
1364         {\cf19 for} ( {\cf18 int} i = 0; i < argc; ++i ) \{\par
1365             {\cf18 int} bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, {\cf17 nullptr}, 0, {\cf17 nullptr}, {\cf17 nullptr} );\par
1366 \par
1367             utf8Argv[ i ] = {\cf17 new} {\cf18 char}[ bufSize ];\par
1368 \par
1369             WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, {\cf17 nullptr}, {\cf17 nullptr} );\par
1370         \}\par
1371 \par
1372         {\cf18 int} returnCode = applyCommandLine( argc, utf8Argv );\par
1373 \par
1374         {\cf19 for} ( {\cf18 int} i = 0; i < argc; ++i )\par
1375             {\cf17 delete} [] utf8Argv[ i ];\par
1376 \par
1377         {\cf17 delete} [] utf8Argv;\par
1378 \par
1379         {\cf19 return} returnCode;\par
1380     \}\par
1381 {\cf21 #endif}\par
1382 \par
1383     {\cf18 void} Session::useConfigData( ConfigData {\cf17 const}& configData ) \{\par
1384         m_configData = configData;\par
1385         m_config.reset();\par
1386     \}\par
1387 \par
1388     {\cf18 int} Session::run() \{\par
1389         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) \{\par
1390             Catch::cout() << {\cf22 "...waiting for enter/ return before starting\\n"} << std::flush;\par
1391             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
1392         \}\par
1393         {\cf18 int} exitCode = runInternal();\par
1394         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) \{\par
1395             Catch::cout() << {\cf22 "...waiting for enter/ return before exiting, with code: "} << exitCode << {\cf23 '\\n'} << std::flush;\par
1396             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
1397         \}\par
1398         {\cf19 return} exitCode;\par
1399     \}\par
1400 \par
1401     Clara::Parser {\cf17 const}& Session::cli(){\cf17  const }\{\par
1402         {\cf19 return} m_cli;\par
1403     \}\par
1404     {\cf18 void} Session::cli( Clara::Parser {\cf17 const}& newParser ) \{\par
1405         m_cli = newParser;\par
1406     \}\par
1407     ConfigData& Session::configData() \{\par
1408         {\cf19 return} m_configData;\par
1409     \}\par
1410     Config& Session::config() \{\par
1411         {\cf19 if}( !m_config )\par
1412             m_config = Detail::make_unique<Config>( m_configData );\par
1413         {\cf19 return} *m_config;\par
1414     \}\par
1415 \par
1416     {\cf18 int} Session::runInternal() \{\par
1417         {\cf19 if}( m_startupExceptions )\par
1418             {\cf19 return} 1;\par
1419 \par
1420         {\cf19 if} (m_configData.showHelp || m_configData.libIdentify) \{\par
1421             {\cf19 return} 0;\par
1422         \}\par
1423 \par
1424         {\cf19 if} ( m_configData.shardIndex >= m_configData.shardCount ) \{\par
1425             Catch::cerr() << {\cf22 "The shard count ("} << m_configData.shardCount\par
1426                           << {\cf22 ") must be greater than the shard index ("}\par
1427                           << m_configData.shardIndex << {\cf22 ")\\n"}\par
1428                           << std::flush;\par
1429             {\cf19 return} 1;\par
1430         \}\par
1431 \par
1432         CATCH_TRY \{\par
1433             config(); {\cf20 // Force config to be constructed}\par
1434 \par
1435             seedRng( *m_config );\par
1436 \par
1437             {\cf19 if} (m_configData.filenamesAsTags) \{\par
1438                 applyFilenamesAsTags();\par
1439             \}\par
1440 \par
1441             {\cf20 // Set up global config instance before we start calling into other functions}\par
1442             getCurrentMutableContext().setConfig(m_config.get());\par
1443 \par
1444             {\cf20 // Create reporter(s) so we can route listings through them}\par
1445             {\cf17 auto} reporter = prepareReporters(m_config.get());\par
1446 \par
1447             {\cf17 auto} {\cf17 const}& invalidSpecs = m_config->testSpec().getInvalidSpecs();\par
1448             {\cf19 if} ( !invalidSpecs.empty() ) \{\par
1449                 {\cf19 for} ( {\cf17 auto} {\cf17 const}& spec : invalidSpecs ) \{\par
1450                     reporter->reportInvalidTestSpec( spec );\par
1451                 \}\par
1452                 {\cf19 return} 1;\par
1453             \}\par
1454 \par
1455 \par
1456             {\cf20 // Handle list request}\par
1457             {\cf19 if} (list(*reporter, *m_config)) \{\par
1458                 {\cf19 return} 0;\par
1459             \}\par
1460 \par
1461             TestGroup tests \{ CATCH_MOVE(reporter), m_config.get() \};\par
1462             {\cf17 auto} {\cf17 const} totals = tests.execute();\par
1463 \par
1464             {\cf19 if} ( tests.hadUnmatchedTestSpecs()\par
1465                 && m_config->warnAboutUnmatchedTestSpecs() ) \{\par
1466                 {\cf19 return} 3;\par
1467             \}\par
1468 \par
1469             {\cf19 if} ( totals.testCases.total() == 0\par
1470                 && !m_config->zeroTestsCountAsSuccess() ) \{\par
1471                 {\cf19 return} 2;\par
1472             \}\par
1473 \par
1474             {\cf19 if} ( totals.testCases.total() > 0 &&\par
1475                  totals.testCases.total() == totals.testCases.skipped\par
1476                 && !m_config->zeroTestsCountAsSuccess() ) \{\par
1477                 {\cf19 return} 4;\par
1478             \}\par
1479 \par
1480             {\cf20 // Note that on unices only the lower 8 bits are usually used, clamping}\par
1481             {\cf20 // the return value to 255 prevents false negative when some multiple}\par
1482             {\cf20 // of 256 tests has failed}\par
1483             {\cf19 return} (std::min) (MaxExitCode, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(totals.assertions.failed));\par
1484         \}\par
1485 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
1486         {\cf19 catch}( std::exception& ex ) \{\par
1487             Catch::cerr() << ex.what() << {\cf23 '\\n'} << std::flush;\par
1488             {\cf19 return} MaxExitCode;\par
1489         \}\par
1490 {\cf21 #endif}\par
1491     \}\par
1492 \par
1493 \} {\cf20 // end namespace Catch}\par
1494 \par
1495 \par
1496 \par
1497 \par
1498 {\cf17 namespace }Catch \{\par
1499 \par
1500     RegistrarForTagAliases::RegistrarForTagAliases({\cf18 char} {\cf17 const}* alias, {\cf18 char} {\cf17 const}* tag, SourceLineInfo {\cf17 const}& lineInfo) \{\par
1501         CATCH_TRY \{\par
1502             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);\par
1503         \} CATCH_CATCH_ALL \{\par
1504             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
1505             getMutableRegistryHub().registerStartupException();\par
1506         \}\par
1507     \}\par
1508 \par
1509 \}\par
1510 \par
1511 \par
1512 \par
1513 {\cf21 #include <cassert>}\par
1514 {\cf21 #include <cctype>}\par
1515 {\cf21 #include <algorithm>}\par
1516 \par
1517 {\cf17 namespace }Catch \{\par
1518 \par
1519     {\cf17 namespace }\{\par
1520         {\cf17 using }TCP_underlying_type = uint8_t;\par
1521         {\cf17 static_assert}({\cf17 sizeof}(TestCaseProperties) == {\cf17 sizeof}(TCP_underlying_type),\par
1522                       {\cf22 "The size of the TestCaseProperties is different from the assumed size"});\par
1523 \par
1524         TestCaseProperties operator|(TestCaseProperties lhs, TestCaseProperties rhs) \{\par
1525             {\cf19 return} {\cf17 static_cast<}TestCaseProperties{\cf17 >}(\par
1526                 {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(lhs) | {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(rhs)\par
1527             );\par
1528         \}\par
1529 \par
1530         TestCaseProperties& operator|=(TestCaseProperties& lhs, TestCaseProperties rhs) \{\par
1531             lhs = {\cf17 static_cast<}TestCaseProperties{\cf17 >}(\par
1532                 {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(lhs) | {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(rhs)\par
1533             );\par
1534             {\cf19 return} lhs;\par
1535         \}\par
1536 \par
1537         TestCaseProperties operator&(TestCaseProperties lhs, TestCaseProperties rhs) \{\par
1538             {\cf19 return} {\cf17 static_cast<}TestCaseProperties{\cf17 >}(\par
1539                 {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(lhs) & {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(rhs)\par
1540             );\par
1541         \}\par
1542 \par
1543         {\cf18 bool} applies(TestCaseProperties tcp) \{\par
1544             {\cf17 static_assert}({\cf17 static_cast<}TCP_underlying_type{\cf17 >}(TestCaseProperties::None) == 0,\par
1545                           {\cf22 "TestCaseProperties::None must be equal to 0"});\par
1546             {\cf19 return} tcp != TestCaseProperties::None;\par
1547         \}\par
1548 \par
1549         TestCaseProperties parseSpecialTag( StringRef tag ) \{\par
1550             {\cf19 if}( !tag.empty() && tag[0] == {\cf23 '.'} )\par
1551                 {\cf19 return} TestCaseProperties::IsHidden;\par
1552             {\cf19 else} {\cf19 if}( tag == {\cf22 "!throws"}_sr )\par
1553                 {\cf19 return} TestCaseProperties::Throws;\par
1554             {\cf19 else} {\cf19 if}( tag == {\cf22 "!shouldfail"}_sr )\par
1555                 {\cf19 return} TestCaseProperties::ShouldFail;\par
1556             {\cf19 else} {\cf19 if}( tag == {\cf22 "!mayfail"}_sr )\par
1557                 {\cf19 return} TestCaseProperties::MayFail;\par
1558             {\cf19 else} {\cf19 if}( tag == {\cf22 "!nonportable"}_sr )\par
1559                 {\cf19 return} TestCaseProperties::NonPortable;\par
1560             {\cf19 else} {\cf19 if}( tag == {\cf22 "!benchmark"}_sr )\par
1561                 {\cf19 return} TestCaseProperties::Benchmark | TestCaseProperties::IsHidden;\par
1562             {\cf19 else}\par
1563                 {\cf19 return} TestCaseProperties::None;\par
1564         \}\par
1565         {\cf18 bool} isReservedTag( StringRef tag ) \{\par
1566             {\cf19 return} parseSpecialTag( tag ) == TestCaseProperties::None\par
1567                 && tag.size() > 0\par
1568                 && !std::isalnum( {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(tag[0]) );\par
1569         \}\par
1570         {\cf18 void} enforceNotReservedTag( StringRef tag, SourceLineInfo {\cf17 const}& _lineInfo ) \{\par
1571             CATCH_ENFORCE( !isReservedTag(tag),\par
1572                           {\cf22 "Tag name: ["} << tag << {\cf22 "] is not allowed.\\n"}\par
1573                           << {\cf22 "Tag names starting with non alphanumeric characters are reserved\\n"}\par
1574                           << _lineInfo );\par
1575         \}\par
1576 \par
1577         std::string makeDefaultName() \{\par
1578             {\cf17 static} {\cf18 size_t} counter = 0;\par
1579             {\cf19 return} {\cf22 "Anonymous test case "} + std::to_string(++counter);\par
1580         \}\par
1581 \par
1582         StringRef extractFilenamePart(StringRef filename) \{\par
1583             {\cf18 size_t} lastDot = filename.size();\par
1584             {\cf19 while} (lastDot > 0 && filename[lastDot - 1] != {\cf23 '.'}) \{\par
1585                 --lastDot;\par
1586             \}\par
1587             {\cf20 // In theory we could have filename without any extension in it}\par
1588             {\cf19 if} ( lastDot == 0 ) \{ {\cf19 return} StringRef(); \}\par
1589 \par
1590             --lastDot;\par
1591             {\cf18 size_t} nameStart = lastDot;\par
1592             {\cf19 while} (nameStart > 0 && filename[nameStart - 1] != {\cf23 '/'} && filename[nameStart - 1] != {\cf23 '\\\\'}) \{\par
1593                 --nameStart;\par
1594             \}\par
1595 \par
1596             {\cf19 return} filename.substr(nameStart, lastDot - nameStart);\par
1597         \}\par
1598 \par
1599         {\cf20 // Returns the upper bound on size of extra tags ([#file]+[.])}\par
1600         {\cf18 size_t} sizeOfExtraTags(StringRef filepath) \{\par
1601             {\cf20 // [.] is 3, [#] is another 3}\par
1602             {\cf17 const} {\cf18 size_t} extras = 3 + 3;\par
1603             {\cf19 return} extractFilenamePart(filepath).size() + extras;\par
1604         \}\par
1605     \} {\cf20 // end unnamed namespace}\par
1606 \par
1607     {\cf18 bool} operator<(  Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs ) \{\par
1608         Detail::CaseInsensitiveLess cmp;\par
1609         {\cf19 return} cmp( lhs.original, rhs.original );\par
1610     \}\par
1611     {\cf18 bool} operator==( Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs ) \{\par
1612         Detail::CaseInsensitiveEqualTo cmp;\par
1613         {\cf19 return} cmp( lhs.original, rhs.original );\par
1614     \}\par
1615 \par
1616     Detail::unique_ptr<TestCaseInfo>\par
1617         makeTestCaseInfo(StringRef _className,\par
1618                          NameAndTags {\cf17 const}& nameAndTags,\par
1619                          SourceLineInfo {\cf17 const}& _lineInfo ) \{\par
1620         {\cf19 return} Detail::make_unique<TestCaseInfo>(_className, nameAndTags, _lineInfo);\par
1621     \}\par
1622 \par
1623     TestCaseInfo::TestCaseInfo(StringRef _className,\par
1624                                NameAndTags {\cf17 const}& _nameAndTags,\par
1625                                SourceLineInfo {\cf17 const}& _lineInfo):\par
1626         name( _nameAndTags.name.empty() ? makeDefaultName() : _nameAndTags.name ),\par
1627         className( _className ),\par
1628         lineInfo( _lineInfo )\par
1629     \{\par
1630         StringRef originalTags = _nameAndTags.tags;\par
1631         {\cf20 // We need to reserve enough space to store all of the tags}\par
1632         {\cf20 // (including optional hidden tag and filename tag)}\par
1633         {\cf17 auto} requiredSize = originalTags.size() + sizeOfExtraTags(_lineInfo.file);\par
1634         backingTags.reserve(requiredSize);\par
1635 \par
1636         {\cf20 // We cannot copy the tags directly, as we need to normalize}\par
1637         {\cf20 // some tags, so that [.foo] is copied as [.][foo].}\par
1638         {\cf18 size_t} tagStart = 0;\par
1639         {\cf18 size_t} tagEnd = 0;\par
1640         {\cf18 bool} inTag = {\cf17 false};\par
1641         for ({\cf18 size_t} idx = 0; idx < originalTags.size(); ++idx) \{\par
1642             {\cf17 auto} c = originalTags[idx];\par
1643             {\cf19 if} (c == {\cf23 '['}) \{\par
1644                 CATCH_ENFORCE(\par
1645                     !inTag,\par
1646                     {\cf22 "Found '[' inside a tag while registering test case '"}\par
1647                         << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1648 \par
1649                 inTag = {\cf17 true};\par
1650                 tagStart = idx;\par
1651             \}\par
1652             {\cf19 if} (c == {\cf23 ']'}) \{\par
1653                 CATCH_ENFORCE(\par
1654                     inTag,\par
1655                     {\cf22 "Found unmatched ']' while registering test case '"}\par
1656                         << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1657 \par
1658                 inTag = {\cf17 false};\par
1659                 tagEnd = idx;\par
1660                 assert(tagStart < tagEnd);\par
1661 \par
1662                 {\cf20 // We need to check the tag for special meanings, copy}\par
1663                 {\cf20 // it over to backing storage and actually reference the}\par
1664                 {\cf20 // backing storage in the saved tags}\par
1665                 StringRef tagStr = originalTags.substr(tagStart+1, tagEnd - tagStart - 1);\par
1666                 CATCH_ENFORCE( !tagStr.empty(),\par
1667                                {\cf22 "Found an empty tag while registering test case '"}\par
1668                                    << _nameAndTags.name << {\cf22 "' at "}\par
1669                                    << _lineInfo );\par
1670 \par
1671                 enforceNotReservedTag(tagStr, lineInfo);\par
1672                 properties |= parseSpecialTag(tagStr);\par
1673                 {\cf20 // When copying a tag to the backing storage, we need to}\par
1674                 {\cf20 // check if it is a merged hide tag, such as [.foo], and}\par
1675                 {\cf20 // if it is, we need to handle it as if it was [foo].}\par
1676                 {\cf19 if} (tagStr.size() > 1 && tagStr[0] == {\cf23 '.'}) \{\par
1677                     tagStr = tagStr.substr(1, tagStr.size() - 1);\par
1678                 \}\par
1679                 {\cf20 // We skip over dealing with the [.] tag, as we will add}\par
1680                 {\cf20 // it later unconditionally and then sort and unique all}\par
1681                 {\cf20 // the tags.}\par
1682                 internalAppendTag(tagStr);\par
1683             \}\par
1684         \}\par
1685         CATCH_ENFORCE( !inTag,\par
1686                        {\cf22 "Found an unclosed tag while registering test case '"}\par
1687                            << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1688 \par
1689 \par
1690         {\cf20 // Add [.] if relevant}\par
1691         {\cf19 if} (isHidden()) \{\par
1692             internalAppendTag({\cf22 "."}_sr);\par
1693         \}\par
1694 \par
1695         {\cf20 // Sort and prepare tags}\par
1696         std::sort(begin(tags), end(tags));\par
1697         tags.erase(std::unique(begin(tags), end(tags)),\par
1698                    end(tags));\par
1699     \}\par
1700 \par
1701     {\cf18 bool} TestCaseInfo::isHidden(){\cf17  const }\{\par
1702         {\cf19 return} applies( properties & TestCaseProperties::IsHidden );\par
1703     \}\par
1704     {\cf18 bool} TestCaseInfo::throws(){\cf17  const }\{\par
1705         {\cf19 return} applies( properties & TestCaseProperties::Throws );\par
1706     \}\par
1707     {\cf18 bool} TestCaseInfo::okToFail(){\cf17  const }\{\par
1708         {\cf19 return} applies( properties & (TestCaseProperties::ShouldFail | TestCaseProperties::MayFail ) );\par
1709     \}\par
1710     {\cf18 bool} TestCaseInfo::expectedToFail(){\cf17  const }\{\par
1711         {\cf19 return} applies( properties & (TestCaseProperties::ShouldFail) );\par
1712     \}\par
1713 \par
1714     {\cf18 void} TestCaseInfo::addFilenameTag() \{\par
1715         std::string combined({\cf22 "#"});\par
1716         combined += extractFilenamePart(lineInfo.file);\par
1717         internalAppendTag(combined);\par
1718     \}\par
1719 \par
1720     std::string TestCaseInfo::tagsAsString(){\cf17  const }\{\par
1721         std::string ret;\par
1722         {\cf20 // '[' and ']' per tag}\par
1723         std::size_t full_size = 2 * tags.size();\par
1724         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
1725             full_size += tag.original.size();\par
1726         \}\par
1727         ret.reserve(full_size);\par
1728         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
1729             ret.push_back({\cf23 '['});\par
1730             ret += tag.original;\par
1731             ret.push_back({\cf23 ']'});\par
1732         \}\par
1733 \par
1734         {\cf19 return} ret;\par
1735     \}\par
1736 \par
1737     {\cf18 void} TestCaseInfo::internalAppendTag(StringRef tagStr) \{\par
1738         backingTags += {\cf23 '['};\par
1739         {\cf17 const} {\cf17 auto} backingStart = backingTags.size();\par
1740         backingTags += tagStr;\par
1741         {\cf17 const} {\cf17 auto} backingEnd = backingTags.size();\par
1742         backingTags += {\cf23 ']'};\par
1743         tags.emplace_back(StringRef(backingTags.c_str() + backingStart, backingEnd - backingStart));\par
1744     \}\par
1745 \par
1746     {\cf18 bool} operator<( TestCaseInfo {\cf17 const}& lhs, TestCaseInfo {\cf17 const}& rhs ) \{\par
1747         {\cf20 // We want to avoid redoing the string comparisons multiple times,}\par
1748         {\cf20 // so we store the result of a three-way comparison before using}\par
1749         {\cf20 // it in the actual comparison logic.}\par
1750         {\cf17 const} {\cf17 auto} cmpName = lhs.name.compare( rhs.name );\par
1751         {\cf19 if} ( cmpName != 0 ) \{\par
1752             {\cf19 return} cmpName < 0;\par
1753         \}\par
1754         {\cf17 const} {\cf17 auto} cmpClassName = lhs.className.compare( rhs.className );\par
1755         {\cf19 if} ( cmpClassName != 0 ) \{\par
1756             {\cf19 return} cmpClassName < 0;\par
1757         \}\par
1758         {\cf19 return} lhs.tags < rhs.tags;\par
1759     \}\par
1760 \par
1761     TestCaseInfo {\cf17 const}& TestCaseHandle::getTestCaseInfo(){\cf17  const }\{\par
1762         {\cf19 return} *m_info;\par
1763     \}\par
1764 \par
1765 \} {\cf20 // end namespace Catch}\par
1766 \par
1767 \par
1768 \par
1769 {\cf21 #include <algorithm>}\par
1770 {\cf21 #include <string>}\par
1771 {\cf21 #include <vector>}\par
1772 {\cf21 #include <ostream>}\par
1773 \par
1774 {\cf17 namespace }Catch \{\par
1775 \par
1776     TestSpec::Pattern::Pattern( std::string {\cf17 const}& name )\par
1777     : m_name( name )\par
1778     \{\}\par
1779 \par
1780     TestSpec::Pattern::~Pattern() = {\cf19 default};\par
1781 \par
1782     std::string {\cf17 const}& TestSpec::Pattern::name(){\cf17  const }\{\par
1783         {\cf19 return} m_name;\par
1784     \}\par
1785 \par
1786 \par
1787     TestSpec::NamePattern::NamePattern( std::string {\cf17 const}& name, std::string {\cf17 const}& filterString )\par
1788     : Pattern( filterString )\par
1789     , m_wildcardPattern( toLower( name ), CaseSensitive::No )\par
1790     \{\}\par
1791 \par
1792     {\cf18 bool} TestSpec::NamePattern::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1793         {\cf19 return} m_wildcardPattern.matches( testCase.name );\par
1794     \}\par
1795 \par
1796     {\cf18 void} TestSpec::NamePattern::serializeTo( std::ostream& out ){\cf17  const }\{\par
1797         out << {\cf23 '"'} << name() << {\cf23 '"'};\par
1798     \}\par
1799 \par
1800 \par
1801     TestSpec::TagPattern::TagPattern( std::string {\cf17 const}& tag, std::string {\cf17 const}& filterString )\par
1802     : Pattern( filterString )\par
1803     , m_tag( tag )\par
1804     \{\}\par
1805 \par
1806     {\cf18 bool} TestSpec::TagPattern::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1807         {\cf19 return} std::find( begin( testCase.tags ),\par
1808                           end( testCase.tags ),\par
1809                           Tag( m_tag ) ) != end( testCase.tags );\par
1810     \}\par
1811 \par
1812     {\cf18 void} TestSpec::TagPattern::serializeTo( std::ostream& out ){\cf17  const }\{\par
1813         out << name();\par
1814     \}\par
1815 \par
1816     {\cf18 bool} TestSpec::Filter::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1817         {\cf18 bool} should_use = !testCase.isHidden();\par
1818         {\cf19 for} ({\cf17 auto} {\cf17 const}& pattern : m_required) \{\par
1819             should_use = {\cf17 true};\par
1820             {\cf19 if} (!pattern->matches(testCase)) \{\par
1821                 {\cf19 return} {\cf17 false};\par
1822             \}\par
1823         \}\par
1824         {\cf19 for} ({\cf17 auto} {\cf17 const}& pattern : m_forbidden) \{\par
1825             {\cf19 if} (pattern->matches(testCase)) \{\par
1826                 {\cf19 return} {\cf17 false};\par
1827             \}\par
1828         \}\par
1829         {\cf19 return} should_use;\par
1830     \}\par
1831 \par
1832     {\cf18 void} TestSpec::Filter::serializeTo( std::ostream& out ){\cf17  const }\{\par
1833         {\cf18 bool} first = {\cf17 true};\par
1834         {\cf19 for} ( {\cf17 auto} {\cf17 const}& pattern : m_required ) \{\par
1835             {\cf19 if} ( !first ) \{\par
1836                 out << {\cf23 ' '};\par
1837             \}\par
1838             out << *pattern;\par
1839             first = {\cf17 false};\par
1840         \}\par
1841         {\cf19 for} ( {\cf17 auto} {\cf17 const}& pattern : m_forbidden ) \{\par
1842             {\cf19 if} ( !first ) \{\par
1843                 out << {\cf23 ' '};\par
1844             \}\par
1845             out << *pattern;\par
1846             first = {\cf17 false};\par
1847         \}\par
1848     \}\par
1849 \par
1850 \par
1851     std::string TestSpec::extractFilterName( Filter {\cf17 const}& filter ) \{\par
1852         Catch::ReusableStringStream sstr;\par
1853         sstr << filter;\par
1854         {\cf19 return} sstr.str();\par
1855     \}\par
1856 \par
1857     {\cf18 bool} TestSpec::hasFilters(){\cf17  const }\{\par
1858         {\cf19 return} !m_filters.empty();\par
1859     \}\par
1860 \par
1861     {\cf18 bool} TestSpec::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1862         {\cf19 return} std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter {\cf17 const}& f )\{ return f.matches( testCase ); \} );\par
1863     \}\par
1864 \par
1865     TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCaseHandle> {\cf17 const}& testCases, IConfig {\cf17 const}& config ){\cf17  const }\{\par
1866         Matches matches;\par
1867         matches.reserve( m_filters.size() );\par
1868         {\cf19 for} ( {\cf17 auto} {\cf17 const}& filter : m_filters ) \{\par
1869             std::vector<TestCaseHandle const*> currentMatches;\par
1870             {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : testCases )\par
1871                 {\cf19 if} ( isThrowSafe( test, config ) &&\par
1872                      filter.matches( test.getTestCaseInfo() ) )\par
1873                     currentMatches.emplace_back( &test );\par
1874             matches.push_back(\par
1875                 FilterMatch\{ extractFilterName( filter ), currentMatches \} );\par
1876         \}\par
1877         {\cf19 return} matches;\par
1878     \}\par
1879 \par
1880     {\cf17 const} TestSpec::vectorStrings& TestSpec::getInvalidSpecs(){\cf17  const }\{\par
1881         {\cf19 return} m_invalidSpecs;\par
1882     \}\par
1883 \par
1884     {\cf18 void} TestSpec::serializeTo( std::ostream& out ){\cf17  const }\{\par
1885         {\cf18 bool} first = {\cf17 true};\par
1886         {\cf19 for} ( {\cf17 auto} {\cf17 const}& filter : m_filters ) \{\par
1887             {\cf19 if} ( !first ) \{\par
1888                 out << {\cf23 ','};\par
1889             \}\par
1890             out << filter;\par
1891             first = {\cf17 false};\par
1892         \}\par
1893     \}\par
1894 \par
1895 \}\par
1896 \par
1897 \par
1898 \par
1899 {\cf21 #include <chrono>}\par
1900 \par
1901 {\cf17 namespace }Catch \{\par
1902 \par
1903     {\cf17 namespace }\{\par
1904         {\cf17 static} {\cf17 auto} getCurrentNanosecondsSinceEpoch() -> uint64_t \{\par
1905             {\cf19 return} std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();\par
1906         \}\par
1907     \} {\cf20 // end unnamed namespace}\par
1908 \par
1909     {\cf18 void} Timer::start() \{\par
1910        m_nanoseconds = getCurrentNanosecondsSinceEpoch();\par
1911     \}\par
1912     {\cf17 auto} Timer::getElapsedNanoseconds() const -> uint64_t \{\par
1913         {\cf19 return} getCurrentNanosecondsSinceEpoch() - m_nanoseconds;\par
1914     \}\par
1915     {\cf17 auto} Timer::getElapsedMicroseconds() const -> uint64_t \{\par
1916         {\cf19 return} getElapsedNanoseconds()/1000;\par
1917     \}\par
1918     {\cf17 auto} Timer::getElapsedMilliseconds() const -> {\cf18 unsigned} {\cf18 int} \{\par
1919         {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(getElapsedMicroseconds()/1000);\par
1920     \}\par
1921     {\cf17 auto} Timer::getElapsedSeconds() const -> {\cf18 double} \{\par
1922         {\cf19 return} getElapsedMicroseconds()/1000000.0;\par
1923     \}\par
1924 \par
1925 \par
1926 \} {\cf20 // namespace Catch}\par
1927 \par
1928 \par
1929 \par
1930 \par
1931 {\cf21 #include <cmath>}\par
1932 {\cf21 #include <iomanip>}\par
1933 \par
1934 {\cf17 namespace }Catch \{\par
1935 \par
1936 {\cf17 namespace }Detail \{\par
1937 \par
1938     {\cf17 namespace }\{\par
1939         {\cf17 const} {\cf18 int} hexThreshold = 255;\par
1940 \par
1941         {\cf17 struct }Endianness \{\par
1942             {\cf17 enum} Arch \{ Big, Little \};\par
1943 \par
1944             {\cf17 static} Arch which() \{\par
1945                 {\cf18 int} one = 1;\par
1946                 {\cf20 // If the lowest byte we read is non-zero, we can assume}\par
1947                 {\cf20 // that little endian format is used.}\par
1948                 {\cf17 auto} value = *{\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >}(&one);\par
1949                 {\cf19 return} value ? Little : Big;\par
1950             \}\par
1951         \};\par
1952 \par
1953         {\cf17 template}<{\cf17 typename} T>\par
1954         std::string fpToString(T value, {\cf18 int} precision) \{\par
1955             {\cf19 if} (Catch::isnan(value)) \{\par
1956                 {\cf19 return} {\cf22 "nan"};\par
1957             \}\par
1958 \par
1959             ReusableStringStream rss;\par
1960             rss << std::setprecision(precision)\par
1961                 << std::fixed\par
1962                 << value;\par
1963             std::string d = rss.str();\par
1964             std::size_t i = d.find_last_not_of({\cf23 '0'});\par
1965             {\cf19 if} (i != std::string::npos && i != d.size() - 1) \{\par
1966                 {\cf19 if} (d[i] == {\cf23 '.'})\par
1967                     i++;\par
1968                 d = d.substr(0, i + 1);\par
1969             \}\par
1970             {\cf19 return} d;\par
1971         \}\par
1972     \} {\cf20 // end unnamed namespace}\par
1973 \par
1974     std::string convertIntoString(StringRef {\cf18 string}, {\cf18 bool} escapeInvisibles) \{\par
1975         std::string ret;\par
1976         {\cf20 // This is enough for the "don't escape invisibles" case, and a good}\par
1977         {\cf20 // lower bound on the "escape invisibles" case.}\par
1978         ret.reserve({\cf18 string}.size() + 2);\par
1979 \par
1980         {\cf19 if} (!escapeInvisibles) \{\par
1981             ret += {\cf23 '"'};\par
1982             ret += string;\par
1983             ret += {\cf23 '"'};\par
1984             {\cf19 return} ret;\par
1985         \}\par
1986 \par
1987         ret += {\cf23 '"'};\par
1988         {\cf19 for} ({\cf18 char} c : {\cf18 string}) \{\par
1989             {\cf19 switch} (c) \{\par
1990             {\cf19 case} {\cf23 '\\r'}:\par
1991                 ret.append({\cf22 "\\\\r"});\par
1992                 {\cf19 break};\par
1993             {\cf19 case} {\cf23 '\\n'}:\par
1994                 ret.append({\cf22 "\\\\n"});\par
1995                 {\cf19 break};\par
1996             {\cf19 case} {\cf23 '\\t'}:\par
1997                 ret.append({\cf22 "\\\\t"});\par
1998                 {\cf19 break};\par
1999             {\cf19 case} {\cf23 '\\f'}:\par
2000                 ret.append({\cf22 "\\\\f"});\par
2001                 {\cf19 break};\par
2002             {\cf19 default}:\par
2003                 ret.push_back(c);\par
2004                 {\cf19 break};\par
2005             \}\par
2006         \}\par
2007         ret += {\cf23 '"'};\par
2008 \par
2009         {\cf19 return} ret;\par
2010     \}\par
2011 \par
2012     std::string convertIntoString(StringRef {\cf18 string}) \{\par
2013         {\cf19 return} convertIntoString({\cf18 string}, getCurrentContext().getConfig()->showInvisibles());\par
2014     \}\par
2015 \par
2016     std::string rawMemoryToString( {\cf17 const} {\cf18 void} *{\cf18 object}, std::size_t size ) \{\par
2017         {\cf20 // Reverse order for little endian architectures}\par
2018         {\cf18 int} i = 0, end = {\cf17 static_cast<}{\cf18 int}{\cf17 >}( size ), inc = 1;\par
2019         {\cf19 if}( Endianness::which() == Endianness::Little ) \{\par
2020             i = end-1;\par
2021             end = inc = -1;\par
2022         \}\par
2023 \par
2024         {\cf18 unsigned} {\cf18 char} {\cf17 const} *bytes = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char} {\cf17 const }*{\cf17 >}(object);\par
2025         ReusableStringStream rss;\par
2026         rss << {\cf22 "0x"} << std::setfill({\cf23 '0'}) << std::hex;\par
2027         {\cf19 for}( ; i != end; i += inc )\par
2028              rss << std::setw(2) << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(bytes[i]);\par
2029        {\cf19 return} rss.str();\par
2030     \}\par
2031 \} {\cf20 // end Detail namespace}\par
2032 \par
2033 \par
2034 \par
2036 {\cf20 //}\par
2037 {\cf20 //   Out-of-line defs for full specialization of StringMaker}\par
2038 {\cf20 //}\par
2040 \par
2041 std::string StringMaker<std::string>::convert({\cf17 const} std::string& str) \{\par
2042     {\cf19 return} Detail::convertIntoString( str );\par
2043 \}\par
2044 \par
2045 {\cf21 #ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2046 std::string StringMaker<std::string_view>::convert(std::string_view str) \{\par
2047     {\cf19 return} Detail::convertIntoString( StringRef( str.data(), str.size() ) );\par
2048 \}\par
2049 {\cf21 #endif}\par
2050 \par
2051 std::string StringMaker<char const*>::convert({\cf18 char} {\cf17 const}* str) \{\par
2052     {\cf19 if} (str) \{\par
2053         {\cf19 return} Detail::convertIntoString( str );\par
2054     \} {\cf19 else} \{\par
2055         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2056     \}\par
2057 \}\par
2058 std::string StringMaker<char*>::convert({\cf18 char}* str) \{ {\cf20 // NOLINT(readability-non-const-parameter)}\par
2059     {\cf19 if} (str) \{\par
2060         {\cf19 return} Detail::convertIntoString( str );\par
2061     \} {\cf19 else} \{\par
2062         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2063     \}\par
2064 \}\par
2065 \par
2066 {\cf21 #ifdef CATCH_CONFIG_WCHAR}\par
2067 std::string StringMaker<std::wstring>::convert({\cf17 const} std::wstring& wstr) \{\par
2068     std::string s;\par
2069     s.reserve(wstr.size());\par
2070     {\cf19 for} ({\cf17 auto} c : wstr) \{\par
2071         s += (c <= 0xff) ? static_cast<char>(c) : {\cf23 '?'};\par
2072     \}\par
2073     return ::Catch::Detail::stringify(s);\par
2074 \}\par
2075 \par
2076 {\cf21 # ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2077 std::string StringMaker<std::wstring_view>::convert(std::wstring_view str) \{\par
2078     {\cf19 return} StringMaker<std::wstring>::convert(std::wstring(str));\par
2079 \}\par
2080 {\cf21 # endif}\par
2081 \par
2082 std::string StringMaker<wchar_t const*>::convert({\cf18 wchar_t} {\cf17 const} * str) \{\par
2083     {\cf19 if} (str) \{\par
2084         return ::Catch::Detail::stringify(std::wstring\{ str \});\par
2085     \} {\cf19 else} \{\par
2086         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2087     \}\par
2088 \}\par
2089 std::string StringMaker<wchar_t *>::convert({\cf18 wchar_t} * str) \{\par
2090     {\cf19 if} (str) \{\par
2091         return ::Catch::Detail::stringify(std::wstring\{ str \});\par
2092     \} {\cf19 else} \{\par
2093         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2094     \}\par
2095 \}\par
2096 {\cf21 #endif}\par
2097 \par
2098 {\cf21 #if defined(CATCH_CONFIG_CPP17_BYTE)}\par
2099 {\cf21 #include <cstddef>}\par
2100 std::string StringMaker<std::byte>::convert(std::byte value) \{\par
2101     return ::Catch::Detail::stringify(std::to_integer<unsigned long long>(value));\par
2102 \}\par
2103 {\cf21 #endif }{\cf20 // defined(CATCH_CONFIG_CPP17_BYTE)}\par
2104 \par
2105 std::string StringMaker<int>::convert({\cf18 int} value) \{\par
2106     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2107 \}\par
2108 std::string StringMaker<long>::convert({\cf18 long} value) \{\par
2109     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2110 \}\par
2111 std::string StringMaker<long long>::convert({\cf18 long} {\cf18 long} value) \{\par
2112     ReusableStringStream rss;\par
2113     rss << value;\par
2114     {\cf19 if} (value > Detail::hexThreshold) \{\par
2115         rss << {\cf22 " (0x"} << std::hex << value << {\cf23 ')'};\par
2116     \}\par
2117     {\cf19 return} rss.str();\par
2118 \}\par
2119 \par
2120 std::string StringMaker<unsigned int>::convert({\cf18 unsigned} {\cf18 int} value) \{\par
2121     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2122 \}\par
2123 std::string StringMaker<unsigned long>::convert({\cf18 unsigned} {\cf18 long} value) \{\par
2124     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2125 \}\par
2126 std::string StringMaker<unsigned long long>::convert({\cf18 unsigned} {\cf18 long} {\cf18 long} value) \{\par
2127     ReusableStringStream rss;\par
2128     rss << value;\par
2129     {\cf19 if} (value > Detail::hexThreshold) \{\par
2130         rss << {\cf22 " (0x"} << std::hex << value << {\cf23 ')'};\par
2131     \}\par
2132     {\cf19 return} rss.str();\par
2133 \}\par
2134 \par
2135 std::string StringMaker<signed char>::convert({\cf18 signed} {\cf18 char} value) \{\par
2136     {\cf19 if} (value == {\cf23 '\\r'}) \{\par
2137         {\cf19 return} {\cf22 "'\\\\r'"};\par
2138     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\f'}) \{\par
2139         {\cf19 return} {\cf22 "'\\\\f'"};\par
2140     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\n'}) \{\par
2141         {\cf19 return} {\cf22 "'\\\\n'"};\par
2142     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\t'}) \{\par
2143         {\cf19 return} {\cf22 "'\\\\t'"};\par
2144     \} {\cf19 else} {\cf19 if} ({\cf23 '\\0'} <= value && value < {\cf23 ' '}) \{\par
2145         return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(value));\par
2146     \} {\cf19 else} \{\par
2147         {\cf18 char} chstr[] = {\cf22 "' '"};\par
2148         chstr[1] = value;\par
2149         {\cf19 return} chstr;\par
2150     \}\par
2151 \}\par
2152 std::string StringMaker<char>::convert({\cf18 char} c) \{\par
2153     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 signed} {\cf18 char}{\cf17 >}(c));\par
2154 \}\par
2155 std::string StringMaker<unsigned char>::convert({\cf18 unsigned} {\cf18 char} value) \{\par
2156     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 char}{\cf17 >}(value));\par
2157 \}\par
2158 \par
2159 {\cf18 int} StringMaker<float>::precision = std::numeric_limits<float>::max_digits10;\par
2160 \par
2161 std::string StringMaker<float>::convert({\cf18 float} value) \{\par
2162     {\cf19 return} Detail::fpToString(value, precision) + {\cf23 'f'};\par
2163 \}\par
2164 \par
2165 {\cf18 int} StringMaker<double>::precision = std::numeric_limits<double>::max_digits10;\par
2166 \par
2167 std::string StringMaker<double>::convert({\cf18 double} value) \{\par
2168     {\cf19 return} Detail::fpToString(value, precision);\par
2169 \}\par
2170 \par
2171 \} {\cf20 // end namespace Catch}\par
2172 \par
2173 \par
2174 \par
2175 {\cf17 namespace }Catch \{\par
2176 \par
2177     Counts Counts::operator - ( Counts {\cf17 const}& other ){\cf17  const }\{\par
2178         Counts diff;\par
2179         diff.passed = passed - other.passed;\par
2180         diff.failed = failed - other.failed;\par
2181         diff.failedButOk = failedButOk - other.failedButOk;\par
2182         diff.skipped = skipped - other.skipped;\par
2183         {\cf19 return} diff;\par
2184     \}\par
2185 \par
2186     Counts& Counts::operator += ( Counts {\cf17 const}& other ) \{\par
2187         passed += other.passed;\par
2188         failed += other.failed;\par
2189         failedButOk += other.failedButOk;\par
2190         skipped += other.skipped;\par
2191         {\cf19 return} *{\cf17 this};\par
2192     \}\par
2193 \par
2194     std::uint64_t Counts::total(){\cf17  const }\{\par
2195         {\cf19 return} passed + failed + failedButOk + skipped;\par
2196     \}\par
2197     {\cf18 bool} Counts::allPassed(){\cf17  const }\{\par
2198         {\cf19 return} failed == 0 && failedButOk == 0 && skipped == 0;\par
2199     \}\par
2200     {\cf18 bool} Counts::allOk(){\cf17  const }\{\par
2201         {\cf19 return} failed == 0;\par
2202     \}\par
2203 \par
2204     Totals Totals::operator - ( Totals {\cf17 const}& other ){\cf17  const }\{\par
2205         Totals diff;\par
2206         diff.assertions = assertions - other.assertions;\par
2207         diff.testCases = testCases - other.testCases;\par
2208         {\cf19 return} diff;\par
2209     \}\par
2210 \par
2211     Totals& Totals::operator += ( Totals {\cf17 const}& other ) \{\par
2212         assertions += other.assertions;\par
2213         testCases += other.testCases;\par
2214         {\cf19 return} *{\cf17 this};\par
2215     \}\par
2216 \par
2217     Totals Totals::delta( Totals {\cf17 const}& prevTotals ){\cf17  const }\{\par
2218         Totals diff = *{\cf17 this} - prevTotals;\par
2219         {\cf19 if}( diff.assertions.failed > 0 )\par
2220             ++diff.testCases.failed;\par
2221         {\cf19 else} {\cf19 if}( diff.assertions.failedButOk > 0 )\par
2222             ++diff.testCases.failedButOk;\par
2223         {\cf19 else} {\cf19 if} ( diff.assertions.skipped > 0 )\par
2224             ++ diff.testCases.skipped;\par
2225         {\cf19 else}\par
2226             ++diff.testCases.passed;\par
2227         {\cf19 return} diff;\par
2228     \}\par
2229 \par
2230 \}\par
2231 \par
2232 \par
2233 \par
2234 \par
2235 {\cf17 namespace }Catch \{\par
2236     {\cf17 namespace }Detail \{\par
2237         {\cf18 void} registerTranslatorImpl(\par
2238             Detail::unique_ptr<IExceptionTranslator>&& translator ) \{\par
2239             getMutableRegistryHub().registerTranslator(\par
2240                 CATCH_MOVE( translator ) );\par
2241         \}\par
2242     \} {\cf20 // namespace Detail}\par
2243 \} {\cf20 // namespace Catch}\par
2244 \par
2245 \par
2246 {\cf21 #include <ostream>}\par
2247 \par
2248 {\cf17 namespace }Catch \{\par
2249 \par
2250     Version::Version\par
2251         (   {\cf18 unsigned} {\cf18 int} _majorVersion,\par
2252             {\cf18 unsigned} {\cf18 int} _minorVersion,\par
2253             {\cf18 unsigned} {\cf18 int} _patchNumber,\par
2254             {\cf18 char} {\cf17 const} * {\cf17 const} _branchName,\par
2255             {\cf18 unsigned} {\cf18 int} _buildNumber )\par
2256     :   majorVersion( _majorVersion ),\par
2257         minorVersion( _minorVersion ),\par
2258         patchNumber( _patchNumber ),\par
2259         branchName( _branchName ),\par
2260         buildNumber( _buildNumber )\par
2261     \{\}\par
2262 \par
2263     std::ostream& operator << ( std::ostream& os, Version {\cf17 const}& version ) \{\par
2264         os  << version.majorVersion << {\cf23 '.'}\par
2265             << version.minorVersion << {\cf23 '.'}\par
2266             << version.patchNumber;\par
2267         {\cf20 // branchName is never null -> 0th char is \\0 if it is empty}\par
2268         {\cf19 if} (version.branchName[0]) \{\par
2269             os << {\cf23 '-'} << version.branchName\par
2270                << {\cf23 '.'} << version.buildNumber;\par
2271         \}\par
2272         {\cf19 return} os;\par
2273     \}\par
2274 \par
2275     Version {\cf17 const}& libraryVersion() \{\par
2276         {\cf17 static} Version version( 3, 6, 0, {\cf22 ""}, 0 );\par
2277         {\cf19 return} version;\par
2278     \}\par
2279 \par
2280 \}\par
2281 \par
2282 \par
2283 \par
2284 \par
2285 {\cf17 namespace }Catch \{\par
2286 \par
2287     {\cf17 const} {\cf18 char}* GeneratorException::what() const noexcept \{\par
2288         {\cf19 return} m_msg;\par
2289     \}\par
2290 \par
2291 \} {\cf20 // end namespace Catch}\par
2292 \par
2293 \par
2294 \par
2295 \par
2296 {\cf17 namespace }Catch \{\par
2297 \par
2298     IGeneratorTracker::~IGeneratorTracker() = {\cf19 default};\par
2299 \par
2300 {\cf17 namespace }Generators \{\par
2301 \par
2302 {\cf17 namespace }Detail \{\par
2303 \par
2304     [[noreturn]]\par
2305     {\cf18 void} throw_generator_exception({\cf18 char} {\cf17 const}* msg) \{\par
2306         Catch::throw_exception(GeneratorException\{ msg \});\par
2307     \}\par
2308 \} {\cf20 // end namespace Detail}\par
2309 \par
2310     GeneratorUntypedBase::~GeneratorUntypedBase() = {\cf19 default};\par
2311 \par
2312     IGeneratorTracker* acquireGeneratorTracker(StringRef generatorName, SourceLineInfo {\cf17 const}& lineInfo ) \{\par
2313         {\cf19 return} getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );\par
2314     \}\par
2315 \par
2316     IGeneratorTracker* createGeneratorTracker( StringRef generatorName,\par
2317                                  SourceLineInfo lineInfo,\par
2318                                  GeneratorBasePtr&& generator ) \{\par
2319         {\cf19 return} getResultCapture().createGeneratorTracker(\par
2320             generatorName, lineInfo, CATCH_MOVE( generator ) );\par
2321     \}\par
2322 \par
2323 \} {\cf20 // namespace Generators}\par
2324 \} {\cf20 // namespace Catch}\par
2325 \par
2326 \par
2327 \par
2328 \par
2329 {\cf21 #include <random>}\par
2330 \par
2331 {\cf17 namespace }Catch \{\par
2332     {\cf17 namespace }Generators \{\par
2333         {\cf17 namespace }Detail \{\par
2334             std::uint32_t getSeed() \{ {\cf19 return} sharedRng()(); \}\par
2335         \} {\cf20 // namespace Detail}\par
2336 \par
2337         {\cf17 struct }RandomFloatingGenerator<long double>::PImpl \{\par
2338             PImpl( {\cf18 long} {\cf18 double} a, {\cf18 long} {\cf18 double} b, uint32_t seed ):\par
2339                 rng( seed ), dist( a, b ) \{\}\par
2340 \par
2341             Catch::SimplePcg32 rng;\par
2342             std::uniform_real_distribution<long double> dist;\par
2343         \};\par
2344 \par
2345         RandomFloatingGenerator<long double>::RandomFloatingGenerator(\par
2346             {\cf18 long} {\cf18 double} a, {\cf18 long} {\cf18 double} b, std::uint32_t seed) :\par
2347             m_pimpl(Catch::Detail::make_unique<PImpl>(a, b, seed)) \{\par
2348             {\cf17 static_cast<}{\cf18 void}{\cf17 >}( next() );\par
2349         \}\par
2350 \par
2351         RandomFloatingGenerator<long double>::~RandomFloatingGenerator() =\par
2352             {\cf19 default};\par
2353         {\cf18 bool} RandomFloatingGenerator<long double>::next() \{\par
2354             m_current_number = m_pimpl->dist( m_pimpl->rng );\par
2355             {\cf19 return} {\cf17 true};\par
2356         \}\par
2357     \} {\cf20 // namespace Generators}\par
2358 \} {\cf20 // namespace Catch}\par
2359 \par
2360 \par
2361 \par
2362 \par
2363 {\cf17 namespace }Catch \{\par
2364     IResultCapture::~IResultCapture() = {\cf19 default};\par
2365 \}\par
2366 \par
2367 \par
2368 \par
2369 \par
2370 {\cf17 namespace }Catch \{\par
2371     IConfig::~IConfig() = {\cf19 default};\par
2372 \}\par
2373 \par
2374 \par
2375 \par
2376 \par
2377 {\cf17 namespace }Catch \{\par
2378     IExceptionTranslator::~IExceptionTranslator() = {\cf19 default};\par
2379     IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = {\cf19 default};\par
2380 \}\par
2381 \par
2382 \par
2383 \par
2384 {\cf21 #include <string>}\par
2385 \par
2386 {\cf17 namespace }Catch \{\par
2387     {\cf17 namespace }Generators \{\par
2388 \par
2389         {\cf18 bool} GeneratorUntypedBase::countedNext() \{\par
2390             {\cf17 auto} ret = next();\par
2391             {\cf19 if} ( ret ) \{\par
2392                 m_stringReprCache.clear();\par
2393                 ++m_currentElementIndex;\par
2394             \}\par
2395             {\cf19 return} ret;\par
2396         \}\par
2397 \par
2398         StringRef GeneratorUntypedBase::currentElementAsString(){\cf17  const }\{\par
2399             {\cf19 if} ( m_stringReprCache.empty() ) \{\par
2400                 m_stringReprCache = stringifyImpl();\par
2401             \}\par
2402             {\cf19 return} m_stringReprCache;\par
2403         \}\par
2404 \par
2405     \} {\cf20 // namespace Generators}\par
2406 \} {\cf20 // namespace Catch}\par
2407 \par
2408 \par
2409 \par
2410 \par
2411 {\cf17 namespace }Catch \{\par
2412     IRegistryHub::~IRegistryHub() = {\cf19 default};\par
2413     IMutableRegistryHub::~IMutableRegistryHub() = {\cf19 default};\par
2414 \}\par
2415 \par
2416 \par
2417 \par
2418 {\cf21 #include <cassert>}\par
2419 \par
2420 {\cf17 namespace }Catch \{\par
2421 \par
2422     ReporterConfig::ReporterConfig(\par
2423         IConfig {\cf17 const}* _fullConfig,\par
2424         Detail::unique_ptr<IStream> _stream,\par
2425         ColourMode colourMode,\par
2426         std::map<std::string, std::string> customOptions ):\par
2427         m_stream( CATCH_MOVE(_stream) ),\par
2428         m_fullConfig( _fullConfig ),\par
2429         m_colourMode( colourMode ),\par
2430         m_customOptions( CATCH_MOVE( customOptions ) ) \{\}\par
2431 \par
2432     Detail::unique_ptr<IStream> ReporterConfig::takeStream() && \{\par
2433         assert( m_stream );\par
2434         {\cf19 return} CATCH_MOVE( m_stream );\par
2435     \}\par
2436     IConfig {\cf17 const} * ReporterConfig::fullConfig(){\cf17  const }\{ {\cf19 return} m_fullConfig; \}\par
2437     ColourMode ReporterConfig::colourMode(){\cf17  const }\{ {\cf19 return} m_colourMode; \}\par
2438 \par
2439     std::map<std::string, std::string> {\cf17 const}&\par
2440     ReporterConfig::customOptions(){\cf17  const }\{\par
2441         {\cf19 return} m_customOptions;\par
2442     \}\par
2443 \par
2444     ReporterConfig::~ReporterConfig() = {\cf19 default};\par
2445 \par
2446     AssertionStats::AssertionStats( AssertionResult {\cf17 const}& _assertionResult,\par
2447                                     std::vector<MessageInfo> {\cf17 const}& _infoMessages,\par
2448                                     Totals {\cf17 const}& _totals )\par
2449     :   assertionResult( _assertionResult ),\par
2450         infoMessages( _infoMessages ),\par
2451         totals( _totals )\par
2452     \{\par
2453         {\cf19 if}( assertionResult.hasMessage() ) \{\par
2454             {\cf20 // Copy message into messages list.}\par
2455             {\cf20 // !TBD This should have been done earlier, somewhere}\par
2456             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );\par
2457             builder.m_info.message = static_cast<std::string>(assertionResult.getMessage());\par
2458 \par
2459             infoMessages.push_back( CATCH_MOVE(builder.m_info) );\par
2460         \}\par
2461     \}\par
2462 \par
2463     SectionStats::SectionStats(  SectionInfo&& _sectionInfo,\par
2464                                  Counts {\cf17 const}& _assertions,\par
2465                                  {\cf18 double} _durationInSeconds,\par
2466                                  {\cf18 bool} _missingAssertions )\par
2467     :   sectionInfo( CATCH_MOVE(_sectionInfo) ),\par
2468         assertions( _assertions ),\par
2469         durationInSeconds( _durationInSeconds ),\par
2470         missingAssertions( _missingAssertions )\par
2471     \{\}\par
2472 \par
2473 \par
2474     TestCaseStats::TestCaseStats(  TestCaseInfo {\cf17 const}& _testInfo,\par
2475                                    Totals {\cf17 const}& _totals,\par
2476                                    std::string&& _stdOut,\par
2477                                    std::string&& _stdErr,\par
2478                                    {\cf18 bool} _aborting )\par
2479     : testInfo( &_testInfo ),\par
2480         totals( _totals ),\par
2481         stdOut( CATCH_MOVE(_stdOut) ),\par
2482         stdErr( CATCH_MOVE(_stdErr) ),\par
2483         aborting( _aborting )\par
2484     \{\}\par
2485 \par
2486 \par
2487     TestRunStats::TestRunStats(   TestRunInfo {\cf17 const}& _runInfo,\par
2488                     Totals {\cf17 const}& _totals,\par
2489                     {\cf18 bool} _aborting )\par
2490     :   runInfo( _runInfo ),\par
2491         totals( _totals ),\par
2492         aborting( _aborting )\par
2493     \{\}\par
2494 \par
2495     IEventListener::~IEventListener() = {\cf19 default};\par
2496 \par
2497 \} {\cf20 // end namespace Catch}\par
2498 \par
2499 \par
2500 \par
2501 \par
2502 {\cf17 namespace }Catch \{\par
2503     IReporterFactory::~IReporterFactory() = {\cf19 default};\par
2504     EventListenerFactory::~EventListenerFactory() = {\cf19 default};\par
2505 \}\par
2506 \par
2507 \par
2508 \par
2509 \par
2510 {\cf17 namespace }Catch \{\par
2511     ITestCaseRegistry::~ITestCaseRegistry() = {\cf19 default};\par
2512 \}\par
2513 \par
2514 \par
2515 \par
2516 {\cf17 namespace }Catch \{\par
2517 \par
2518     AssertionHandler::AssertionHandler\par
2519         (   StringRef macroName,\par
2520             SourceLineInfo {\cf17 const}& lineInfo,\par
2521             StringRef capturedExpression,\par
2522             ResultDisposition::Flags resultDisposition )\par
2523     :   m_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},\par
2524         m_resultCapture( getResultCapture() )\par
2525     \{\par
2526         m_resultCapture.notifyAssertionStarted( m_assertionInfo );\par
2527     \}\par
2528 \par
2529     {\cf18 void} AssertionHandler::handleExpr( ITransientExpression {\cf17 const}& expr ) \{\par
2530         m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );\par
2531     \}\par
2532     {\cf18 void} AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef message) \{\par
2533         m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );\par
2534     \}\par
2535 \par
2536     {\cf17 auto} AssertionHandler::allowThrows() const -> {\cf18 bool} \{\par
2537         {\cf19 return} getCurrentContext().getConfig()->allowThrows();\par
2538     \}\par
2539 \par
2540     {\cf18 void} AssertionHandler::complete() \{\par
2541         m_completed = {\cf17 true};\par
2542         {\cf19 if}( m_reaction.shouldDebugBreak ) \{\par
2543 \par
2544             {\cf20 // If you find your debugger stopping you here then go one level up on the}\par
2545             {\cf20 // call-stack for the code that caused it (typically a failed assertion)}\par
2546 \par
2547             {\cf20 // (To go back to the test and change execution, jump over the throw, next)}\par
2548             CATCH_BREAK_INTO_DEBUGGER();\par
2549         \}\par
2550         {\cf19 if} (m_reaction.shouldThrow) \{\par
2551             throw_test_failure_exception();\par
2552         \}\par
2553         {\cf19 if} ( m_reaction.shouldSkip ) \{\par
2554             throw_test_skip_exception();\par
2555         \}\par
2556     \}\par
2557 \par
2558     {\cf18 void} AssertionHandler::handleUnexpectedInflightException() \{\par
2559         m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );\par
2560     \}\par
2561 \par
2562     {\cf18 void} AssertionHandler::handleExceptionThrownAsExpected() \{\par
2563         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2564     \}\par
2565     {\cf18 void} AssertionHandler::handleExceptionNotThrownAsExpected() \{\par
2566         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2567     \}\par
2568 \par
2569     {\cf18 void} AssertionHandler::handleUnexpectedExceptionNotThrown() \{\par
2570         m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );\par
2571     \}\par
2572 \par
2573     {\cf18 void} AssertionHandler::handleThrowingCallSkipped() \{\par
2574         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2575     \}\par
2576 \par
2577     {\cf20 // This is the overload that takes a string and infers the Equals matcher from it}\par
2578     {\cf20 // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp}\par
2579     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, std::string {\cf17 const}& str ) \{\par
2580         handleExceptionMatchExpr( handler, Matchers::Equals( str ) );\par
2581     \}\par
2582 \par
2583 \} {\cf20 // namespace Catch}\par
2584 \par
2585 \par
2586 \par
2587 \par
2588 {\cf21 #include <algorithm>}\par
2589 \par
2590 {\cf17 namespace }Catch \{\par
2591     {\cf17 namespace }Detail \{\par
2592 \par
2593         {\cf18 bool} CaseInsensitiveLess::operator()( StringRef lhs,\par
2594                                               StringRef rhs ){\cf17  const }\{\par
2595             {\cf19 return} std::lexicographical_compare(\par
2596                 lhs.begin(), lhs.end(),\par
2597                 rhs.begin(), rhs.end(),\par
2598                 []( {\cf18 char} l, {\cf18 char} r ) \{ return toLower( l ) < toLower( r ); \} );\par
2599         \}\par
2600 \par
2601         {\cf18 bool}\par
2602         CaseInsensitiveEqualTo::operator()( StringRef lhs,\par
2603                                             StringRef rhs ){\cf17  const }\{\par
2604             {\cf19 return} std::equal(\par
2605                 lhs.begin(), lhs.end(),\par
2606                 rhs.begin(), rhs.end(),\par
2607                 []( {\cf18 char} l, {\cf18 char} r ) \{ return toLower( l ) == toLower( r ); \} );\par
2608         \}\par
2609 \par
2610     \} {\cf20 // namespace Detail}\par
2611 \} {\cf20 // namespace Catch}\par
2612 \par
2613 \par
2614 \par
2615 \par
2616 {\cf21 #include <algorithm>}\par
2617 {\cf21 #include <ostream>}\par
2618 \par
2619 {\cf17 namespace }\{\par
2620     {\cf18 bool} isOptPrefix( {\cf18 char} c ) \{\par
2621         {\cf19 return} c == {\cf23 '-'}\par
2622 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
2623                || c == {\cf23 '/'}\par
2624 {\cf21 #endif}\par
2625             ;\par
2626     \}\par
2627 \par
2628     Catch::StringRef normaliseOpt( Catch::StringRef optName ) \{\par
2629         {\cf19 if} ( optName[0] == {\cf23 '-'}\par
2630 #{\cf19 if} defined(CATCH_PLATFORM_WINDOWS)\par
2631              || optName[0] == {\cf23 '/'}\par
2632 #endif\par
2633         ) \{\par
2634             {\cf19 return} optName.substr( 1, optName.size() );\par
2635         \}\par
2636 \par
2637         {\cf19 return} optName;\par
2638     \}\par
2639 \par
2640     {\cf17 static} {\cf18 size_t} find_first_separator(Catch::StringRef sr) \{\par
2641         {\cf17 auto} is_separator = []( {\cf18 char} c ) \{\par
2642             {\cf19 return} c == {\cf23 ' '} || c == {\cf23 ':'} || c == {\cf23 '='};\par
2643         \};\par
2644         {\cf18 size_t} pos = 0;\par
2645         {\cf19 while} (pos < sr.size()) \{\par
2646             {\cf19 if} (is_separator(sr[pos])) \{ {\cf19 return} pos; \}\par
2647             ++pos;\par
2648         \}\par
2649 \par
2650         {\cf19 return} Catch::StringRef::npos;\par
2651     \}\par
2652 \par
2653 \} {\cf20 // namespace}\par
2654 \par
2655 {\cf17 namespace }Catch \{\par
2656     {\cf17 namespace }Clara \{\par
2657         {\cf17 namespace }Detail \{\par
2658 \par
2659             {\cf18 void} TokenStream::loadBuffer() \{\par
2660                 m_tokenBuffer.clear();\par
2661 \par
2662                 {\cf20 // Skip any empty strings}\par
2663                 {\cf19 while} ( it != itEnd && it->empty() ) \{\par
2664                     ++it;\par
2665                 \}\par
2666 \par
2667                 {\cf19 if} ( it != itEnd ) \{\par
2668                     StringRef next = *it;\par
2669                     {\cf19 if} ( isOptPrefix( next[0] ) ) \{\par
2670                         {\cf17 auto} delimiterPos = find_first_separator(next);\par
2671                         {\cf19 if} ( delimiterPos != StringRef::npos ) \{\par
2672                             m_tokenBuffer.push_back(\par
2673                                 \{ TokenType::Option,\par
2674                                   next.substr( 0, delimiterPos ) \} );\par
2675                             m_tokenBuffer.push_back(\par
2676                                 \{ TokenType::Argument,\par
2677                                   next.substr( delimiterPos + 1, next.size() ) \} );\par
2678                         \} {\cf19 else} \{\par
2679                             {\cf19 if} ( next[1] != {\cf23 '-'} && next.size() > 2 ) \{\par
2680                                 {\cf20 // Combined short args, e.g. "-ab" for "-a -b"}\par
2681                                 {\cf19 for} ( {\cf18 size_t} i = 1; i < next.size(); ++i ) \{\par
2682                                     m_tokenBuffer.push_back(\par
2683                                         \{ TokenType::Option,\par
2684                                           next.substr( i, 1 ) \} );\par
2685                                 \}\par
2686                             \} {\cf19 else} \{\par
2687                                 m_tokenBuffer.push_back(\par
2688                                     \{ TokenType::Option, next \} );\par
2689                             \}\par
2690                         \}\par
2691                     \} {\cf19 else} \{\par
2692                         m_tokenBuffer.push_back(\par
2693                             \{ TokenType::Argument, next \} );\par
2694                     \}\par
2695                 \}\par
2696             \}\par
2697 \par
2698             TokenStream::TokenStream( Args {\cf17 const}& args ):\par
2699                 TokenStream( args.m_args.begin(), args.m_args.end() ) \{\}\par
2700 \par
2701             TokenStream::TokenStream( Iterator it_, Iterator itEnd_ ):\par
2702                 it( it_ ), itEnd( itEnd_ ) \{\par
2703                 loadBuffer();\par
2704             \}\par
2705 \par
2706             TokenStream& TokenStream::operator++() \{\par
2707                 {\cf19 if} ( m_tokenBuffer.size() >= 2 ) \{\par
2708                     m_tokenBuffer.erase( m_tokenBuffer.begin() );\par
2709                 \} {\cf19 else} \{\par
2710                     {\cf19 if} ( it != itEnd )\par
2711                         ++it;\par
2712                     loadBuffer();\par
2713                 \}\par
2714                 {\cf19 return} *{\cf17 this};\par
2715             \}\par
2716 \par
2717             ParserResult convertInto( std::string {\cf17 const}& source,\par
2718                                       std::string& target ) \{\par
2719                 target = source;\par
2720                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2721             \}\par
2722 \par
2723             ParserResult convertInto( std::string {\cf17 const}& source,\par
2724                                       {\cf18 bool}& target ) \{\par
2725                 std::string srcLC = toLower( source );\par
2726 \par
2727                 {\cf19 if} ( srcLC == {\cf22 "y"} || srcLC == {\cf22 "1"} || srcLC == {\cf22 "true"} ||\par
2728                      srcLC == {\cf22 "yes"} || srcLC == {\cf22 "on"} ) \{\par
2729                     target = {\cf17 true};\par
2730                 \} {\cf19 else} {\cf19 if} ( srcLC == {\cf22 "n"} || srcLC == {\cf22 "0"} || srcLC == {\cf22 "false"} ||\par
2731                             srcLC == {\cf22 "no"} || srcLC == {\cf22 "off"} ) \{\par
2732                     target = {\cf17 false};\par
2733                 \} {\cf19 else} \{\par
2734                     {\cf19 return} ParserResult::runtimeError(\par
2735                         {\cf22 "Expected a boolean value but did not recognise: '"} +\par
2736                         source + {\cf23 '\\''} );\par
2737                 \}\par
2738                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2739             \}\par
2740 \par
2741             {\cf18 size_t} ParserBase::cardinality(){\cf17  const }\{ {\cf19 return} 1; \}\par
2742 \par
2743             InternalParseResult ParserBase::parse( Args {\cf17 const}& args ){\cf17  const }\{\par
2744                 {\cf19 return} parse( {\cf17 static_cast<}std::string{\cf17 >}(args.exeName()), TokenStream( args ) );\par
2745             \}\par
2746 \par
2747             ParseState::ParseState( ParseResultType type,\par
2748                                     TokenStream remainingTokens ):\par
2749                 m_type( type ), m_remainingTokens( CATCH_MOVE(remainingTokens) ) \{\}\par
2750 \par
2751             ParserResult BoundFlagRef::setFlag( {\cf18 bool} flag ) \{\par
2752                 m_ref = flag;\par
2753                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2754             \}\par
2755 \par
2756             ResultBase::~ResultBase() = {\cf19 default};\par
2757 \par
2758             {\cf18 bool} BoundRef::isContainer(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
2759 \par
2760             {\cf18 bool} BoundRef::isFlag(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
2761 \par
2762             {\cf18 bool} BoundFlagRefBase::isFlag(){\cf17  const }\{ {\cf19 return} {\cf17 true}; \}\par
2763 \par
2764 \} {\cf20 // namespace Detail}\par
2765 \par
2766         Detail::InternalParseResult Arg::parse(std::string {\cf17 const}&,\par
2767                                                Detail::TokenStream tokens){\cf17  const }\{\par
2768             {\cf17 auto} validationResult = validate();\par
2769             {\cf19 if} (!validationResult)\par
2770                 {\cf19 return} Detail::InternalParseResult(validationResult);\par
2771 \par
2772             {\cf17 auto} token = *tokens;\par
2773             {\cf19 if} (token.type != Detail::TokenType::Argument)\par
2774                 {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2775                     ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2776 \par
2777             assert(!m_ref->isFlag());\par
2778             {\cf17 auto} valueRef =\par
2779                 {\cf17 static_cast<}Detail::BoundValueRefBase*{\cf17 >}(m_ref.get());\par
2780 \par
2781             {\cf17 auto} result = valueRef->setValue({\cf17 static_cast<}std::string{\cf17 >}(token.token));\par
2782             {\cf19 if} ( !result )\par
2783                 {\cf19 return} Detail::InternalParseResult( result );\par
2784             {\cf19 else}\par
2785                 {\cf19 return} Detail::InternalParseResult::ok(\par
2786                     Detail::ParseState( ParseResultType::Matched,\par
2787                                         CATCH_MOVE( ++tokens ) ) );\par
2788         \}\par
2789 \par
2790         Opt::Opt({\cf18 bool}& ref) :\par
2791             ParserRefImpl(std::make_shared<Detail::BoundFlagRef>(ref)) \{\}\par
2792 \par
2793         Detail::HelpColumns Opt::getHelpColumns(){\cf17  const }\{\par
2794             ReusableStringStream oss;\par
2795             {\cf18 bool} first = {\cf17 true};\par
2796             {\cf19 for} ({\cf17 auto} {\cf17 const}& opt : m_optNames) \{\par
2797                 {\cf19 if} (first)\par
2798                     first = {\cf17 false};\par
2799                 {\cf19 else}\par
2800                     oss << {\cf22 ", "};\par
2801                 oss << opt;\par
2802             \}\par
2803             {\cf19 if} (!m_hint.empty())\par
2804                 oss << {\cf22 " <"} << m_hint << {\cf23 '>'};\par
2805             {\cf19 return} \{ oss.str(), m_description \};\par
2806         \}\par
2807 \par
2808         {\cf18 bool} Opt::isMatch(StringRef optToken){\cf17  const }\{\par
2809             {\cf17 auto} normalisedToken = normaliseOpt(optToken);\par
2810             {\cf19 for} ({\cf17 auto} {\cf17 const}& name : m_optNames) \{\par
2811                 {\cf19 if} (normaliseOpt(name) == normalisedToken)\par
2812                     {\cf19 return} {\cf17 true};\par
2813             \}\par
2814             {\cf19 return} {\cf17 false};\par
2815         \}\par
2816 \par
2817         Detail::InternalParseResult Opt::parse(std::string {\cf17 const}&,\par
2818                                        Detail::TokenStream tokens){\cf17  const }\{\par
2819             {\cf17 auto} validationResult = validate();\par
2820             {\cf19 if} (!validationResult)\par
2821                 {\cf19 return} Detail::InternalParseResult(validationResult);\par
2822 \par
2823             {\cf19 if} (tokens &&\par
2824                 tokens->type == Detail::TokenType::Option) \{\par
2825                 {\cf17 auto} {\cf17 const}& token = *tokens;\par
2826                 {\cf19 if} (isMatch(token.token)) \{\par
2827                     {\cf19 if} (m_ref->isFlag()) \{\par
2828                         {\cf17 auto} flagRef =\par
2829                             {\cf17 static_cast<}Detail::BoundFlagRefBase*{\cf17 >}(\par
2830                                 m_ref.get());\par
2831                         {\cf17 auto} result = flagRef->setFlag({\cf17 true});\par
2832                         {\cf19 if} (!result)\par
2833                             {\cf19 return} Detail::InternalParseResult(result);\par
2834                         {\cf19 if} (result.value() ==\par
2835                             ParseResultType::ShortCircuitAll)\par
2836                             {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2837                                 result.value(), CATCH_MOVE(tokens)));\par
2838                     \} {\cf19 else} \{\par
2839                         {\cf17 auto} valueRef =\par
2840                             {\cf17 static_cast<}Detail::BoundValueRefBase*{\cf17 >}(\par
2841                                 m_ref.get());\par
2842                         ++tokens;\par
2843                         {\cf19 if} (!tokens)\par
2844                             {\cf19 return} Detail::InternalParseResult::runtimeError(\par
2845                                 {\cf22 "Expected argument following "} +\par
2846                                 token.token);\par
2847                         {\cf17 auto} {\cf17 const}& argToken = *tokens;\par
2848                         {\cf19 if} (argToken.type != Detail::TokenType::Argument)\par
2849                             {\cf19 return} Detail::InternalParseResult::runtimeError(\par
2850                                 {\cf22 "Expected argument following "} +\par
2851                                 token.token);\par
2852                         {\cf17 const} {\cf17 auto} result = valueRef->setValue({\cf17 static_cast<}std::string{\cf17 >}(argToken.token));\par
2853                         {\cf19 if} (!result)\par
2854                             {\cf19 return} Detail::InternalParseResult(result);\par
2855                         {\cf19 if} (result.value() ==\par
2856                             ParseResultType::ShortCircuitAll)\par
2857                             {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2858                                 result.value(), CATCH_MOVE(tokens)));\par
2859                     \}\par
2860                     {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2861                         ParseResultType::Matched, CATCH_MOVE(++tokens)));\par
2862                 \}\par
2863             \}\par
2864             {\cf19 return} Detail::InternalParseResult::ok(\par
2865                 Detail::ParseState(ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2866         \}\par
2867 \par
2868         Detail::Result Opt::validate(){\cf17  const }\{\par
2869             {\cf19 if} (m_optNames.empty())\par
2870                 {\cf19 return} Detail::Result::logicError({\cf22 "No options supplied to Opt"});\par
2871             {\cf19 for} ({\cf17 auto} {\cf17 const}& name : m_optNames) \{\par
2872                 {\cf19 if} (name.empty())\par
2873                     {\cf19 return} Detail::Result::logicError(\par
2874                         {\cf22 "Option name cannot be empty"});\par
2875 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
2876                 {\cf19 if} (name[0] != {\cf23 '-'} && name[0] != {\cf23 '/'})\par
2877                     {\cf19 return} Detail::Result::logicError(\par
2878                         {\cf22 "Option name must begin with '-' or '/'"});\par
2879 {\cf21 #else}\par
2880                 {\cf19 if} (name[0] != {\cf23 '-'})\par
2881                     {\cf19 return} Detail::Result::logicError(\par
2882                         {\cf22 "Option name must begin with '-'"});\par
2883 {\cf21 #endif}\par
2884             \}\par
2885             {\cf19 return} ParserRefImpl::validate();\par
2886         \}\par
2887 \par
2888         ExeName::ExeName() :\par
2889             m_name(std::make_shared<std::string>({\cf22 "<executable>"})) \{\}\par
2890 \par
2891         ExeName::ExeName(std::string& ref) : ExeName() \{\par
2892             m_ref = std::make_shared<Detail::BoundValueRef<std::string>>(ref);\par
2893         \}\par
2894 \par
2895         Detail::InternalParseResult\par
2896             ExeName::parse(std::string {\cf17 const}&,\par
2897                            Detail::TokenStream tokens){\cf17  const }\{\par
2898             {\cf19 return} Detail::InternalParseResult::ok(\par
2899                 Detail::ParseState(ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2900         \}\par
2901 \par
2902         ParserResult ExeName::set(std::string {\cf17 const}& newName) \{\par
2903             {\cf17 auto} lastSlash = newName.find_last_of({\cf22 "\\\\/"});\par
2904             {\cf17 auto} filename = (lastSlash == std::string::npos)\par
2905                 ? newName\par
2906                 : newName.substr(lastSlash + 1);\par
2907 \par
2908             *m_name = filename;\par
2909             {\cf19 if} (m_ref)\par
2910                 {\cf19 return} m_ref->setValue(filename);\par
2911             {\cf19 else}\par
2912                 {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
2913         \}\par
2914 \par
2915 \par
2916 \par
2917 \par
2918         Parser& Parser::operator|=( Parser {\cf17 const}& other ) \{\par
2919             m_options.insert( m_options.end(),\par
2920                               other.m_options.begin(),\par
2921                               other.m_options.end() );\par
2922             m_args.insert(\par
2923                 m_args.end(), other.m_args.begin(), other.m_args.end() );\par
2924             {\cf19 return} *{\cf17 this};\par
2925         \}\par
2926 \par
2927         std::vector<Detail::HelpColumns> Parser::getHelpColumns(){\cf17  const }\{\par
2928             std::vector<Detail::HelpColumns> cols;\par
2929             cols.reserve( m_options.size() );\par
2930             {\cf19 for} ( {\cf17 auto} {\cf17 const}& o : m_options ) \{\par
2931                 cols.push_back(o.getHelpColumns());\par
2932             \}\par
2933             {\cf19 return} cols;\par
2934         \}\par
2935 \par
2936         {\cf18 void} Parser::writeToStream( std::ostream& os ){\cf17  const }\{\par
2937             {\cf19 if} ( !m_exeName.name().empty() ) \{\par
2938                 os << {\cf22 "usage:\\n"}\par
2939                    << {\cf22 "  "} << m_exeName.name() << {\cf23 ' '};\par
2940                 {\cf18 bool} required = {\cf17 true}, first = {\cf17 true};\par
2941                 {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
2942                     {\cf19 if} ( first )\par
2943                         first = {\cf17 false};\par
2944                     {\cf19 else}\par
2945                         os << {\cf23 ' '};\par
2946                     {\cf19 if} ( arg.isOptional() && required ) \{\par
2947                         os << {\cf23 '['};\par
2948                         required = {\cf17 false};\par
2949                     \}\par
2950                     os << {\cf23 '<'} << arg.hint() << {\cf23 '>'};\par
2951                     {\cf19 if} ( arg.cardinality() == 0 )\par
2952                         os << {\cf22 " ... "};\par
2953                 \}\par
2954                 {\cf19 if} ( !required )\par
2955                     os << {\cf23 ']'};\par
2956                 {\cf19 if} ( !m_options.empty() )\par
2957                     os << {\cf22 " options"};\par
2958                 os << {\cf22 "\\n\\nwhere options are:\\n"};\par
2959             \}\par
2960 \par
2961             {\cf17 auto} rows = getHelpColumns();\par
2962             {\cf18 size_t} consoleWidth = CATCH_CONFIG_CONSOLE_WIDTH;\par
2963             {\cf18 size_t} optWidth = 0;\par
2964             {\cf19 for} ( {\cf17 auto} {\cf17 const}& cols : rows )\par
2965                 optWidth = ( std::max )( optWidth, cols.left.size() + 2 );\par
2966 \par
2967             optWidth = ( std::min )( optWidth, consoleWidth / 2 );\par
2968 \par
2969             {\cf19 for} ( {\cf17 auto}& cols : rows ) \{\par
2970                 {\cf17 auto} row = TextFlow::Column( CATCH_MOVE(cols.left) )\par
2971                                .width( optWidth )\par
2972                                .indent( 2 ) +\par
2973                            TextFlow::Spacer( 4 ) +\par
2974                            TextFlow::Column( {\cf17 static_cast<}std::string{\cf17 >}(cols.descriptions) )\par
2975                                .width( consoleWidth - 7 - optWidth );\par
2976                 os << row << {\cf23 '\\n'};\par
2977             \}\par
2978         \}\par
2979 \par
2980         Detail::Result Parser::validate(){\cf17  const }\{\par
2981             {\cf19 for} ( {\cf17 auto} {\cf17 const}& opt : m_options ) \{\par
2982                 {\cf17 auto} result = opt.validate();\par
2983                 {\cf19 if} ( !result )\par
2984                     {\cf19 return} result;\par
2985             \}\par
2986             {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
2987                 {\cf17 auto} result = arg.validate();\par
2988                 {\cf19 if} ( !result )\par
2989                     {\cf19 return} result;\par
2990             \}\par
2991             {\cf19 return} Detail::Result::ok();\par
2992         \}\par
2993 \par
2994         Detail::InternalParseResult\par
2995         Parser::parse( std::string {\cf17 const}& exeName,\par
2996                        Detail::TokenStream tokens ){\cf17  const }\{\par
2997 \par
2998             {\cf17 struct }ParserInfo \{\par
2999                 ParserBase {\cf17 const}* parser = {\cf17 nullptr};\par
3000                 {\cf18 size_t} count = 0;\par
3001             \};\par
3002             std::vector<ParserInfo> parseInfos;\par
3003             parseInfos.reserve( m_options.size() + m_args.size() );\par
3004             {\cf19 for} ( {\cf17 auto} {\cf17 const}& opt : m_options ) \{\par
3005                 parseInfos.push_back( \{ &opt, 0 \} );\par
3006             \}\par
3007             {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
3008                 parseInfos.push_back( \{ &arg, 0 \} );\par
3009             \}\par
3010 \par
3011             m_exeName.set( exeName );\par
3012 \par
3013             {\cf17 auto} result = Detail::InternalParseResult::ok(\par
3014                 Detail::ParseState( ParseResultType::NoMatch, CATCH_MOVE(tokens) ) );\par
3015             {\cf19 while} ( result.value().remainingTokens() ) \{\par
3016                 {\cf18 bool} tokenParsed = {\cf17 false};\par
3017 \par
3018                 {\cf19 for} ( {\cf17 auto}& parseInfo : parseInfos ) \{\par
3019                     {\cf19 if} ( parseInfo.parser->cardinality() == 0 ||\par
3020                          parseInfo.count < parseInfo.parser->cardinality() ) \{\par
3021                         result = parseInfo.parser->parse(\par
3022                             exeName, CATCH_MOVE(result).value().remainingTokens() );\par
3023                         {\cf19 if} ( !result )\par
3024                             {\cf19 return} result;\par
3025                         {\cf19 if} ( result.value().type() !=\par
3026                              ParseResultType::NoMatch ) \{\par
3027                             tokenParsed = {\cf17 true};\par
3028                             ++parseInfo.count;\par
3029                             {\cf19 break};\par
3030                         \}\par
3031                     \}\par
3032                 \}\par
3033 \par
3034                 {\cf19 if} ( result.value().type() == ParseResultType::ShortCircuitAll )\par
3035                     {\cf19 return} result;\par
3036                 {\cf19 if} ( !tokenParsed )\par
3037                     {\cf19 return} Detail::InternalParseResult::runtimeError(\par
3038                         {\cf22 "Unrecognised token: "} +\par
3039                         result.value().remainingTokens()->token );\par
3040             \}\par
3041             {\cf20 // !TBD Check missing required options}\par
3042             {\cf19 return} result;\par
3043         \}\par
3044 \par
3045         Args::Args({\cf18 int} argc, {\cf18 char} {\cf17 const}* {\cf17 const}* argv) :\par
3046             m_exeName(argv[0]), m_args(argv + 1, argv + argc) \{\}\par
3047 \par
3048         Args::Args(std::initializer_list<StringRef> args) :\par
3049             m_exeName(*args.begin()),\par
3050             m_args(args.begin() + 1, args.end()) \{\}\par
3051 \par
3052 \par
3053         Help::Help( {\cf18 bool}& showHelpFlag ):\par
3054             Opt( [&]( bool flag ) \{\par
3055                 showHelpFlag = flag;\par
3056                 {\cf19 return} ParserResult::ok( ParseResultType::ShortCircuitAll );\par
3057             \} ) \{\par
3058             {\cf17 static_cast<}Opt&{\cf17 >} ( *this )(\par
3059                 {\cf22 "display usage information"} )[{\cf22 "-?"}][{\cf22 "-h"}][{\cf22 "--help"}]\par
3060                 .optional();\par
3061         \}\par
3062 \par
3063     \} {\cf20 // namespace Clara}\par
3064 \} {\cf20 // namespace Catch}\par
3065 \par
3066 \par
3067 \par
3068 \par
3069 {\cf21 #include <fstream>}\par
3070 {\cf21 #include <string>}\par
3071 \par
3072 {\cf17 namespace }Catch \{\par
3073 \par
3074     Clara::Parser makeCommandLineParser( ConfigData& config ) \{\par
3075 \par
3076         {\cf17 using namespace }Clara;\par
3077 \par
3078         {\cf17 auto} {\cf17 const} setWarning = [&]( std::string {\cf17 const}& warning ) \{\par
3079             {\cf19 if} ( warning == {\cf22 "NoAssertions"} ) \{\par
3080                 config.warnings = {\cf17 static_cast<}WarnAbout::What{\cf17 >}(config.warnings | WarnAbout::NoAssertions);\par
3081                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3082             \} {\cf19 else} {\cf19 if} ( warning == {\cf22 "UnmatchedTestSpec"} ) \{\par
3083                 config.warnings = {\cf17 static_cast<}WarnAbout::What{\cf17 >}(config.warnings | WarnAbout::UnmatchedTestSpec);\par
3084                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3085             \}\par
3086 \par
3087             {\cf19 return} ParserResult ::runtimeError(\par
3088                 {\cf22 "Unrecognised warning option: '"} + warning + {\cf23 '\\''} );\par
3089         \};\par
3090         {\cf17 auto} {\cf17 const} loadTestNamesFromFile = [&]( std::string {\cf17 const}& filename ) \{\par
3091                 std::ifstream f( filename.c_str() );\par
3092                 {\cf19 if}( !f.is_open() )\par
3093                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unable to load input file: '"} + filename + {\cf23 '\\''} );\par
3094 \par
3095                 std::string line;\par
3096                 {\cf19 while}( std::getline( f, line ) ) \{\par
3097                     line = trim(line);\par
3098                     {\cf19 if}( !line.empty() && !startsWith( line, {\cf23 '#'} ) ) \{\par
3099                         {\cf19 if}( !startsWith( line, {\cf23 '"'} ) )\par
3100                             line = {\cf23 '"'} + CATCH_MOVE(line) + {\cf23 '"'};\par
3101                         config.testsOrTags.push_back( line );\par
3102                         config.testsOrTags.emplace_back( {\cf22 ","} );\par
3103                     \}\par
3104                 \}\par
3105                 {\cf20 //Remove comma in the end}\par
3106                 {\cf19 if}(!config.testsOrTags.empty())\par
3107                     config.testsOrTags.erase( config.testsOrTags.end()-1 );\par
3108 \par
3109                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3110             \};\par
3111         {\cf17 auto} {\cf17 const} setTestOrder = [&]( std::string {\cf17 const}& order ) \{\par
3112                 {\cf19 if}( startsWith( {\cf22 "declared"}, order ) )\par
3113                     config.runOrder = TestRunOrder::Declared;\par
3114                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "lexical"}, order ) )\par
3115                     config.runOrder = TestRunOrder::LexicographicallySorted;\par
3116                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "random"}, order ) )\par
3117                     config.runOrder = TestRunOrder::Randomized;\par
3118                 {\cf19 else}\par
3119                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised ordering: '"} + order + {\cf23 '\\''} );\par
3120                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3121             \};\par
3122         {\cf17 auto} {\cf17 const} setRngSeed = [&]( std::string {\cf17 const}& seed ) \{\par
3123                 {\cf19 if}( seed == {\cf22 "time"} ) \{\par
3124                     config.rngSeed = generateRandomSeed(GenerateFrom::Time);\par
3125                     {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
3126                 \} {\cf19 else} {\cf19 if} (seed == {\cf22 "random-device"}) \{\par
3127                     config.rngSeed = generateRandomSeed(GenerateFrom::RandomDevice);\par
3128                     {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
3129                 \}\par
3130 \par
3131                 {\cf20 // TODO: ideally we should be parsing uint32_t directly}\par
3132                 {\cf20 //       fix this later when we add new parse overload}\par
3133                 {\cf17 auto} parsedSeed = parseUInt( seed, 0 );\par
3134                 {\cf19 if} ( !parsedSeed ) \{\par
3135                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Could not parse '"} + seed + {\cf22 "' as seed"} );\par
3136                 \}\par
3137                 config.rngSeed = *parsedSeed;\par
3138                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3139             \};\par
3140         {\cf17 auto} {\cf17 const} setDefaultColourMode = [&]( std::string {\cf17 const}& colourMode ) \{\par
3141             Optional<ColourMode> maybeMode = Catch::Detail::stringToColourMode(toLower( colourMode ));\par
3142             {\cf19 if} ( !maybeMode ) \{\par
3143                 {\cf19 return} ParserResult::runtimeError(\par
3144                     {\cf22 "colour mode must be one of: default, ansi, win32, "}\par
3145                     {\cf22 "or none. '"} +\par
3146                     colourMode + {\cf22 "' is not recognised"} );\par
3147             \}\par
3148             {\cf17 auto} mode = *maybeMode;\par
3149             {\cf19 if} ( !isColourImplAvailable( mode ) ) \{\par
3150                 {\cf19 return} ParserResult::runtimeError(\par
3151                     {\cf22 "colour mode '"} + colourMode +\par
3152                     {\cf22 "' is not supported in this binary"} );\par
3153             \}\par
3154             config.defaultColourMode = mode;\par
3155             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3156         \};\par
3157         {\cf17 auto} {\cf17 const} setWaitForKeypress = [&]( std::string {\cf17 const}& keypress ) \{\par
3158                 {\cf17 auto} keypressLc = toLower( keypress );\par
3159                 {\cf19 if} (keypressLc == {\cf22 "never"})\par
3160                     config.waitForKeypress = WaitForKeypress::Never;\par
3161                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "start"} )\par
3162                     config.waitForKeypress = WaitForKeypress::BeforeStart;\par
3163                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "exit"} )\par
3164                     config.waitForKeypress = WaitForKeypress::BeforeExit;\par
3165                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "both"} )\par
3166                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;\par
3167                 {\cf19 else}\par
3168                     {\cf19 return} ParserResult::runtimeError( {\cf22 "keypress argument must be one of: never, start, exit or both. '"} + keypress + {\cf22 "' not recognised"} );\par
3169             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3170             \};\par
3171         {\cf17 auto} {\cf17 const} setVerbosity = [&]( std::string {\cf17 const}& verbosity ) \{\par
3172             {\cf17 auto} lcVerbosity = toLower( verbosity );\par
3173             {\cf19 if}( lcVerbosity == {\cf22 "quiet"} )\par
3174                 config.verbosity = Verbosity::Quiet;\par
3175             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "normal"} )\par
3176                 config.verbosity = Verbosity::Normal;\par
3177             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "high"} )\par
3178                 config.verbosity = Verbosity::High;\par
3179             {\cf19 else}\par
3180                 {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised verbosity, '"} + verbosity + {\cf23 '\\''} );\par
3181             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3182         \};\par
3183         {\cf17 auto} {\cf17 const} setReporter = [&]( std::string {\cf17 const}& userReporterSpec ) \{\par
3184             {\cf19 if} ( userReporterSpec.empty() ) \{\par
3185                 {\cf19 return} ParserResult::runtimeError( {\cf22 "Received empty reporter spec."} );\par
3186             \}\par
3187 \par
3188             Optional<ReporterSpec> parsed =\par
3189                 parseReporterSpec( userReporterSpec );\par
3190             {\cf19 if} ( !parsed ) \{\par
3191                 {\cf19 return} ParserResult::runtimeError(\par
3192                     {\cf22 "Could not parse reporter spec '"} + userReporterSpec +\par
3193                     {\cf22 "'"} );\par
3194             \}\par
3195 \par
3196             {\cf17 auto} {\cf17 const}& reporterSpec = *parsed;\par
3197 \par
3198             {\cf17 auto} {\cf17 const}& factories =\par
3199                 getRegistryHub().getReporterRegistry().getFactories();\par
3200             {\cf17 auto} result = factories.find( reporterSpec.name() );\par
3201 \par
3202             {\cf19 if} ( result == factories.end() ) \{\par
3203                 {\cf19 return} ParserResult::runtimeError(\par
3204                     {\cf22 "Unrecognized reporter, '"} + reporterSpec.name() +\par
3205                     {\cf22 "'. Check available with --list-reporters"} );\par
3206             \}\par
3207 \par
3208 \par
3209             {\cf17 const} {\cf18 bool} hadOutputFile = reporterSpec.outputFile().some();\par
3210             config.reporterSpecifications.push_back( CATCH_MOVE( *parsed ) );\par
3211             {\cf20 // It would be enough to check this only once at the very end, but}\par
3212             {\cf20 // there is  not a place where we could call this check, so do it}\par
3213             {\cf20 // every time it could fail. For valid inputs, this is still called}\par
3214             {\cf20 // at most once.}\par
3215             {\cf19 if} (!hadOutputFile) \{\par
3216                 {\cf18 int} n_reporters_without_file = 0;\par
3217                 {\cf19 for} ({\cf17 auto} {\cf17 const}& spec : config.reporterSpecifications) \{\par
3218                     {\cf19 if} (spec.outputFile().none()) \{\par
3219                         n_reporters_without_file++;\par
3220                     \}\par
3221                 \}\par
3222                 {\cf19 if} (n_reporters_without_file > 1) \{\par
3223                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Only one reporter may have unspecified output file."} );\par
3224                 \}\par
3225             \}\par
3226 \par
3227             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3228         \};\par
3229         {\cf17 auto} {\cf17 const} setShardCount = [&]( std::string {\cf17 const}& shardCount ) \{\par
3230             {\cf17 auto} parsedCount = parseUInt( shardCount );\par
3231             {\cf19 if} ( !parsedCount ) \{\par
3232                 {\cf19 return} ParserResult::runtimeError(\par
3233                     {\cf22 "Could not parse '"} + shardCount + {\cf22 "' as shard count"} );\par
3234             \}\par
3235             {\cf19 if} ( *parsedCount == 0 ) \{\par
3236                 {\cf19 return} ParserResult::runtimeError(\par
3237                     {\cf22 "Shard count must be positive"} );\par
3238             \}\par
3239             config.shardCount = *parsedCount;\par
3240             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3241         \};\par
3242 \par
3243         {\cf17 auto} {\cf17 const} setShardIndex = [&](std::string {\cf17 const}& shardIndex) \{\par
3244             {\cf17 auto} parsedIndex = parseUInt( shardIndex );\par
3245             {\cf19 if} ( !parsedIndex ) \{\par
3246                 {\cf19 return} ParserResult::runtimeError(\par
3247                     {\cf22 "Could not parse '"} + shardIndex + {\cf22 "' as shard index"} );\par
3248             \}\par
3249             config.shardIndex = *parsedIndex;\par
3250             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3251         \};\par
3252 \par
3253         {\cf17 auto} cli\par
3254             = ExeName( config.processName )\par
3255             | Help( config.showHelp )\par
3256             | Opt( config.showSuccessfulTests )\par
3257                 [{\cf22 "-s"}][{\cf22 "--success"}]\par
3258                 ( {\cf22 "include successful tests in output"} )\par
3259             | Opt( config.shouldDebugBreak )\par
3260                 [{\cf22 "-b"}][{\cf22 "--break"}]\par
3261                 ( {\cf22 "break into debugger on failure"} )\par
3262             | Opt( config.noThrow )\par
3263                 [{\cf22 "-e"}][{\cf22 "--nothrow"}]\par
3264                 ( {\cf22 "skip exception tests"} )\par
3265             | Opt( config.showInvisibles )\par
3266                 [{\cf22 "-i"}][{\cf22 "--invisibles"}]\par
3267                 ( {\cf22 "show invisibles (tabs, newlines)"} )\par
3268             | Opt( config.defaultOutputFilename, {\cf22 "filename"} )\par
3269                 [{\cf22 "-o"}][{\cf22 "--out"}]\par
3270                 ( {\cf22 "default output filename"} )\par
3271             | Opt( accept_many, setReporter, {\cf22 "name[::key=value]*"} )\par
3272                 [{\cf22 "-r"}][{\cf22 "--reporter"}]\par
3273                 ( {\cf22 "reporter to use (defaults to console)"} )\par
3274             | Opt( config.name, {\cf22 "name"} )\par
3275                 [{\cf22 "-n"}][{\cf22 "--name"}]\par
3276                 ( {\cf22 "suite name"} )\par
3277             | Opt( [&]( {\cf18 bool} )\{ config.abortAfter = 1; \} )\par
3278                 [{\cf22 "-a"}][{\cf22 "--abort"}]\par
3279                 ( {\cf22 "abort at first failure"} )\par
3280             | Opt( [&]( {\cf18 int} x )\{ config.abortAfter = x; \}, {\cf22 "no. failures"} )\par
3281                 [{\cf22 "-x"}][{\cf22 "--abortx"}]\par
3282                 ( {\cf22 "abort after x failures"} )\par
3283             | Opt( accept_many, setWarning, {\cf22 "warning name"} )\par
3284                 [{\cf22 "-w"}][{\cf22 "--warn"}]\par
3285                 ( {\cf22 "enable warnings"} )\par
3286             | Opt( [&]( {\cf18 bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, {\cf22 "yes|no"} )\par
3287                 [{\cf22 "-d"}][{\cf22 "--durations"}]\par
3288                 ( {\cf22 "show test durations"} )\par
3289             | Opt( config.minDuration, {\cf22 "seconds"} )\par
3290                 [{\cf22 "-D"}][{\cf22 "--min-duration"}]\par
3291                 ( {\cf22 "show test durations for tests taking at least the given number of seconds"} )\par
3292             | Opt( loadTestNamesFromFile, {\cf22 "filename"} )\par
3293                 [{\cf22 "-f"}][{\cf22 "--input-file"}]\par
3294                 ( {\cf22 "load test names to run from a file"} )\par
3295             | Opt( config.filenamesAsTags )\par
3296                 [{\cf22 "-#"}][{\cf22 "--filenames-as-tags"}]\par
3297                 ( {\cf22 "adds a tag for the filename"} )\par
3298             | Opt( config.sectionsToRun, {\cf22 "section name"} )\par
3299                 [{\cf22 "-c"}][{\cf22 "--section"}]\par
3300                 ( {\cf22 "specify section to run"} )\par
3301             | Opt( setVerbosity, {\cf22 "quiet|normal|high"} )\par
3302                 [{\cf22 "-v"}][{\cf22 "--verbosity"}]\par
3303                 ( {\cf22 "set output verbosity"} )\par
3304             | Opt( config.listTests )\par
3305                 [{\cf22 "--list-tests"}]\par
3306                 ( {\cf22 "list all/matching test cases"} )\par
3307             | Opt( config.listTags )\par
3308                 [{\cf22 "--list-tags"}]\par
3309                 ( {\cf22 "list all/matching tags"} )\par
3310             | Opt( config.listReporters )\par
3311                 [{\cf22 "--list-reporters"}]\par
3312                 ( {\cf22 "list all available reporters"} )\par
3313             | Opt( config.listListeners )\par
3314                 [{\cf22 "--list-listeners"}]\par
3315                 ( {\cf22 "list all listeners"} )\par
3316             | Opt( setTestOrder, {\cf22 "decl|lex|rand"} )\par
3317                 [{\cf22 "--order"}]\par
3318                 ( {\cf22 "test case order (defaults to decl)"} )\par
3319             | Opt( setRngSeed, {\cf22 "'time'|'random-device'|number"} )\par
3320                 [{\cf22 "--rng-seed"}]\par
3321                 ( {\cf22 "set a specific seed for random numbers"} )\par
3322             | Opt( setDefaultColourMode, {\cf22 "ansi|win32|none|default"} )\par
3323                 [{\cf22 "--colour-mode"}]\par
3324                 ( {\cf22 "what color mode should be used as default"} )\par
3325             | Opt( config.libIdentify )\par
3326                 [{\cf22 "--libidentify"}]\par
3327                 ( {\cf22 "report name and version according to libidentify standard"} )\par
3328             | Opt( setWaitForKeypress, {\cf22 "never|start|exit|both"} )\par
3329                 [{\cf22 "--wait-for-keypress"}]\par
3330                 ( {\cf22 "waits for a keypress before exiting"} )\par
3331             | Opt( config.skipBenchmarks)\par
3332                 [{\cf22 "--skip-benchmarks"}]\par
3333                 ( {\cf22 "disable running benchmarks"})\par
3334             | Opt( config.benchmarkSamples, {\cf22 "samples"} )\par
3335                 [{\cf22 "--benchmark-samples"}]\par
3336                 ( {\cf22 "number of samples to collect (default: 100)"} )\par
3337             | Opt( config.benchmarkResamples, {\cf22 "resamples"} )\par
3338                 [{\cf22 "--benchmark-resamples"}]\par
3339                 ( {\cf22 "number of resamples for the bootstrap (default: 100000)"} )\par
3340             | Opt( config.benchmarkConfidenceInterval, {\cf22 "confidence interval"} )\par
3341                 [{\cf22 "--benchmark-confidence-interval"}]\par
3342                 ( {\cf22 "confidence interval for the bootstrap (between 0 and 1, default: 0.95)"} )\par
3343             | Opt( config.benchmarkNoAnalysis )\par
3344                 [{\cf22 "--benchmark-no-analysis"}]\par
3345                 ( {\cf22 "perform only measurements; do not perform any analysis"} )\par
3346             | Opt( config.benchmarkWarmupTime, {\cf22 "benchmarkWarmupTime"} )\par
3347                 [{\cf22 "--benchmark-warmup-time"}]\par
3348                 ( {\cf22 "amount of time in milliseconds spent on warming up each test (default: 100)"} )\par
3349             | Opt( setShardCount, {\cf22 "shard count"} )\par
3350                 [{\cf22 "--shard-count"}]\par
3351                 ( {\cf22 "split the tests to execute into this many groups"} )\par
3352             | Opt( setShardIndex, {\cf22 "shard index"} )\par
3353                 [{\cf22 "--shard-index"}]\par
3354                 ( {\cf22 "index of the group of tests to execute (see --shard-count)"} )\par
3355             | Opt( config.allowZeroTests )\par
3356                 [{\cf22 "--allow-running-no-tests"}]\par
3357                 ( {\cf22 "Treat 'No tests run' as a success"} )\par
3358             | Arg( config.testsOrTags, {\cf22 "test name|pattern|tags"} )\par
3359                 ( {\cf22 "which test or tests to use"} );\par
3360 \par
3361         {\cf19 return} cli;\par
3362     \}\par
3363 \par
3364 \} {\cf20 // end namespace Catch}\par
3365 \par
3366 \par
3367 {\cf21 #if defined(__clang__)}\par
3368 {\cf21 #    pragma clang diagnostic push}\par
3369 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
3370 {\cf21 #endif}\par
3371 \par
3372 \par
3373 \par
3374 {\cf21 #include <cassert>}\par
3375 {\cf21 #include <ostream>}\par
3376 {\cf21 #include <utility>}\par
3377 \par
3378 {\cf17 namespace }Catch \{\par
3379 \par
3380     ColourImpl::~ColourImpl() = {\cf19 default};\par
3381 \par
3382     ColourImpl::ColourGuard ColourImpl::guardColour( Colour::Code colourCode ) \{\par
3383         {\cf19 return} ColourGuard(colourCode, {\cf17 this} );\par
3384     \}\par
3385 \par
3386     {\cf18 void} ColourImpl::ColourGuard::engageImpl( std::ostream& stream ) \{\par
3387         assert( &stream == &m_colourImpl->m_stream->stream() &&\par
3388                 {\cf22 "Engaging colour guard for different stream than used by the "}\par
3389                 {\cf22 "parent colour implementation"} );\par
3390         {\cf17 static_cast<}{\cf18 void}{\cf17 >}( stream );\par
3391 \par
3392         m_engaged = {\cf17 true};\par
3393         m_colourImpl->use( m_code );\par
3394     \}\par
3395 \par
3396     ColourImpl::ColourGuard::ColourGuard( Colour::Code code,\par
3397                                           ColourImpl {\cf17 const}* colour ):\par
3398         m_colourImpl( colour ), m_code( code ) \{\par
3399     \}\par
3400     ColourImpl::ColourGuard::ColourGuard( ColourGuard&& rhs ) {\cf17 noexcept}:\par
3401         m_colourImpl( rhs.m_colourImpl ),\par
3402         m_code( rhs.m_code ),\par
3403         m_engaged( rhs.m_engaged ) \{\par
3404         rhs.m_engaged = {\cf17 false};\par
3405     \}\par
3406     ColourImpl::ColourGuard&\par
3407     ColourImpl::ColourGuard::operator=( ColourGuard&& rhs ) {\cf17 noexcept} \{\par
3408         {\cf17 using }std::swap;\par
3409         swap( m_colourImpl, rhs.m_colourImpl );\par
3410         swap( m_code, rhs.m_code );\par
3411         swap( m_engaged, rhs.m_engaged );\par
3412 \par
3413         {\cf19 return} *{\cf17 this};\par
3414     \}\par
3415     ColourImpl::ColourGuard::~ColourGuard() \{\par
3416         {\cf19 if} ( m_engaged ) \{\par
3417             m_colourImpl->use( Colour::None );\par
3418         \}\par
3419     \}\par
3420 \par
3421     ColourImpl::ColourGuard&\par
3422     ColourImpl::ColourGuard::engage( std::ostream& stream ) & \{\par
3423         engageImpl( stream );\par
3424         {\cf19 return} *{\cf17 this};\par
3425     \}\par
3426 \par
3427     ColourImpl::ColourGuard&&\par
3428     ColourImpl::ColourGuard::engage( std::ostream& stream ) && \{\par
3429         engageImpl( stream );\par
3430         {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
3431     \}\par
3432 \par
3433     {\cf17 namespace }\{\par
3436         {\cf17 class }NoColourImpl final : {\cf17 public} ColourImpl \{\par
3437         {\cf17 public}:\par
3438             NoColourImpl( IStream* stream ): ColourImpl( stream ) \{\}\par
3439 \par
3440         {\cf17 private}:\par
3441             {\cf18 void} use( Colour::Code ){\cf17  const override }\{\}\par
3442         \};\par
3443     \} {\cf20 // namespace}\par
3444 \par
3445 \par
3446 \} {\cf20 // namespace Catch}\par
3447 \par
3448 \par
3449 {\cf21 #if defined ( CATCH_CONFIG_COLOUR_WIN32 ) }\par
3450 \par
3451 {\cf17 namespace }Catch \{\par
3452 {\cf17 namespace }\{\par
3453 \par
3454     {\cf17 class }Win32ColourImpl final : {\cf17 public} ColourImpl \{\par
3455     {\cf17 public}:\par
3456         Win32ColourImpl(IStream* stream):\par
3457             ColourImpl(stream) \{\par
3458             CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\par
3459             GetConsoleScreenBufferInfo( GetStdHandle( STD_OUTPUT_HANDLE ),\par
3460                                         &csbiInfo );\par
3461             originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\par
3462             originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\par
3463         \}\par
3464 \par
3465         {\cf17 static} {\cf18 bool} useImplementationForStream(IStream {\cf17 const}& stream) \{\par
3466             {\cf20 // Win32 text colour APIs can only be used on console streams}\par
3467             {\cf20 // We cannot check that the output hasn't been redirected,}\par
3468             {\cf20 // so we just check that the original stream is console stream.}\par
3469             {\cf19 return} stream.isConsole();\par
3470         \}\par
3471 \par
3472     {\cf17 private}:\par
3473         {\cf18 void} use( Colour::Code _colourCode ){\cf17  const override }\{\par
3474             {\cf19 switch}( _colourCode ) \{\par
3475                 {\cf19 case} Colour::None:      {\cf19 return} setTextAttribute( originalForegroundAttributes );\par
3476                 {\cf19 case} Colour::White:     {\cf19 return} setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\par
3477                 {\cf19 case} Colour::Red:       {\cf19 return} setTextAttribute( FOREGROUND_RED );\par
3478                 {\cf19 case} Colour::Green:     {\cf19 return} setTextAttribute( FOREGROUND_GREEN );\par
3479                 {\cf19 case} Colour::Blue:      {\cf19 return} setTextAttribute( FOREGROUND_BLUE );\par
3480                 {\cf19 case} Colour::Cyan:      {\cf19 return} setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\par
3481                 {\cf19 case} Colour::Yellow:    {\cf19 return} setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\par
3482                 {\cf19 case} Colour::Grey:      {\cf19 return} setTextAttribute( 0 );\par
3483 \par
3484                 {\cf19 case} Colour::LightGrey:     {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY );\par
3485                 {\cf19 case} Colour::BrightRed:     {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\par
3486                 {\cf19 case} Colour::BrightGreen:   {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\par
3487                 {\cf19 case} Colour::BrightWhite:   {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\par
3488                 {\cf19 case} Colour::BrightYellow:  {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );\par
3489 \par
3490                 {\cf19 case} Colour::Bright: CATCH_INTERNAL_ERROR( {\cf22 "not a colour"} );\par
3491 \par
3492                 {\cf19 default}:\par
3493                     CATCH_ERROR( {\cf22 "Unknown colour requested"} );\par
3494             \}\par
3495         \}\par
3496 \par
3497         {\cf18 void} setTextAttribute( WORD _textAttribute ){\cf17  const }\{\par
3498             SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ),\par
3499                                      _textAttribute |\par
3500                                          originalBackgroundAttributes );\par
3501         \}\par
3502         WORD originalForegroundAttributes;\par
3503         WORD originalBackgroundAttributes;\par
3504     \};\par
3505 \par
3506 \} {\cf20 // end anon namespace}\par
3507 \} {\cf20 // end namespace Catch}\par
3508 \par
3509 {\cf21 #endif }{\cf20 // Windows/ ANSI/ None}\par
3510 \par
3511 \par
3512 {\cf21 #if defined( CATCH_PLATFORM_LINUX ) || defined( CATCH_PLATFORM_MAC )}\par
3513 {\cf21 #    define CATCH_INTERNAL_HAS_ISATTY}\par
3514 {\cf21 #    include <unistd.h>}\par
3515 {\cf21 #endif}\par
3516 \par
3517 {\cf17 namespace }Catch \{\par
3518 {\cf17 namespace }\{\par
3519 \par
3520     {\cf17 class }ANSIColourImpl final : {\cf17 public} ColourImpl \{\par
3521     {\cf17 public}:\par
3522         ANSIColourImpl( IStream* stream ): ColourImpl( stream ) \{\}\par
3523 \par
3524         {\cf17 static} {\cf18 bool} useImplementationForStream(IStream {\cf17 const}& stream) \{\par
3525             {\cf20 // This is kinda messy due to trying to support a bunch of}\par
3526             {\cf20 // different platforms at once.}\par
3527             {\cf20 // The basic idea is that if we are asked to do autodetection (as}\par
3528             {\cf20 // opposed to being told to use posixy colours outright), then we}\par
3529             {\cf20 // only want to use the colours if we are writing to console.}\par
3530             {\cf20 // However, console might be redirected, so we make an attempt at}\par
3531             {\cf20 // checking for that on platforms where we know how to do that.}\par
3532             {\cf18 bool} useColour = stream.isConsole();\par
3533 {\cf21 #if defined( CATCH_INTERNAL_HAS_ISATTY ) && \\}\par
3534 {\cf21     !( defined( __DJGPP__ ) && defined( __STRICT_ANSI__ ) )}\par
3535             ErrnoGuard _; {\cf20 // for isatty}\par
3536             useColour = useColour && isatty( STDOUT_FILENO );\par
3537 {\cf21 #    endif}\par
3538 {\cf21 #    if defined( CATCH_PLATFORM_MAC ) || defined( CATCH_PLATFORM_IPHONE )}\par
3539             useColour = useColour && !isDebuggerActive();\par
3540 {\cf21 #    endif}\par
3541 \par
3542             {\cf19 return} useColour;\par
3543         \}\par
3544 \par
3545     {\cf17 private}:\par
3546         {\cf18 void} use( Colour::Code _colourCode ){\cf17  const override }\{\par
3547             {\cf17 auto} setColour = [&out =\par
3548                                   m_stream->stream()]( {\cf18 char} {\cf17 const}* escapeCode ) \{\par
3549                 {\cf20 // The escape sequence must be flushed to console, otherwise}\par
3550                 {\cf20 // if stdin and stderr are intermixed, we'd get accidentally}\par
3551                 {\cf20 // coloured output.}\par
3552                 out << {\cf23 '\\033'} << escapeCode << std::flush;\par
3553             \};\par
3554             {\cf19 switch}( _colourCode ) \{\par
3555                 {\cf19 case} Colour::None:\par
3556                 {\cf19 case} Colour::White:     {\cf19 return} setColour( {\cf22 "[0m"} );\par
3557                 {\cf19 case} Colour::Red:       {\cf19 return} setColour( {\cf22 "[0;31m"} );\par
3558                 {\cf19 case} Colour::Green:     {\cf19 return} setColour( {\cf22 "[0;32m"} );\par
3559                 {\cf19 case} Colour::Blue:      {\cf19 return} setColour( {\cf22 "[0;34m"} );\par
3560                 {\cf19 case} Colour::Cyan:      {\cf19 return} setColour( {\cf22 "[0;36m"} );\par
3561                 {\cf19 case} Colour::Yellow:    {\cf19 return} setColour( {\cf22 "[0;33m"} );\par
3562                 {\cf19 case} Colour::Grey:      {\cf19 return} setColour( {\cf22 "[1;30m"} );\par
3563 \par
3564                 {\cf19 case} Colour::LightGrey:     {\cf19 return} setColour( {\cf22 "[0;37m"} );\par
3565                 {\cf19 case} Colour::BrightRed:     {\cf19 return} setColour( {\cf22 "[1;31m"} );\par
3566                 {\cf19 case} Colour::BrightGreen:   {\cf19 return} setColour( {\cf22 "[1;32m"} );\par
3567                 {\cf19 case} Colour::BrightWhite:   {\cf19 return} setColour( {\cf22 "[1;37m"} );\par
3568                 {\cf19 case} Colour::BrightYellow:  {\cf19 return} setColour( {\cf22 "[1;33m"} );\par
3569 \par
3570                 {\cf19 case} Colour::Bright: CATCH_INTERNAL_ERROR( {\cf22 "not a colour"} );\par
3571                 {\cf19 default}: CATCH_INTERNAL_ERROR( {\cf22 "Unknown colour requested"} );\par
3572             \}\par
3573         \}\par
3574     \};\par
3575 \par
3576 \} {\cf20 // end anon namespace}\par
3577 \} {\cf20 // end namespace Catch}\par
3578 \par
3579 {\cf17 namespace }Catch \{\par
3580 \par
3581     Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,\par
3582                                                    IStream* stream ) \{\par
3583 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3584         {\cf19 if} ( colourSelection == ColourMode::Win32 ) \{\par
3585             {\cf19 return} Detail::make_unique<Win32ColourImpl>( stream );\par
3586         \}\par
3587 {\cf21 #endif}\par
3588         {\cf19 if} ( colourSelection == ColourMode::ANSI ) \{\par
3589             {\cf19 return} Detail::make_unique<ANSIColourImpl>( stream );\par
3590         \}\par
3591         {\cf19 if} ( colourSelection == ColourMode::None ) \{\par
3592             {\cf19 return} Detail::make_unique<NoColourImpl>( stream );\par
3593         \}\par
3594 \par
3595         {\cf19 if} ( colourSelection == ColourMode::PlatformDefault) \{\par
3596 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3597             {\cf19 if} ( Win32ColourImpl::useImplementationForStream( *stream ) ) \{\par
3598                 {\cf19 return} Detail::make_unique<Win32ColourImpl>( stream );\par
3599             \}\par
3600 {\cf21 #endif}\par
3601             {\cf19 if} ( ANSIColourImpl::useImplementationForStream( *stream ) ) \{\par
3602                 {\cf19 return} Detail::make_unique<ANSIColourImpl>( stream );\par
3603             \}\par
3604             {\cf19 return} Detail::make_unique<NoColourImpl>( stream );\par
3605         \}\par
3606 \par
3607         CATCH_ERROR( {\cf22 "Could not create colour impl for selection "} << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(colourSelection) );\par
3608     \}\par
3609 \par
3610     {\cf18 bool} isColourImplAvailable( ColourMode colourSelection ) \{\par
3611         {\cf19 switch} ( colourSelection ) \{\par
3612 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3613         {\cf19 case} ColourMode::Win32:\par
3614 {\cf21 #endif}\par
3615         {\cf19 case} ColourMode::ANSI:\par
3616         {\cf19 case} ColourMode::None:\par
3617         {\cf19 case} ColourMode::PlatformDefault:\par
3618             {\cf19 return} {\cf17 true};\par
3619         {\cf19 default}:\par
3620             {\cf19 return} {\cf17 false};\par
3621         \}\par
3622     \}\par
3623 \par
3624 \par
3625 \} {\cf20 // end namespace Catch}\par
3626 \par
3627 {\cf21 #if defined(__clang__)}\par
3628 {\cf21 #    pragma clang diagnostic pop}\par
3629 {\cf21 #endif}\par
3630 \par
3631 \par
3632 \par
3633 \par
3634 {\cf17 namespace }Catch \{\par
3635 \par
3636     Context* Context::currentContext = {\cf17 nullptr};\par
3637 \par
3638     {\cf18 void} cleanUpContext() \{\par
3639         {\cf17 delete} Context::currentContext;\par
3640         Context::currentContext = {\cf17 nullptr};\par
3641     \}\par
3642     {\cf18 void} Context::createContext() \{\par
3643         currentContext = {\cf17 new} Context();\par
3644     \}\par
3645 \par
3646     Context& getCurrentMutableContext() \{\par
3647         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
3648         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
3649         {\cf19 return} *Context::currentContext;\par
3650     \}\par
3651 \par
3652     {\cf18 void} Context::setResultCapture( IResultCapture* resultCapture ) \{\par
3653         m_resultCapture = resultCapture;\par
3654     \}\par
3655 \par
3656     {\cf18 void} Context::setConfig( IConfig {\cf17 const}* config ) \{ m_config = config; \}\par
3657 \par
3658     SimplePcg32& sharedRng() \{\par
3659         {\cf17 static} SimplePcg32 s_rng;\par
3660         {\cf19 return} s_rng;\par
3661     \}\par
3662 \par
3663 \}\par
3664 \par
3665 \par
3666 \par
3667 \par
3668 \par
3669 {\cf21 #include <ostream>}\par
3670 \par
3671 {\cf21 #if defined(CATCH_CONFIG_ANDROID_LOGWRITE)}\par
3672 {\cf21 #include <android/log.h>}\par
3673 \par
3674     {\cf17 namespace }Catch \{\par
3675         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
3676             __android_log_write( ANDROID_LOG_DEBUG, {\cf22 "Catch"}, text.c_str() );\par
3677         \}\par
3678     \}\par
3679 \par
3680 {\cf21 #elif defined(CATCH_PLATFORM_WINDOWS)}\par
3681 \par
3682     {\cf17 namespace }Catch \{\par
3683         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
3684             ::OutputDebugStringA( text.c_str() );\par
3685         \}\par
3686     \}\par
3687 \par
3688 {\cf21 #else}\par
3689 \par
3690     {\cf17 namespace }Catch \{\par
3691         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
3692             {\cf20 // !TBD: Need a version for Mac/ XCode and other IDEs}\par
3693             Catch::cout() << text;\par
3694         \}\par
3695     \}\par
3696 \par
3697 {\cf21 #endif }{\cf20 // Platform}\par
3698 \par
3699 \par
3700 \par
3701 {\cf21 #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)}\par
3702 \par
3703 {\cf21 #  include <cassert>}\par
3704 {\cf21 #  include <sys/types.h>}\par
3705 {\cf21 #  include <unistd.h>}\par
3706 {\cf21 #  include <cstddef>}\par
3707 {\cf21 #  include <ostream>}\par
3708 \par
3709 {\cf21 #ifdef __apple_build_version__}\par
3710     {\cf20 // These headers will only compile with AppleClang (XCode)}\par
3711     {\cf20 // For other compilers (Clang, GCC, ... ) we need to exclude them}\par
3712 {\cf21 #  include <sys/sysctl.h>}\par
3713 {\cf21 #endif}\par
3714 \par
3715     {\cf17 namespace }Catch \{\par
3716 {\cf21         #ifdef __apple_build_version__}\par
3717         {\cf20 // The following function is taken directly from the following technical note:}\par
3718         {\cf20 // https://developer.apple.com/library/archive/qa/qa1361/_index.html}\par
3719 \par
3720         {\cf20 // Returns true if the current process is being debugged (either}\par
3721         {\cf20 // running under the debugger or has a debugger attached post facto).}\par
3722         {\cf18 bool} isDebuggerActive()\{\par
3723             {\cf18 int}                 mib[4];\par
3724             {\cf17 struct }kinfo_proc   info;\par
3725             std::size_t         size;\par
3726 \par
3727             {\cf20 // Initialize the flags so that, if sysctl fails for some bizarre}\par
3728             {\cf20 // reason, we get a predictable result.}\par
3729 \par
3730             info.kp_proc.p_flag = 0;\par
3731 \par
3732             {\cf20 // Initialize mib, which tells sysctl the info we want, in this case}\par
3733             {\cf20 // we're looking for information about a specific process ID.}\par
3734 \par
3735             mib[0] = CTL_KERN;\par
3736             mib[1] = KERN_PROC;\par
3737             mib[2] = KERN_PROC_PID;\par
3738             mib[3] = getpid();\par
3739 \par
3740             {\cf20 // Call sysctl.}\par
3741 \par
3742             size = {\cf17 sizeof}(info);\par
3743             {\cf19 if}( sysctl(mib, {\cf17 sizeof}(mib) / {\cf17 sizeof}(*mib), &info, &size, {\cf17 nullptr}, 0) != 0 ) \{\par
3744                 Catch::cerr() << {\cf22 "\\n** Call to sysctl failed - unable to determine if debugger is active **\\n\\n"} << std::flush;\par
3745                 {\cf19 return} {\cf17 false};\par
3746             \}\par
3747 \par
3748             {\cf20 // We're being debugged if the P_TRACED flag is set.}\par
3749 \par
3750             {\cf19 return} ( (info.kp_proc.p_flag & P_TRACED) != 0 );\par
3751         \}\par
3752 {\cf21         #else}\par
3753         {\cf18 bool} isDebuggerActive() \{\par
3754             {\cf20 // We need to find another way to determine this for non-appleclang compilers on macOS}\par
3755             {\cf19 return} {\cf17 false};\par
3756         \}\par
3757 {\cf21         #endif}\par
3758     \} {\cf20 // namespace Catch}\par
3759 \par
3760 {\cf21 #elif defined(CATCH_PLATFORM_LINUX)}\par
3761 {\cf21     #include <fstream>}\par
3762 {\cf21     #include <string>}\par
3763 \par
3764     {\cf17 namespace }Catch\{\par
3765         {\cf20 // The standard POSIX way of detecting a debugger is to attempt to}\par
3766         {\cf20 // ptrace() the process, but this needs to be done from a child and not}\par
3767         {\cf20 // this process itself to still allow attaching to this process later}\par
3768         {\cf20 // if wanted, so is rather heavy. Under Linux we have the PID of the}\par
3769         {\cf20 // "debugger" (which doesn't need to be gdb, of course, it could also}\par
3770         {\cf20 // be strace, for example) in /proc/$PID/status, so just get it from}\par
3771         {\cf20 // there instead.}\par
3772         {\cf18 bool} isDebuggerActive()\{\par
3773             {\cf20 // Libstdc++ has a bug, where std::ifstream sets errno to 0}\par
3774             {\cf20 // This way our users can properly assert over errno values}\par
3775             ErrnoGuard guard;\par
3776             std::ifstream in({\cf22 "/proc/self/status"});\par
3777             {\cf19 for}( std::string line; std::getline(in, line); ) \{\par
3778                 {\cf17 static} {\cf17 const} {\cf18 int} PREFIX_LEN = 11;\par
3779                 {\cf19 if}( line.compare(0, PREFIX_LEN, {\cf22 "TracerPid:\\t"}) == 0 ) \{\par
3780                     {\cf20 // We're traced if the PID is not 0 and no other PID starts}\par
3781                     {\cf20 // with 0 digit, so it's enough to check for just a single}\par
3782                     {\cf20 // character.}\par
3783                     {\cf19 return} line.length() > PREFIX_LEN && line[PREFIX_LEN] != {\cf23 '0'};\par
3784                 \}\par
3785             \}\par
3786 \par
3787             {\cf19 return} {\cf17 false};\par
3788         \}\par
3789     \} {\cf20 // namespace Catch}\par
3790 {\cf21 #elif defined(_MSC_VER)}\par
3791     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 int} __stdcall IsDebuggerPresent();\par
3792     {\cf17 namespace }Catch \{\par
3793         {\cf18 bool} isDebuggerActive() \{\par
3794             {\cf19 return} IsDebuggerPresent() != 0;\par
3795         \}\par
3796     \}\par
3797 {\cf21 #elif defined(__MINGW32__)}\par
3798     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 int} __stdcall IsDebuggerPresent();\par
3799     {\cf17 namespace }Catch \{\par
3800         {\cf18 bool} isDebuggerActive() \{\par
3801             {\cf19 return} IsDebuggerPresent() != 0;\par
3802         \}\par
3803     \}\par
3804 {\cf21 #else}\par
3805     {\cf17 namespace }Catch \{\par
3806        {\cf18 bool} isDebuggerActive() \{ {\cf19 return} {\cf17 false}; \}\par
3807     \}\par
3808 {\cf21 #endif }{\cf20 // Platform}\par
3809 \par
3810 \par
3811 \par
3812 \par
3813 {\cf17 namespace }Catch \{\par
3814 \par
3815     {\cf18 void} ITransientExpression::streamReconstructedExpression(\par
3816         std::ostream& os ){\cf17  const }\{\par
3817         {\cf20 // We can't make this function pure virtual to keep ITransientExpression}\par
3818         {\cf20 // constexpr, so we write error message instead}\par
3819         os << {\cf22 "Some class derived from ITransientExpression without overriding streamReconstructedExpression"};\par
3820     \}\par
3821 \par
3822     {\cf18 void} formatReconstructedExpression( std::ostream &os, std::string {\cf17 const}& lhs, StringRef op, std::string {\cf17 const}& rhs ) \{\par
3823         {\cf19 if}( lhs.size() + rhs.size() < 40 &&\par
3824                 lhs.find({\cf23 '\\n'}) == std::string::npos &&\par
3825                 rhs.find({\cf23 '\\n'}) == std::string::npos )\par
3826             os << lhs << {\cf23 ' '} << op << {\cf23 ' '} << rhs;\par
3827         {\cf19 else}\par
3828             os << lhs << {\cf23 '\\n'} << op << {\cf23 '\\n'} << rhs;\par
3829     \}\par
3830 \}\par
3831 \par
3832 \par
3833 \par
3834 {\cf21 #include <stdexcept>}\par
3835 \par
3836 \par
3837 {\cf17 namespace }Catch \{\par
3838 {\cf21 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)}\par
3839     [[noreturn]]\par
3840     {\cf18 void} throw_exception(std::exception {\cf17 const}& e) \{\par
3841         Catch::cerr() << {\cf22 "Catch will terminate because it needed to throw an exception.\\n"}\par
3842                       << {\cf22 "The message was: "} << e.what() << {\cf23 '\\n'};\par
3843         std::terminate();\par
3844     \}\par
3845 {\cf21 #endif}\par
3846 \par
3847     [[noreturn]]\par
3848     {\cf18 void} throw_logic_error(std::string {\cf17 const}& msg) \{\par
3849         throw_exception(std::logic_error(msg));\par
3850     \}\par
3851 \par
3852     [[noreturn]]\par
3853     {\cf18 void} throw_domain_error(std::string {\cf17 const}& msg) \{\par
3854         throw_exception(std::domain_error(msg));\par
3855     \}\par
3856 \par
3857     [[noreturn]]\par
3858     {\cf18 void} throw_runtime_error(std::string {\cf17 const}& msg) \{\par
3859         throw_exception(std::runtime_error(msg));\par
3860     \}\par
3861 \par
3862 \par
3863 \par
3864 \} {\cf20 // namespace Catch;}\par
3865 \par
3866 \par
3867 \par
3868 {\cf21 #include <cassert>}\par
3869 \par
3870 {\cf17 namespace }Catch \{\par
3871 \par
3872     IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() = {\cf19 default};\par
3873 \par
3874     {\cf17 namespace }Detail \{\par
3875 \par
3876         {\cf17 namespace }\{\par
3877             {\cf20 // Extracts the actual name part of an enum instance}\par
3878             {\cf20 // In other words, it returns the Blue part of Bikeshed::Colour::Blue}\par
3879             StringRef extractInstanceName(StringRef enumInstance) \{\par
3880                 {\cf20 // Find last occurrence of ":"}\par
3881                 {\cf18 size_t} name_start = enumInstance.size();\par
3882                 {\cf19 while} (name_start > 0 && enumInstance[name_start - 1] != {\cf23 ':'}) \{\par
3883                     --name_start;\par
3884                 \}\par
3885                 {\cf19 return} enumInstance.substr(name_start, enumInstance.size() - name_start);\par
3886             \}\par
3887         \}\par
3888 \par
3889         std::vector<StringRef> parseEnums( StringRef enums ) \{\par
3890             {\cf17 auto} enumValues = splitStringRef( enums, {\cf23 ','} );\par
3891             std::vector<StringRef> parsed;\par
3892             parsed.reserve( enumValues.size() );\par
3893             {\cf19 for}( {\cf17 auto} {\cf17 const}& enumValue : enumValues ) \{\par
3894                 parsed.push_back(trim(extractInstanceName(enumValue)));\par
3895             \}\par
3896             {\cf19 return} parsed;\par
3897         \}\par
3898 \par
3899         EnumInfo::~EnumInfo() = {\cf19 default};\par
3900 \par
3901         StringRef EnumInfo::lookup( {\cf18 int} value ){\cf17  const }\{\par
3902             {\cf19 for}( {\cf17 auto} {\cf17 const}& valueToName : m_values ) \{\par
3903                 {\cf19 if}( valueToName.first == value )\par
3904                     {\cf19 return} valueToName.second;\par
3905             \}\par
3906             {\cf19 return} {\cf22 "\{** unexpected enum value **\}"}_sr;\par
3907         \}\par
3908 \par
3909         Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values ) \{\par
3910             {\cf17 auto} enumInfo = Catch::Detail::make_unique<EnumInfo>();\par
3911             enumInfo->m_name = enumName;\par
3912             enumInfo->m_values.reserve( values.size() );\par
3913 \par
3914             {\cf17 const} {\cf17 auto} valueNames = Catch::Detail::parseEnums( allValueNames );\par
3915             assert( valueNames.size() == values.size() );\par
3916             std::size_t i = 0;\par
3917             {\cf19 for}( {\cf17 auto} value : values )\par
3918                 enumInfo->m_values.emplace_back(value, valueNames[i++]);\par
3919 \par
3920             {\cf19 return} enumInfo;\par
3921         \}\par
3922 \par
3923         EnumInfo {\cf17 const}& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values ) \{\par
3924             m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));\par
3925             {\cf19 return} *m_enumInfos.back();\par
3926         \}\par
3927 \par
3928     \} {\cf20 // Detail}\par
3929 \} {\cf20 // Catch}\par
3930 \par
3931 \par
3932 \par
3933 \par
3934 \par
3935 {\cf21 #include <cerrno>}\par
3936 \par
3937 {\cf17 namespace }Catch \{\par
3938         ErrnoGuard::ErrnoGuard():m_oldErrno(errno)\{\}\par
3939         ErrnoGuard::~ErrnoGuard() \{ errno = m_oldErrno; \}\par
3940 \}\par
3941 \par
3942 \par
3943 \par
3944 {\cf21 #include <exception>}\par
3945 \par
3946 {\cf17 namespace }Catch \{\par
3947 \par
3948 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
3949     {\cf17 namespace }\{\par
3950         {\cf17 static} std::string tryTranslators(\par
3951             std::vector<\par
3952                 Detail::unique_ptr<IExceptionTranslator const>> {\cf17 const}& translators ) \{\par
3953             {\cf19 if} ( translators.empty() ) \{\par
3954                 std::rethrow_exception( std::current_exception() );\par
3955             \} {\cf19 else} \{\par
3956                 {\cf19 return} translators[0]->translate( translators.begin() + 1,\par
3957                                                   translators.end() );\par
3958             \}\par
3959         \}\par
3960 \par
3961     \}\par
3962 {\cf21 #endif }\par
3963 \par
3964     ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() = {\cf19 default};\par
3965 \par
3966     {\cf18 void} ExceptionTranslatorRegistry::registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator ) \{\par
3967         m_translators.push_back( CATCH_MOVE( translator ) );\par
3968     \}\par
3969 \par
3970 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
3971     std::string ExceptionTranslatorRegistry::translateActiveException(){\cf17  const }\{\par
3972         {\cf20 // Compiling a mixed mode project with MSVC means that CLR}\par
3973         {\cf20 // exceptions will be caught in (...) as well. However, these do}\par
3974         {\cf20 // do not fill-in std::current_exception and thus lead to crash}\par
3975         {\cf20 // when attempting rethrow.}\par
3976         {\cf20 // /EHa switch also causes structured exceptions to be caught}\par
3977         {\cf20 // here, but they fill-in current_exception properly, so}\par
3978         {\cf20 // at worst the output should be a little weird, instead of}\par
3979         {\cf20 // causing a crash.}\par
3980         {\cf19 if} ( std::current_exception() == {\cf17 nullptr} ) \{\par
3981             {\cf19 return} {\cf22 "Non C++ exception. Possibly a CLR exception."};\par
3982         \}\par
3983 \par
3984         {\cf20 // First we try user-registered translators. If none of them can}\par
3985         {\cf20 // handle the exception, it will be rethrown handled by our defaults.}\par
3986         {\cf19 try} \{\par
3987             {\cf19 return} tryTranslators(m_translators);\par
3988         \}\par
3989         {\cf20 // To avoid having to handle TFE explicitly everywhere, we just}\par
3990         {\cf20 // rethrow it so that it goes back up the caller.}\par
3991         {\cf19 catch}( TestFailureException& ) \{\par
3992             std::rethrow_exception(std::current_exception());\par
3993         \}\par
3994         {\cf19 catch}( TestSkipException& ) \{\par
3995             std::rethrow_exception(std::current_exception());\par
3996         \}\par
3997         {\cf19 catch}( std::exception {\cf17 const}& ex ) \{\par
3998             {\cf19 return} ex.what();\par
3999         \}\par
4000         {\cf19 catch}( std::string {\cf17 const}& msg ) \{\par
4001             {\cf19 return} msg;\par
4002         \}\par
4003         {\cf19 catch}( {\cf17 const} {\cf18 char}* msg ) \{\par
4004             {\cf19 return} msg;\par
4005         \}\par
4006         {\cf19 catch}(...) \{\par
4007             {\cf19 return} {\cf22 "Unknown exception"};\par
4008         \}\par
4009     \}\par
4010 \par
4011 {\cf21 #else }{\cf20 // ^^ Exceptions are enabled // Exceptions are disabled vv}\par
4012     std::string ExceptionTranslatorRegistry::translateActiveException(){\cf17  const }\{\par
4013         CATCH_INTERNAL_ERROR({\cf22 "Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!"});\par
4014     \}\par
4015 {\cf21 #endif}\par
4016 \par
4017 \}\par
4018 \par
4019 \par
4020 \par
4041 {\cf21 #include <algorithm>}\par
4042 \par
4043 {\cf21 #if !defined( CATCH_CONFIG_WINDOWS_SEH ) && !defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4044 \par
4045 {\cf17 namespace }Catch \{\par
4046 \par
4047     {\cf20 // If neither SEH nor signal handling is required, the handler impls}\par
4048     {\cf20 // do not have to do anything, and can be empty.}\par
4049     {\cf18 void} FatalConditionHandler::engage_platform() \{\}\par
4050     {\cf18 void} FatalConditionHandler::disengage_platform() noexcept \{\}\par
4051     FatalConditionHandler::FatalConditionHandler() = {\cf19 default};\par
4052     FatalConditionHandler::~FatalConditionHandler() = {\cf19 default};\par
4053 \par
4054 \} {\cf20 // end namespace Catch}\par
4055 \par
4056 {\cf21 #endif }{\cf20 // !CATCH_CONFIG_WINDOWS_SEH && !CATCH_CONFIG_POSIX_SIGNALS}\par
4057 \par
4058 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH ) && defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4059 {\cf21 #error "Inconsistent configuration: Windows' SEH handling and POSIX signals cannot be enabled at the same time"}\par
4060 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_SEH && CATCH_CONFIG_POSIX_SIGNALS}\par
4061 \par
4062 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4063 \par
4064 {\cf17 namespace }\{\par
4066     {\cf18 void} reportFatal( {\cf18 char} {\cf17 const} * {\cf17 const} message ) \{\par
4067         Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );\par
4068     \}\par
4069 \par
4073     {\cf17 constexpr} std::size_t minStackSizeForErrors = 32 * 1024;\par
4074 \} {\cf20 // end unnamed namespace}\par
4075 \par
4076 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_SEH || CATCH_CONFIG_POSIX_SIGNALS}\par
4077 \par
4078 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH )}\par
4079 \par
4080 {\cf17 namespace }Catch \{\par
4081 \par
4082     {\cf17 struct }SignalDefs \{ DWORD id; {\cf17 const} {\cf18 char}* name; \};\par
4083 \par
4084     {\cf20 // There is no 1-1 mapping between signals and windows exceptions.}\par
4085     {\cf20 // Windows can easily distinguish between SO and SigSegV,}\par
4086     {\cf20 // but SigInt, SigTerm, etc are handled differently.}\par
4087     {\cf17 static} SignalDefs signalDefs[] = \{\par
4088         \{ EXCEPTION_ILLEGAL_INSTRUCTION,  {\cf22 "SIGILL - Illegal instruction signal"} \},\par
4089         \{ EXCEPTION_STACK_OVERFLOW, {\cf22 "SIGSEGV - Stack overflow"} \},\par
4090         \{ EXCEPTION_ACCESS_VIOLATION, {\cf22 "SIGSEGV - Segmentation violation signal"} \},\par
4091         \{ EXCEPTION_INT_DIVIDE_BY_ZERO, {\cf22 "Divide by zero error"} \},\par
4092     \};\par
4093 \par
4094     {\cf17 static} LONG CALLBACK topLevelExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo) \{\par
4095         {\cf19 for} ({\cf17 auto} {\cf17 const}& def : signalDefs) \{\par
4096             {\cf19 if} (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) \{\par
4097                 reportFatal(def.name);\par
4098             \}\par
4099         \}\par
4100         {\cf20 // If its not an exception we care about, pass it along.}\par
4101         {\cf20 // This stops us from eating debugger breaks etc.}\par
4102         {\cf19 return} EXCEPTION_CONTINUE_SEARCH;\par
4103     \}\par
4104 \par
4105     {\cf20 // Since we do not support multiple instantiations, we put these}\par
4106     {\cf20 // into global variables and rely on cleaning them up in outlined}\par
4107     {\cf20 // constructors/destructors}\par
4108     {\cf17 static} LPTOP_LEVEL_EXCEPTION_FILTER previousTopLevelExceptionFilter = {\cf17 nullptr};\par
4109 \par
4110 \par
4111     {\cf20 // For MSVC, we reserve part of the stack memory for handling}\par
4112     {\cf20 // memory overflow structured exception.}\par
4113     FatalConditionHandler::FatalConditionHandler() \{\par
4114         ULONG guaranteeSize = {\cf17 static_cast<}ULONG{\cf17 >}(minStackSizeForErrors);\par
4115         {\cf19 if} (!SetThreadStackGuarantee(&guaranteeSize)) \{\par
4116             {\cf20 // We do not want to fully error out, because needing}\par
4117             {\cf20 // the stack reserve should be rare enough anyway.}\par
4118             Catch::cerr()\par
4119                 << {\cf22 "Failed to reserve piece of stack."}\par
4120                 << {\cf22 " Stack overflows will not be reported successfully."};\par
4121         \}\par
4122     \}\par
4123 \par
4124     {\cf20 // We do not attempt to unset the stack guarantee, because}\par
4125     {\cf20 // Windows does not support lowering the stack size guarantee.}\par
4126     FatalConditionHandler::~FatalConditionHandler() = {\cf19 default};\par
4127 \par
4128 \par
4129     {\cf18 void} FatalConditionHandler::engage_platform() \{\par
4130         {\cf20 // Register as a the top level exception filter.}\par
4131         previousTopLevelExceptionFilter = SetUnhandledExceptionFilter(topLevelExceptionFilter);\par
4132     \}\par
4133 \par
4134     {\cf18 void} FatalConditionHandler::disengage_platform() noexcept \{\par
4135         {\cf19 if} (SetUnhandledExceptionFilter(previousTopLevelExceptionFilter) != topLevelExceptionFilter) \{\par
4136             Catch::cerr()\par
4137                 << {\cf22 "Unexpected SEH unhandled exception filter on disengage."}\par
4138                 << {\cf22 " The filter was restored, but might be rolled back unexpectedly."};\par
4139         \}\par
4140         previousTopLevelExceptionFilter = {\cf17 nullptr};\par
4141     \}\par
4142 \par
4143 \} {\cf20 // end namespace Catch}\par
4144 \par
4145 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_SEH}\par
4146 \par
4147 {\cf21 #if defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4148 \par
4149 {\cf21 #include <signal.h>}\par
4150 \par
4151 {\cf17 namespace }Catch \{\par
4152 \par
4153     {\cf17 struct }SignalDefs \{\par
4154         {\cf18 int} id;\par
4155         {\cf17 const} {\cf18 char}* name;\par
4156     \};\par
4157 \par
4158     {\cf17 static} SignalDefs signalDefs[] = \{\par
4159         \{ SIGINT,  {\cf22 "SIGINT - Terminal interrupt signal"} \},\par
4160         \{ SIGILL,  {\cf22 "SIGILL - Illegal instruction signal"} \},\par
4161         \{ SIGFPE,  {\cf22 "SIGFPE - Floating point error signal"} \},\par
4162         \{ SIGSEGV, {\cf22 "SIGSEGV - Segmentation violation signal"} \},\par
4163         \{ SIGTERM, {\cf22 "SIGTERM - Termination request signal"} \},\par
4164         \{ SIGABRT, {\cf22 "SIGABRT - Abort (abnormal termination) signal"} \}\par
4165     \};\par
4166 \par
4167 {\cf20 // Older GCCs trigger -Wmissing-field-initializers for T foo = \{\}}\par
4168 {\cf20 // which is zero initialization, but not explicit. We want to avoid}\par
4169 {\cf20 // that.}\par
4170 {\cf21 #if defined(__GNUC__)}\par
4171 {\cf21 #    pragma GCC diagnostic push}\par
4172 {\cf21 #    pragma GCC diagnostic ignored "-Wmissing-field-initializers"}\par
4173 {\cf21 #endif}\par
4174 \par
4175     {\cf17 static} {\cf18 char}* altStackMem = {\cf17 nullptr};\par
4176     {\cf17 static} std::size_t altStackSize = 0;\par
4177     {\cf17 static} stack_t oldSigStack\{\};\par
4178     {\cf17 static} {\cf17 struct }sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]\{\};\par
4179 \par
4180     {\cf17 static} {\cf18 void} restorePreviousSignalHandlers() noexcept \{\par
4181         {\cf20 // We set signal handlers back to the previous ones. Hopefully}\par
4182         {\cf20 // nobody overwrote them in the meantime, and doesn't expect}\par
4183         {\cf20 // their signal handlers to live past ours given that they}\par
4184         {\cf20 // installed them after ours..}\par
4185         {\cf19 for} (std::size_t i = 0; i < {\cf17 sizeof}(signalDefs) / {\cf17 sizeof}(SignalDefs); ++i) \{\par
4186             sigaction(signalDefs[i].{\cf18 id}, &oldSigActions[i], {\cf17 nullptr});\par
4187         \}\par
4188         {\cf20 // Return the old stack}\par
4189         sigaltstack(&oldSigStack, {\cf17 nullptr});\par
4190     \}\par
4191 \par
4192     {\cf17 static} {\cf18 void} handleSignal( {\cf18 int} sig ) \{\par
4193         {\cf18 char} {\cf17 const} * name = {\cf22 "<unknown signal>"};\par
4194         {\cf19 for} ({\cf17 auto} {\cf17 const}& def : signalDefs) \{\par
4195             {\cf19 if} (sig == def.id) \{\par
4196                 name = def.name;\par
4197                 {\cf19 break};\par
4198             \}\par
4199         \}\par
4200         {\cf20 // We need to restore previous signal handlers and let them do}\par
4201         {\cf20 // their thing, so that the users can have the debugger break}\par
4202         {\cf20 // when a signal is raised, and so on.}\par
4203         restorePreviousSignalHandlers();\par
4204         reportFatal( name );\par
4205         raise( sig );\par
4206     \}\par
4207 \par
4208     FatalConditionHandler::FatalConditionHandler() \{\par
4209         assert(!altStackMem && {\cf22 "Cannot initialize POSIX signal handler when one already exists"});\par
4210         {\cf19 if} (altStackSize == 0) \{\par
4211             altStackSize = std::max({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(SIGSTKSZ), minStackSizeForErrors);\par
4212         \}\par
4213         altStackMem = {\cf17 new} {\cf18 char}[altStackSize]();\par
4214     \}\par
4215 \par
4216     FatalConditionHandler::~FatalConditionHandler() \{\par
4217         {\cf17 delete}[] altStackMem;\par
4218         {\cf20 // We signal that another instance can be constructed by zeroing}\par
4219         {\cf20 // out the pointer.}\par
4220         altStackMem = {\cf17 nullptr};\par
4221     \}\par
4222 \par
4223     {\cf18 void} FatalConditionHandler::engage_platform() \{\par
4224         stack_t sigStack;\par
4225         sigStack.ss_sp = altStackMem;\par
4226         sigStack.ss_size = altStackSize;\par
4227         sigStack.ss_flags = 0;\par
4228         sigaltstack(&sigStack, &oldSigStack);\par
4229         {\cf17 struct }sigaction sa = \{ \};\par
4230 \par
4231         sa.sa_handler = handleSignal;\par
4232         sa.sa_flags = SA_ONSTACK;\par
4233         {\cf19 for} (std::size_t i = 0; i < {\cf17 sizeof}(signalDefs)/{\cf17 sizeof}(SignalDefs); ++i) \{\par
4234             sigaction(signalDefs[i].{\cf18 id}, &sa, &oldSigActions[i]);\par
4235         \}\par
4236     \}\par
4237 \par
4238 {\cf21 #if defined(__GNUC__)}\par
4239 {\cf21 #    pragma GCC diagnostic pop}\par
4240 {\cf21 #endif}\par
4241 \par
4242 \par
4243     {\cf18 void} FatalConditionHandler::disengage_platform() noexcept \{\par
4244         restorePreviousSignalHandlers();\par
4245     \}\par
4246 \par
4247 \} {\cf20 // end namespace Catch}\par
4248 \par
4249 {\cf21 #endif }{\cf20 // CATCH_CONFIG_POSIX_SIGNALS}\par
4250 \par
4251 \par
4252 \par
4253 \par
4254 {\cf21 #include <cstring>}\par
4255 \par
4256 {\cf17 namespace }Catch \{\par
4257     {\cf17 namespace }Detail \{\par
4258 \par
4259         uint32_t convertToBits({\cf18 float} f) \{\par
4260             {\cf17 static_assert}({\cf17 sizeof}(float) == {\cf17 sizeof}(uint32_t), {\cf22 "Important ULP matcher assumption violated"});\par
4261             uint32_t i;\par
4262             std::memcpy(&i, &f, {\cf17 sizeof}(f));\par
4263             {\cf19 return} i;\par
4264         \}\par
4265 \par
4266         uint64_t convertToBits({\cf18 double} d) \{\par
4267             {\cf17 static_assert}({\cf17 sizeof}(double) == {\cf17 sizeof}(uint64_t), {\cf22 "Important ULP matcher assumption violated"});\par
4268             uint64_t i;\par
4269             std::memcpy(&i, &d, {\cf17 sizeof}(d));\par
4270             {\cf19 return} i;\par
4271         \}\par
4272 \par
4273 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
4274 {\cf21 #    pragma GCC diagnostic push}\par
4275 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
4276 {\cf21 #endif}\par
4277         {\cf18 bool} directCompare( {\cf18 float} lhs, {\cf18 float} rhs ) \{ {\cf19 return} lhs == rhs; \}\par
4278         {\cf18 bool} directCompare( {\cf18 double} lhs, {\cf18 double} rhs ) \{ {\cf19 return} lhs == rhs; \}\par
4279 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
4280 {\cf21 #    pragma GCC diagnostic pop}\par
4281 {\cf21 #endif}\par
4282 \par
4283 \par
4284     \} {\cf20 // end namespace Detail}\par
4285 \} {\cf20 // end namespace Catch}\par
4286 \par
4287 \par
4288 \par
4289 \par
4290 \par
4291 \par
4292 {\cf21 #include <cstdlib>}\par
4293 \par
4294 {\cf17 namespace }Catch \{\par
4295     {\cf17 namespace }Detail \{\par
4296 \par
4297 {\cf21 #if !defined (CATCH_CONFIG_GETENV)}\par
4298         {\cf18 char} {\cf17 const}* getEnv( {\cf18 char} {\cf17 const}* ) \{ {\cf19 return} {\cf17 nullptr}; \}\par
4299 {\cf21 #else}\par
4300 \par
4301         {\cf18 char} {\cf17 const}* getEnv( {\cf18 char} {\cf17 const}* varName ) \{\par
4302 {\cf21 #    if defined( _MSC_VER )}\par
4303 {\cf21 #        pragma warning( push )}\par
4304 {\cf21 #        pragma warning( disable : 4996 ) }{\cf20 // use getenv_s instead of getenv}\par
4305 {\cf21 #    endif}\par
4306 \par
4307             {\cf19 return} std::getenv( varName );\par
4308 \par
4309 {\cf21 #    if defined( _MSC_VER )}\par
4310 {\cf21 #        pragma warning( pop )}\par
4311 {\cf21 #    endif}\par
4312         \}\par
4313 {\cf21 #endif}\par
4314 \} {\cf20 // namespace Detail}\par
4315 \} {\cf20 // namespace Catch}\par
4316 \par
4317 \par
4318 \par
4319 \par
4320 {\cf21 #include <cstdio>}\par
4321 {\cf21 #include <fstream>}\par
4322 {\cf21 #include <sstream>}\par
4323 {\cf21 #include <vector>}\par
4324 \par
4325 {\cf17 namespace }Catch \{\par
4326 \par
4327     Catch::IStream::~IStream() = {\cf19 default};\par
4328 \par
4329 {\cf17 namespace }Detail \{\par
4330     {\cf17 namespace }\{\par
4331         {\cf17 template}<{\cf17 typename} WriterF, std::{\cf18 size_t} bufferSize=256>\par
4332         {\cf17 class }StreamBufImpl final : {\cf17 public} std::streambuf \{\par
4333             {\cf18 char} data[bufferSize];\par
4334             WriterF m_writer;\par
4335 \par
4336         {\cf17 public}:\par
4337             StreamBufImpl() \{\par
4338                 setp( data, data + {\cf17 sizeof}(data) );\par
4339             \}\par
4340 \par
4341             ~StreamBufImpl() noexcept{\cf17  override }\{\par
4342                 StreamBufImpl::sync();\par
4343             \}\par
4344 \par
4345         {\cf17 private}:\par
4346             {\cf18 int} overflow( {\cf18 int} c ){\cf17  override }\{\par
4347                 sync();\par
4348 \par
4349                 {\cf19 if}( c != EOF ) \{\par
4350                     {\cf19 if}( pbase() == epptr() )\par
4351                         m_writer( std::string( 1, {\cf17 static_cast<}{\cf18 char}{\cf17 >}( c ) ) );\par
4352                     {\cf19 else}\par
4353                         sputc( {\cf17 static_cast<}{\cf18 char}{\cf17 >}( c ) );\par
4354                 \}\par
4355                 {\cf19 return} 0;\par
4356             \}\par
4357 \par
4358             {\cf18 int} sync(){\cf17  override }\{\par
4359                 {\cf19 if}( pbase() != pptr() ) \{\par
4360                     m_writer( std::string( pbase(), {\cf17 static_cast<}std::string::size_type{\cf17 >}( pptr() - pbase() ) ) );\par
4361                     setp( pbase(), epptr() );\par
4362                 \}\par
4363                 {\cf19 return} 0;\par
4364             \}\par
4365         \};\par
4366 \par
4368 \par
4369         {\cf17 struct }OutputDebugWriter \{\par
4370 \par
4371             {\cf18 void} operator()( std::string {\cf17 const}& str ) \{\par
4372                 {\cf19 if} ( !str.empty() ) \{\par
4373                     writeToDebugConsole( str );\par
4374                 \}\par
4375             \}\par
4376         \};\par
4377 \par
4379 \par
4380         {\cf17 class }FileStream final : {\cf17 public} IStream \{\par
4381             std::ofstream m_ofs;\par
4382         {\cf17 public}:\par
4383             FileStream( std::string {\cf17 const}& filename ) \{\par
4384                 m_ofs.open( filename.c_str() );\par
4385                 CATCH_ENFORCE( !m_ofs.fail(), {\cf22 "Unable to open file: '"} << filename << {\cf23 '\\''} );\par
4386                 m_ofs << std::unitbuf;\par
4387             \}\par
4388         {\cf17 public}: {\cf20 // IStream}\par
4389             std::ostream& stream(){\cf17  override }\{\par
4390                 {\cf19 return} m_ofs;\par
4391             \}\par
4392         \};\par
4393 \par
4395 \par
4396         {\cf17 class }CoutStream final : {\cf17 public} IStream \{\par
4397             std::ostream m_os;\par
4398         {\cf17 public}:\par
4399             {\cf20 // Store the streambuf from cout up-front because}\par
4400             {\cf20 // cout may get redirected when running tests}\par
4401             CoutStream() : m_os( Catch::cout().rdbuf() ) \{\}\par
4402 \par
4403         {\cf17 public}: {\cf20 // IStream}\par
4404             std::ostream& stream(){\cf17  override }\{ {\cf19 return} m_os; \}\par
4405             {\cf18 bool} isConsole(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
4406         \};\par
4407 \par
4408         {\cf17 class }CerrStream : {\cf17 public} IStream \{\par
4409             std::ostream m_os;\par
4410 \par
4411         {\cf17 public}:\par
4412             {\cf20 // Store the streambuf from cerr up-front because}\par
4413             {\cf20 // cout may get redirected when running tests}\par
4414             CerrStream(): m_os( Catch::cerr().rdbuf() ) \{\}\par
4415 \par
4416         {\cf17 public}: {\cf20 // IStream}\par
4417             std::ostream& stream(){\cf17  override }\{ {\cf19 return} m_os; \}\par
4418             {\cf18 bool} isConsole(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
4419         \};\par
4420 \par
4422 \par
4423         {\cf17 class }DebugOutStream final : {\cf17 public} IStream \{\par
4424             Detail::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\par
4425             std::ostream m_os;\par
4426         {\cf17 public}:\par
4427             DebugOutStream()\par
4428             :   m_streamBuf( Detail::make_unique<StreamBufImpl<OutputDebugWriter>>() ),\par
4429                 m_os( m_streamBuf.get() )\par
4430             \{\}\par
4431 \par
4432         {\cf17 public}: {\cf20 // IStream}\par
4433             std::ostream& stream(){\cf17  override }\{ {\cf19 return} m_os; \}\par
4434         \};\par
4435 \par
4436     \} {\cf20 // unnamed namespace}\par
4437 \} {\cf20 // namespace Detail}\par
4438 \par
4440 \par
4441     {\cf17 auto} makeStream( std::string {\cf17 const}& filename ) -> Detail::unique_ptr<IStream> \{\par
4442         {\cf19 if} ( filename.empty() || filename == {\cf22 "-"} ) \{\par
4443             {\cf19 return} Detail::make_unique<Detail::CoutStream>();\par
4444         \}\par
4445         {\cf19 if}( filename[0] == {\cf23 '%'} ) \{\par
4446             {\cf19 if} ( filename == {\cf22 "%debug"} ) \{\par
4447                 {\cf19 return} Detail::make_unique<Detail::DebugOutStream>();\par
4448             \} {\cf19 else} {\cf19 if} ( filename == {\cf22 "%stderr"} ) \{\par
4449                 {\cf19 return} Detail::make_unique<Detail::CerrStream>();\par
4450             \} {\cf19 else} {\cf19 if} ( filename == {\cf22 "%stdout"} ) \{\par
4451                 {\cf19 return} Detail::make_unique<Detail::CoutStream>();\par
4452             \} {\cf19 else} \{\par
4453                 CATCH_ERROR( {\cf22 "Unrecognised stream: '"} << filename << {\cf23 '\\''} );\par
4454             \}\par
4455         \}\par
4456         {\cf19 return} Detail::make_unique<Detail::FileStream>( filename );\par
4457     \}\par
4458 \par
4459 \}\par
4460 \par
4461 \par
4462 \par
4463 {\cf17 namespace }Catch \{\par
4464     {\cf18 void} JsonUtils::indent( std::ostream& os, std::uint64_t level ) \{\par
4465         {\cf19 for} ( std::uint64_t i = 0; i < level; ++i ) \{\par
4466             os << {\cf22 "  "};\par
4467         \}\par
4468     \}\par
4469     {\cf18 void} JsonUtils::appendCommaNewline( std::ostream& os,\par
4470                                         {\cf18 bool}& should_comma,\par
4471                                         std::uint64_t level ) \{\par
4472         {\cf19 if} ( should_comma ) \{ os << {\cf23 ','}; \}\par
4473         should_comma = {\cf17 true};\par
4474         os << {\cf23 '\\n'};\par
4475         indent( os, level );\par
4476     \}\par
4477 \par
4478     JsonObjectWriter::JsonObjectWriter( std::ostream& os ):\par
4479         JsonObjectWriter\{ os, 0 \} \{\}\par
4480 \par
4481     JsonObjectWriter::JsonObjectWriter( std::ostream& os,\par
4482                                         std::uint64_t indent_level ):\par
4483         m_os\{ os \}, m_indent_level\{ indent_level \} \{\par
4484         m_os << {\cf23 '\{'};\par
4485     \}\par
4486     JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ) {\cf17 noexcept}:\par
4487         m_os\{ source.m_os \},\par
4488         m_indent_level\{ source.m_indent_level \},\par
4489         m_should_comma\{ source.m_should_comma \},\par
4490         m_active\{ source.m_active \} \{\par
4491         source.m_active = {\cf17 false};\par
4492     \}\par
4493 \par
4494     JsonObjectWriter::~JsonObjectWriter() \{\par
4495         {\cf19 if} ( !m_active ) \{ {\cf19 return}; \}\par
4496 \par
4497         m_os << {\cf23 '\\n'};\par
4498         JsonUtils::indent( m_os, m_indent_level );\par
4499         m_os << {\cf23 '\}'};\par
4500     \}\par
4501 \par
4502     JsonValueWriter JsonObjectWriter::write( StringRef key ) \{\par
4503         JsonUtils::appendCommaNewline(\par
4504             m_os, m_should_comma, m_indent_level + 1 );\par
4505 \par
4506         m_os << {\cf23 '"'} << key << {\cf22 "\\": "};\par
4507         {\cf19 return} JsonValueWriter\{ m_os, m_indent_level + 1 \};\par
4508     \}\par
4509 \par
4510     JsonArrayWriter::JsonArrayWriter( std::ostream& os ):\par
4511         JsonArrayWriter\{ os, 0 \} \{\}\par
4512     JsonArrayWriter::JsonArrayWriter( std::ostream& os,\par
4513                                       std::uint64_t indent_level ):\par
4514         m_os\{ os \}, m_indent_level\{ indent_level \} \{\par
4515         m_os << {\cf23 '['};\par
4516     \}\par
4517     JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ) {\cf17 noexcept}:\par
4518         m_os\{ source.m_os \},\par
4519         m_indent_level\{ source.m_indent_level \},\par
4520         m_should_comma\{ source.m_should_comma \},\par
4521         m_active\{ source.m_active \} \{\par
4522         source.m_active = {\cf17 false};\par
4523     \}\par
4524     JsonArrayWriter::~JsonArrayWriter() \{\par
4525         {\cf19 if} ( !m_active ) \{ {\cf19 return}; \}\par
4526 \par
4527         m_os << {\cf23 '\\n'};\par
4528         JsonUtils::indent( m_os, m_indent_level );\par
4529         m_os << {\cf23 ']'};\par
4530     \}\par
4531 \par
4532     JsonObjectWriter JsonArrayWriter::writeObject() \{\par
4533         JsonUtils::appendCommaNewline(\par
4534             m_os, m_should_comma, m_indent_level + 1 );\par
4535         {\cf19 return} JsonObjectWriter\{ m_os, m_indent_level + 1 \};\par
4536     \}\par
4537 \par
4538     JsonArrayWriter JsonArrayWriter::writeArray() \{\par
4539         JsonUtils::appendCommaNewline(\par
4540             m_os, m_should_comma, m_indent_level + 1 );\par
4541         {\cf19 return} JsonArrayWriter\{ m_os, m_indent_level + 1 \};\par
4542     \}\par
4543 \par
4544     JsonArrayWriter& JsonArrayWriter::write( {\cf18 bool} value ) \{\par
4545         {\cf19 return} writeImpl( value );\par
4546     \}\par
4547 \par
4548     JsonValueWriter::JsonValueWriter( std::ostream& os ):\par
4549         JsonValueWriter\{ os, 0 \} \{\}\par
4550 \par
4551     JsonValueWriter::JsonValueWriter( std::ostream& os,\par
4552                                       std::uint64_t indent_level ):\par
4553         m_os\{ os \}, m_indent_level\{ indent_level \} \{\}\par
4554 \par
4555     JsonObjectWriter JsonValueWriter::writeObject() && \{\par
4556         {\cf19 return} JsonObjectWriter\{ m_os, m_indent_level \};\par
4557     \}\par
4558 \par
4559     JsonArrayWriter JsonValueWriter::writeArray() && \{\par
4560         {\cf19 return} JsonArrayWriter\{ m_os, m_indent_level \};\par
4561     \}\par
4562 \par
4563     {\cf18 void} JsonValueWriter::write( Catch::StringRef value ) && \{\par
4564         writeImpl( value, {\cf17 true} );\par
4565     \}\par
4566 \par
4567     {\cf18 void} JsonValueWriter::write( {\cf18 bool} value ) && \{\par
4568         writeImpl( value ? {\cf22 "true"}_sr : {\cf22 "false"}_sr, {\cf17 false} );\par
4569     \}\par
4570 \par
4571     {\cf18 void} JsonValueWriter::writeImpl( Catch::StringRef value, {\cf18 bool} quote ) \{\par
4572         {\cf19 if} ( quote ) \{ m_os << {\cf23 '"'}; \}\par
4573         {\cf19 for} ({\cf18 char} c : value) \{\par
4574             {\cf20 // Escape list taken from https://www.json.org/json-en.html,}\par
4575             {\cf20 // string definition.}\par
4576             {\cf20 // Note that while forward slash _can_ be escaped, it does}\par
4577             {\cf20 // not have to be, if JSON is not further embedded somewhere}\par
4578             {\cf20 // where forward slash is meaningful.}\par
4579             {\cf19 if} ( c == {\cf23 '"'} ) \{\par
4580                 m_os << {\cf22 "\\\\\\""};\par
4581             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\\\'} ) \{\par
4582                 m_os << {\cf22 "\\\\\\\\"};\par
4583             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\b'} ) \{\par
4584                 m_os << {\cf22 "\\\\b"};\par
4585             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\f'} ) \{\par
4586                 m_os << {\cf22 "\\\\f"};\par
4587             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\n'} ) \{\par
4588                 m_os << {\cf22 "\\\\n"};\par
4589             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\r'} ) \{\par
4590                 m_os << {\cf22 "\\\\r"};\par
4591             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\t'} ) \{\par
4592                 m_os << {\cf22 "\\\\t"};\par
4593             \} {\cf19 else} \{\par
4594                 m_os << c;\par
4595             \}\par
4596         \}\par
4597         {\cf19 if} ( quote ) \{ m_os << {\cf23 '"'}; \}\par
4598     \}\par
4599 \par
4600 \} {\cf20 // namespace Catch}\par
4601 \par
4602 \par
4603 \par
4604 \par
4605 {\cf17 namespace }Catch \{\par
4606 \par
4607     {\cf17 auto} operator << (std::ostream& os, LazyExpression {\cf17 const}& lazyExpr) -> std::ostream& \{\par
4608         {\cf19 if} (lazyExpr.m_isNegated)\par
4609             os << {\cf23 '!'};\par
4610 \par
4611         {\cf19 if} (lazyExpr) \{\par
4612             {\cf19 if} (lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression())\par
4613                 os << {\cf23 '('} << *lazyExpr.m_transientExpression << {\cf23 ')'};\par
4614             {\cf19 else}\par
4615                 os << *lazyExpr.m_transientExpression;\par
4616         \} {\cf19 else} \{\par
4617             os << {\cf22 "\{** error - unchecked empty expression requested **\}"};\par
4618         \}\par
4619         {\cf19 return} os;\par
4620     \}\par
4621 \par
4622 \} {\cf20 // namespace Catch}\par
4623 \par
4624 \par
4625 \par
4626 \par
4627 {\cf21 #ifdef CATCH_CONFIG_WINDOWS_CRTDBG}\par
4628 {\cf21 #include <crtdbg.h>}\par
4629 \par
4630 {\cf17 namespace }Catch \{\par
4631 \par
4632     LeakDetector::LeakDetector() \{\par
4633         {\cf18 int} flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\par
4634         flag |= _CRTDBG_LEAK_CHECK_DF;\par
4635         flag |= _CRTDBG_ALLOC_MEM_DF;\par
4636         _CrtSetDbgFlag(flag);\par
4637         _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\par
4638         _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\par
4639         {\cf20 // Change this to leaking allocation's number to break there}\par
4640         _CrtSetBreakAlloc(-1);\par
4641     \}\par
4642 \}\par
4643 \par
4644 {\cf21 #else }{\cf20 // ^^ Windows crt debug heap enabled // Windows crt debug heap disabled vv}\par
4645 \par
4646     Catch::LeakDetector::LeakDetector() = {\cf19 default};\par
4647 \par
4648 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_CRTDBG}\par
4649 \par
4650 Catch::LeakDetector::~LeakDetector() \{\par
4651     Catch::cleanUp();\par
4652 \}\par
4653 \par
4654 \par
4655 \par
4656 \par
4657 {\cf17 namespace }Catch \{\par
4658     {\cf17 namespace }\{\par
4659 \par
4660         {\cf18 void} listTests(IEventListener& reporter, IConfig {\cf17 const}& config) \{\par
4661             {\cf17 auto} {\cf17 const}& testSpec = config.testSpec();\par
4662             {\cf17 auto} matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);\par
4663             reporter.listTests(matchedTestCases);\par
4664         \}\par
4665 \par
4666         {\cf18 void} listTags(IEventListener& reporter, IConfig {\cf17 const}& config) \{\par
4667             {\cf17 auto} {\cf17 const}& testSpec = config.testSpec();\par
4668             std::vector<TestCaseHandle> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);\par
4669 \par
4670             std::map<StringRef, TagInfo, Detail::CaseInsensitiveLess> tagCounts;\par
4671             {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : matchedTestCases) \{\par
4672                 {\cf19 for} ({\cf17 auto} {\cf17 const}& tagName : testCase.getTestCaseInfo().tags) \{\par
4673                     {\cf17 auto} it = tagCounts.find(tagName.original);\par
4674                     {\cf19 if} (it == tagCounts.end())\par
4675                         it = tagCounts.insert(std::make_pair(tagName.original, TagInfo())).first;\par
4676                     it->second.add(tagName.original);\par
4677                 \}\par
4678             \}\par
4679 \par
4680             std::vector<TagInfo> infos; infos.reserve(tagCounts.size());\par
4681             {\cf19 for} ({\cf17 auto}& tagc : tagCounts) \{\par
4682                 infos.push_back(CATCH_MOVE(tagc.second));\par
4683             \}\par
4684 \par
4685             reporter.listTags(infos);\par
4686         \}\par
4687 \par
4688         {\cf18 void} listReporters(IEventListener& reporter) \{\par
4689             std::vector<ReporterDescription> descriptions;\par
4690 \par
4691             {\cf17 auto} {\cf17 const}& factories = getRegistryHub().getReporterRegistry().getFactories();\par
4692             descriptions.reserve(factories.size());\par
4693             {\cf19 for} ({\cf17 auto} {\cf17 const}& fac : factories) \{\par
4694                 descriptions.push_back(\{ fac.first, fac.second->getDescription() \});\par
4695             \}\par
4696 \par
4697             reporter.listReporters(descriptions);\par
4698         \}\par
4699 \par
4700         {\cf18 void} listListeners(IEventListener& reporter) \{\par
4701             std::vector<ListenerDescription> descriptions;\par
4702 \par
4703             {\cf17 auto} {\cf17 const}& factories =\par
4704                 getRegistryHub().getReporterRegistry().getListeners();\par
4705             descriptions.reserve( factories.size() );\par
4706             {\cf19 for} ( {\cf17 auto} {\cf17 const}& fac : factories ) \{\par
4707                 descriptions.push_back( \{ fac->getName(), fac->getDescription() \} );\par
4708             \}\par
4709 \par
4710             reporter.listListeners( descriptions );\par
4711         \}\par
4712 \par
4713     \} {\cf20 // end anonymous namespace}\par
4714 \par
4715     {\cf18 void} TagInfo::add( StringRef spelling ) \{\par
4716         ++count;\par
4717         spellings.insert( spelling );\par
4718     \}\par
4719 \par
4720     std::string TagInfo::all(){\cf17  const }\{\par
4721         {\cf20 // 2 per tag for brackets '[' and ']'}\par
4722         {\cf18 size_t} size =  spellings.size() * 2;\par
4723         {\cf19 for} ({\cf17 auto} {\cf17 const}& spelling : spellings) \{\par
4724             size += spelling.size();\par
4725         \}\par
4726 \par
4727         std::string out; out.reserve(size);\par
4728         {\cf19 for} ({\cf17 auto} {\cf17 const}& spelling : spellings) \{\par
4729             out += {\cf23 '['};\par
4730             out += spelling;\par
4731             out += {\cf23 ']'};\par
4732         \}\par
4733         {\cf19 return} out;\par
4734     \}\par
4735 \par
4736     {\cf18 bool} list( IEventListener& reporter, Config {\cf17 const}& config ) \{\par
4737         {\cf18 bool} listed = {\cf17 false};\par
4738         {\cf19 if} (config.listTests()) \{\par
4739             listed = {\cf17 true};\par
4740             listTests(reporter, config);\par
4741         \}\par
4742         {\cf19 if} (config.listTags()) \{\par
4743             listed = {\cf17 true};\par
4744             listTags(reporter, config);\par
4745         \}\par
4746         {\cf19 if} (config.listReporters()) \{\par
4747             listed = {\cf17 true};\par
4748             listReporters(reporter);\par
4749         \}\par
4750         {\cf19 if} ( config.listListeners() ) \{\par
4751             listed = {\cf17 true};\par
4752             listListeners( reporter );\par
4753         \}\par
4754         {\cf19 return} listed;\par
4755     \}\par
4756 \par
4757 \} {\cf20 // end namespace Catch}\par
4758 \par
4759 \par
4760 \par
4761 {\cf17 namespace }Catch \{\par
4762     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION\par
4763     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\par
4764     {\cf17 static} LeakDetector leakDetector;\par
4765     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\par
4766 \}\par
4767 \par
4768 {\cf20 // Allow users of amalgamated .cpp file to remove our main and provide their own.}\par
4769 {\cf21 #if !defined(CATCH_AMALGAMATED_CUSTOM_MAIN)}\par
4770 \par
4771 {\cf21 #if defined(CATCH_CONFIG_WCHAR) && defined(CATCH_PLATFORM_WINDOWS) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)}\par
4772 {\cf20 // Standard C/C++ Win32 Unicode wmain entry point}\par
4773 {\cf17 extern} {\cf22 "C"} {\cf18 int} __cdecl wmain ({\cf18 int} argc, {\cf18 wchar_t} * argv[], {\cf18 wchar_t} * []) \{\par
4774 {\cf21 #else}\par
4775 {\cf20 // Standard C/C++ main entry point}\par
4776 {\cf18 int} main ({\cf18 int} argc, {\cf18 char} * argv[]) \{\par
4777 {\cf21 #endif}\par
4778 \par
4779     {\cf20 // We want to force the linker not to discard the global variable}\par
4780     {\cf20 // and its constructor, as it (optionally) registers leak detector}\par
4781     (void)&Catch::leakDetector;\par
4782 \par
4783     {\cf19 return} Catch::Session().run( argc, argv );\par
4784 \}\par
4785 \par
4786 {\cf21 #endif }{\cf20 // !defined(CATCH_AMALGAMATED_CUSTOM_MAIN}\par
4787 \par
4788 \par
4789 \par
4790 \par
4791 {\cf17 namespace }Catch \{\par
4792 \par
4793     MessageInfo::MessageInfo(   StringRef _macroName,\par
4794                                 SourceLineInfo {\cf17 const}& _lineInfo,\par
4795                                 ResultWas::OfType _type )\par
4796     :   macroName( _macroName ),\par
4797         lineInfo( _lineInfo ),\par
4798         type( _type ),\par
4799         sequence( ++globalCount )\par
4800     \{\}\par
4801 \par
4802     {\cf20 // This may need protecting if threading support is added}\par
4803     {\cf18 unsigned} {\cf18 int} MessageInfo::globalCount = 0;\par
4804 \par
4805 \} {\cf20 // end namespace Catch}\par
4806 \par
4807 \par
4808 \par
4809 {\cf21 #include <cstdio>}\par
4810 {\cf21 #include <cstring>}\par
4811 {\cf21 #include <sstream>}\par
4812 \par
4813 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
4814 {\cf21     #if defined(_MSC_VER)}\par
4815 {\cf21     #include <io.h>}      {\cf20 //_dup and _dup2}\par
4816 {\cf21     #define dup _dup}\par
4817 {\cf21     #define dup2 _dup2}\par
4818 {\cf21     #define fileno _fileno}\par
4819 {\cf21     #else}\par
4820 {\cf21     #include <unistd.h>}  {\cf20 // dup and dup2}\par
4821 {\cf21     #endif}\par
4822 {\cf21 #endif}\par
4823 \par
4824 \par
4825 {\cf17 namespace }Catch \{\par
4826 \par
4827     RedirectedStream::RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )\par
4828     :   m_originalStream( originalStream ),\par
4829         m_redirectionStream( redirectionStream ),\par
4830         m_prevBuf( m_originalStream.rdbuf() )\par
4831     \{\par
4832         m_originalStream.rdbuf( m_redirectionStream.rdbuf() );\par
4833     \}\par
4834 \par
4835     RedirectedStream::~RedirectedStream() \{\par
4836         m_originalStream.rdbuf( m_prevBuf );\par
4837     \}\par
4838 \par
4839     RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) \{\}\par
4840     {\cf17 auto} RedirectedStdOut::str() const -> std::{\cf18 string} \{ {\cf19 return} m_rss.str(); \}\par
4841 \par
4842     RedirectedStdErr::RedirectedStdErr()\par
4843     :   m_cerr( Catch::cerr(), m_rss.get() ),\par
4844         m_clog( Catch::clog(), m_rss.get() )\par
4845     \{\}\par
4846     {\cf17 auto} RedirectedStdErr::str() const -> std::{\cf18 string} \{ {\cf19 return} m_rss.str(); \}\par
4847 \par
4848     RedirectedStreams::RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr)\par
4849     :   m_redirectedCout(redirectedCout),\par
4850         m_redirectedCerr(redirectedCerr)\par
4851     \{\}\par
4852 \par
4853     RedirectedStreams::~RedirectedStreams() \{\par
4854         m_redirectedCout += m_redirectedStdOut.str();\par
4855         m_redirectedCerr += m_redirectedStdErr.str();\par
4856     \}\par
4857 \par
4858 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
4859 \par
4860 {\cf21 #if defined(_MSC_VER)}\par
4861     TempFile::TempFile() \{\par
4862         {\cf19 if} (tmpnam_s(m_buffer)) \{\par
4863             CATCH_RUNTIME_ERROR({\cf22 "Could not get a temp filename"});\par
4864         \}\par
4865         {\cf19 if} (fopen_s(&m_file, m_buffer, {\cf22 "w+"})) \{\par
4866             {\cf18 char} buffer[100];\par
4867             {\cf19 if} (strerror_s(buffer, errno)) \{\par
4868                 CATCH_RUNTIME_ERROR({\cf22 "Could not translate errno to a string"});\par
4869             \}\par
4870             CATCH_RUNTIME_ERROR({\cf22 "Could not open the temp file: '"} << m_buffer << {\cf22 "' because: "} << buffer);\par
4871         \}\par
4872     \}\par
4873 {\cf21 #else}\par
4874     TempFile::TempFile() \{\par
4875         m_file = std::tmpfile();\par
4876         {\cf19 if} (!m_file) \{\par
4877             CATCH_RUNTIME_ERROR({\cf22 "Could not create a temp file."});\par
4878         \}\par
4879     \}\par
4880 \par
4881 {\cf21 #endif}\par
4882 \par
4883     TempFile::~TempFile() \{\par
4884          {\cf20 // TBD: What to do about errors here?}\par
4885          std::fclose(m_file);\par
4886          {\cf20 // We manually create the file on Windows only, on Linux}\par
4887          {\cf20 // it will be autodeleted}\par
4888 {\cf21 #if defined(_MSC_VER)}\par
4889          std::remove(m_buffer);\par
4890 {\cf21 #endif}\par
4891     \}\par
4892 \par
4893 \par
4894     FILE* TempFile::getFile() \{\par
4895         {\cf19 return} m_file;\par
4896     \}\par
4897 \par
4898     std::string TempFile::getContents() \{\par
4899         std::stringstream sstr;\par
4900         {\cf18 char} buffer[100] = \{\};\par
4901         std::rewind(m_file);\par
4902         {\cf19 while} (std::fgets(buffer, {\cf17 sizeof}(buffer), m_file)) \{\par
4903             sstr << buffer;\par
4904         \}\par
4905         {\cf19 return} sstr.str();\par
4906     \}\par
4907 \par
4908     OutputRedirect::OutputRedirect(std::string& stdout_dest, std::string& stderr_dest) :\par
4909         m_originalStdout(dup(1)),\par
4910         m_originalStderr(dup(2)),\par
4911         m_stdoutDest(stdout_dest),\par
4912         m_stderrDest(stderr_dest) \{\par
4913         dup2(fileno(m_stdoutFile.getFile()), 1);\par
4914         dup2(fileno(m_stderrFile.getFile()), 2);\par
4915     \}\par
4916 \par
4917     OutputRedirect::~OutputRedirect() \{\par
4918         Catch::cout() << std::flush;\par
4919         fflush(stdout);\par
4920         {\cf20 // Since we support overriding these streams, we flush cerr}\par
4921         {\cf20 // even though std::cerr is unbuffered}\par
4922         Catch::cerr() << std::flush;\par
4923         Catch::clog() << std::flush;\par
4924         fflush(stderr);\par
4925 \par
4926         dup2(m_originalStdout, 1);\par
4927         dup2(m_originalStderr, 2);\par
4928 \par
4929         m_stdoutDest += m_stdoutFile.getContents();\par
4930         m_stderrDest += m_stderrFile.getContents();\par
4931     \}\par
4932 \par
4933 {\cf21 #endif }{\cf20 // CATCH_CONFIG_NEW_CAPTURE}\par
4934 \par
4935 \} {\cf20 // namespace Catch}\par
4936 \par
4937 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
4938 {\cf21     #if defined(_MSC_VER)}\par
4939 {\cf21     #undef dup}\par
4940 {\cf21     #undef dup2}\par
4941 {\cf21     #undef fileno}\par
4942 {\cf21     #endif}\par
4943 {\cf21 #endif}\par
4944 \par
4945 \par
4946 \par
4947 \par
4948 {\cf21 #include <limits>}\par
4949 {\cf21 #include <stdexcept>}\par
4950 \par
4951 {\cf17 namespace }Catch \{\par
4952 \par
4953     Optional<unsigned int> parseUInt(std::string {\cf17 const}& input, {\cf18 int} base) \{\par
4954         {\cf17 auto} trimmed = trim( input );\par
4955         {\cf20 // std::stoull is annoying and accepts numbers starting with '-',}\par
4956         {\cf20 // it just negates them into unsigned int}\par
4957         {\cf19 if} ( trimmed.empty() || trimmed[0] == {\cf23 '-'} ) \{\par
4958             {\cf19 return} \{\};\par
4959         \}\par
4960 \par
4961         CATCH_TRY \{\par
4962             {\cf18 size_t} pos = 0;\par
4963             {\cf17 const} {\cf17 auto} ret = std::stoull( trimmed, &pos, base );\par
4964 \par
4965             {\cf20 // We did not consume the whole input, so there is an issue}\par
4966             {\cf20 // This can be bunch of different stuff, like multiple numbers}\par
4967             {\cf20 // in the input, or invalid digits/characters and so on. Either}\par
4968             {\cf20 // way, we do not want to return the partially parsed result.}\par
4969             {\cf19 if} ( pos != trimmed.size() ) \{\par
4970                 {\cf19 return} \{\};\par
4971             \}\par
4972             {\cf20 // Too large}\par
4973             {\cf19 if} ( ret > std::numeric_limits<unsigned int>::max() ) \{\par
4974                 {\cf19 return} \{\};\par
4975             \}\par
4976             {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(ret);\par
4977         \}\par
4978         CATCH_CATCH_ANON( std::invalid_argument {\cf17 const}& ) \{\par
4979             {\cf20 // no conversion could be performed}\par
4980         \}\par
4981         CATCH_CATCH_ANON( std::out_of_range {\cf17 const}& ) \{\par
4982             {\cf20 // the input does not fit into an unsigned long long}\par
4983         \}\par
4984         {\cf19 return} \{\};\par
4985     \}\par
4986 \par
4987 \} {\cf20 // namespace Catch}\par
4988 \par
4989 \par
4990 \par
4991 \par
4992 {\cf21 #include <cmath>}\par
4993 \par
4994 {\cf17 namespace }Catch \{\par
4995 \par
4996 {\cf21 #if !defined(CATCH_CONFIG_POLYFILL_ISNAN)}\par
4997     {\cf18 bool} isnan({\cf18 float} f) \{\par
4998         {\cf19 return} std::isnan(f);\par
4999     \}\par
5000     {\cf18 bool} isnan({\cf18 double} d) \{\par
5001         {\cf19 return} std::isnan(d);\par
5002     \}\par
5003 {\cf21 #else}\par
5004     {\cf20 // For now we only use this for embarcadero}\par
5005     {\cf18 bool} isnan({\cf18 float} f) \{\par
5006         {\cf19 return} std::_isnan(f);\par
5007     \}\par
5008     {\cf18 bool} isnan({\cf18 double} d) \{\par
5009         {\cf19 return} std::_isnan(d);\par
5010     \}\par
5011 {\cf21 #endif}\par
5012 \par
5013 {\cf21 #if !defined( CATCH_CONFIG_GLOBAL_NEXTAFTER )}\par
5014     {\cf18 float} nextafter( {\cf18 float} x, {\cf18 float} y ) \{ {\cf19 return} std::nextafter( x, y ); \}\par
5015     {\cf18 double} nextafter( {\cf18 double} x, {\cf18 double} y ) \{ {\cf19 return} std::nextafter( x, y ); \}\par
5016 {\cf21 #else}\par
5017     {\cf18 float} nextafter( {\cf18 float} x, {\cf18 float} y ) \{ return ::nextafterf( x, y ); \}\par
5018     {\cf18 double} nextafter( {\cf18 double} x, {\cf18 double} y ) \{ return ::nextafter( x, y ); \}\par
5019 {\cf21 #endif}\par
5020 \par
5021 \} {\cf20 // end namespace Catch}\par
5022 \par
5023 \par
5024 \par
5025 {\cf17 namespace }Catch \{\par
5026 \par
5027 {\cf17 namespace }\{\par
5028 \par
5029 {\cf21 #if defined(_MSC_VER)}\par
5030 {\cf21 #pragma warning(push)}\par
5031 {\cf21 #pragma warning(disable:4146) }{\cf20 // we negate uint32 during the rotate}\par
5032 {\cf21 #endif}\par
5033         {\cf20 // Safe rotr implementation thanks to John Regehr}\par
5034         uint32_t rotate_right(uint32_t val, uint32_t count) \{\par
5035             {\cf17 const} uint32_t mask = 31;\par
5036             count &= mask;\par
5037             {\cf19 return} (val >> count) | (val << (-count & mask));\par
5038         \}\par
5039 \par
5040 {\cf21 #if defined(_MSC_VER)}\par
5041 {\cf21 #pragma warning(pop)}\par
5042 {\cf21 #endif}\par
5043 \par
5044 \}\par
5045 \par
5046 \par
5047     SimplePcg32::SimplePcg32(result_type seed_) \{\par
5048         seed(seed_);\par
5049     \}\par
5050 \par
5051 \par
5052     {\cf18 void} SimplePcg32::seed(result_type seed_) \{\par
5053         m_state = 0;\par
5054         (*this)();\par
5055         m_state += seed_;\par
5056         (*this)();\par
5057     \}\par
5058 \par
5059     {\cf18 void} SimplePcg32::discard(uint64_t skip) \{\par
5060         {\cf20 // We could implement this to run in O(log n) steps, but this}\par
5061         {\cf20 // should suffice for our use case.}\par
5062         {\cf19 for} (uint64_t s = 0; s < skip; ++s) \{\par
5063             {\cf17 static_cast<}{\cf18 void}{\cf17 >}((*this)());\par
5064         \}\par
5065     \}\par
5066 \par
5067     SimplePcg32::result_type SimplePcg32::operator()() \{\par
5068         {\cf20 // prepare the output value}\par
5069         {\cf17 const} uint32_t xorshifted = {\cf17 static_cast<}uint32_t{\cf17 >}(((m_state >> 18u) ^ m_state) >> 27u);\par
5070         {\cf17 const} {\cf17 auto} output = rotate_right(xorshifted, m_state >> 59u);\par
5071 \par
5072         {\cf20 // advance state}\par
5073         m_state = m_state * 6364136223846793005ULL + s_inc;\par
5074 \par
5075         {\cf19 return} output;\par
5076     \}\par
5077 \par
5078     {\cf18 bool} operator==(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs) \{\par
5079         {\cf19 return} lhs.m_state == rhs.m_state;\par
5080     \}\par
5081 \par
5082     {\cf18 bool} operator!=(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs) \{\par
5083         {\cf19 return} lhs.m_state != rhs.m_state;\par
5084     \}\par
5085 \}\par
5086 \par
5087 \par
5088 \par
5089 \par
5090 \par
5091 {\cf21 #include <ctime>}\par
5092 {\cf21 #include <random>}\par
5093 \par
5094 {\cf17 namespace }Catch \{\par
5095 \par
5096     std::uint32_t generateRandomSeed( GenerateFrom from ) \{\par
5097         {\cf19 switch} ( from ) \{\par
5098         {\cf19 case} GenerateFrom::Time:\par
5099             {\cf19 return} {\cf17 static_cast<}std::uint32_t{\cf17 >}( std::time( {\cf17 nullptr} ) );\par
5100 \par
5101         {\cf19 case} GenerateFrom::Default:\par
5102         {\cf19 case} GenerateFrom::RandomDevice: \{\par
5103             std::random_device rd;\par
5104             {\cf19 return} Detail::fillBitsFrom<std::uint32_t>( rd );\par
5105         \}\par
5106 \par
5107         {\cf19 default}:\par
5108             CATCH_ERROR({\cf22 "Unknown generation method"});\par
5109         \}\par
5110     \}\par
5111 \par
5112 \} {\cf20 // end namespace Catch}\par
5113 \par
5114 \par
5115 \par
5116 \par
5117 {\cf17 namespace }Catch \{\par
5118     {\cf17 struct }ReporterRegistry::ReporterRegistryImpl \{\par
5119         std::vector<Detail::unique_ptr<EventListenerFactory>> listeners;\par
5120         std::map<std::string, IReporterFactoryPtr, Detail::CaseInsensitiveLess>\par
5121             factories;\par
5122     \};\par
5123 \par
5124     ReporterRegistry::ReporterRegistry():\par
5125         m_impl( Detail::make_unique<ReporterRegistryImpl>() ) \{\par
5126         {\cf20 // Because it is impossible to move out of initializer list,}\par
5127         {\cf20 // we have to add the elements manually}\par
5128         m_impl->factories[{\cf22 "Automake"}] =\par
5129             Detail::make_unique<ReporterFactory<AutomakeReporter>>();\par
5130         m_impl->factories[{\cf22 "compact"}] =\par
5131             Detail::make_unique<ReporterFactory<CompactReporter>>();\par
5132         m_impl->factories[{\cf22 "console"}] =\par
5133             Detail::make_unique<ReporterFactory<ConsoleReporter>>();\par
5134         m_impl->factories[{\cf22 "JUnit"}] =\par
5135             Detail::make_unique<ReporterFactory<JunitReporter>>();\par
5136         m_impl->factories[{\cf22 "SonarQube"}] =\par
5137             Detail::make_unique<ReporterFactory<SonarQubeReporter>>();\par
5138         m_impl->factories[{\cf22 "TAP"}] =\par
5139             Detail::make_unique<ReporterFactory<TAPReporter>>();\par
5140         m_impl->factories[{\cf22 "TeamCity"}] =\par
5141             Detail::make_unique<ReporterFactory<TeamCityReporter>>();\par
5142         m_impl->factories[{\cf22 "XML"}] =\par
5143             Detail::make_unique<ReporterFactory<XmlReporter>>();\par
5144         m_impl->factories[{\cf22 "JSON"}] =\par
5145             Detail::make_unique<ReporterFactory<JsonReporter>>();\par
5146     \}\par
5147 \par
5148     ReporterRegistry::~ReporterRegistry() = {\cf19 default};\par
5149 \par
5150     IEventListenerPtr\par
5151     ReporterRegistry::create( std::string {\cf17 const}& name,\par
5152                               ReporterConfig&& config ){\cf17  const }\{\par
5153         {\cf17 auto} it = m_impl->factories.find( name );\par
5154         {\cf19 if} ( it == m_impl->factories.end() ) {\cf19 return} {\cf17 nullptr};\par
5155         {\cf19 return} it->second->create( CATCH_MOVE( config ) );\par
5156     \}\par
5157 \par
5158     {\cf18 void} ReporterRegistry::registerReporter( std::string {\cf17 const}& name,\par
5159                                              IReporterFactoryPtr factory ) \{\par
5160         CATCH_ENFORCE( name.find( {\cf22 "::"} ) == name.npos,\par
5161                        {\cf22 "'::' is not allowed in reporter name: '"} + name +\par
5162                            {\cf23 '\\''} );\par
5163         {\cf17 auto} ret = m_impl->factories.emplace( name, CATCH_MOVE( factory ) );\par
5164         CATCH_ENFORCE( ret.second,\par
5165                        {\cf22 "reporter using '"} + name +\par
5166                            {\cf22 "' as name was already registered"} );\par
5167     \}\par
5168     {\cf18 void} ReporterRegistry::registerListener(\par
5169         Detail::unique_ptr<EventListenerFactory> factory ) \{\par
5170         m_impl->listeners.push_back( CATCH_MOVE( factory ) );\par
5171     \}\par
5172 \par
5173     std::map<std::string,\par
5174              IReporterFactoryPtr,\par
5175              Detail::CaseInsensitiveLess> {\cf17 const}&\par
5176     ReporterRegistry::getFactories(){\cf17  const }\{\par
5177         {\cf19 return} m_impl->factories;\par
5178     \}\par
5179 \par
5180     std::vector<Detail::unique_ptr<EventListenerFactory>> {\cf17 const}&\par
5181     ReporterRegistry::getListeners(){\cf17  const }\{\par
5182         {\cf19 return} m_impl->listeners;\par
5183     \}\par
5184 \} {\cf20 // namespace Catch}\par
5185 \par
5186 \par
5187 \par
5188 \par
5189 \par
5190 {\cf21 #include <algorithm>}\par
5191 \par
5192 {\cf17 namespace }Catch \{\par
5193 \par
5194     {\cf17 namespace }\{\par
5195         {\cf17 struct }kvPair \{\par
5196             StringRef key, value;\par
5197         \};\par
5198 \par
5199         kvPair splitKVPair(StringRef kvString) \{\par
5200             {\cf17 auto} splitPos = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
5201                 std::find( kvString.begin(), kvString.end(), {\cf23 '='} ) -\par
5202                 kvString.begin() );\par
5203 \par
5204             {\cf19 return} \{ kvString.substr( 0, splitPos ),\par
5205                      kvString.substr( splitPos + 1, kvString.size() ) \};\par
5206         \}\par
5207     \}\par
5208 \par
5209     {\cf17 namespace }Detail \{\par
5210         std::vector<std::string> splitReporterSpec( StringRef reporterSpec ) \{\par
5211             {\cf17 static} {\cf17 constexpr} {\cf17 auto} separator = {\cf22 "::"};\par
5212             {\cf17 static} {\cf17 constexpr} {\cf18 size_t} separatorSize = 2;\par
5213 \par
5214             {\cf18 size_t} separatorPos = 0;\par
5215             {\cf17 auto} findNextSeparator = [&reporterSpec]( {\cf18 size_t} startPos ) \{\par
5216                 {\cf17 static_assert}(\par
5217                     separatorSize == 2,\par
5218                     {\cf22 "The code below currently assumes 2 char separator"} );\par
5219 \par
5220                 {\cf17 auto} currentPos = startPos;\par
5221                 {\cf19 do} \{\par
5222                     {\cf19 while} ( currentPos < reporterSpec.size() &&\par
5223                             reporterSpec[currentPos] != separator[0] ) \{\par
5224                         ++currentPos;\par
5225                     \}\par
5226                     {\cf19 if} ( currentPos + 1 < reporterSpec.size() &&\par
5227                          reporterSpec[currentPos + 1] == separator[1] ) \{\par
5228                         {\cf19 return} currentPos;\par
5229                     \}\par
5230                     ++currentPos;\par
5231                 \} {\cf19 while} ( currentPos < reporterSpec.size() );\par
5232 \par
5233                 {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( -1 );\par
5234             \};\par
5235 \par
5236             std::vector<std::string> parts;\par
5237 \par
5238             {\cf19 while} ( separatorPos < reporterSpec.size() ) \{\par
5239                 {\cf17 const} {\cf17 auto} nextSeparator = findNextSeparator( separatorPos );\par
5240                 parts.push_back( {\cf17 static_cast<}std::string{\cf17 >}( reporterSpec.substr(\par
5241                     separatorPos, nextSeparator - separatorPos ) ) );\par
5242 \par
5243                 {\cf19 if} ( nextSeparator == {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( -1 ) ) \{\par
5244                     {\cf19 break};\par
5245                 \}\par
5246                 separatorPos = nextSeparator + separatorSize;\par
5247             \}\par
5248 \par
5249             {\cf20 // Handle a separator at the end.}\par
5250             {\cf20 // This is not a valid spec, but we want to do validation in a}\par
5251             {\cf20 // centralized place}\par
5252             {\cf19 if} ( separatorPos == reporterSpec.size() ) \{\par
5253                 parts.emplace_back();\par
5254             \}\par
5255 \par
5256             {\cf19 return} parts;\par
5257         \}\par
5258 \par
5259         Optional<ColourMode> stringToColourMode( StringRef colourMode ) \{\par
5260             {\cf19 if} ( colourMode == {\cf22 "default"} ) \{\par
5261                 {\cf19 return} ColourMode::PlatformDefault;\par
5262             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "ansi"} ) \{\par
5263                 {\cf19 return} ColourMode::ANSI;\par
5264             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "win32"} ) \{\par
5265                 {\cf19 return} ColourMode::Win32;\par
5266             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "none"} ) \{\par
5267                 {\cf19 return} ColourMode::None;\par
5268             \} {\cf19 else} \{\par
5269                 {\cf19 return} \{\};\par
5270             \}\par
5271         \}\par
5272     \} {\cf20 // namespace Detail}\par
5273 \par
5274 \par
5275     {\cf18 bool} operator==( ReporterSpec {\cf17 const}& lhs, ReporterSpec {\cf17 const}& rhs ) \{\par
5276         {\cf19 return} lhs.m_name == rhs.m_name &&\par
5277                lhs.m_outputFileName == rhs.m_outputFileName &&\par
5278                lhs.m_colourMode == rhs.m_colourMode &&\par
5279                lhs.m_customOptions == rhs.m_customOptions;\par
5280     \}\par
5281 \par
5282     Optional<ReporterSpec> parseReporterSpec( StringRef reporterSpec ) \{\par
5283         {\cf17 auto} parts = Detail::splitReporterSpec( reporterSpec );\par
5284 \par
5285         assert( parts.size() > 0 && {\cf22 "Split should never return empty vector"} );\par
5286 \par
5287         std::map<std::string, std::string> kvPairs;\par
5288         Optional<std::string> outputFileName;\par
5289         Optional<ColourMode> colourMode;\par
5290 \par
5291         {\cf20 // First part is always reporter name, so we skip it}\par
5292         {\cf19 for} ( {\cf18 size_t} i = 1; i < parts.size(); ++i ) \{\par
5293             {\cf17 auto} kv = splitKVPair( parts[i] );\par
5294             {\cf17 auto} key = kv.key, value = kv.value;\par
5295 \par
5296             {\cf19 if} ( key.empty() || value.empty() ) \{ {\cf20 // NOLINT(bugprone-branch-clone)}\par
5297                 {\cf19 return} \{\};\par
5298             \} {\cf19 else} {\cf19 if} ( key[0] == {\cf23 'X'} ) \{\par
5299                 {\cf20 // This is a reporter-specific option, we don't check these}\par
5300                 {\cf20 // apart from basic sanity checks}\par
5301                 {\cf19 if} ( key.size() == 1 ) \{\par
5302                     {\cf19 return} \{\};\par
5303                 \}\par
5304 \par
5305                 {\cf17 auto} ret = kvPairs.emplace( std::string(kv.key), std::string(kv.value) );\par
5306                 {\cf19 if} ( !ret.second ) \{\par
5307                     {\cf20 // Duplicated key. We might want to handle this differently,}\par
5308                     {\cf20 // e.g. by overwriting the existing value?}\par
5309                     {\cf19 return} \{\};\par
5310                 \}\par
5311             \} {\cf19 else} {\cf19 if} ( key == {\cf22 "out"} ) \{\par
5312                 {\cf20 // Duplicated key}\par
5313                 {\cf19 if} ( outputFileName ) \{\par
5314                     {\cf19 return} \{\};\par
5315                 \}\par
5316                 outputFileName = {\cf17 static_cast<}std::string{\cf17 >}( value );\par
5317             \} {\cf19 else} {\cf19 if} ( key == {\cf22 "colour-mode"} ) \{\par
5318                 {\cf20 // Duplicated key}\par
5319                 {\cf19 if} ( colourMode ) \{\par
5320                     {\cf19 return} \{\};\par
5321                 \}\par
5322                 colourMode = Detail::stringToColourMode( value );\par
5323                 {\cf20 // Parsing failed}\par
5324                 {\cf19 if} ( !colourMode ) \{\par
5325                     {\cf19 return} \{\};\par
5326                 \}\par
5327             \} {\cf19 else} \{\par
5328                 {\cf20 // Unrecognized option}\par
5329                 {\cf19 return} \{\};\par
5330             \}\par
5331         \}\par
5332 \par
5333         {\cf19 return} ReporterSpec\{ CATCH_MOVE( parts[0] ),\par
5334                              CATCH_MOVE( outputFileName ),\par
5335                              CATCH_MOVE( colourMode ),\par
5336                              CATCH_MOVE( kvPairs ) \};\par
5337     \}\par
5338 \par
5339 ReporterSpec::ReporterSpec(\par
5340         std::string name,\par
5341         Optional<std::string> outputFileName,\par
5342         Optional<ColourMode> colourMode,\par
5343         std::map<std::string, std::string> customOptions ):\par
5344         m_name( CATCH_MOVE( name ) ),\par
5345         m_outputFileName( CATCH_MOVE( outputFileName ) ),\par
5346         m_colourMode( CATCH_MOVE( colourMode ) ),\par
5347         m_customOptions( CATCH_MOVE( customOptions ) ) \{\}\par
5348 \par
5349 \} {\cf20 // namespace Catch}\par
5350 \par
5351 \par
5352 \par
5353 {\cf17 namespace }Catch \{\par
5354 \par
5355     {\cf18 bool} isOk( ResultWas::OfType resultType ) \{\par
5356         {\cf19 return} ( resultType & ResultWas::FailureBit ) == 0;\par
5357     \}\par
5358     {\cf18 bool} isJustInfo( {\cf18 int} flags ) \{\par
5359         {\cf19 return} flags == ResultWas::Info;\par
5360     \}\par
5361 \par
5362     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{\par
5363         {\cf19 return} {\cf17 static_cast<}ResultDisposition::Flags{\cf17 >}( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( lhs ) | {\cf17 static_cast<}{\cf18 int}{\cf17 >}( rhs ) );\par
5364     \}\par
5365 \par
5366     {\cf18 bool} shouldContinueOnFailure( {\cf18 int} flags )    \{ {\cf19 return} ( flags & ResultDisposition::ContinueOnFailure ) != 0; \}\par
5367     {\cf18 bool} shouldSuppressFailure( {\cf18 int} flags )      \{ {\cf19 return} ( flags & ResultDisposition::SuppressFail ) != 0; \}\par
5368 \par
5369 \} {\cf20 // end namespace Catch}\par
5370 \par
5371 \par
5372 \par
5373 {\cf21 #include <cstdio>}\par
5374 {\cf21 #include <sstream>}\par
5375 {\cf21 #include <vector>}\par
5376 \par
5377 {\cf17 namespace }Catch \{\par
5378 \par
5379     {\cf20 // This class encapsulates the idea of a pool of ostringstreams that can be reused.}\par
5380     {\cf17 struct }StringStreams \{\par
5381         std::vector<Detail::unique_ptr<std::ostringstream>> m_streams;\par
5382         std::vector<std::size_t> m_unused;\par
5383         std::ostringstream m_referenceStream; {\cf20 // Used for copy state/ flags from}\par
5384 \par
5385         {\cf17 auto} add() -> std::size_t \{\par
5386             {\cf19 if}( m_unused.empty() ) \{\par
5387                 m_streams.push_back( Detail::make_unique<std::ostringstream>() );\par
5388                 {\cf19 return} m_streams.size()-1;\par
5389             \}\par
5390             {\cf19 else} \{\par
5391                 {\cf17 auto} index = m_unused.back();\par
5392                 m_unused.pop_back();\par
5393                 {\cf19 return} index;\par
5394             \}\par
5395         \}\par
5396 \par
5397         {\cf18 void} release( std::size_t index ) \{\par
5398             m_streams[index]->copyfmt( m_referenceStream ); {\cf20 // Restore initial flags and other state}\par
5399             m_unused.push_back(index);\par
5400         \}\par
5401     \};\par
5402 \par
5403     ReusableStringStream::ReusableStringStream()\par
5404     :   m_index( Singleton<StringStreams>::getMutable().add() ),\par
5405         m_oss( Singleton<StringStreams>::getMutable().m_streams[m_index].get() )\par
5406     \{\}\par
5407 \par
5408     ReusableStringStream::~ReusableStringStream() \{\par
5409         {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str({\cf22 ""});\par
5410         m_oss->clear();\par
5411         Singleton<StringStreams>::getMutable().release( m_index );\par
5412     \}\par
5413 \par
5414     std::string ReusableStringStream::str(){\cf17  const }\{\par
5415         {\cf19 return} {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str();\par
5416     \}\par
5417 \par
5418     {\cf18 void} ReusableStringStream::str( std::string {\cf17 const}& str ) \{\par
5419         {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str( str );\par
5420     \}\par
5421 \par
5422 \par
5423 \}\par
5424 \par
5425 \par
5426 \par
5427 \par
5428 {\cf21 #include <cassert>}\par
5429 {\cf21 #include <algorithm>}\par
5430 \par
5431 {\cf17 namespace }Catch \{\par
5432 \par
5433     {\cf17 namespace }Generators \{\par
5434         {\cf17 namespace }\{\par
5435             {\cf17 struct }GeneratorTracker final : TestCaseTracking::TrackerBase,\par
5436                                       IGeneratorTracker \{\par
5437                 GeneratorBasePtr m_generator;\par
5438 \par
5439                 GeneratorTracker(\par
5440                     TestCaseTracking::NameAndLocation&& nameAndLocation,\par
5441                     TrackerContext& ctx,\par
5442                     ITracker* parent ):\par
5443                     TrackerBase( CATCH_MOVE( nameAndLocation ), ctx, parent ) \{\}\par
5444 \par
5445                 {\cf17 static} GeneratorTracker*\par
5446                 acquire( TrackerContext& ctx,\par
5447                          TestCaseTracking::NameAndLocationRef {\cf17 const}&\par
5448                              nameAndLocation ) \{\par
5449                     GeneratorTracker* tracker;\par
5450 \par
5451                     ITracker& currentTracker = ctx.currentTracker();\par
5452                     {\cf20 // Under specific circumstances, the generator we want}\par
5453                     {\cf20 // to acquire is also the current tracker. If this is}\par
5454                     {\cf20 // the case, we have to avoid looking through current}\par
5455                     {\cf20 // tracker's children, and instead return the current}\par
5456                     {\cf20 // tracker.}\par
5457                     {\cf20 // A case where this check is important is e.g.}\par
5458                     {\cf20 //     for (int i = 0; i < 5; ++i) \{}\par
5459                     {\cf20 //         int n = GENERATE(1, 2);}\par
5460                     {\cf20 //     \}}\par
5461                     {\cf20 //}\par
5462                     {\cf20 // without it, the code above creates 5 nested generators.}\par
5463                     {\cf19 if} ( currentTracker.nameAndLocation() == nameAndLocation ) \{\par
5464                         {\cf17 auto} thisTracker = currentTracker.parent()->findChild(\par
5465                             nameAndLocation );\par
5466                         assert( thisTracker );\par
5467                         assert( thisTracker->isGeneratorTracker() );\par
5468                         tracker = {\cf17 static_cast<}GeneratorTracker*{\cf17 >}( thisTracker );\par
5469                     \} {\cf19 else} {\cf19 if} ( ITracker* childTracker =\par
5470                                     currentTracker.findChild(\par
5471                                         nameAndLocation ) ) \{\par
5472                         assert( childTracker );\par
5473                         assert( childTracker->isGeneratorTracker() );\par
5474                         tracker =\par
5475                             {\cf17 static_cast<}GeneratorTracker*{\cf17 >}( childTracker );\par
5476                     \} {\cf19 else} \{\par
5477                         {\cf19 return} {\cf17 nullptr};\par
5478                     \}\par
5479 \par
5480                     {\cf19 if} ( !tracker->isComplete() ) \{ tracker->open(); \}\par
5481 \par
5482                     {\cf19 return} tracker;\par
5483                 \}\par
5484 \par
5485                 {\cf20 // TrackerBase interface}\par
5486                 {\cf18 bool} isGeneratorTracker(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
5487                 {\cf17 auto} hasGenerator() const -> {\cf18 bool}{\cf17  override }\{\par
5488                     {\cf19 return} !!m_generator;\par
5489                 \}\par
5490                 {\cf18 void} close(){\cf17  override }\{\par
5491                     TrackerBase::close();\par
5492                     {\cf20 // If a generator has a child (it is followed by a section)}\par
5493                     {\cf20 // and none of its children have started, then we must wait}\par
5494                     {\cf20 // until later to start consuming its values.}\par
5495                     {\cf20 // This catches cases where `GENERATE` is placed between two}\par
5496                     {\cf20 // `SECTION`s.}\par
5497                     {\cf20 // **The check for m_children.empty cannot be removed**.}\par
5498                     {\cf20 // doing so would break `GENERATE` _not_ followed by}\par
5499                     {\cf20 // `SECTION`s.}\par
5500                     {\cf17 const} {\cf18 bool} should_wait_for_child = [&]() \{\par
5501                         {\cf20 // No children -> nobody to wait for}\par
5502                         {\cf19 if} ( m_children.empty() ) \{ {\cf19 return} {\cf17 false}; \}\par
5503                         {\cf20 // If at least one child started executing, don't wait}\par
5504                         {\cf19 if} ( std::find_if(\par
5505                                  m_children.begin(),\par
5506                                  m_children.end(),\par
5507                                  []( TestCaseTracking::ITrackerPtr {\cf17 const}&\par
5508                                          tracker ) \{\par
5509                                      return tracker->hasStarted();\par
5510                                  \} ) != m_children.end() ) \{\par
5511                             {\cf19 return} {\cf17 false};\par
5512                         \}\par
5513 \par
5514                         {\cf20 // No children have started. We need to check if they}\par
5515                         {\cf20 // _can_ start, and thus we should wait for them, or}\par
5516                         {\cf20 // they cannot start (due to filters), and we shouldn't}\par
5517                         {\cf20 // wait for them}\par
5518                         ITracker* parent = m_parent;\par
5519                         {\cf20 // This is safe: there is always at least one section}\par
5520                         {\cf20 // tracker in a test case tracking tree}\par
5521                         {\cf19 while} ( !parent->isSectionTracker() ) \{\par
5522                             parent = parent->parent();\par
5523                         \}\par
5524                         assert( parent &&\par
5525                                 {\cf22 "Missing root (test case) level section"} );\par
5526 \par
5527                         {\cf17 auto} {\cf17 const}& parentSection =\par
5528                             {\cf17 static_cast<}SectionTracker const&{\cf17 >}( *parent );\par
5529                         {\cf17 auto} {\cf17 const}& filters = parentSection.getFilters();\par
5530                         {\cf20 // No filters -> no restrictions on running sections}\par
5531                         {\cf19 if} ( filters.empty() ) \{ {\cf19 return} {\cf17 true}; \}\par
5532 \par
5533                         {\cf19 for} ( {\cf17 auto} {\cf17 const}& child : m_children ) \{\par
5534                             {\cf19 if} ( child->isSectionTracker() &&\par
5535                                  std::find( filters.begin(),\par
5536                                             filters.end(),\par
5537                                             {\cf17 static_cast<}SectionTracker const&{\cf17 >}(\par
5538                                                 *child )\par
5539                                                 .trimmedName() ) !=\par
5540                                      filters.end() ) \{\par
5541                                 {\cf19 return} {\cf17 true};\par
5542                             \}\par
5543                         \}\par
5544                         {\cf19 return} {\cf17 false};\par
5545                     \}();\par
5546 \par
5547                     {\cf20 // This check is a bit tricky, because m_generator->next()}\par
5548                     {\cf20 // has a side-effect, where it consumes generator's current}\par
5549                     {\cf20 // value, but we do not want to invoke the side-effect if}\par
5550                     {\cf20 // this generator is still waiting for any child to start.}\par
5551                     assert( m_generator && {\cf22 "Tracker without generator"} );\par
5552                     {\cf19 if} ( should_wait_for_child ||\par
5553                          ( m_runState == CompletedSuccessfully &&\par
5554                            m_generator->countedNext() ) ) \{\par
5555                         m_children.clear();\par
5556                         m_runState = Executing;\par
5557                     \}\par
5558                 \}\par
5559 \par
5560                 {\cf20 // IGeneratorTracker interface}\par
5561                 {\cf17 auto} getGenerator() const -> GeneratorBasePtr const&{\cf17  override }\{\par
5562                     {\cf19 return} m_generator;\par
5563                 \}\par
5564                 {\cf18 void} setGenerator( GeneratorBasePtr&& generator ){\cf17  override }\{\par
5565                     m_generator = CATCH_MOVE( generator );\par
5566                 \}\par
5567             \};\par
5568         \} {\cf20 // namespace}\par
5569     \}\par
5570 \par
5571     RunContext::RunContext(IConfig {\cf17 const}* _config, IEventListenerPtr&& reporter)\par
5572     :   m_runInfo(_config->name()),\par
5573         m_config(_config),\par
5574         m_reporter(CATCH_MOVE(reporter)),\par
5575         m_lastAssertionInfo\{ StringRef(), SourceLineInfo({\cf22 ""},0), StringRef(), ResultDisposition::Normal \},\par
5576         m_includeSuccessfulResults( m_config->includeSuccessfulResults() || m_reporter->getPreferences().shouldReportAllAssertions )\par
5577     \{\par
5578         getCurrentMutableContext().setResultCapture( {\cf17 this} );\par
5579         m_reporter->testRunStarting(m_runInfo);\par
5580     \}\par
5581 \par
5582     RunContext::~RunContext() \{\par
5583         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));\par
5584     \}\par
5585 \par
5586     Totals RunContext::runTest(TestCaseHandle {\cf17 const}& testCase) \{\par
5587         {\cf17 const} Totals prevTotals = m_totals;\par
5588 \par
5589         {\cf17 auto} {\cf17 const}& testInfo = testCase.getTestCaseInfo();\par
5590         m_reporter->testCaseStarting(testInfo);\par
5591         m_activeTestCase = &testCase;\par
5592 \par
5593 \par
5594         ITracker& rootTracker = m_trackerContext.startRun();\par
5595         assert(rootTracker.isSectionTracker());\par
5596         {\cf17 static_cast<}SectionTracker&{\cf17 >}(rootTracker).addInitialFilters(m_config->getSectionsToRun());\par
5597 \par
5598         {\cf20 // We intentionally only seed the internal RNG once per test case,}\par
5599         {\cf20 // before it is first invoked. The reason for that is a complex}\par
5600         {\cf20 // interplay of generator/section implementation details and the}\par
5601         {\cf20 // Random*Generator types.}\par
5602         {\cf20 //}\par
5603         {\cf20 // The issue boils down to us needing to seed the Random*Generators}\par
5604         {\cf20 // with different seed each, so that they return different sequences}\par
5605         {\cf20 // of random numbers. We do this by giving them a number from the}\par
5606         {\cf20 // shared RNG instance as their seed.}\par
5607         {\cf20 //}\par
5608         {\cf20 // However, this runs into an issue if the reseeding happens each}\par
5609         {\cf20 // time the test case is entered (as opposed to first time only),}\par
5610         {\cf20 // because multiple generators could get the same seed, e.g. in}\par
5611         {\cf20 // ```cpp}\par
5612         {\cf20 // TEST_CASE() \{}\par
5613         {\cf20 //     auto i = GENERATE(take(10, random(0, 100));}\par
5614         {\cf20 //     SECTION("A") \{}\par
5615         {\cf20 //         auto j = GENERATE(take(10, random(0, 100));}\par
5616         {\cf20 //     \}}\par
5617         {\cf20 //     SECTION("B") \{}\par
5618         {\cf20 //         auto k = GENERATE(take(10, random(0, 100));}\par
5619         {\cf20 //     \}}\par
5620         {\cf20 // \}}\par
5621         {\cf20 // ```}\par
5622         {\cf20 // `i` and `j` would properly return values from different sequences,}\par
5623         {\cf20 // but `i` and `k` would return the same sequence, because their seed}\par
5624         {\cf20 // would be the same.}\par
5625         {\cf20 // (The reason their seeds would be the same is that the generator}\par
5626         {\cf20 //  for k would be initialized when the test case is entered the second}\par
5627         {\cf20 //  time, after the shared RNG instance was reset to the same value}\par
5628         {\cf20 //  it had when the generator for i was initialized.)}\par
5629         seedRng( *m_config );\par
5630 \par
5631         uint64_t testRuns = 0;\par
5632         std::string redirectedCout;\par
5633         std::string redirectedCerr;\par
5634         {\cf19 do} \{\par
5635             m_trackerContext.startCycle();\par
5636             m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocationRef(testInfo.name, testInfo.lineInfo));\par
5637 \par
5638             m_reporter->testCasePartialStarting(testInfo, testRuns);\par
5639 \par
5640             {\cf17 const} {\cf17 auto} beforeRunTotals = m_totals;\par
5641             std::string oneRunCout, oneRunCerr;\par
5642             runCurrentTest(oneRunCout, oneRunCerr);\par
5643             redirectedCout += oneRunCout;\par
5644             redirectedCerr += oneRunCerr;\par
5645 \par
5646             {\cf17 const} {\cf17 auto} singleRunTotals = m_totals.delta(beforeRunTotals);\par
5647             {\cf17 auto} statsForOneRun = TestCaseStats(testInfo, singleRunTotals, CATCH_MOVE(oneRunCout), CATCH_MOVE(oneRunCerr), aborting());\par
5648 \par
5649             m_reporter->testCasePartialEnded(statsForOneRun, testRuns);\par
5650             ++testRuns;\par
5651         \} {\cf19 while} (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());\par
5652 \par
5653         Totals deltaTotals = m_totals.delta(prevTotals);\par
5654         {\cf19 if} (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) \{\par
5655             deltaTotals.assertions.failed++;\par
5656             deltaTotals.testCases.passed--;\par
5657             deltaTotals.testCases.failed++;\par
5658         \}\par
5659         m_totals.testCases += deltaTotals.testCases;\par
5660         m_reporter->testCaseEnded(TestCaseStats(testInfo,\par
5661                                   deltaTotals,\par
5662                                   CATCH_MOVE(redirectedCout),\par
5663                                   CATCH_MOVE(redirectedCerr),\par
5664                                   aborting()));\par
5665 \par
5666         m_activeTestCase = {\cf17 nullptr};\par
5667         m_testCaseTracker = {\cf17 nullptr};\par
5668 \par
5669         {\cf19 return} deltaTotals;\par
5670     \}\par
5671 \par
5672 \par
5673     {\cf18 void} RunContext::assertionEnded(AssertionResult&& result) \{\par
5674         {\cf19 if} (result.getResultType() == ResultWas::Ok) \{\par
5675             m_totals.assertions.passed++;\par
5676             m_lastAssertionPassed = {\cf17 true};\par
5677         \} {\cf19 else} {\cf19 if} (result.getResultType() == ResultWas::ExplicitSkip) \{\par
5678             m_totals.assertions.skipped++;\par
5679             m_lastAssertionPassed = {\cf17 true};\par
5680         \} {\cf19 else} {\cf19 if} (!result.succeeded()) \{\par
5681             m_lastAssertionPassed = {\cf17 false};\par
5682             {\cf19 if} (result.isOk()) \{\par
5683             \}\par
5684             {\cf19 else} {\cf19 if}( m_activeTestCase->getTestCaseInfo().okToFail() )\par
5685                 m_totals.assertions.failedButOk++;\par
5686             {\cf19 else}\par
5687                 m_totals.assertions.failed++;\par
5688         \}\par
5689         {\cf19 else} \{\par
5690             m_lastAssertionPassed = {\cf17 true};\par
5691         \}\par
5692 \par
5693         m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals));\par
5694 \par
5695         {\cf19 if} ( result.getResultType() != ResultWas::Warning ) \{\par
5696             m_messageScopes.clear();\par
5697         \}\par
5698 \par
5699         {\cf20 // Reset working state. assertion info will be reset after}\par
5700         {\cf20 // populateReaction is run if it is needed}\par
5701         m_lastResult = CATCH_MOVE( result );\par
5702     \}\par
5703     {\cf18 void} RunContext::resetAssertionInfo() \{\par
5704         m_lastAssertionInfo.macroName = StringRef();\par
5705         m_lastAssertionInfo.capturedExpression = {\cf22 "\{Unknown expression after the reported line\}"}_sr;\par
5706         m_lastAssertionInfo.resultDisposition = ResultDisposition::Normal;\par
5707     \}\par
5708 \par
5709     {\cf18 void} RunContext::notifyAssertionStarted( AssertionInfo {\cf17 const}& info ) \{\par
5710         m_reporter->assertionStarting( info );\par
5711     \}\par
5712 \par
5713     {\cf18 bool} RunContext::sectionStarted( StringRef sectionName,\par
5714                                      SourceLineInfo {\cf17 const}& sectionLineInfo,\par
5715                                      Counts& assertions ) \{\par
5716         ITracker& sectionTracker =\par
5717             SectionTracker::acquire( m_trackerContext,\par
5718                                      TestCaseTracking::NameAndLocationRef(\par
5719                                          sectionName, sectionLineInfo ) );\par
5720 \par
5721         {\cf19 if} (!sectionTracker.isOpen())\par
5722             {\cf19 return} {\cf17 false};\par
5723         m_activeSections.push_back(&sectionTracker);\par
5724 \par
5725         SectionInfo sectionInfo( sectionLineInfo, {\cf17 static_cast<}std::string{\cf17 >}(sectionName) );\par
5726         m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;\par
5727 \par
5728         m_reporter->sectionStarting(sectionInfo);\par
5729 \par
5730         assertions = m_totals.assertions;\par
5731 \par
5732         {\cf19 return} {\cf17 true};\par
5733     \}\par
5734     IGeneratorTracker*\par
5735     RunContext::acquireGeneratorTracker( StringRef generatorName,\par
5736                                          SourceLineInfo {\cf17 const}& lineInfo ) \{\par
5737         {\cf17 using namespace }Generators;\par
5738         GeneratorTracker* tracker = GeneratorTracker::acquire(\par
5739             m_trackerContext,\par
5740             TestCaseTracking::NameAndLocationRef(\par
5741                  generatorName, lineInfo ) );\par
5742         m_lastAssertionInfo.lineInfo = lineInfo;\par
5743         {\cf19 return} tracker;\par
5744     \}\par
5745 \par
5746     IGeneratorTracker* RunContext::createGeneratorTracker(\par
5747         StringRef generatorName,\par
5748         SourceLineInfo lineInfo,\par
5749         Generators::GeneratorBasePtr&& generator ) \{\par
5750 \par
5751         {\cf17 auto} nameAndLoc = TestCaseTracking::NameAndLocation( {\cf17 static_cast<}std::string{\cf17 >}( generatorName ), lineInfo );\par
5752         {\cf17 auto}& currentTracker = m_trackerContext.currentTracker();\par
5753         assert(\par
5754             currentTracker.nameAndLocation() != nameAndLoc &&\par
5755             {\cf22 "Trying to create tracker for a genreator that already has one"} );\par
5756 \par
5757         {\cf17 auto} newTracker = Catch::Detail::make_unique<Generators::GeneratorTracker>(\par
5758             CATCH_MOVE(nameAndLoc), m_trackerContext, &currentTracker );\par
5759         {\cf17 auto} ret = newTracker.get();\par
5760         currentTracker.addChild( CATCH_MOVE( newTracker ) );\par
5761 \par
5762         ret->setGenerator( CATCH_MOVE( generator ) );\par
5763         ret->open();\par
5764         {\cf19 return} ret;\par
5765     \}\par
5766 \par
5767     {\cf18 bool} RunContext::testForMissingAssertions(Counts& assertions) \{\par
5768         {\cf19 if} (assertions.total() != 0)\par
5769             {\cf19 return} {\cf17 false};\par
5770         {\cf19 if} (!m_config->warnAboutMissingAssertions())\par
5771             {\cf19 return} {\cf17 false};\par
5772         {\cf19 if} (m_trackerContext.currentTracker().hasChildren())\par
5773             {\cf19 return} {\cf17 false};\par
5774         m_totals.assertions.failed++;\par
5775         assertions.failed++;\par
5776         {\cf19 return} {\cf17 true};\par
5777     \}\par
5778 \par
5779     {\cf18 void} RunContext::sectionEnded(SectionEndInfo&& endInfo) \{\par
5780         Counts assertions = m_totals.assertions - endInfo.prevAssertions;\par
5781         {\cf18 bool} missingAssertions = testForMissingAssertions(assertions);\par
5782 \par
5783         {\cf19 if} (!m_activeSections.empty()) \{\par
5784             m_activeSections.back()->close();\par
5785             m_activeSections.pop_back();\par
5786         \}\par
5787 \par
5788         m_reporter->sectionEnded(SectionStats(CATCH_MOVE(endInfo.sectionInfo), assertions, endInfo.durationInSeconds, missingAssertions));\par
5789         m_messages.clear();\par
5790         m_messageScopes.clear();\par
5791     \}\par
5792 \par
5793     {\cf18 void} RunContext::sectionEndedEarly(SectionEndInfo&& endInfo) \{\par
5794         {\cf19 if} ( m_unfinishedSections.empty() ) \{\par
5795             m_activeSections.back()->fail();\par
5796         \} {\cf19 else} \{\par
5797             m_activeSections.back()->close();\par
5798         \}\par
5799         m_activeSections.pop_back();\par
5800 \par
5801         m_unfinishedSections.push_back(CATCH_MOVE(endInfo));\par
5802     \}\par
5803 \par
5804     {\cf18 void} RunContext::benchmarkPreparing( StringRef name ) \{\par
5805         m_reporter->benchmarkPreparing(name);\par
5806     \}\par
5807     {\cf18 void} RunContext::benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) \{\par
5808         m_reporter->benchmarkStarting( info );\par
5809     \}\par
5810     {\cf18 void} RunContext::benchmarkEnded( BenchmarkStats<> {\cf17 const}& stats ) \{\par
5811         m_reporter->benchmarkEnded( stats );\par
5812     \}\par
5813     {\cf18 void} RunContext::benchmarkFailed( StringRef error ) \{\par
5814         m_reporter->benchmarkFailed( error );\par
5815     \}\par
5816 \par
5817     {\cf18 void} RunContext::pushScopedMessage(MessageInfo {\cf17 const} & message) \{\par
5818         m_messages.push_back(message);\par
5819     \}\par
5820 \par
5821     {\cf18 void} RunContext::popScopedMessage(MessageInfo {\cf17 const} & message) \{\par
5822         m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());\par
5823     \}\par
5824 \par
5825     {\cf18 void} RunContext::emplaceUnscopedMessage( MessageBuilder&& builder ) \{\par
5826         m_messageScopes.emplace_back( CATCH_MOVE(builder) );\par
5827     \}\par
5828 \par
5829     std::string RunContext::getCurrentTestName(){\cf17  const }\{\par
5830         {\cf19 return} m_activeTestCase\par
5831             ? m_activeTestCase->getTestCaseInfo().name\par
5832             : std::string();\par
5833     \}\par
5834 \par
5835     {\cf17 const} AssertionResult * RunContext::getLastResult(){\cf17  const }\{\par
5836         {\cf19 return} &(*m_lastResult);\par
5837     \}\par
5838 \par
5839     {\cf18 void} RunContext::exceptionEarlyReported() \{\par
5840         m_shouldReportUnexpected = {\cf17 false};\par
5841     \}\par
5842 \par
5843     {\cf18 void} RunContext::handleFatalErrorCondition( StringRef message ) \{\par
5844         {\cf20 // First notify reporter that bad things happened}\par
5845         m_reporter->fatalErrorEncountered(message);\par
5846 \par
5847         {\cf20 // Don't rebuild the result -- the stringification itself can cause more fatal errors}\par
5848         {\cf20 // Instead, fake a result data.}\par
5849         AssertionResultData tempResult( ResultWas::FatalErrorCondition, \{ {\cf17 false} \} );\par
5850         tempResult.message = {\cf17 static_cast<}std::string{\cf17 >}(message);\par
5851         AssertionResult result(m_lastAssertionInfo, CATCH_MOVE(tempResult));\par
5852 \par
5853         assertionEnded(CATCH_MOVE(result) );\par
5854         resetAssertionInfo();\par
5855 \par
5856         {\cf20 // Best effort cleanup for sections that have not been destructed yet}\par
5857         {\cf20 // Since this is a fatal error, we have not had and won't have the opportunity to destruct them properly}\par
5858         {\cf19 while} (!m_activeSections.empty()) \{\par
5859             {\cf17 auto} nl = m_activeSections.back()->nameAndLocation();\par
5860             SectionEndInfo endInfo\{ SectionInfo(CATCH_MOVE(nl.location), CATCH_MOVE(nl.name)), \{\}, 0.0 \};\par
5861             sectionEndedEarly(CATCH_MOVE(endInfo));\par
5862         \}\par
5863         handleUnfinishedSections();\par
5864 \par
5865         {\cf20 // Recreate section for test case (as we will lose the one that was in scope)}\par
5866         {\cf17 auto} {\cf17 const}& testCaseInfo = m_activeTestCase->getTestCaseInfo();\par
5867         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);\par
5868 \par
5869         Counts assertions;\par
5870         assertions.failed = 1;\par
5871         SectionStats testCaseSectionStats(CATCH_MOVE(testCaseSection), assertions, 0, {\cf17 false});\par
5872         m_reporter->sectionEnded(testCaseSectionStats);\par
5873 \par
5874         {\cf17 auto} {\cf17 const}& testInfo = m_activeTestCase->getTestCaseInfo();\par
5875 \par
5876         Totals deltaTotals;\par
5877         deltaTotals.testCases.failed = 1;\par
5878         deltaTotals.assertions.failed = 1;\par
5879         m_reporter->testCaseEnded(TestCaseStats(testInfo,\par
5880                                   deltaTotals,\par
5881                                   std::string(),\par
5882                                   std::string(),\par
5883                                   {\cf17 false}));\par
5884         m_totals.testCases.failed++;\par
5885         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, {\cf17 false}));\par
5886     \}\par
5887 \par
5888     {\cf18 bool} RunContext::lastAssertionPassed() \{\par
5889          {\cf19 return} m_lastAssertionPassed;\par
5890     \}\par
5891 \par
5892     {\cf18 void} RunContext::assertionPassed() \{\par
5893         m_lastAssertionPassed = {\cf17 true};\par
5894         ++m_totals.assertions.passed;\par
5895         resetAssertionInfo();\par
5896         m_messageScopes.clear();\par
5897     \}\par
5898 \par
5899     {\cf18 bool} RunContext::aborting(){\cf17  const }\{\par
5900         {\cf19 return} m_totals.assertions.failed >= {\cf17 static_cast<}std::size_t{\cf17 >}(m_config->abortAfter());\par
5901     \}\par
5902 \par
5903     {\cf18 void} RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) \{\par
5904         {\cf17 auto} {\cf17 const}& testCaseInfo = m_activeTestCase->getTestCaseInfo();\par
5905         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);\par
5906         m_reporter->sectionStarting(testCaseSection);\par
5907         Counts prevAssertions = m_totals.assertions;\par
5908         {\cf18 double} duration = 0;\par
5909         m_shouldReportUnexpected = {\cf17 true};\par
5910         m_lastAssertionInfo = \{ {\cf22 "TEST_CASE"}_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal \};\par
5911 \par
5912         Timer timer;\par
5913         CATCH_TRY \{\par
5914             {\cf19 if} (m_reporter->getPreferences().shouldRedirectStdOut) \{\par
5915 {\cf21 #if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)}\par
5916                 RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);\par
5917 \par
5918                 timer.start();\par
5919                 invokeActiveTestCase();\par
5920 {\cf21 #else}\par
5921                 OutputRedirect r(redirectedCout, redirectedCerr);\par
5922                 timer.start();\par
5923                 invokeActiveTestCase();\par
5924 {\cf21 #endif}\par
5925             \} {\cf19 else} \{\par
5926                 timer.start();\par
5927                 invokeActiveTestCase();\par
5928             \}\par
5929             duration = timer.getElapsedSeconds();\par
5930         \} CATCH_CATCH_ANON (TestFailureException&) \{\par
5931             {\cf20 // This just means the test was aborted due to failure}\par
5932         \} CATCH_CATCH_ANON (TestSkipException&) \{\par
5933             {\cf20 // This just means the test was explicitly skipped}\par
5934         \} CATCH_CATCH_ALL \{\par
5935             {\cf20 // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions}\par
5936             {\cf20 // are reported without translation at the point of origin.}\par
5937             {\cf19 if}( m_shouldReportUnexpected ) \{\par
5938                 AssertionReaction dummyReaction;\par
5939                 handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );\par
5940             \}\par
5941         \}\par
5942         Counts assertions = m_totals.assertions - prevAssertions;\par
5943         {\cf18 bool} missingAssertions = testForMissingAssertions(assertions);\par
5944 \par
5945         m_testCaseTracker->close();\par
5946         handleUnfinishedSections();\par
5947         m_messages.clear();\par
5948         m_messageScopes.clear();\par
5949 \par
5950         SectionStats testCaseSectionStats(CATCH_MOVE(testCaseSection), assertions, duration, missingAssertions);\par
5951         m_reporter->sectionEnded(testCaseSectionStats);\par
5952     \}\par
5953 \par
5954     {\cf18 void} RunContext::invokeActiveTestCase() \{\par
5955         {\cf20 // We need to engage a handler for signals/structured exceptions}\par
5956         {\cf20 // before running the tests themselves, or the binary can crash}\par
5957         {\cf20 // without failed test being reported.}\par
5958         FatalConditionHandlerGuard _(&m_fatalConditionhandler);\par
5959         {\cf20 // We keep having issue where some compilers warn about an unused}\par
5960         {\cf20 // variable, even though the type has non-trivial constructor and}\par
5961         {\cf20 // destructor. This is annoying and ugly, but it makes them stfu.}\par
5962         (void)_;\par
5963 \par
5964         m_activeTestCase->invoke();\par
5965     \}\par
5966 \par
5967     {\cf18 void} RunContext::handleUnfinishedSections() \{\par
5968         {\cf20 // If sections ended prematurely due to an exception we stored their}\par
5969         {\cf20 // infos here so we can tear them down outside the unwind process.}\par
5970         {\cf19 for} ({\cf17 auto} it = m_unfinishedSections.rbegin(),\par
5971              itEnd = m_unfinishedSections.rend();\par
5972              it != itEnd;\par
5973              ++it)\par
5974             sectionEnded(CATCH_MOVE(*it));\par
5975         m_unfinishedSections.clear();\par
5976     \}\par
5977 \par
5978     {\cf18 void} RunContext::handleExpr(\par
5979         AssertionInfo {\cf17 const}& info,\par
5980         ITransientExpression {\cf17 const}& expr,\par
5981         AssertionReaction& reaction\par
5982     ) \{\par
5983         {\cf18 bool} negated = isFalseTest( info.resultDisposition );\par
5984         {\cf18 bool} result = expr.getResult() != negated;\par
5985 \par
5986         {\cf19 if}( result ) \{\par
5987             {\cf19 if} (!m_includeSuccessfulResults) \{\par
5988                 assertionPassed();\par
5989             \}\par
5990             {\cf19 else} \{\par
5991                 reportExpr(info, ResultWas::Ok, &expr, negated);\par
5992             \}\par
5993         \}\par
5994         {\cf19 else} \{\par
5995             reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\par
5996             populateReaction( reaction );\par
5997         \}\par
5998         resetAssertionInfo();\par
5999     \}\par
6000     {\cf18 void} RunContext::reportExpr(\par
6001             AssertionInfo {\cf17 const} &info,\par
6002             ResultWas::OfType resultType,\par
6003             ITransientExpression {\cf17 const} *expr,\par
6004             {\cf18 bool} negated ) \{\par
6005 \par
6006         m_lastAssertionInfo = info;\par
6007         AssertionResultData data( resultType, LazyExpression( negated ) );\par
6008 \par
6009         AssertionResult assertionResult\{ info, CATCH_MOVE( data ) \};\par
6010         assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;\par
6011 \par
6012         assertionEnded( CATCH_MOVE(assertionResult) );\par
6013     \}\par
6014 \par
6015     {\cf18 void} RunContext::handleMessage(\par
6016             AssertionInfo {\cf17 const}& info,\par
6017             ResultWas::OfType resultType,\par
6018             StringRef message,\par
6019             AssertionReaction& reaction\par
6020     ) \{\par
6021         m_lastAssertionInfo = info;\par
6022 \par
6023         AssertionResultData data( resultType, LazyExpression( {\cf17 false} ) );\par
6024         data.message = {\cf17 static_cast<}std::string{\cf17 >}(message);\par
6025         AssertionResult assertionResult\{ m_lastAssertionInfo,\par
6026                                          CATCH_MOVE( data ) \};\par
6027 \par
6028         {\cf17 const} {\cf17 auto} isOk = assertionResult.isOk();\par
6029         assertionEnded( CATCH_MOVE(assertionResult) );\par
6030         {\cf19 if} ( !isOk ) \{\par
6031             populateReaction( reaction );\par
6032         \} {\cf19 else} {\cf19 if} ( resultType == ResultWas::ExplicitSkip ) \{\par
6033             {\cf20 // TODO: Need to handle this explicitly, as ExplicitSkip is}\par
6034             {\cf20 // considered "OK"}\par
6035             reaction.shouldSkip = {\cf17 true};\par
6036         \}\par
6037         resetAssertionInfo();\par
6038     \}\par
6039     {\cf18 void} RunContext::handleUnexpectedExceptionNotThrown(\par
6040             AssertionInfo {\cf17 const}& info,\par
6041             AssertionReaction& reaction\par
6042     ) \{\par
6043         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);\par
6044     \}\par
6045 \par
6046     {\cf18 void} RunContext::handleUnexpectedInflightException(\par
6047             AssertionInfo {\cf17 const}& info,\par
6048             std::string&& message,\par
6049             AssertionReaction& reaction\par
6050     ) \{\par
6051         m_lastAssertionInfo = info;\par
6052 \par
6053         AssertionResultData data( ResultWas::ThrewException, LazyExpression( {\cf17 false} ) );\par
6054         data.message = CATCH_MOVE(message);\par
6055         AssertionResult assertionResult\{ info, CATCH_MOVE(data) \};\par
6056         assertionEnded( CATCH_MOVE(assertionResult) );\par
6057         populateReaction( reaction );\par
6058         resetAssertionInfo();\par
6059     \}\par
6060 \par
6061     {\cf18 void} RunContext::populateReaction( AssertionReaction& reaction ) \{\par
6062         reaction.shouldDebugBreak = m_config->shouldDebugBreak();\par
6063         reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);\par
6064     \}\par
6065 \par
6066     {\cf18 void} RunContext::handleIncomplete(\par
6067             AssertionInfo {\cf17 const}& info\par
6068     ) \{\par
6069         {\cf17 using namespace }std::string_literals;\par
6070         m_lastAssertionInfo = info;\par
6071 \par
6072         AssertionResultData data( ResultWas::ThrewException, LazyExpression( {\cf17 false} ) );\par
6073         data.message = {\cf22 "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE"}s;\par
6074         AssertionResult assertionResult\{ info, CATCH_MOVE( data ) \};\par
6075         assertionEnded( CATCH_MOVE(assertionResult) );\par
6076         resetAssertionInfo();\par
6077     \}\par
6078     {\cf18 void} RunContext::handleNonExpr(\par
6079             AssertionInfo {\cf17 const} &info,\par
6080             ResultWas::OfType resultType,\par
6081             AssertionReaction &reaction\par
6082     ) \{\par
6083         m_lastAssertionInfo = info;\par
6084 \par
6085         AssertionResultData data( resultType, LazyExpression( {\cf17 false} ) );\par
6086         AssertionResult assertionResult\{ info, CATCH_MOVE( data ) \};\par
6087 \par
6088         {\cf17 const} {\cf17 auto} isOk = assertionResult.isOk();\par
6089         assertionEnded( CATCH_MOVE(assertionResult) );\par
6090         {\cf19 if} ( !isOk ) \{ populateReaction( reaction ); \}\par
6091         resetAssertionInfo();\par
6092     \}\par
6093 \par
6094 \par
6095     IResultCapture& getResultCapture() \{\par
6096         {\cf19 if} ({\cf17 auto}* capture = getCurrentContext().getResultCapture())\par
6097             {\cf19 return} *capture;\par
6098         {\cf19 else}\par
6099             CATCH_INTERNAL_ERROR({\cf22 "No result capture instance"});\par
6100     \}\par
6101 \par
6102     {\cf18 void} seedRng(IConfig {\cf17 const}& config) \{\par
6103         sharedRng().seed(config.rngSeed());\par
6104     \}\par
6105 \par
6106     {\cf18 unsigned} {\cf18 int} rngSeed() \{\par
6107         {\cf19 return} getCurrentContext().getConfig()->rngSeed();\par
6108     \}\par
6109 \par
6110 \}\par
6111 \par
6112 \par
6113 \par
6114 {\cf17 namespace }Catch \{\par
6115 \par
6116     Section::Section( SectionInfo&& info ):\par
6117         m_info( CATCH_MOVE( info ) ),\par
6118         m_sectionIncluded(\par
6119             getResultCapture().sectionStarted( m_info.name, m_info.lineInfo, m_assertions ) ) \{\par
6120         {\cf20 // Non-"included" sections will not use the timing information}\par
6121         {\cf20 // anyway, so don't bother with the potential syscall.}\par
6122         {\cf19 if} (m_sectionIncluded) \{\par
6123             m_timer.start();\par
6124         \}\par
6125     \}\par
6126 \par
6127     Section::Section( SourceLineInfo {\cf17 const}& _lineInfo,\par
6128                       StringRef _name,\par
6129                       {\cf17 const} {\cf18 char}* {\cf17 const} ):\par
6130         m_info( \{ {\cf22 "invalid"}, {\cf17 static_cast<}std::size_t{\cf17 >}( -1 ) \}, std::string\{\} ),\par
6131         m_sectionIncluded(\par
6132             getResultCapture().sectionStarted( _name, _lineInfo, m_assertions ) ) \{\par
6133         {\cf20 // We delay initialization the SectionInfo member until we know}\par
6134         {\cf20 // this section needs it, so we avoid allocating std::string for name.}\par
6135         {\cf20 // We also delay timer start to avoid the potential syscall unless we}\par
6136         {\cf20 // will actually use the result.}\par
6137         {\cf19 if} ( m_sectionIncluded ) \{\par
6138             m_info.name = {\cf17 static_cast<}std::string{\cf17 >}( _name );\par
6139             m_info.lineInfo = _lineInfo;\par
6140             m_timer.start();\par
6141         \}\par
6142     \}\par
6143 \par
6144     Section::~Section() \{\par
6145         {\cf19 if}( m_sectionIncluded ) \{\par
6146             SectionEndInfo endInfo\{ CATCH_MOVE(m_info), m_assertions, m_timer.getElapsedSeconds() \};\par
6147             {\cf19 if} ( uncaught_exceptions() ) \{\par
6148                 getResultCapture().sectionEndedEarly( CATCH_MOVE(endInfo) );\par
6149             \} {\cf19 else} \{\par
6150                 getResultCapture().sectionEnded( CATCH_MOVE( endInfo ) );\par
6151             \}\par
6152         \}\par
6153     \}\par
6154 \par
6155     {\cf20 // This indicates whether the section should be executed or not}\par
6156     Section::operator bool(){\cf17  const }\{\par
6157         {\cf19 return} m_sectionIncluded;\par
6158     \}\par
6159 \par
6160 \par
6161 \} {\cf20 // end namespace Catch}\par
6162 \par
6163 \par
6164 \par
6165 {\cf21 #include <vector>}\par
6166 \par
6167 {\cf17 namespace }Catch \{\par
6168 \par
6169     {\cf17 namespace }\{\par
6170         {\cf17 static} {\cf17 auto} getSingletons() -> std::vector<ISingleton*>*& \{\par
6171             {\cf17 static} std::vector<ISingleton*>* g_singletons = {\cf17 nullptr};\par
6172             {\cf19 if}( !g_singletons )\par
6173                 g_singletons = {\cf17 new} std::vector<ISingleton*>();\par
6174             {\cf19 return} g_singletons;\par
6175         \}\par
6176     \}\par
6177 \par
6178     ISingleton::~ISingleton() = {\cf19 default};\par
6179 \par
6180     {\cf18 void} addSingleton(ISingleton* singleton ) \{\par
6181         getSingletons()->push_back( singleton );\par
6182     \}\par
6183     {\cf18 void} cleanupSingletons() \{\par
6184         {\cf17 auto}& singletons = getSingletons();\par
6185         {\cf19 for}( {\cf17 auto} singleton : *singletons )\par
6186             {\cf17 delete} singleton;\par
6187         {\cf17 delete} singletons;\par
6188         singletons = {\cf17 nullptr};\par
6189     \}\par
6190 \par
6191 \} {\cf20 // namespace Catch}\par
6192 \par
6193 \par
6194 \par
6195 {\cf21 #include <cstring>}\par
6196 {\cf21 #include <ostream>}\par
6197 \par
6198 {\cf17 namespace }Catch \{\par
6199 \par
6200     {\cf18 bool} SourceLineInfo::operator == ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} \{\par
6201         {\cf19 return} line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);\par
6202     \}\par
6203     {\cf18 bool} SourceLineInfo::operator < ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} \{\par
6204         {\cf20 // We can assume that the same file will usually have the same pointer.}\par
6205         {\cf20 // Thus, if the pointers are the same, there is no point in calling the strcmp}\par
6206         {\cf19 return} line < other.line || ( line == other.line && file != other.file && (std::strcmp(file, other.file) < 0));\par
6207     \}\par
6208 \par
6209     std::ostream& operator << ( std::ostream& os, SourceLineInfo {\cf17 const}& info ) \{\par
6210 {\cf21 #ifndef __GNUG__}\par
6211         os << info.file << {\cf23 '('} << info.line << {\cf23 ')'};\par
6212 {\cf21 #else}\par
6213         os << info.file << {\cf23 ':'} << info.line;\par
6214 {\cf21 #endif}\par
6215         {\cf19 return} os;\par
6216     \}\par
6217 \par
6218 \} {\cf20 // end namespace Catch}\par
6219 \par
6220 \par
6221 \par
6222 \par
6223 {\cf17 namespace }Catch \{\par
6224 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
6225     {\cf18 void} StartupExceptionRegistry::add( std::exception_ptr {\cf17 const}& exception ) {\cf17 noexcept} \{\par
6226         CATCH_TRY \{\par
6227             m_exceptions.push_back(exception);\par
6228         \} CATCH_CATCH_ALL \{\par
6229             {\cf20 // If we run out of memory during start-up there's really not a lot more we can do about it}\par
6230             std::terminate();\par
6231         \}\par
6232     \}\par
6233 \par
6234     std::vector<std::exception_ptr> {\cf17 const}& StartupExceptionRegistry::getExceptions() const noexcept \{\par
6235         {\cf19 return} m_exceptions;\par
6236     \}\par
6237 {\cf21 #endif}\par
6238 \par
6239 \} {\cf20 // end namespace Catch}\par
6240 \par
6241 \par
6242 \par
6243 \par
6244 \par
6245 {\cf21 #include <iostream>}\par
6246 \par
6247 {\cf17 namespace }Catch \{\par
6248 \par
6249 {\cf20 // If you #define this you must implement these functions}\par
6250 {\cf21 #if !defined( CATCH_CONFIG_NOSTDOUT )}\par
6251     std::ostream& cout() \{ {\cf19 return} std::cout; \}\par
6252     std::ostream& cerr() \{ {\cf19 return} std::cerr; \}\par
6253     std::ostream& clog() \{ {\cf19 return} std::clog; \}\par
6254 {\cf21 #endif}\par
6255 \par
6256 \} {\cf20 // namespace Catch}\par
6257 \par
6258 \par
6259 \par
6260 {\cf21 #include <ostream>}\par
6261 {\cf21 #include <cstring>}\par
6262 {\cf21 #include <cctype>}\par
6263 {\cf21 #include <vector>}\par
6264 \par
6265 {\cf17 namespace }Catch \{\par
6266 \par
6267     {\cf18 bool} startsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& prefix ) \{\par
6268         {\cf19 return} s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\par
6269     \}\par
6270     {\cf18 bool} startsWith( StringRef s, {\cf18 char} prefix ) \{\par
6271         {\cf19 return} !s.empty() && s[0] == prefix;\par
6272     \}\par
6273     {\cf18 bool} endsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& suffix ) \{\par
6274         {\cf19 return} s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\par
6275     \}\par
6276     {\cf18 bool} endsWith( std::string {\cf17 const}& s, {\cf18 char} suffix ) \{\par
6277         {\cf19 return} !s.empty() && s[s.size()-1] == suffix;\par
6278     \}\par
6279     {\cf18 bool} contains( std::string {\cf17 const}& s, std::string {\cf17 const}& infix ) \{\par
6280         {\cf19 return} s.find( infix ) != std::string::npos;\par
6281     \}\par
6282     {\cf18 void} toLowerInPlace( std::string& s ) \{\par
6283         {\cf19 for} ( {\cf18 char}& c : s ) \{\par
6284             c = toLower( c );\par
6285         \}\par
6286     \}\par
6287     std::string toLower( std::string {\cf17 const}& s ) \{\par
6288         std::string lc = s;\par
6289         toLowerInPlace( lc );\par
6290         {\cf19 return} lc;\par
6291     \}\par
6292     {\cf18 char} toLower({\cf18 char} c) \{\par
6293         {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(std::tolower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c)));\par
6294     \}\par
6295 \par
6296     std::string trim( std::string {\cf17 const}& str ) \{\par
6297         {\cf17 static} {\cf18 char} {\cf17 const}* whitespaceChars = {\cf22 "\\n\\r\\t "};\par
6298         std::string::size_type start = str.find_first_not_of( whitespaceChars );\par
6299         std::string::size_type end = str.find_last_not_of( whitespaceChars );\par
6300 \par
6301         {\cf19 return} start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\par
6302     \}\par
6303 \par
6304     StringRef trim(StringRef ref) \{\par
6305         {\cf17 const} {\cf17 auto} is_ws = []({\cf18 char} c) \{\par
6306             {\cf19 return} c == {\cf23 ' '} || c == {\cf23 '\\t'} || c == {\cf23 '\\n'} || c == {\cf23 '\\r'};\par
6307         \};\par
6308         {\cf18 size_t} real_begin = 0;\par
6309         {\cf19 while} (real_begin < ref.size() && is_ws(ref[real_begin])) \{ ++real_begin; \}\par
6310         {\cf18 size_t} real_end = ref.size();\par
6311         {\cf19 while} (real_end > real_begin && is_ws(ref[real_end - 1])) \{ --real_end; \}\par
6312 \par
6313         {\cf19 return} ref.substr(real_begin, real_end - real_begin);\par
6314     \}\par
6315 \par
6316     {\cf18 bool} replaceInPlace( std::string& str, std::string {\cf17 const}& replaceThis, std::string {\cf17 const}& withThis ) \{\par
6317         std::size_t i = str.find( replaceThis );\par
6318         {\cf19 if} (i == std::string::npos) \{\par
6319             {\cf19 return} {\cf17 false};\par
6320         \}\par
6321         std::size_t copyBegin = 0;\par
6322         std::string origStr = CATCH_MOVE(str);\par
6323         str.clear();\par
6324         {\cf20 // There is at least one replacement, so reserve with the best guess}\par
6325         {\cf20 // we can make without actually counting the number of occurences.}\par
6326         str.reserve(origStr.size() - replaceThis.size() + withThis.size());\par
6327         {\cf19 do} \{\par
6328             str.append(origStr, copyBegin, i-copyBegin );\par
6329             str += withThis;\par
6330             copyBegin = i + replaceThis.size();\par
6331             {\cf19 if}( copyBegin < origStr.size() )\par
6332                 i = origStr.find( replaceThis, copyBegin );\par
6333             {\cf19 else}\par
6334                 i = std::string::npos;\par
6335         \} {\cf19 while}( i != std::string::npos );\par
6336         {\cf19 if} ( copyBegin < origStr.size() ) \{\par
6337             str.append(origStr, copyBegin, origStr.size() );\par
6338         \}\par
6339         {\cf19 return} {\cf17 true};\par
6340     \}\par
6341 \par
6342     std::vector<StringRef> splitStringRef( StringRef str, {\cf18 char} delimiter ) \{\par
6343         std::vector<StringRef> subStrings;\par
6344         std::size_t start = 0;\par
6345         {\cf19 for}(std::size_t pos = 0; pos < str.size(); ++pos ) \{\par
6346             {\cf19 if}( str[pos] == delimiter ) \{\par
6347                 {\cf19 if}( pos - start > 1 )\par
6348                     subStrings.push_back( str.substr( start, pos-start ) );\par
6349                 start = pos+1;\par
6350             \}\par
6351         \}\par
6352         {\cf19 if}( start < str.size() )\par
6353             subStrings.push_back( str.substr( start, str.size()-start ) );\par
6354         {\cf19 return} subStrings;\par
6355     \}\par
6356 \par
6357     std::ostream& operator << ( std::ostream& os, pluralise {\cf17 const}& pluraliser ) \{\par
6358         os << pluraliser.m_count << {\cf23 ' '} << pluraliser.m_label;\par
6359         {\cf19 if}( pluraliser.m_count != 1 )\par
6360             os << {\cf23 's'};\par
6361         {\cf19 return} os;\par
6362     \}\par
6363 \par
6364 \}\par
6365 \par
6366 \par
6367 \par
6368 {\cf21 #include <algorithm>}\par
6369 {\cf21 #include <ostream>}\par
6370 {\cf21 #include <cstring>}\par
6371 {\cf21 #include <cstdint>}\par
6372 \par
6373 {\cf17 namespace }Catch \{\par
6374     StringRef::StringRef( {\cf18 char} {\cf17 const}* rawChars ) noexcept\par
6375     : StringRef( rawChars, std::strlen(rawChars) )\par
6376     \{\}\par
6377 \par
6378 \par
6379     {\cf18 bool} StringRef::operator<(StringRef rhs) {\cf17 const} {\cf17 noexcept} \{\par
6380         {\cf19 if} (m_size < rhs.m_size) \{\par
6381             {\cf19 return} strncmp(m_start, rhs.m_start, m_size) <= 0;\par
6382         \}\par
6383         {\cf19 return} strncmp(m_start, rhs.m_start, rhs.m_size) < 0;\par
6384     \}\par
6385 \par
6386     {\cf18 int} StringRef::compare( StringRef rhs ){\cf17  const }\{\par
6387         {\cf17 auto} cmpResult =\par
6388             strncmp( m_start, rhs.m_start, std::min( m_size, rhs.m_size ) );\par
6389 \par
6390         {\cf20 // This means that strncmp found a difference before the strings}\par
6391         {\cf20 // ended, and we can return it directly}\par
6392         {\cf19 if} ( cmpResult != 0 ) \{\par
6393             {\cf19 return} cmpResult;\par
6394         \}\par
6395 \par
6396         {\cf20 // If strings are equal up to length, then their comparison results on}\par
6397         {\cf20 // their size}\par
6398         {\cf19 if} ( m_size < rhs.m_size ) \{\par
6399             {\cf19 return} -1;\par
6400         \} {\cf19 else} {\cf19 if} ( m_size > rhs.m_size ) \{\par
6401             {\cf19 return} 1;\par
6402         \} {\cf19 else} \{\par
6403             {\cf19 return} 0;\par
6404         \}\par
6405     \}\par
6406 \par
6407     {\cf17 auto} operator << ( std::ostream& os, StringRef str ) -> std::ostream& \{\par
6408         {\cf19 return} os.write(str.data(), {\cf17 static_cast<}std::streamsize{\cf17 >}(str.size()));\par
6409     \}\par
6410 \par
6411     std::string operator+(StringRef lhs, StringRef rhs) \{\par
6412         std::string ret;\par
6413         ret.reserve(lhs.size() + rhs.size());\par
6414         ret += lhs;\par
6415         ret += rhs;\par
6416         {\cf19 return} ret;\par
6417     \}\par
6418 \par
6419     {\cf17 auto} operator+=( std::string& lhs, StringRef rhs ) -> std::string& \{\par
6420         lhs.append(rhs.data(), rhs.size());\par
6421         {\cf19 return} lhs;\par
6422     \}\par
6423 \par
6424 \} {\cf20 // namespace Catch}\par
6425 \par
6426 \par
6427 \par
6428 {\cf17 namespace }Catch \{\par
6429 \par
6430     TagAliasRegistry::~TagAliasRegistry() = {\cf19 default};\par
6431 \par
6432     TagAlias {\cf17 const}* TagAliasRegistry::find( std::string {\cf17 const}& alias ){\cf17  const }\{\par
6433         {\cf17 auto} it = m_registry.find( alias );\par
6434         {\cf19 if}( it != m_registry.end() )\par
6435             {\cf19 return} &(it->second);\par
6436         {\cf19 else}\par
6437             {\cf19 return} {\cf17 nullptr};\par
6438     \}\par
6439 \par
6440     std::string TagAliasRegistry::expandAliases( std::string {\cf17 const}& unexpandedTestSpec ){\cf17  const }\{\par
6441         std::string expandedTestSpec = unexpandedTestSpec;\par
6442         {\cf19 for}( {\cf17 auto} {\cf17 const}& registryKvp : m_registry ) \{\par
6443             std::size_t pos = expandedTestSpec.find( registryKvp.first );\par
6444             {\cf19 if}( pos != std::string::npos ) \{\par
6445                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +\par
6446                                     registryKvp.second.tag +\par
6447                                     expandedTestSpec.substr( pos + registryKvp.first.size() );\par
6448             \}\par
6449         \}\par
6450         {\cf19 return} expandedTestSpec;\par
6451     \}\par
6452 \par
6453     {\cf18 void} TagAliasRegistry::add( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ) \{\par
6454         CATCH_ENFORCE( startsWith(alias, {\cf22 "[@"}) && endsWith(alias, {\cf23 ']'}),\par
6455                       {\cf22 "error: tag alias, '"} << alias << {\cf22 "' is not of the form [@alias name].\\n"} << lineInfo );\par
6456 \par
6457         CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,\par
6458                       {\cf22 "error: tag alias, '"} << alias << {\cf22 "' already registered.\\n"}\par
6459                       << {\cf22 "\\tFirst seen at: "} << find(alias)->lineInfo << {\cf22 "\\n"}\par
6460                       << {\cf22 "\\tRedefined at: "} << lineInfo );\par
6461     \}\par
6462 \par
6463     ITagAliasRegistry::~ITagAliasRegistry() = {\cf19 default};\par
6464 \par
6465     ITagAliasRegistry {\cf17 const}& ITagAliasRegistry::get() \{\par
6466         {\cf19 return} getRegistryHub().getTagAliasRegistry();\par
6467     \}\par
6468 \par
6469 \} {\cf20 // end namespace Catch}\par
6470 \par
6471 \par
6472 \par
6473 \par
6474 {\cf17 namespace }Catch \{\par
6475     TestCaseInfoHasher::TestCaseInfoHasher( hash_t seed ): m_seed( seed ) \{\}\par
6476 \par
6477     uint32_t TestCaseInfoHasher::operator()( TestCaseInfo {\cf17 const}& t ){\cf17  const }\{\par
6478         {\cf20 // FNV-1a hash algorithm that is designed for uniqueness:}\par
6479         {\cf17 const} hash_t prime = 1099511628211u;\par
6480         hash_t hash = 14695981039346656037u;\par
6481         {\cf19 for} ( {\cf17 const} {\cf18 char} c : t.name ) \{\par
6482             hash ^= c;\par
6483             hash *= prime;\par
6484         \}\par
6485         {\cf19 for} ( {\cf17 const} {\cf18 char} c : t.className ) \{\par
6486             hash ^= c;\par
6487             hash *= prime;\par
6488         \}\par
6489         {\cf19 for} ( {\cf17 const} Tag& tag : t.tags ) \{\par
6490             {\cf19 for} ( {\cf17 const} {\cf18 char} c : tag.original ) \{\par
6491                 hash ^= c;\par
6492                 hash *= prime;\par
6493             \}\par
6494         \}\par
6495         hash ^= m_seed;\par
6496         hash *= prime;\par
6497         {\cf17 const} uint32_t low\{ {\cf17 static_cast<}uint32_t{\cf17 >}( hash ) \};\par
6498         {\cf17 const} uint32_t high\{ {\cf17 static_cast<}uint32_t{\cf17 >}( hash >> 32 ) \};\par
6499         {\cf19 return} low * high;\par
6500     \}\par
6501 \} {\cf20 // namespace Catch}\par
6502 \par
6503 \par
6504 \par
6505 \par
6506 {\cf21 #include <algorithm>}\par
6507 {\cf21 #include <set>}\par
6508 \par
6509 {\cf17 namespace }Catch \{\par
6510 \par
6511     {\cf17 namespace }\{\par
6512         {\cf17 static} {\cf18 void} enforceNoDuplicateTestCases(\par
6513             std::vector<TestCaseHandle> {\cf17 const}& tests ) \{\par
6514             {\cf17 auto} testInfoCmp = []( TestCaseInfo {\cf17 const}* lhs,\par
6515                                    TestCaseInfo {\cf17 const}* rhs ) \{\par
6516                 {\cf19 return} *lhs < *rhs;\par
6517             \};\par
6518             std::set<TestCaseInfo {\cf17 const}*, {\cf17 decltype}( testInfoCmp )&> seenTests(\par
6519                 testInfoCmp );\par
6520             {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : tests ) \{\par
6521                 {\cf17 const} {\cf17 auto} infoPtr = &test.getTestCaseInfo();\par
6522                 {\cf17 const} {\cf17 auto} prev = seenTests.insert( infoPtr );\par
6523                 CATCH_ENFORCE( prev.second,\par
6524                                {\cf22 "error: test case \\""}\par
6525                                    << infoPtr->name << {\cf22 "\\", with tags \\""}\par
6526                                    << infoPtr->tagsAsString()\par
6527                                    << {\cf22 "\\" already defined.\\n"}\par
6528                                    << {\cf22 "\\tFirst seen at "}\par
6529                                    << ( *prev.first )->lineInfo << {\cf22 "\\n"}\par
6530                                    << {\cf22 "\\tRedefined at "} << infoPtr->lineInfo );\par
6531             \}\par
6532         \}\par
6533 \par
6534         {\cf17 static} {\cf18 bool} matchTest( TestCaseHandle {\cf17 const}& testCase,\par
6535                                TestSpec {\cf17 const}& testSpec,\par
6536                                IConfig {\cf17 const}& config ) \{\par
6537             {\cf19 return} testSpec.matches( testCase.getTestCaseInfo() ) &&\par
6538                    isThrowSafe( testCase, config );\par
6539         \}\par
6540 \par
6541     \} {\cf20 // end unnamed namespace}\par
6542 \par
6543     std::vector<TestCaseHandle> sortTests( IConfig {\cf17 const}& config, std::vector<TestCaseHandle> {\cf17 const}& unsortedTestCases ) \{\par
6544         {\cf19 switch} (config.runOrder()) \{\par
6545         {\cf19 case} TestRunOrder::Declared:\par
6546             {\cf19 return} unsortedTestCases;\par
6547 \par
6548         {\cf19 case} TestRunOrder::LexicographicallySorted: \{\par
6549             std::vector<TestCaseHandle> sorted = unsortedTestCases;\par
6550             std::sort(\par
6551                 sorted.begin(),\par
6552                 sorted.end(),\par
6553                 []( TestCaseHandle {\cf17 const}& lhs, TestCaseHandle {\cf17 const}& rhs ) \{\par
6554                     return lhs.getTestCaseInfo() < rhs.getTestCaseInfo();\par
6555                 \}\par
6556             );\par
6557             {\cf19 return} sorted;\par
6558         \}\par
6559         {\cf19 case} TestRunOrder::Randomized: \{\par
6560             {\cf17 using }TestWithHash = std::pair<TestCaseInfoHasher::hash_t, TestCaseHandle>;\par
6561 \par
6562             TestCaseInfoHasher h\{ config.rngSeed() \};\par
6563             std::vector<TestWithHash> indexed_tests;\par
6564             indexed_tests.reserve(unsortedTestCases.size());\par
6565 \par
6566             {\cf19 for} ({\cf17 auto} {\cf17 const}& handle : unsortedTestCases) \{\par
6567                 indexed_tests.emplace_back(h(handle.getTestCaseInfo()), handle);\par
6568             \}\par
6569 \par
6570             std::sort( indexed_tests.begin(),\par
6571                        indexed_tests.end(),\par
6572                        []( TestWithHash {\cf17 const}& lhs, TestWithHash {\cf17 const}& rhs ) \{\par
6573                            if ( lhs.first == rhs.first ) \{\par
6574                                return lhs.second.getTestCaseInfo() <\par
6575                                       rhs.second.getTestCaseInfo();\par
6576                            \}\par
6577                            {\cf19 return} lhs.first < rhs.first;\par
6578                        \} );\par
6579 \par
6580             std::vector<TestCaseHandle> randomized;\par
6581             randomized.reserve(indexed_tests.size());\par
6582 \par
6583             {\cf19 for} ({\cf17 auto} {\cf17 const}& indexed : indexed_tests) \{\par
6584                 randomized.push_back(indexed.second);\par
6585             \}\par
6586 \par
6587             {\cf19 return} randomized;\par
6588         \}\par
6589         \}\par
6590 \par
6591         CATCH_INTERNAL_ERROR({\cf22 "Unknown test order value!"});\par
6592     \}\par
6593 \par
6594     {\cf18 bool} isThrowSafe( TestCaseHandle {\cf17 const}& testCase, IConfig {\cf17 const}& config ) \{\par
6595         {\cf19 return} !testCase.getTestCaseInfo().throws() || config.allowThrows();\par
6596     \}\par
6597 \par
6598     std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> {\cf17 const}& testCases, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config ) \{\par
6599         std::vector<TestCaseHandle> filtered;\par
6600         filtered.reserve( testCases.size() );\par
6601         {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : testCases) \{\par
6602             {\cf19 if} ((!testSpec.hasFilters() && !testCase.getTestCaseInfo().isHidden()) ||\par
6603                 (testSpec.hasFilters() && matchTest(testCase, testSpec, config))) \{\par
6604                 filtered.push_back(testCase);\par
6605             \}\par
6606         \}\par
6607         {\cf19 return} createShard(filtered, config.shardCount(), config.shardIndex());\par
6608     \}\par
6609     std::vector<TestCaseHandle> {\cf17 const}& getAllTestCasesSorted( IConfig {\cf17 const}& config ) \{\par
6610         {\cf19 return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );\par
6611     \}\par
6612 \par
6613     TestRegistry::~TestRegistry() = {\cf19 default};\par
6614 \par
6615     {\cf18 void} TestRegistry::registerTest(Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker) \{\par
6616         m_handles.emplace_back(testInfo.get(), testInvoker.get());\par
6617         m_viewed_test_infos.push_back(testInfo.get());\par
6618         m_owned_test_infos.push_back(CATCH_MOVE(testInfo));\par
6619         m_invokers.push_back(CATCH_MOVE(testInvoker));\par
6620     \}\par
6621 \par
6622     std::vector<TestCaseInfo*> {\cf17 const}& TestRegistry::getAllInfos(){\cf17  const }\{\par
6623         {\cf19 return} m_viewed_test_infos;\par
6624     \}\par
6625 \par
6626     std::vector<TestCaseHandle> {\cf17 const}& TestRegistry::getAllTests(){\cf17  const }\{\par
6627         {\cf19 return} m_handles;\par
6628     \}\par
6629     std::vector<TestCaseHandle> {\cf17 const}& TestRegistry::getAllTestsSorted( IConfig {\cf17 const}& config ){\cf17  const }\{\par
6630         {\cf19 if}( m_sortedFunctions.empty() )\par
6631             enforceNoDuplicateTestCases( m_handles );\par
6632 \par
6633         {\cf19 if}(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) \{\par
6634             m_sortedFunctions = sortTests( config, m_handles );\par
6635             m_currentSortOrder = config.runOrder();\par
6636         \}\par
6637         {\cf19 return} m_sortedFunctions;\par
6638     \}\par
6639 \par
6640 \} {\cf20 // end namespace Catch}\par
6641 \par
6642 \par
6643 \par
6644 \par
6645 {\cf21 #include <algorithm>}\par
6646 {\cf21 #include <cassert>}\par
6647 \par
6648 {\cf21 #if defined(__clang__)}\par
6649 {\cf21 #    pragma clang diagnostic push}\par
6650 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
6651 {\cf21 #endif}\par
6652 \par
6653 {\cf17 namespace }Catch \{\par
6654 {\cf17 namespace }TestCaseTracking \{\par
6655 \par
6656     NameAndLocation::NameAndLocation( std::string&& _name, SourceLineInfo {\cf17 const}& _location )\par
6657     :   name( CATCH_MOVE(_name) ),\par
6658         location( _location )\par
6659     \{\}\par
6660 \par
6661 \par
6662     ITracker::~ITracker() = {\cf19 default};\par
6663 \par
6664     {\cf18 void} ITracker::markAsNeedingAnotherRun() \{\par
6665         m_runState = NeedsAnotherRun;\par
6666     \}\par
6667 \par
6668     {\cf18 void} ITracker::addChild( ITrackerPtr&& child ) \{\par
6669         m_children.push_back( CATCH_MOVE(child) );\par
6670     \}\par
6671 \par
6672     ITracker* ITracker::findChild( NameAndLocationRef {\cf17 const}& nameAndLocation ) \{\par
6673         {\cf17 auto} it = std::find_if(\par
6674             m_children.begin(),\par
6675             m_children.end(),\par
6676             [&nameAndLocation]( ITrackerPtr {\cf17 const}& tracker ) \{\par
6677                 auto const& tnameAndLoc = tracker->nameAndLocation();\par
6678                 if ( tnameAndLoc.location.line !=\par
6679                      nameAndLocation.location.line ) \{\par
6680                     return false;\par
6681                 \}\par
6682                 {\cf19 return} tnameAndLoc == nameAndLocation;\par
6683             \} );\par
6684         {\cf19 return} ( it != m_children.end() ) ? it->get() : {\cf17 nullptr};\par
6685     \}\par
6686 \par
6687     {\cf18 bool} ITracker::isSectionTracker(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
6688     {\cf18 bool} ITracker::isGeneratorTracker(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
6689 \par
6690     {\cf18 bool} ITracker::isOpen(){\cf17  const }\{\par
6691         {\cf19 return} m_runState != NotStarted && !isComplete();\par
6692     \}\par
6693 \par
6694     {\cf18 bool} ITracker::hasStarted(){\cf17  const }\{ {\cf19 return} m_runState != NotStarted; \}\par
6695 \par
6696     {\cf18 void} ITracker::openChild() \{\par
6697         {\cf19 if} (m_runState != ExecutingChildren) \{\par
6698             m_runState = ExecutingChildren;\par
6699             {\cf19 if} (m_parent) \{\par
6700                 m_parent->openChild();\par
6701             \}\par
6702         \}\par
6703     \}\par
6704 \par
6705     ITracker& TrackerContext::startRun() \{\par
6706         {\cf17 using namespace }std::string_literals;\par
6707         m_rootTracker = Catch::Detail::make_unique<SectionTracker>(\par
6708             NameAndLocation( {\cf22 "\{root\}"}s, CATCH_INTERNAL_LINEINFO ),\par
6709             *{\cf17 this},\par
6710             {\cf17 nullptr} );\par
6711         m_currentTracker = {\cf17 nullptr};\par
6712         m_runState = Executing;\par
6713         {\cf19 return} *m_rootTracker;\par
6714     \}\par
6715 \par
6716     {\cf18 void} TrackerContext::completeCycle() \{\par
6717         m_runState = CompletedCycle;\par
6718     \}\par
6719 \par
6720     {\cf18 bool} TrackerContext::completedCycle(){\cf17  const }\{\par
6721         {\cf19 return} m_runState == CompletedCycle;\par
6722     \}\par
6723     {\cf18 void} TrackerContext::setCurrentTracker( ITracker* tracker ) \{\par
6724         m_currentTracker = tracker;\par
6725     \}\par
6726 \par
6727 \par
6728     TrackerBase::TrackerBase( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent ):\par
6729         ITracker(CATCH_MOVE(nameAndLocation), parent),\par
6730         m_ctx( ctx )\par
6731     \{\}\par
6732 \par
6733     {\cf18 bool} TrackerBase::isComplete(){\cf17  const }\{\par
6734         {\cf19 return} m_runState == CompletedSuccessfully || m_runState == Failed;\par
6735     \}\par
6736 \par
6737     {\cf18 void} TrackerBase::open() \{\par
6738         m_runState = Executing;\par
6739         moveToThis();\par
6740         {\cf19 if}( m_parent )\par
6741             m_parent->openChild();\par
6742     \}\par
6743 \par
6744     {\cf18 void} TrackerBase::close() \{\par
6745 \par
6746         {\cf20 // Close any still open children (e.g. generators)}\par
6747         {\cf19 while}( &m_ctx.currentTracker() != {\cf17 this} )\par
6748             m_ctx.currentTracker().close();\par
6749 \par
6750         {\cf19 switch}( m_runState ) \{\par
6751             {\cf19 case} NeedsAnotherRun:\par
6752                 {\cf19 break};\par
6753 \par
6754             {\cf19 case} Executing:\par
6755                 m_runState = CompletedSuccessfully;\par
6756                 {\cf19 break};\par
6757             {\cf19 case} ExecutingChildren:\par
6758                 {\cf19 if}( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr {\cf17 const}& t)\{ return t->isComplete(); \}) )\par
6759                     m_runState = CompletedSuccessfully;\par
6760                 {\cf19 break};\par
6761 \par
6762             {\cf19 case} NotStarted:\par
6763             {\cf19 case} CompletedSuccessfully:\par
6764             {\cf19 case} Failed:\par
6765                 CATCH_INTERNAL_ERROR( {\cf22 "Illogical state: "} << m_runState );\par
6766 \par
6767             {\cf19 default}:\par
6768                 CATCH_INTERNAL_ERROR( {\cf22 "Unknown state: "} << m_runState );\par
6769         \}\par
6770         moveToParent();\par
6771         m_ctx.completeCycle();\par
6772     \}\par
6773     {\cf18 void} TrackerBase::fail() \{\par
6774         m_runState = Failed;\par
6775         {\cf19 if}( m_parent )\par
6776             m_parent->markAsNeedingAnotherRun();\par
6777         moveToParent();\par
6778         m_ctx.completeCycle();\par
6779     \}\par
6780 \par
6781     {\cf18 void} TrackerBase::moveToParent() \{\par
6782         assert( m_parent );\par
6783         m_ctx.setCurrentTracker( m_parent );\par
6784     \}\par
6785     {\cf18 void} TrackerBase::moveToThis() \{\par
6786         m_ctx.setCurrentTracker( {\cf17 this} );\par
6787     \}\par
6788 \par
6789     SectionTracker::SectionTracker( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent )\par
6790     :   TrackerBase( CATCH_MOVE(nameAndLocation), ctx, parent ),\par
6791         m_trimmed_name(trim(StringRef(ITracker::nameAndLocation().name)))\par
6792     \{\par
6793         {\cf19 if}( parent ) \{\par
6794             {\cf19 while} ( !parent->isSectionTracker() ) \{\par
6795                 parent = parent->parent();\par
6796             \}\par
6797 \par
6798             SectionTracker& parentSection = {\cf17 static_cast<}SectionTracker&{\cf17 >}( *parent );\par
6799             addNextFilters( parentSection.m_filters );\par
6800         \}\par
6801     \}\par
6802 \par
6803     {\cf18 bool} SectionTracker::isComplete(){\cf17  const }\{\par
6804         {\cf18 bool} complete = {\cf17 true};\par
6805 \par
6806         {\cf19 if} (m_filters.empty()\par
6807             || m_filters[0].empty()\par
6808             || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) \{\par
6809             complete = TrackerBase::isComplete();\par
6810         \}\par
6811         {\cf19 return} complete;\par
6812     \}\par
6813 \par
6814     {\cf18 bool} SectionTracker::isSectionTracker(){\cf17  const }\{ {\cf19 return} {\cf17 true}; \}\par
6815 \par
6816     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocationRef {\cf17 const}& nameAndLocation ) \{\par
6817         SectionTracker* tracker;\par
6818 \par
6819         ITracker& currentTracker = ctx.currentTracker();\par
6820         {\cf19 if} ( ITracker* childTracker =\par
6821                  currentTracker.findChild( nameAndLocation ) ) \{\par
6822             assert( childTracker );\par
6823             assert( childTracker->isSectionTracker() );\par
6824             tracker = {\cf17 static_cast<}SectionTracker*{\cf17 >}( childTracker );\par
6825         \} {\cf19 else} \{\par
6826             {\cf17 auto} newTracker = Catch::Detail::make_unique<SectionTracker>(\par
6827                 NameAndLocation\{ {\cf17 static_cast<}std::string{\cf17 >}(nameAndLocation.name),\par
6828                                  nameAndLocation.location \},\par
6829                 ctx,\par
6830                 &currentTracker );\par
6831             tracker = newTracker.get();\par
6832             currentTracker.addChild( CATCH_MOVE( newTracker ) );\par
6833         \}\par
6834 \par
6835         {\cf19 if} ( !ctx.completedCycle() ) \{\par
6836             tracker->tryOpen();\par
6837         \}\par
6838 \par
6839         {\cf19 return} *tracker;\par
6840     \}\par
6841 \par
6842     {\cf18 void} SectionTracker::tryOpen() \{\par
6843         {\cf19 if}( !isComplete() )\par
6844             open();\par
6845     \}\par
6846 \par
6847     {\cf18 void} SectionTracker::addInitialFilters( std::vector<std::string> {\cf17 const}& filters ) \{\par
6848         {\cf19 if}( !filters.empty() ) \{\par
6849             m_filters.reserve( m_filters.size() + filters.size() + 2 );\par
6850             m_filters.emplace_back(StringRef\{\}); {\cf20 // Root - should never be consulted}\par
6851             m_filters.emplace_back(StringRef\{\}); {\cf20 // Test Case - not a section filter}\par
6852             m_filters.insert( m_filters.end(), filters.begin(), filters.end() );\par
6853         \}\par
6854     \}\par
6855     {\cf18 void} SectionTracker::addNextFilters( std::vector<StringRef> {\cf17 const}& filters ) \{\par
6856         {\cf19 if}( filters.size() > 1 )\par
6857             m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );\par
6858     \}\par
6859 \par
6860     StringRef SectionTracker::trimmedName(){\cf17  const }\{\par
6861         {\cf19 return} m_trimmed_name;\par
6862     \}\par
6863 \par
6864 \} {\cf20 // namespace TestCaseTracking}\par
6865 \par
6866 \} {\cf20 // namespace Catch}\par
6867 \par
6868 {\cf21 #if defined(__clang__)}\par
6869 {\cf21 #    pragma clang diagnostic pop}\par
6870 {\cf21 #endif}\par
6871 \par
6872 \par
6873 \par
6874 \par
6875 {\cf17 namespace }Catch \{\par
6876 \par
6877     {\cf18 void} throw_test_failure_exception() \{\par
6878 {\cf21 #if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )}\par
6879         {\cf19 throw} TestFailureException\{\};\par
6880 {\cf21 #else}\par
6881         CATCH_ERROR( {\cf22 "Test failure requires aborting test!"} );\par
6882 {\cf21 #endif}\par
6883     \}\par
6884 \par
6885     {\cf18 void} throw_test_skip_exception() \{\par
6886 {\cf21 #if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )}\par
6887         {\cf19 throw} Catch::TestSkipException();\par
6888 {\cf21 #else}\par
6889         CATCH_ERROR( {\cf22 "Explicitly skipping tests during runtime requires exceptions"} );\par
6890 {\cf21 #endif}\par
6891     \}\par
6892 \par
6893 \} {\cf20 // namespace Catch}\par
6894 \par
6895 \par
6896 \par
6897 {\cf21 #include <algorithm>}\par
6898 {\cf21 #include <iterator>}\par
6899 \par
6900 {\cf17 namespace }Catch \{\par
6901     ITestInvoker::~ITestInvoker() = {\cf19 default};\par
6902 \par
6903     {\cf17 namespace }\{\par
6904         {\cf17 static} StringRef extractClassName( StringRef classOrMethodName ) \{\par
6905             {\cf19 if} ( !startsWith( classOrMethodName, {\cf23 '&'} ) ) \{\par
6906                 {\cf19 return} classOrMethodName;\par
6907             \}\par
6908 \par
6909             {\cf20 // Remove the leading '&' to avoid having to special case it later}\par
6910             {\cf17 const} {\cf17 auto} methodName =\par
6911                 classOrMethodName.substr( 1, classOrMethodName.size() );\par
6912 \par
6913             {\cf17 auto} reverseStart = std::make_reverse_iterator( methodName.end() );\par
6914             {\cf17 auto} reverseEnd = std::make_reverse_iterator( methodName.begin() );\par
6915 \par
6916             {\cf20 // We make a simplifying assumption that ":" is only present}\par
6917             {\cf20 // in the input as part of "::" from C++ typenames (this is}\par
6918             {\cf20 // relatively safe assumption because the input is generated}\par
6919             {\cf20 // as stringification of type through preprocessor).}\par
6920             {\cf17 auto} lastColons = std::find( reverseStart, reverseEnd, {\cf23 ':'} ) + 1;\par
6921             {\cf17 auto} secondLastColons =\par
6922                 std::find( lastColons + 1, reverseEnd, {\cf23 ':'} );\par
6923 \par
6924             {\cf17 auto} {\cf17 const} startIdx = reverseEnd - secondLastColons;\par
6925             {\cf17 auto} {\cf17 const} classNameSize = secondLastColons - lastColons - 1;\par
6926 \par
6927             {\cf19 return} methodName.substr(\par
6928                 {\cf17 static_cast<}std::size_t{\cf17 >}( startIdx ),\par
6929                 {\cf17 static_cast<}std::size_t{\cf17 >}( classNameSize ) );\par
6930         \}\par
6931 \par
6932         {\cf17 class }TestInvokerAsFunction final : {\cf17 public} ITestInvoker \{\par
6933             {\cf17 using }TestType = void ( * )();\par
6934             TestType m_testAsFunction;\par
6935 \par
6936         {\cf17 public}:\par
6937             TestInvokerAsFunction( TestType testAsFunction ) {\cf17 noexcept}:\par
6938                 m_testAsFunction( testAsFunction ) \{\}\par
6939 \par
6940             {\cf18 void} invoke(){\cf17  const override }\{ m_testAsFunction(); \}\par
6941         \};\par
6942 \par
6943     \} {\cf20 // namespace}\par
6944 \par
6945     Detail::unique_ptr<ITestInvoker> makeTestInvoker( {\cf18 void}(*testAsFunction)() ) \{\par
6946         {\cf19 return} Detail::make_unique<TestInvokerAsFunction>( testAsFunction );\par
6947     \}\par
6948 \par
6949     AutoReg::AutoReg( Detail::unique_ptr<ITestInvoker> invoker, SourceLineInfo {\cf17 const}& lineInfo, StringRef classOrMethod, NameAndTags {\cf17 const}& nameAndTags ) {\cf17 noexcept} \{\par
6950         CATCH_TRY \{\par
6951             getMutableRegistryHub()\par
6952                     .registerTest(\par
6953                         makeTestCaseInfo(\par
6954                             extractClassName( classOrMethod ),\par
6955                             nameAndTags,\par
6956                             lineInfo),\par
6957                         CATCH_MOVE(invoker)\par
6958                     );\par
6959         \} CATCH_CATCH_ALL \{\par
6960             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
6961             getMutableRegistryHub().registerStartupException();\par
6962         \}\par
6963     \}\par
6964 \}\par
6965 \par
6966 \par
6967 \par
6968 \par
6969 \par
6970 {\cf17 namespace }Catch \{\par
6971 \par
6972     TestSpecParser::TestSpecParser( ITagAliasRegistry {\cf17 const}& tagAliases ) : m_tagAliases( &tagAliases ) \{\}\par
6973 \par
6974     TestSpecParser& TestSpecParser::parse( std::string {\cf17 const}& arg ) \{\par
6975         m_mode = None;\par
6976         m_exclusion = {\cf17 false};\par
6977         m_arg = m_tagAliases->expandAliases( arg );\par
6978         m_escapeChars.clear();\par
6979         m_substring.reserve(m_arg.size());\par
6980         m_patternName.reserve(m_arg.size());\par
6981         m_realPatternPos = 0;\par
6982 \par
6983         {\cf19 for}( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\par
6984           {\cf20 //if visitChar fails}\par
6985            {\cf19 if}( !visitChar( m_arg[m_pos] ) )\{\par
6986                m_testSpec.m_invalidSpecs.push_back(arg);\par
6987                {\cf19 break};\par
6988            \}\par
6989         endMode();\par
6990         {\cf19 return} *{\cf17 this};\par
6991     \}\par
6992     TestSpec TestSpecParser::testSpec() \{\par
6993         addFilter();\par
6994         {\cf19 return} CATCH_MOVE(m_testSpec);\par
6995     \}\par
6996     {\cf18 bool} TestSpecParser::visitChar( {\cf18 char} c ) \{\par
6997         {\cf19 if}( (m_mode != EscapedName) && (c == {\cf23 '\\\\'}) ) \{\par
6998             escape();\par
6999             addCharToPattern(c);\par
7000             {\cf19 return} {\cf17 true};\par
7001         \}{\cf19 else} {\cf19 if}((m_mode != EscapedName) && (c == {\cf23 ','}) )  \{\par
7002             {\cf19 return} separate();\par
7003         \}\par
7004 \par
7005         {\cf19 switch}( m_mode ) \{\par
7006         {\cf19 case} None:\par
7007             {\cf19 if}( processNoneChar( c ) )\par
7008                 {\cf19 return} {\cf17 true};\par
7009             {\cf19 break};\par
7010         {\cf19 case} Name:\par
7011             processNameChar( c );\par
7012             {\cf19 break};\par
7013         {\cf19 case} EscapedName:\par
7014             endMode();\par
7015             addCharToPattern(c);\par
7016             {\cf19 return} {\cf17 true};\par
7017         {\cf19 default}:\par
7018         {\cf19 case} Tag:\par
7019         {\cf19 case} QuotedName:\par
7020             {\cf19 if}( processOtherChar( c ) )\par
7021                 {\cf19 return} {\cf17 true};\par
7022             {\cf19 break};\par
7023         \}\par
7024 \par
7025         m_substring += c;\par
7026         {\cf19 if}( !isControlChar( c ) ) \{\par
7027             m_patternName += c;\par
7028             m_realPatternPos++;\par
7029         \}\par
7030         {\cf19 return} {\cf17 true};\par
7031     \}\par
7032     {\cf20 // Two of the processing methods return true to signal the caller to return}\par
7033     {\cf20 // without adding the given character to the current pattern strings}\par
7034     {\cf18 bool} TestSpecParser::processNoneChar( {\cf18 char} c ) \{\par
7035         {\cf19 switch}( c ) \{\par
7036         {\cf19 case} {\cf23 ' '}:\par
7037             {\cf19 return} {\cf17 true};\par
7038         {\cf19 case} {\cf23 '~'}:\par
7039             m_exclusion = {\cf17 true};\par
7040             {\cf19 return} {\cf17 false};\par
7041         {\cf19 case} {\cf23 '['}:\par
7042             startNewMode( Tag );\par
7043             {\cf19 return} {\cf17 false};\par
7044         {\cf19 case} {\cf23 '"'}:\par
7045             startNewMode( QuotedName );\par
7046             {\cf19 return} {\cf17 false};\par
7047         {\cf19 default}:\par
7048             startNewMode( Name );\par
7049             {\cf19 return} {\cf17 false};\par
7050         \}\par
7051     \}\par
7052     {\cf18 void} TestSpecParser::processNameChar( {\cf18 char} c ) \{\par
7053         {\cf19 if}( c == {\cf23 '['} ) \{\par
7054             {\cf19 if}( m_substring == {\cf22 "exclude:"} )\par
7055                 m_exclusion = {\cf17 true};\par
7056             {\cf19 else}\par
7057                 endMode();\par
7058             startNewMode( Tag );\par
7059         \}\par
7060     \}\par
7061     {\cf18 bool} TestSpecParser::processOtherChar( {\cf18 char} c ) \{\par
7062         {\cf19 if}( !isControlChar( c ) )\par
7063             {\cf19 return} {\cf17 false};\par
7064         m_substring += c;\par
7065         endMode();\par
7066         {\cf19 return} {\cf17 true};\par
7067     \}\par
7068     {\cf18 void} TestSpecParser::startNewMode( Mode mode ) \{\par
7069         m_mode = mode;\par
7070     \}\par
7071     {\cf18 void} TestSpecParser::endMode() \{\par
7072         {\cf19 switch}( m_mode ) \{\par
7073         {\cf19 case} Name:\par
7074         {\cf19 case} QuotedName:\par
7075             {\cf19 return} addNamePattern();\par
7076         {\cf19 case} Tag:\par
7077             {\cf19 return} addTagPattern();\par
7078         {\cf19 case} EscapedName:\par
7079             revertBackToLastMode();\par
7080             {\cf19 return};\par
7081         {\cf19 case} None:\par
7082         {\cf19 default}:\par
7083             {\cf19 return} startNewMode( None );\par
7084         \}\par
7085     \}\par
7086     {\cf18 void} TestSpecParser::escape() \{\par
7087         saveLastMode();\par
7088         m_mode = EscapedName;\par
7089         m_escapeChars.push_back(m_realPatternPos);\par
7090     \}\par
7091     {\cf18 bool} TestSpecParser::isControlChar( {\cf18 char} c ){\cf17  const }\{\par
7092         {\cf19 switch}( m_mode ) \{\par
7093             {\cf19 default}:\par
7094                 {\cf19 return} {\cf17 false};\par
7095             {\cf19 case} None:\par
7096                 {\cf19 return} c == {\cf23 '~'};\par
7097             {\cf19 case} Name:\par
7098                 {\cf19 return} c == {\cf23 '['};\par
7099             {\cf19 case} EscapedName:\par
7100                 {\cf19 return} {\cf17 true};\par
7101             {\cf19 case} QuotedName:\par
7102                 {\cf19 return} c == {\cf23 '"'};\par
7103             {\cf19 case} Tag:\par
7104                 {\cf19 return} c == {\cf23 '['} || c == {\cf23 ']'};\par
7105         \}\par
7106     \}\par
7107 \par
7108     {\cf18 void} TestSpecParser::addFilter() \{\par
7109         {\cf19 if}( !m_currentFilter.m_required.empty() || !m_currentFilter.m_forbidden.empty() ) \{\par
7110             m_testSpec.m_filters.push_back( CATCH_MOVE(m_currentFilter) );\par
7111             m_currentFilter = TestSpec::Filter();\par
7112         \}\par
7113     \}\par
7114 \par
7115     {\cf18 void} TestSpecParser::saveLastMode() \{\par
7116       lastMode = m_mode;\par
7117     \}\par
7118 \par
7119     {\cf18 void} TestSpecParser::revertBackToLastMode() \{\par
7120       m_mode = lastMode;\par
7121     \}\par
7122 \par
7123     {\cf18 bool} TestSpecParser::separate() \{\par
7124       {\cf19 if}( (m_mode==QuotedName) || (m_mode==Tag) )\{\par
7125          {\cf20 //invalid argument, signal failure to previous scope.}\par
7126          m_mode = None;\par
7127          m_pos = m_arg.size();\par
7128          m_substring.clear();\par
7129          m_patternName.clear();\par
7130          m_realPatternPos = 0;\par
7131          {\cf19 return} {\cf17 false};\par
7132       \}\par
7133       endMode();\par
7134       addFilter();\par
7135       {\cf19 return} {\cf17 true}; {\cf20 //success}\par
7136     \}\par
7137 \par
7138     std::string TestSpecParser::preprocessPattern() \{\par
7139         std::string token = m_patternName;\par
7140         {\cf19 for} (std::size_t i = 0; i < m_escapeChars.size(); ++i)\par
7141             token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);\par
7142         m_escapeChars.clear();\par
7143         {\cf19 if} (startsWith(token, {\cf22 "exclude:"})) \{\par
7144             m_exclusion = {\cf17 true};\par
7145             token = token.substr(8);\par
7146         \}\par
7147 \par
7148         m_patternName.clear();\par
7149         m_realPatternPos = 0;\par
7150 \par
7151         {\cf19 return} token;\par
7152     \}\par
7153 \par
7154     {\cf18 void} TestSpecParser::addNamePattern() \{\par
7155         {\cf17 auto} token = preprocessPattern();\par
7156 \par
7157         {\cf19 if} (!token.empty()) \{\par
7158             {\cf19 if} (m_exclusion) \{\par
7159                 m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::NamePattern>(token, m_substring));\par
7160             \} {\cf19 else} \{\par
7161                 m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::NamePattern>(token, m_substring));\par
7162             \}\par
7163         \}\par
7164         m_substring.clear();\par
7165         m_exclusion = {\cf17 false};\par
7166         m_mode = None;\par
7167     \}\par
7168 \par
7169     {\cf18 void} TestSpecParser::addTagPattern() \{\par
7170         {\cf17 auto} token = preprocessPattern();\par
7171 \par
7172         {\cf19 if} (!token.empty()) \{\par
7173             {\cf20 // If the tag pattern is the "hide and tag" shorthand (e.g. [.foo])}\par
7174             {\cf20 // we have to create a separate hide tag and shorten the real one}\par
7175             {\cf19 if} (token.size() > 1 && token[0] == {\cf23 '.'}) \{\par
7176                 token.erase(token.begin());\par
7177                 {\cf19 if} (m_exclusion) \{\par
7178                     m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::TagPattern>({\cf22 "."}, m_substring));\par
7179                 \} {\cf19 else} \{\par
7180                     m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::TagPattern>({\cf22 "."}, m_substring));\par
7181                 \}\par
7182             \}\par
7183             {\cf19 if} (m_exclusion) \{\par
7184                 m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));\par
7185             \} {\cf19 else} \{\par
7186                 m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));\par
7187             \}\par
7188         \}\par
7189         m_substring.clear();\par
7190         m_exclusion = {\cf17 false};\par
7191         m_mode = None;\par
7192     \}\par
7193 \par
7194 \} {\cf20 // namespace Catch}\par
7195 \par
7196 \par
7197 \par
7198 {\cf21 #include <algorithm>}\par
7199 {\cf21 #include <cstring>}\par
7200 {\cf21 #include <ostream>}\par
7201 \par
7202 {\cf17 namespace }\{\par
7203     {\cf18 bool} isWhitespace( {\cf18 char} c ) \{\par
7204         {\cf19 return} c == {\cf23 ' '} || c == {\cf23 '\\t'} || c == {\cf23 '\\n'} || c == {\cf23 '\\r'};\par
7205     \}\par
7206 \par
7207     {\cf18 bool} isBreakableBefore( {\cf18 char} c ) \{\par
7208         {\cf17 static} {\cf17 const} {\cf18 char} chars[] = {\cf22 "[(\{<|"};\par
7209         {\cf19 return} std::memchr( chars, c, {\cf17 sizeof}( chars ) - 1 ) != {\cf17 nullptr};\par
7210     \}\par
7211 \par
7212     {\cf18 bool} isBreakableAfter( {\cf18 char} c ) \{\par
7213         {\cf17 static} {\cf17 const} {\cf18 char} chars[] = {\cf22 "])\}>.,:;*+-=&/\\\\"};\par
7214         {\cf19 return} std::memchr( chars, c, {\cf17 sizeof}( chars ) - 1 ) != {\cf17 nullptr};\par
7215     \}\par
7216 \par
7217 \} {\cf20 // namespace}\par
7218 \par
7219 {\cf17 namespace }Catch \{\par
7220     {\cf17 namespace }TextFlow \{\par
7221         {\cf18 void} AnsiSkippingString::preprocessString() \{\par
7222             {\cf19 for} ( {\cf17 auto} it = m_string.begin(); it != m_string.end(); ) \{\par
7223                 {\cf20 // try to read through an ansi sequence}\par
7224                 {\cf19 while} ( it != m_string.end() && *it == {\cf23 '\\033'} &&\par
7225                         it + 1 != m_string.end() && *( it + 1 ) == {\cf23 '['} ) \{\par
7226                     {\cf17 auto} cursor = it + 2;\par
7227                     {\cf19 while} ( cursor != m_string.end() &&\par
7228                             ( isdigit( *cursor ) || *cursor == {\cf23 ';'} ) ) \{\par
7229                         ++cursor;\par
7230                     \}\par
7231                     {\cf19 if} ( cursor == m_string.end() || *cursor != {\cf23 'm'} ) \{\par
7232                         {\cf19 break};\par
7233                     \}\par
7234                     {\cf20 // 'm' -> 0xff}\par
7235                     *cursor = AnsiSkippingString::sentinel;\par
7236                     {\cf20 // if we've read an ansi sequence, set the iterator and}\par
7237                     {\cf20 // return to the top of the loop}\par
7238                     it = cursor + 1;\par
7239                 \}\par
7240                 {\cf19 if} ( it != m_string.end() ) \{\par
7241                     ++m_size;\par
7242                     ++it;\par
7243                 \}\par
7244             \}\par
7245         \}\par
7246 \par
7247         AnsiSkippingString::AnsiSkippingString( std::string {\cf17 const}& text ):\par
7248             m_string( text ) \{\par
7249             preprocessString();\par
7250         \}\par
7251 \par
7252         AnsiSkippingString::AnsiSkippingString( std::string&& text ):\par
7253             m_string( CATCH_MOVE( text ) ) \{\par
7254             preprocessString();\par
7255         \}\par
7256 \par
7257         AnsiSkippingString::const_iterator AnsiSkippingString::begin(){\cf17  const }\{\par
7258             {\cf19 return} const_iterator( m_string );\par
7259         \}\par
7260 \par
7261         AnsiSkippingString::const_iterator AnsiSkippingString::end(){\cf17  const }\{\par
7262             {\cf19 return} const_iterator( m_string, const_iterator::EndTag\{\} );\par
7263         \}\par
7264 \par
7265         std::string AnsiSkippingString::substring( const_iterator begin,\par
7266                                                    const_iterator end ){\cf17  const }\{\par
7267             {\cf20 // There's one caveat here to an otherwise simple substring: when}\par
7268             {\cf20 // making a begin iterator we might have skipped ansi sequences at}\par
7269             {\cf20 // the start. If `begin` here is a begin iterator, skipped over}\par
7270             {\cf20 // initial ansi sequences, we'll use the true beginning of the}\par
7271             {\cf20 // string. Lastly: We need to transform any chars we replaced with}\par
7272             {\cf20 // 0xff back to 'm'}\par
7273             {\cf17 auto} str = std::string( begin == this->begin() ? m_string.begin()\par
7274                                                            : begin.m_it,\par
7275                                     end.m_it );\par
7276             std::transform( str.begin(), str.end(), str.begin(), []( {\cf18 char} c ) \{\par
7277                 return c == AnsiSkippingString::sentinel ? {\cf22 'm'} : c;\par
7278             \} );\par
7279             {\cf19 return} str;\par
7280         \}\par
7281 \par
7282         {\cf18 void} AnsiSkippingString::const_iterator::tryParseAnsiEscapes() \{\par
7283             {\cf20 // check if we've landed on an ansi sequence, and if so read through}\par
7284             {\cf20 // it}\par
7285             {\cf19 while} ( m_it != m_string->end() && *m_it == {\cf23 '\\033'} &&\par
7286                     m_it + 1 != m_string->end() &&  *( m_it + 1 ) == {\cf23 '['} ) \{\par
7287                 {\cf17 auto} cursor = m_it + 2;\par
7288                 {\cf19 while} ( cursor != m_string->end() &&\par
7289                         ( isdigit( *cursor ) || *cursor == {\cf23 ';'} ) ) \{\par
7290                     ++cursor;\par
7291                 \}\par
7292                 {\cf19 if} ( cursor == m_string->end() ||\par
7293                      *cursor != AnsiSkippingString::sentinel ) \{\par
7294                     {\cf19 break};\par
7295                 \}\par
7296                 {\cf20 // if we've read an ansi sequence, set the iterator and}\par
7297                 {\cf20 // return to the top of the loop}\par
7298                 m_it = cursor + 1;\par
7299             \}\par
7300         \}\par
7301 \par
7302         {\cf18 void} AnsiSkippingString::const_iterator::advance() \{\par
7303             assert( m_it != m_string->end() );\par
7304             m_it++;\par
7305             tryParseAnsiEscapes();\par
7306         \}\par
7307 \par
7308         {\cf18 void} AnsiSkippingString::const_iterator::unadvance() \{\par
7309             assert( m_it != m_string->begin() );\par
7310             m_it--;\par
7311             {\cf20 // if *m_it is 0xff, scan back to the \\033 and then m_it-- once more}\par
7312             {\cf20 // (and repeat check)}\par
7313             {\cf19 while} ( *m_it == AnsiSkippingString::sentinel ) \{\par
7314                 {\cf19 while} ( *m_it != {\cf23 '\\033'} ) \{\par
7315                     assert( m_it != m_string->begin() );\par
7316                     m_it--;\par
7317                 \}\par
7318                 {\cf20 // if this happens, we must have been a begin iterator that had}\par
7319                 {\cf20 // skipped over ansi sequences at the start of a string}\par
7320                 assert( m_it != m_string->begin() );\par
7321                 assert( *m_it == {\cf23 '\\033'} );\par
7322                 m_it--;\par
7323             \}\par
7324         \}\par
7325 \par
7326         {\cf17 static} {\cf18 bool} isBoundary( AnsiSkippingString {\cf17 const}& line,\par
7327                                 AnsiSkippingString::const_iterator it ) \{\par
7328             {\cf19 return} it == line.end() ||\par
7329                    ( isWhitespace( *it ) &&\par
7330                      !isWhitespace( *it.oneBefore() ) ) ||\par
7331                    isBreakableBefore( *it ) ||\par
7332                    isBreakableAfter( *it.oneBefore() );\par
7333         \}\par
7334 \par
7335         {\cf18 void} Column::const_iterator::calcLength() \{\par
7336             m_addHyphen = {\cf17 false};\par
7337             m_parsedTo = m_lineStart;\par
7338             AnsiSkippingString {\cf17 const}& current_line = m_column.m_string;\par
7339 \par
7340             {\cf19 if} ( m_parsedTo == current_line.end() ) \{\par
7341                 m_lineEnd = m_parsedTo;\par
7342                 {\cf19 return};\par
7343             \}\par
7344 \par
7345             assert( m_lineStart != current_line.end() );\par
7346             {\cf19 if} ( *m_lineStart == {\cf23 '\\n'} ) \{ ++m_parsedTo; \}\par
7347 \par
7348             {\cf17 const} {\cf17 auto} maxLineLength = m_column.m_width - indentSize();\par
7349             std::size_t lineLength = 0;\par
7350             {\cf19 while} ( m_parsedTo != current_line.end() &&\par
7351                     lineLength < maxLineLength && *m_parsedTo != {\cf23 '\\n'} ) \{\par
7352                 ++m_parsedTo;\par
7353                 ++lineLength;\par
7354             \}\par
7355 \par
7356             {\cf20 // If we encountered a newline before the column is filled,}\par
7357             {\cf20 // then we linebreak at the newline and consider this line}\par
7358             {\cf20 // finished.}\par
7359             {\cf19 if} ( lineLength < maxLineLength ) \{\par
7360                 m_lineEnd = m_parsedTo;\par
7361             \} {\cf19 else} \{\par
7362                 {\cf20 // Look for a natural linebreak boundary in the column}\par
7363                 {\cf20 // (We look from the end, so that the first found boundary is}\par
7364                 {\cf20 // the right one)}\par
7365                 m_lineEnd = m_parsedTo;\par
7366                 {\cf19 while} ( lineLength > 0 &&\par
7367                         !isBoundary( current_line, m_lineEnd ) ) \{\par
7368                     --lineLength;\par
7369                     --m_lineEnd;\par
7370                 \}\par
7371                 {\cf19 while} ( lineLength > 0 &&\par
7372                         isWhitespace( *m_lineEnd.oneBefore() ) ) \{\par
7373                     --lineLength;\par
7374                     --m_lineEnd;\par
7375                 \}\par
7376 \par
7377                 {\cf20 // If we found one, then that is where we linebreak, otherwise}\par
7378                 {\cf20 // we have to split text with a hyphen}\par
7379                 {\cf19 if} ( lineLength == 0 ) \{\par
7380                     m_addHyphen = {\cf17 true};\par
7381                     m_lineEnd = m_parsedTo.oneBefore();\par
7382                 \}\par
7383             \}\par
7384         \}\par
7385 \par
7386         {\cf18 size_t} Column::const_iterator::indentSize(){\cf17  const }\{\par
7387             {\cf17 auto} initial = m_lineStart == m_column.m_string.begin()\par
7388                                ? m_column.m_initialIndent\par
7389                                : std::string::npos;\par
7390             {\cf19 return} initial == std::string::npos ? m_column.m_indent : initial;\par
7391         \}\par
7392 \par
7393         std::string Column::const_iterator::addIndentAndSuffix(\par
7394             AnsiSkippingString::const_iterator start,\par
7395             AnsiSkippingString::const_iterator end ){\cf17  const }\{\par
7396             std::string ret;\par
7397             {\cf17 const} {\cf17 auto} desired_indent = indentSize();\par
7398             {\cf20 // ret.reserve( desired_indent + (end - start) + m_addHyphen );}\par
7399             ret.append( desired_indent, {\cf23 ' '} );\par
7400             {\cf20 // ret.append( start, end );}\par
7401             ret += m_column.m_string.substring( start, end );\par
7402             {\cf19 if} ( m_addHyphen ) \{ ret.push_back( {\cf23 '-'} ); \}\par
7403 \par
7404             {\cf19 return} ret;\par
7405         \}\par
7406 \par
7407         Column::const_iterator::const_iterator( Column {\cf17 const}& column ):\par
7408             m_column( column ),\par
7409             m_lineStart( column.m_string.begin() ),\par
7410             m_lineEnd( column.m_string.begin() ),\par
7411             m_parsedTo( column.m_string.begin() ) \{\par
7412             assert( m_column.m_width > m_column.m_indent );\par
7413             assert( m_column.m_initialIndent == std::string::npos ||\par
7414                     m_column.m_width > m_column.m_initialIndent );\par
7415             calcLength();\par
7416             {\cf19 if} ( m_lineStart == m_lineEnd ) \{\par
7417                 m_lineStart = m_column.m_string.end();\par
7418             \}\par
7419         \}\par
7420 \par
7421         std::string Column::const_iterator::operator*(){\cf17  const }\{\par
7422             assert( m_lineStart <= m_parsedTo );\par
7423             {\cf19 return} addIndentAndSuffix( m_lineStart, m_lineEnd );\par
7424         \}\par
7425 \par
7426         Column::const_iterator& Column::const_iterator::operator++() \{\par
7427             m_lineStart = m_lineEnd;\par
7428             AnsiSkippingString {\cf17 const}& current_line = m_column.m_string;\par
7429             {\cf19 if} ( m_lineStart != current_line.end() && *m_lineStart == {\cf23 '\\n'} ) \{\par
7430                 m_lineStart++;\par
7431             \} {\cf19 else} \{\par
7432                 {\cf19 while} ( m_lineStart != current_line.end() &&\par
7433                         isWhitespace( *m_lineStart ) ) \{\par
7434                     ++m_lineStart;\par
7435                 \}\par
7436             \}\par
7437 \par
7438             {\cf19 if} ( m_lineStart != current_line.end() ) \{ calcLength(); \}\par
7439             {\cf19 return} *{\cf17 this};\par
7440         \}\par
7441 \par
7442         Column::const_iterator Column::const_iterator::operator++( {\cf18 int} ) \{\par
7443             const_iterator prev( *{\cf17 this} );\par
7444             operator++();\par
7445             {\cf19 return} prev;\par
7446         \}\par
7447 \par
7448         std::ostream& operator<<( std::ostream& os, Column {\cf17 const}& col ) \{\par
7449             {\cf18 bool} first = {\cf17 true};\par
7450             {\cf19 for} ( {\cf17 auto} line : col ) \{\par
7451                 {\cf19 if} ( first ) \{\par
7452                     first = {\cf17 false};\par
7453                 \} {\cf19 else} \{\par
7454                     os << {\cf23 '\\n'};\par
7455                 \}\par
7456                 os << line;\par
7457             \}\par
7458             {\cf19 return} os;\par
7459         \}\par
7460 \par
7461         Column Spacer( {\cf18 size_t} spaceWidth ) \{\par
7462             Column ret\{ {\cf22 ""} \};\par
7463             ret.width( spaceWidth );\par
7464             {\cf19 return} ret;\par
7465         \}\par
7466 \par
7467         Columns::iterator::iterator( Columns {\cf17 const}& columns, EndTag ):\par
7468             m_columns( columns.m_columns ), m_activeIterators( 0 ) \{\par
7469 \par
7470             m_iterators.reserve( m_columns.size() );\par
7471             for ( {\cf17 auto} {\cf17 const}& col : m_columns ) \{\par
7472                 m_iterators.push_back( col.end() );\par
7473             \}\par
7474         \}\par
7475 \par
7476         Columns::iterator::iterator( Columns {\cf17 const}& columns ):\par
7477             m_columns( columns.m_columns ),\par
7478             m_activeIterators( m_columns.size() ) \{\par
7479 \par
7480             m_iterators.reserve( m_columns.size() );\par
7481             for ( {\cf17 auto} {\cf17 const}& col : m_columns ) \{\par
7482                 m_iterators.push_back( col.begin() );\par
7483             \}\par
7484         \}\par
7485 \par
7486         std::string Columns::iterator::operator*(){\cf17  const }\{\par
7487             std::string row, padding;\par
7488 \par
7489             {\cf19 for} ( {\cf18 size_t} i = 0; i < m_columns.size(); ++i ) \{\par
7490                 {\cf17 const} {\cf17 auto} width = m_columns[i].width();\par
7491                 {\cf19 if} ( m_iterators[i] != m_columns[i].end() ) \{\par
7492                     std::string col = *m_iterators[i];\par
7493                     row += padding;\par
7494                     row += col;\par
7495 \par
7496                     padding.clear();\par
7497                     {\cf19 if} ( col.size() < width ) \{\par
7498                         padding.append( width - col.size(), {\cf23 ' '} );\par
7499                     \}\par
7500                 \} {\cf19 else} \{\par
7501                     padding.append( width, {\cf23 ' '} );\par
7502                 \}\par
7503             \}\par
7504             {\cf19 return} row;\par
7505         \}\par
7506 \par
7507         Columns::iterator& Columns::iterator::operator++() \{\par
7508             {\cf19 for} ( {\cf18 size_t} i = 0; i < m_columns.size(); ++i ) \{\par
7509                 {\cf19 if} ( m_iterators[i] != m_columns[i].end() ) \{\par
7510                     ++m_iterators[i];\par
7511                 \}\par
7512             \}\par
7513             {\cf19 return} *{\cf17 this};\par
7514         \}\par
7515 \par
7516         Columns::iterator Columns::iterator::operator++( {\cf18 int} ) \{\par
7517             iterator prev( *{\cf17 this} );\par
7518             operator++();\par
7519             {\cf19 return} prev;\par
7520         \}\par
7521 \par
7522         std::ostream& operator<<( std::ostream& os, Columns {\cf17 const}& cols ) \{\par
7523             {\cf18 bool} first = {\cf17 true};\par
7524             {\cf19 for} ( {\cf17 auto} line : cols ) \{\par
7525                 {\cf19 if} ( first ) \{\par
7526                     first = {\cf17 false};\par
7527                 \} {\cf19 else} \{\par
7528                     os << {\cf23 '\\n'};\par
7529                 \}\par
7530                 os << line;\par
7531             \}\par
7532             {\cf19 return} os;\par
7533         \}\par
7534 \par
7535         Columns operator+( Column {\cf17 const}& lhs, Column {\cf17 const}& rhs ) \{\par
7536             Columns cols;\par
7537             cols += lhs;\par
7538             cols += rhs;\par
7539             {\cf19 return} cols;\par
7540         \}\par
7541         Columns operator+( Column&& lhs, Column&& rhs ) \{\par
7542             Columns cols;\par
7543             cols += CATCH_MOVE( lhs );\par
7544             cols += CATCH_MOVE( rhs );\par
7545             {\cf19 return} cols;\par
7546         \}\par
7547 \par
7548         Columns& operator+=( Columns& lhs, Column {\cf17 const}& rhs ) \{\par
7549             lhs.m_columns.push_back( rhs );\par
7550             {\cf19 return} lhs;\par
7551         \}\par
7552         Columns& operator+=( Columns& lhs, Column&& rhs ) \{\par
7553             lhs.m_columns.push_back( CATCH_MOVE( rhs ) );\par
7554             {\cf19 return} lhs;\par
7555         \}\par
7556         Columns operator+( Columns {\cf17 const}& lhs, Column {\cf17 const}& rhs ) \{\par
7557             {\cf17 auto} combined( lhs );\par
7558             combined += rhs;\par
7559             {\cf19 return} combined;\par
7560         \}\par
7561         Columns operator+( Columns&& lhs, Column&& rhs ) \{\par
7562             lhs += CATCH_MOVE( rhs );\par
7563             {\cf19 return} CATCH_MOVE( lhs );\par
7564         \}\par
7565 \par
7566     \} {\cf20 // namespace TextFlow}\par
7567 \} {\cf20 // namespace Catch}\par
7568 \par
7569 \par
7570 \par
7571 \par
7572 {\cf21 #include <exception>}\par
7573 \par
7574 {\cf17 namespace }Catch \{\par
7575     {\cf18 bool} uncaught_exceptions() \{\par
7576 {\cf21 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
7577         {\cf19 return} {\cf17 false};\par
7578 {\cf21 #elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
7579         {\cf19 return} std::uncaught_exceptions() > 0;\par
7580 {\cf21 #else}\par
7581         {\cf19 return} std::uncaught_exception();\par
7582 {\cf21 #endif}\par
7583   \}\par
7584 \} {\cf20 // end namespace Catch}\par
7585 \par
7586 \par
7587 \par
7588 {\cf17 namespace }Catch \{\par
7589 \par
7590     WildcardPattern::WildcardPattern( std::string {\cf17 const}& pattern,\par
7591                                       CaseSensitive caseSensitivity )\par
7592     :   m_caseSensitivity( caseSensitivity ),\par
7593         m_pattern( normaliseString( pattern ) )\par
7594     \{\par
7595         {\cf19 if}( startsWith( m_pattern, {\cf23 '*'} ) ) \{\par
7596             m_pattern = m_pattern.substr( 1 );\par
7597             m_wildcard = WildcardAtStart;\par
7598         \}\par
7599         {\cf19 if}( endsWith( m_pattern, {\cf23 '*'} ) ) \{\par
7600             m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );\par
7601             m_wildcard = {\cf17 static_cast<}WildcardPosition{\cf17 >}( m_wildcard | WildcardAtEnd );\par
7602         \}\par
7603     \}\par
7604 \par
7605     {\cf18 bool} WildcardPattern::matches( std::string {\cf17 const}& str ){\cf17  const }\{\par
7606         {\cf19 switch}( m_wildcard ) \{\par
7607             {\cf19 case} NoWildcard:\par
7608                 {\cf19 return} m_pattern == normaliseString( str );\par
7609             {\cf19 case} WildcardAtStart:\par
7610                 {\cf19 return} endsWith( normaliseString( str ), m_pattern );\par
7611             {\cf19 case} WildcardAtEnd:\par
7612                 {\cf19 return} startsWith( normaliseString( str ), m_pattern );\par
7613             {\cf19 case} WildcardAtBothEnds:\par
7614                 {\cf19 return} contains( normaliseString( str ), m_pattern );\par
7615             {\cf19 default}:\par
7616                 CATCH_INTERNAL_ERROR( {\cf22 "Unknown enum"} );\par
7617         \}\par
7618     \}\par
7619 \par
7620     std::string WildcardPattern::normaliseString( std::string {\cf17 const}& str ){\cf17  const }\{\par
7621         {\cf19 return} trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );\par
7622     \}\par
7623 \}\par
7624 \par
7625 \par
7626 {\cf20 // Note: swapping these two includes around causes MSVC to error out}\par
7627 {\cf20 //       while in /permissive- mode. No, I don't know why.}\par
7628 {\cf20 //       Tested on VS 2019, 18.\{3, 4\}.x}\par
7629 \par
7630 {\cf21 #include <cstdint>}\par
7631 {\cf21 #include <iomanip>}\par
7632 {\cf21 #include <type_traits>}\par
7633 \par
7634 {\cf17 namespace }Catch \{\par
7635 \par
7636 {\cf17 namespace }\{\par
7637 \par
7638     {\cf18 size_t} trailingBytes({\cf18 unsigned} {\cf18 char} c) \{\par
7639         {\cf19 if} ((c & 0xE0) == 0xC0) \{\par
7640             {\cf19 return} 2;\par
7641         \}\par
7642         {\cf19 if} ((c & 0xF0) == 0xE0) \{\par
7643             {\cf19 return} 3;\par
7644         \}\par
7645         {\cf19 if} ((c & 0xF8) == 0xF0) \{\par
7646             {\cf19 return} 4;\par
7647         \}\par
7648         CATCH_INTERNAL_ERROR({\cf22 "Invalid multibyte utf-8 start byte encountered"});\par
7649     \}\par
7650 \par
7651     uint32_t headerValue({\cf18 unsigned} {\cf18 char} c) \{\par
7652         {\cf19 if} ((c & 0xE0) == 0xC0) \{\par
7653             {\cf19 return} c & 0x1F;\par
7654         \}\par
7655         {\cf19 if} ((c & 0xF0) == 0xE0) \{\par
7656             {\cf19 return} c & 0x0F;\par
7657         \}\par
7658         {\cf19 if} ((c & 0xF8) == 0xF0) \{\par
7659             {\cf19 return} c & 0x07;\par
7660         \}\par
7661         CATCH_INTERNAL_ERROR({\cf22 "Invalid multibyte utf-8 start byte encountered"});\par
7662     \}\par
7663 \par
7664     {\cf18 void} hexEscapeChar(std::ostream& os, {\cf18 unsigned} {\cf18 char} c) \{\par
7665         std::ios_base::fmtflags f(os.flags());\par
7666         os << {\cf22 "\\\\x"}\par
7667             << std::uppercase << std::hex << std::setfill({\cf23 '0'}) << std::setw(2)\par
7668             << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(c);\par
7669         os.flags(f);\par
7670     \}\par
7671 \par
7672     {\cf18 bool} shouldNewline(XmlFormatting fmt) \{\par
7673         {\cf19 return} !!({\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(fmt & XmlFormatting::Newline));\par
7674     \}\par
7675 \par
7676     {\cf18 bool} shouldIndent(XmlFormatting fmt) \{\par
7677         {\cf19 return} !!({\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(fmt & XmlFormatting::Indent));\par
7678     \}\par
7679 \par
7680 \} {\cf20 // anonymous namespace}\par
7681 \par
7682     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) \{\par
7683         {\cf19 return} {\cf17 static_cast<}XmlFormatting{\cf17 >}(\par
7684             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(lhs) |\par
7685             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(rhs)\par
7686         );\par
7687     \}\par
7688 \par
7689     XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs) \{\par
7690         {\cf19 return} {\cf17 static_cast<}XmlFormatting{\cf17 >}(\par
7691             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(lhs) &\par
7692             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(rhs)\par
7693         );\par
7694     \}\par
7695 \par
7696 \par
7697     XmlEncode::XmlEncode( StringRef str, ForWhat forWhat )\par
7698     :   m_str( str ),\par
7699         m_forWhat( forWhat )\par
7700     \{\}\par
7701 \par
7702     {\cf18 void} XmlEncode::encodeTo( std::ostream& os ){\cf17  const }\{\par
7703         {\cf20 // Apostrophe escaping not necessary if we always use " to write attributes}\par
7704         {\cf20 // (see: http://www.w3.org/TR/xml/#syntax)}\par
7705 \par
7706         {\cf19 for}( std::size_t idx = 0; idx < m_str.size(); ++ idx ) \{\par
7707             {\cf18 unsigned} {\cf18 char} c = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(m_str[idx]);\par
7708             {\cf19 switch} (c) \{\par
7709             {\cf19 case} {\cf23 '<'}:   os << {\cf22 "&lt;"}; {\cf19 break};\par
7710             {\cf19 case} {\cf23 '&'}:   os << {\cf22 "&amp;"}; {\cf19 break};\par
7711 \par
7712             {\cf19 case} {\cf23 '>'}:\par
7713                 {\cf20 // See: http://www.w3.org/TR/xml/#syntax}\par
7714                 {\cf19 if} (idx > 2 && m_str[idx - 1] == {\cf23 ']'} && m_str[idx - 2] == {\cf23 ']'})\par
7715                     os << {\cf22 "&gt;"};\par
7716                 {\cf19 else}\par
7717                     os << c;\par
7718                 {\cf19 break};\par
7719 \par
7720             {\cf19 case} {\cf23 '\\"'}:\par
7721                 {\cf19 if} (m_forWhat == ForAttributes)\par
7722                     os << {\cf22 "&quot;"};\par
7723                 {\cf19 else}\par
7724                     os << c;\par
7725                 {\cf19 break};\par
7726 \par
7727             {\cf19 default}:\par
7728                 {\cf20 // Check for control characters and invalid utf-8}\par
7729 \par
7730                 {\cf20 // Escape control characters in standard ascii}\par
7731                 {\cf20 // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0}\par
7732                 {\cf19 if} (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) \{\par
7733                     hexEscapeChar(os, c);\par
7734                     {\cf19 break};\par
7735                 \}\par
7736 \par
7737                 {\cf20 // Plain ASCII: Write it to stream}\par
7738                 {\cf19 if} (c < 0x7F) \{\par
7739                     os << c;\par
7740                     {\cf19 break};\par
7741                 \}\par
7742 \par
7743                 {\cf20 // UTF-8 territory}\par
7744                 {\cf20 // Check if the encoding is valid and if it is not, hex escape bytes.}\par
7745                 {\cf20 // Important: We do not check the exact decoded values for validity, only the encoding format}\par
7746                 {\cf20 // First check that this bytes is a valid lead byte:}\par
7747                 {\cf20 // This means that it is not encoded as 1111 1XXX}\par
7748                 {\cf20 // Or as 10XX XXXX}\par
7749                 {\cf19 if} (c <  0xC0 ||\par
7750                     c >= 0xF8) \{\par
7751                     hexEscapeChar(os, c);\par
7752                     {\cf19 break};\par
7753                 \}\par
7754 \par
7755                 {\cf17 auto} encBytes = trailingBytes(c);\par
7756                 {\cf20 // Are there enough bytes left to avoid accessing out-of-bounds memory?}\par
7757                 {\cf19 if} (idx + encBytes - 1 >= m_str.size()) \{\par
7758                     hexEscapeChar(os, c);\par
7759                     {\cf19 break};\par
7760                 \}\par
7761                 {\cf20 // The header is valid, check data}\par
7762                 {\cf20 // The next encBytes bytes must together be a valid utf-8}\par
7763                 {\cf20 // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)}\par
7764                 {\cf18 bool} valid = {\cf17 true};\par
7765                 uint32_t value = headerValue(c);\par
7766                 {\cf19 for} (std::size_t n = 1; n < encBytes; ++n) \{\par
7767                     {\cf18 unsigned} {\cf18 char} nc = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(m_str[idx + n]);\par
7768                     valid &= ((nc & 0xC0) == 0x80);\par
7769                     value = (value << 6) | (nc & 0x3F);\par
7770                 \}\par
7771 \par
7772                 {\cf19 if} (\par
7773                     {\cf20 // Wrong bit pattern of following bytes}\par
7774                     (!valid) ||\par
7775                     {\cf20 // Overlong encodings}\par
7776                     (value < 0x80) ||\par
7777                     (0x80 <= value && value < 0x800   && encBytes > 2) ||\par
7778                     (0x800 < value && value < 0x10000 && encBytes > 3) ||\par
7779                     {\cf20 // Encoded value out of range}\par
7780                     (value >= 0x110000)\par
7781                     ) \{\par
7782                     hexEscapeChar(os, c);\par
7783                     {\cf19 break};\par
7784                 \}\par
7785 \par
7786                 {\cf20 // If we got here, this is in fact a valid(ish) utf-8 sequence}\par
7787                 {\cf19 for} (std::size_t n = 0; n < encBytes; ++n) \{\par
7788                     os << m_str[idx + n];\par
7789                 \}\par
7790                 idx += encBytes - 1;\par
7791                 {\cf19 break};\par
7792             \}\par
7793         \}\par
7794     \}\par
7795 \par
7796     std::ostream& operator << ( std::ostream& os, XmlEncode {\cf17 const}& xmlEncode ) \{\par
7797         xmlEncode.encodeTo( os );\par
7798         {\cf19 return} os;\par
7799     \}\par
7800 \par
7801     XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )\par
7802     :   m_writer( writer ),\par
7803         m_fmt(fmt)\par
7804     \{\}\par
7805 \par
7806     XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept\par
7807     :   m_writer( other.m_writer ),\par
7808         m_fmt(other.m_fmt)\par
7809     \{\par
7810         other.m_writer = {\cf17 nullptr};\par
7811         other.m_fmt = XmlFormatting::None;\par
7812     \}\par
7813     XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) {\cf17 noexcept} \{\par
7814         {\cf19 if} ( m_writer ) \{\par
7815             m_writer->endElement();\par
7816         \}\par
7817         m_writer = other.m_writer;\par
7818         other.m_writer = {\cf17 nullptr};\par
7819         m_fmt = other.m_fmt;\par
7820         other.m_fmt = XmlFormatting::None;\par
7821         {\cf19 return} *{\cf17 this};\par
7822     \}\par
7823 \par
7824 \par
7825     XmlWriter::ScopedElement::~ScopedElement() \{\par
7826         {\cf19 if} (m_writer) \{\par
7827             m_writer->endElement(m_fmt);\par
7828         \}\par
7829     \}\par
7830 \par
7831     XmlWriter::ScopedElement&\par
7832     XmlWriter::ScopedElement::writeText( StringRef text, XmlFormatting fmt ) \{\par
7833         m_writer->writeText( text, fmt );\par
7834         {\cf19 return} *{\cf17 this};\par
7835     \}\par
7836 \par
7837     XmlWriter::ScopedElement&\par
7838     XmlWriter::ScopedElement::writeAttribute( StringRef name,\par
7839                                               StringRef attribute ) \{\par
7840         m_writer->writeAttribute( name, attribute );\par
7841         {\cf19 return} *{\cf17 this};\par
7842     \}\par
7843 \par
7844 \par
7845     XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )\par
7846     \{\par
7847         writeDeclaration();\par
7848     \}\par
7849 \par
7850     XmlWriter::~XmlWriter() \{\par
7851         {\cf19 while} (!m_tags.empty()) \{\par
7852             endElement();\par
7853         \}\par
7854         newlineIfNecessary();\par
7855     \}\par
7856 \par
7857     XmlWriter& XmlWriter::startElement( std::string {\cf17 const}& name, XmlFormatting fmt ) \{\par
7858         ensureTagClosed();\par
7859         newlineIfNecessary();\par
7860         {\cf19 if} (shouldIndent(fmt)) \{\par
7861             m_os << m_indent;\par
7862             m_indent += {\cf22 "  "};\par
7863         \}\par
7864         m_os << {\cf23 '<'} << name;\par
7865         m_tags.push_back( name );\par
7866         m_tagIsOpen = {\cf17 true};\par
7867         applyFormatting(fmt);\par
7868         {\cf19 return} *{\cf17 this};\par
7869     \}\par
7870 \par
7871     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string {\cf17 const}& name, XmlFormatting fmt ) \{\par
7872         ScopedElement scoped( {\cf17 this}, fmt );\par
7873         startElement( name, fmt );\par
7874         {\cf19 return} scoped;\par
7875     \}\par
7876 \par
7877     XmlWriter& XmlWriter::endElement(XmlFormatting fmt) \{\par
7878         m_indent = m_indent.substr(0, m_indent.size() - 2);\par
7879 \par
7880         {\cf19 if}( m_tagIsOpen ) \{\par
7881             m_os << {\cf22 "/>"};\par
7882             m_tagIsOpen = {\cf17 false};\par
7883         \} {\cf19 else} \{\par
7884             newlineIfNecessary();\par
7885             {\cf19 if} (shouldIndent(fmt)) \{\par
7886                 m_os << m_indent;\par
7887             \}\par
7888             m_os << {\cf22 "</"} << m_tags.back() << {\cf23 '>'};\par
7889         \}\par
7890         m_os << std::flush;\par
7891         applyFormatting(fmt);\par
7892         m_tags.pop_back();\par
7893         {\cf19 return} *{\cf17 this};\par
7894     \}\par
7895 \par
7896     XmlWriter& XmlWriter::writeAttribute( StringRef name,\par
7897                                           StringRef attribute ) \{\par
7898         {\cf19 if}( !name.empty() && !attribute.empty() )\par
7899             m_os << {\cf23 ' '} << name << {\cf22 "=\\""} << XmlEncode( attribute, XmlEncode::ForAttributes ) << {\cf23 '"'};\par
7900         {\cf19 return} *{\cf17 this};\par
7901     \}\par
7902 \par
7903     XmlWriter& XmlWriter::writeAttribute( StringRef name, {\cf18 bool} attribute ) \{\par
7904         writeAttribute(name, (attribute ? {\cf22 "true"}_sr : {\cf22 "false"}_sr));\par
7905         {\cf19 return} *{\cf17 this};\par
7906     \}\par
7907 \par
7908     XmlWriter& XmlWriter::writeAttribute( StringRef name,\par
7909                                           {\cf18 char} {\cf17 const}* attribute ) \{\par
7910         writeAttribute( name, StringRef( attribute ) );\par
7911         {\cf19 return} *{\cf17 this};\par
7912     \}\par
7913 \par
7914     XmlWriter& XmlWriter::writeText( StringRef text, XmlFormatting fmt ) \{\par
7915         CATCH_ENFORCE(!m_tags.empty(), {\cf22 "Cannot write text as top level element"});\par
7916         {\cf19 if}( !text.empty() )\{\par
7917             {\cf18 bool} tagWasOpen = m_tagIsOpen;\par
7918             ensureTagClosed();\par
7919             {\cf19 if} (tagWasOpen && shouldIndent(fmt)) \{\par
7920                 m_os << m_indent;\par
7921             \}\par
7922             m_os << XmlEncode( text, XmlEncode::ForTextNodes );\par
7923             applyFormatting(fmt);\par
7924         \}\par
7925         {\cf19 return} *{\cf17 this};\par
7926     \}\par
7927 \par
7928     XmlWriter& XmlWriter::writeComment( StringRef text, XmlFormatting fmt ) \{\par
7929         ensureTagClosed();\par
7930         {\cf19 if} (shouldIndent(fmt)) \{\par
7931             m_os << m_indent;\par
7932         \}\par
7933         m_os << {\cf22 "<!-- "} << text << {\cf22 " -->"};\par
7934         applyFormatting(fmt);\par
7935         {\cf19 return} *{\cf17 this};\par
7936     \}\par
7937 \par
7938     {\cf18 void} XmlWriter::writeStylesheetRef( StringRef url ) \{\par
7939         m_os << R{\cf22 "(<?xml-stylesheet type="text/xsl" href=")" << url << R}{\cf22 "("?>)" << }{\cf23 '\\n'};\par
7940     \}\par
7941 \par
7942     {\cf18 void} XmlWriter::ensureTagClosed() \{\par
7943         {\cf19 if}( m_tagIsOpen ) \{\par
7944             m_os << {\cf23 '>'} << std::flush;\par
7945             newlineIfNecessary();\par
7946             m_tagIsOpen = {\cf17 false};\par
7947         \}\par
7948     \}\par
7949 \par
7950     {\cf18 void} XmlWriter::applyFormatting(XmlFormatting fmt) \{\par
7951         m_needsNewline = shouldNewline(fmt);\par
7952     \}\par
7953 \par
7954     {\cf18 void} XmlWriter::writeDeclaration() \{\par
7955         m_os << R{\cf22 "(<?xml version="1.0" encoding="UTF-8"?>)" << }{\cf23 '\\n'};\par
7956     \}\par
7957 \par
7958     {\cf18 void} XmlWriter::newlineIfNecessary() \{\par
7959         {\cf19 if}( m_needsNewline ) \{\par
7960             m_os << {\cf23 '\\n'} << std::flush;\par
7961             m_needsNewline = {\cf17 false};\par
7962         \}\par
7963     \}\par
7964 \}\par
7965 \par
7966 \par
7967 \par
7968 \par
7969 \par
7970 {\cf17 namespace }Catch \{\par
7971 {\cf17 namespace }Matchers \{\par
7972 \par
7973     std::string MatcherUntypedBase::toString(){\cf17  const }\{\par
7974         {\cf19 if} (m_cachedToString.empty()) \{\par
7975             m_cachedToString = describe();\par
7976         \}\par
7977         {\cf19 return} m_cachedToString;\par
7978     \}\par
7979 \par
7980     MatcherUntypedBase::~MatcherUntypedBase() = {\cf19 default};\par
7981 \par
7982 \} {\cf20 // namespace Matchers}\par
7983 \} {\cf20 // namespace Catch}\par
7984 \par
7985 \par
7986 \par
7987 \par
7988 {\cf17 namespace }Catch \{\par
7989 {\cf17 namespace }Matchers \{\par
7990 \par
7991     std::string IsEmptyMatcher::describe(){\cf17  const }\{\par
7992         {\cf19 return} {\cf22 "is empty"};\par
7993     \}\par
7994 \par
7995     std::string HasSizeMatcher::describe(){\cf17  const }\{\par
7996         ReusableStringStream sstr;\par
7997         sstr << {\cf22 "has size == "} << m_target_size;\par
7998         {\cf19 return} sstr.str();\par
7999     \}\par
8000 \par
8001     IsEmptyMatcher IsEmpty() \{\par
8002         {\cf19 return} \{\};\par
8003     \}\par
8004 \par
8005     HasSizeMatcher SizeIs(std::size_t sz) \{\par
8006         {\cf19 return} HasSizeMatcher\{ sz \};\par
8007     \}\par
8008 \par
8009 \} {\cf20 // end namespace Matchers}\par
8010 \} {\cf20 // end namespace Catch}\par
8011 \par
8012 \par
8013 \par
8014 {\cf17 namespace }Catch \{\par
8015 {\cf17 namespace }Matchers \{\par
8016 \par
8017 {\cf18 bool} ExceptionMessageMatcher::match(std::exception {\cf17 const}& ex){\cf17  const }\{\par
8018     {\cf19 return} ex.what() == m_message;\par
8019 \}\par
8020 \par
8021 std::string ExceptionMessageMatcher::describe(){\cf17  const }\{\par
8022     {\cf19 return} {\cf22 "exception message matches \\""} + m_message + {\cf23 '"'};\par
8023 \}\par
8024 \par
8025 ExceptionMessageMatcher Message(std::string {\cf17 const}& message) \{\par
8026     {\cf19 return} ExceptionMessageMatcher(message);\par
8027 \}\par
8028 \par
8029 \} {\cf20 // namespace Matchers}\par
8030 \} {\cf20 // namespace Catch}\par
8031 \par
8032 \par
8033 \par
8034 {\cf21 #include <algorithm>}\par
8035 {\cf21 #include <cmath>}\par
8036 {\cf21 #include <cstdlib>}\par
8037 {\cf21 #include <cstdint>}\par
8038 {\cf21 #include <sstream>}\par
8039 {\cf21 #include <iomanip>}\par
8040 {\cf21 #include <limits>}\par
8041 \par
8042 \par
8043 {\cf17 namespace }Catch \{\par
8044 {\cf17 namespace }\{\par
8045 \par
8046     {\cf17 template} <{\cf17 typename} FP>\par
8047     {\cf18 bool} almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) \{\par
8048         {\cf20 // Comparison with NaN should always be false.}\par
8049         {\cf20 // This way we can rule it out before getting into the ugly details}\par
8050         {\cf19 if} (Catch::isnan(lhs) || Catch::isnan(rhs)) \{\par
8051             {\cf19 return} {\cf17 false};\par
8052         \}\par
8053 \par
8054         {\cf20 // This should also handle positive and negative zeros, infinities}\par
8055         {\cf17 const} {\cf17 auto} ulpDist = ulpDistance(lhs, rhs);\par
8056 \par
8057         {\cf19 return} ulpDist <= maxUlpDiff;\par
8058     \}\par
8059 \par
8060 \par
8061 {\cf17 template} <{\cf17 typename} FP>\par
8062 FP step(FP start, FP direction, uint64_t steps) \{\par
8063     {\cf19 for} (uint64_t i = 0; i < steps; ++i) \{\par
8064         start = Catch::nextafter(start, direction);\par
8065     \}\par
8066     {\cf19 return} start;\par
8067 \}\par
8068 \par
8069 {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
8070 {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
8071 {\cf18 bool} marginComparison({\cf18 double} lhs, {\cf18 double} rhs, {\cf18 double} margin) \{\par
8072     {\cf19 return} (lhs + margin >= rhs) && (rhs + margin >= lhs);\par
8073 \}\par
8074 \par
8075 {\cf17 template} <{\cf17 typename} FloatingPo{\cf18 int}>\par
8076 {\cf18 void} write(std::ostream& out, FloatingPoint num) \{\par
8077     out << std::scientific\par
8078         << std::setprecision(std::numeric_limits<FloatingPoint>::max_digits10 - 1)\par
8079         << num;\par
8080 \}\par
8081 \par
8082 \} {\cf20 // end anonymous namespace}\par
8083 \par
8084 {\cf17 namespace }Matchers \{\par
8085 {\cf17 namespace }Detail \{\par
8086 \par
8087     {\cf17 enum class} FloatingPointKind : uint8_t \{\par
8088         Float,\par
8089         Double\par
8090     \};\par
8091 \par
8092 \} {\cf20 // end namespace Detail}\par
8093 \par
8094 \par
8095     WithinAbsMatcher::WithinAbsMatcher({\cf18 double} target, {\cf18 double} margin)\par
8096         :m_target\{ target \}, m_margin\{ margin \} \{\par
8097         CATCH_ENFORCE(margin >= 0, {\cf22 "Invalid margin: "} << margin << {\cf23 '.'}\par
8098             << {\cf22 " Margin has to be non-negative."});\par
8099     \}\par
8100 \par
8101     {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
8102     {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
8103     {\cf18 bool} WithinAbsMatcher::match({\cf18 double} {\cf17 const}& matchee){\cf17  const }\{\par
8104         {\cf19 return} (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);\par
8105     \}\par
8106 \par
8107     std::string WithinAbsMatcher::describe(){\cf17  const }\{\par
8108         {\cf19 return} {\cf22 "is within "} + ::Catch::Detail::stringify(m_margin) + {\cf22 " of "} + ::Catch::Detail::stringify(m_target);\par
8109     \}\par
8110 \par
8111 \par
8112     WithinUlpsMatcher::WithinUlpsMatcher({\cf18 double} target, uint64_t ulps, Detail::FloatingPointKind baseType)\par
8113         :m_target\{ target \}, m_ulps\{ ulps \}, m_type\{ baseType \} \{\par
8114         CATCH_ENFORCE(m_type == Detail::FloatingPointKind::Double\par
8115                    || m_ulps < (std::numeric_limits<uint32_t>::max)(),\par
8116             {\cf22 "Provided ULP is impossibly large for a float comparison."});\par
8117         CATCH_ENFORCE( std::numeric_limits<double>::is_iec559,\par
8118                        {\cf22 "WithinUlp matcher only supports platforms with "}\par
8119                        {\cf22 "IEEE-754 compatible floating point representation"} );\par
8120     \}\par
8121 \par
8122 {\cf21 #if defined(__clang__)}\par
8123 {\cf21 #pragma clang diagnostic push}\par
8124 {\cf20 // Clang <3.5 reports on the default branch in the switch below}\par
8125 {\cf21 #pragma clang diagnostic ignored "-Wunreachable-code"}\par
8126 {\cf21 #endif}\par
8127 \par
8128     {\cf18 bool} WithinUlpsMatcher::match({\cf18 double} {\cf17 const}& matchee){\cf17  const }\{\par
8129         {\cf19 switch} (m_type) \{\par
8130         {\cf19 case} Detail::FloatingPointKind::Float:\par
8131             {\cf19 return} almostEqualUlps<float>({\cf17 static_cast<}{\cf18 float}{\cf17 >}(matchee), {\cf17 static_cast<}{\cf18 float}{\cf17 >}(m_target), m_ulps);\par
8132         {\cf19 case} Detail::FloatingPointKind::Double:\par
8133             {\cf19 return} almostEqualUlps<double>(matchee, m_target, m_ulps);\par
8134         {\cf19 default}:\par
8135             CATCH_INTERNAL_ERROR( {\cf22 "Unknown Detail::FloatingPointKind value"} );\par
8136         \}\par
8137     \}\par
8138 \par
8139 {\cf21 #if defined(__clang__)}\par
8140 {\cf21 #pragma clang diagnostic pop}\par
8141 {\cf21 #endif}\par
8142 \par
8143     std::string WithinUlpsMatcher::describe(){\cf17  const }\{\par
8144         std::stringstream ret;\par
8145 \par
8146         ret << {\cf22 "is within "} << m_ulps << {\cf22 " ULPs of "};\par
8147 \par
8148         {\cf19 if} (m_type == Detail::FloatingPointKind::Float) \{\par
8149             write(ret, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(m_target));\par
8150             ret << {\cf23 'f'};\par
8151         \} {\cf19 else} \{\par
8152             write(ret, m_target);\par
8153         \}\par
8154 \par
8155         ret << {\cf22 " (["};\par
8156         {\cf19 if} (m_type == Detail::FloatingPointKind::Double) \{\par
8157             write( ret,\par
8158                    step( m_target,\par
8159                          -std::numeric_limits<double>::infinity(),\par
8160                          m_ulps ) );\par
8161             ret << {\cf22 ", "};\par
8162             write( ret,\par
8163                    step( m_target,\par
8164                          std::numeric_limits<double>::infinity(),\par
8165                          m_ulps ) );\par
8166         \} {\cf19 else} \{\par
8167             {\cf20 // We have to cast INFINITY to float because of MinGW, see #1782}\par
8168             write( ret,\par
8169                    step( {\cf17 static_cast<}{\cf18 float}{\cf17 >}( m_target ),\par
8170                          -std::numeric_limits<float>::infinity(),\par
8171                          m_ulps ) );\par
8172             ret << {\cf22 ", "};\par
8173             write( ret,\par
8174                    step( {\cf17 static_cast<}{\cf18 float}{\cf17 >}( m_target ),\par
8175                          std::numeric_limits<float>::infinity(),\par
8176                          m_ulps ) );\par
8177         \}\par
8178         ret << {\cf22 "])"};\par
8179 \par
8180         {\cf19 return} ret.str();\par
8181     \}\par
8182 \par
8183     WithinRelMatcher::WithinRelMatcher({\cf18 double} target, {\cf18 double} epsilon):\par
8184         m_target(target),\par
8185         m_epsilon(epsilon)\{\par
8186         CATCH_ENFORCE(m_epsilon >= 0., {\cf22 "Relative comparison with epsilon <  0 does not make sense."});\par
8187         CATCH_ENFORCE(m_epsilon  < 1., "Relative comparison with epsilon >= 1 does not make sense.{\cf22 ");}\par
8188 {\cf22     \}}\par
8189 {\cf22 }\par
8190 {\cf22     bool WithinRelMatcher::match(double const& matchee) const \{}\par
8191 {\cf22         const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));}\par
8192 {\cf22         return marginComparison(matchee, m_target,}\par
8193 {\cf22                                 std::isinf(relMargin)? 0 : relMargin);}\par
8194 {\cf22     \}}\par
8195 {\cf22 }\par
8196 {\cf22     std::string WithinRelMatcher::describe() const \{}\par
8197 {\cf22         Catch::ReusableStringStream sstr;}\par
8198 {\cf22         sstr << "}and {\cf22 " << ::Catch::Detail::stringify(m_target) << "} are within {\cf22 " << m_epsilon * 100. << "}% of each other{\cf22 ";}\par
8199 {\cf22         return sstr.str();}\par
8200 {\cf22     \}}\par
8201 {\cf22 }\par
8202 {\cf22 }\par
8203 {\cf22 WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) \{}\par
8204 {\cf22     return WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Double);}\par
8205 {\cf22 \}}\par
8206 {\cf22 }\par
8207 {\cf22 WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) \{}\par
8208 {\cf22     return WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Float);}\par
8209 {\cf22 \}}\par
8210 {\cf22 }\par
8211 {\cf22 WithinAbsMatcher WithinAbs(double target, double margin) \{}\par
8212 {\cf22     return WithinAbsMatcher(target, margin);}\par
8213 {\cf22 \}}\par
8214 {\cf22 }\par
8215 {\cf22 WithinRelMatcher WithinRel(double target, double eps) \{}\par
8216 {\cf22     return WithinRelMatcher(target, eps);}\par
8217 {\cf22 \}}\par
8218 {\cf22 }\par
8219 {\cf22 WithinRelMatcher WithinRel(double target) \{}\par
8220 {\cf22     return WithinRelMatcher(target, std::numeric_limits<double>::epsilon() * 100);}\par
8221 {\cf22 \}}\par
8222 {\cf22 }\par
8223 {\cf22 WithinRelMatcher WithinRel(float target, float eps) \{}\par
8224 {\cf22     return WithinRelMatcher(target, eps);}\par
8225 {\cf22 \}}\par
8226 {\cf22 }\par
8227 {\cf22 WithinRelMatcher WithinRel(float target) \{}\par
8228 {\cf22     return WithinRelMatcher(target, std::numeric_limits<float>::epsilon() * 100);}\par
8229 {\cf22 \}}\par
8230 {\cf22 }\par
8231 {\cf22 }\par
8232 {\cf22 }\par
8233 {\cf22 bool IsNaNMatcher::match( double const& matchee ) const \{}\par
8234 {\cf22     return std::isnan( matchee );}\par
8235 {\cf22 \}}\par
8236 {\cf22 }\par
8237 {\cf22 std::string IsNaNMatcher::describe() const \{}\par
8238 {\cf22     using namespace std::string_literals;}\par
8239 {\cf22     return "}is NaN{\cf22 "s;}\par
8240 {\cf22 \}}\par
8241 {\cf22 }\par
8242 {\cf22 IsNaNMatcher IsNaN() \{ return IsNaNMatcher(); \}}\par
8243 {\cf22 }\par
8244 {\cf22     \} // namespace Matchers}\par
8245 {\cf22 \} // namespace Catch}\par
8246 {\cf22 }\par
8247 {\cf22 }\par
8248 {\cf22 }\par
8249 {\cf22 }\par
8250 {\cf22 std::string Catch::Matchers::Detail::finalizeDescription(const std::string& desc) \{}\par
8251 {\cf22     if (desc.empty()) \{}\par
8252 {\cf22         return "}matches undescribed predicate{\cf22 ";}\par
8253 {\cf22     \} else \{}\par
8254 {\cf22         return "}matches predicate: \\{\cf22 ""} + desc + {\cf23 '"'};\par
8255     \}\par
8256 \}\par
8257 \par
8258 \par
8259 \par
8260 {\cf17 namespace }Catch \{\par
8261     {\cf17 namespace }Matchers \{\par
8262         std::string AllTrueMatcher::describe(){\cf17  const }\{ {\cf19 return} {\cf22 "contains only true"}; \}\par
8263 \par
8264         AllTrueMatcher AllTrue() \{ {\cf19 return} AllTrueMatcher\{\}; \}\par
8265 \par
8266         std::string NoneTrueMatcher::describe(){\cf17  const }\{ {\cf19 return} {\cf22 "contains no true"}; \}\par
8267 \par
8268         NoneTrueMatcher NoneTrue() \{ {\cf19 return} NoneTrueMatcher\{\}; \}\par
8269 \par
8270         std::string AnyTrueMatcher::describe(){\cf17  const }\{ {\cf19 return} {\cf22 "contains at least one true"}; \}\par
8271 \par
8272         AnyTrueMatcher AnyTrue() \{ {\cf19 return} AnyTrueMatcher\{\}; \}\par
8273     \} {\cf20 // namespace Matchers}\par
8274 \} {\cf20 // namespace Catch}\par
8275 \par
8276 \par
8277 \par
8278 {\cf21 #include <regex>}\par
8279 \par
8280 {\cf17 namespace }Catch \{\par
8281 {\cf17 namespace }Matchers \{\par
8282 \par
8283     CasedString::CasedString( std::string {\cf17 const}& str, CaseSensitive caseSensitivity )\par
8284     :   m_caseSensitivity( caseSensitivity ),\par
8285         m_str( adjustString( str ) )\par
8286     \{\}\par
8287     std::string CasedString::adjustString( std::string {\cf17 const}& str ){\cf17  const }\{\par
8288         {\cf19 return} m_caseSensitivity == CaseSensitive::No\par
8289                ? toLower( str )\par
8290                : str;\par
8291     \}\par
8292     StringRef CasedString::caseSensitivitySuffix(){\cf17  const }\{\par
8293         {\cf19 return} m_caseSensitivity == CaseSensitive::Yes\par
8294                    ? StringRef()\par
8295                    : {\cf22 " (case insensitive)"}_sr;\par
8296     \}\par
8297 \par
8298 \par
8299     StringMatcherBase::StringMatcherBase( StringRef operation, CasedString {\cf17 const}& comparator )\par
8300     : m_comparator( comparator ),\par
8301       m_operation( operation ) \{\par
8302     \}\par
8303 \par
8304     std::string StringMatcherBase::describe(){\cf17  const }\{\par
8305         std::string description;\par
8306         description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\par
8307                                     m_comparator.caseSensitivitySuffix().size());\par
8308         description += m_operation;\par
8309         description += {\cf22 ": \\""};\par
8310         description += m_comparator.m_str;\par
8311         description += {\cf23 '"'};\par
8312         description += m_comparator.caseSensitivitySuffix();\par
8313         {\cf19 return} description;\par
8314     \}\par
8315 \par
8316     StringEqualsMatcher::StringEqualsMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "equals"}_sr, comparator ) \{\}\par
8317 \par
8318     {\cf18 bool} StringEqualsMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8319         {\cf19 return} m_comparator.adjustString( source ) == m_comparator.m_str;\par
8320     \}\par
8321 \par
8322 \par
8323     StringContainsMatcher::StringContainsMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "contains"}_sr, comparator ) \{\}\par
8324 \par
8325     {\cf18 bool} StringContainsMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8326         {\cf19 return} contains( m_comparator.adjustString( source ), m_comparator.m_str );\par
8327     \}\par
8328 \par
8329 \par
8330     StartsWithMatcher::StartsWithMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "starts with"}_sr, comparator ) \{\}\par
8331 \par
8332     {\cf18 bool} StartsWithMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8333         {\cf19 return} startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\par
8334     \}\par
8335 \par
8336 \par
8337     EndsWithMatcher::EndsWithMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "ends with"}_sr, comparator ) \{\}\par
8338 \par
8339     {\cf18 bool} EndsWithMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8340         {\cf19 return} endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\par
8341     \}\par
8342 \par
8343 \par
8344 \par
8345     RegexMatcher::RegexMatcher(std::string regex, CaseSensitive caseSensitivity): m_regex(CATCH_MOVE(regex)), m_caseSensitivity(caseSensitivity) \{\}\par
8346 \par
8347     {\cf18 bool} RegexMatcher::match(std::string {\cf17 const}& matchee){\cf17  const }\{\par
8348         {\cf17 auto} flags = std::regex::ECMAScript; {\cf20 // ECMAScript is the default syntax option anyway}\par
8349         {\cf19 if} (m_caseSensitivity == CaseSensitive::No) \{\par
8350             flags |= std::regex::icase;\par
8351         \}\par
8352         {\cf17 auto} reg = std::regex(m_regex, flags);\par
8353         {\cf19 return} std::regex_match(matchee, reg);\par
8354     \}\par
8355 \par
8356     std::string RegexMatcher::describe(){\cf17  const }\{\par
8357         {\cf19 return} {\cf22 "matches "} + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Yes)? {\cf22 " case sensitively"} : {\cf22 " case insensitively"});\par
8358     \}\par
8359 \par
8360 \par
8361     StringEqualsMatcher Equals( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8362         {\cf19 return} StringEqualsMatcher( CasedString( str, caseSensitivity) );\par
8363     \}\par
8364     StringContainsMatcher ContainsSubstring( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8365         {\cf19 return} StringContainsMatcher( CasedString( str, caseSensitivity) );\par
8366     \}\par
8367     EndsWithMatcher EndsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8368         {\cf19 return} EndsWithMatcher( CasedString( str, caseSensitivity) );\par
8369     \}\par
8370     StartsWithMatcher StartsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8371         {\cf19 return} StartsWithMatcher( CasedString( str, caseSensitivity) );\par
8372     \}\par
8373 \par
8374     RegexMatcher Matches(std::string {\cf17 const}& regex, CaseSensitive caseSensitivity) \{\par
8375         {\cf19 return} RegexMatcher(regex, caseSensitivity);\par
8376     \}\par
8377 \par
8378 \} {\cf20 // namespace Matchers}\par
8379 \} {\cf20 // namespace Catch}\par
8380 \par
8381 \par
8382 \par
8383 {\cf17 namespace }Catch \{\par
8384 {\cf17 namespace }Matchers \{\par
8385     MatcherGenericBase::~MatcherGenericBase() = {\cf19 default};\par
8386 \par
8387     {\cf17 namespace }Detail \{\par
8388 \par
8389         std::string describe_multi_matcher(StringRef combine, std::string {\cf17 const}* descriptions_begin, std::string {\cf17 const}* descriptions_end) \{\par
8390             std::string description;\par
8391             std::size_t combined_size = 4;\par
8392             {\cf19 for} ( {\cf17 auto} desc = descriptions_begin; desc != descriptions_end; ++desc ) \{\par
8393                 combined_size += desc->size();\par
8394             \}\par
8395             combined_size += {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(descriptions_end - descriptions_begin - 1) * combine.size();\par
8396 \par
8397             description.reserve(combined_size);\par
8398 \par
8399             description += {\cf22 "( "};\par
8400             {\cf18 bool} first = {\cf17 true};\par
8401             {\cf19 for}( {\cf17 auto} desc = descriptions_begin; desc != descriptions_end; ++desc ) \{\par
8402                 {\cf19 if}( first )\par
8403                     first = {\cf17 false};\par
8404                 {\cf19 else}\par
8405                     description += combine;\par
8406                 description += *desc;\par
8407             \}\par
8408             description += {\cf22 " )"};\par
8409             {\cf19 return} description;\par
8410         \}\par
8411 \par
8412     \} {\cf20 // namespace Detail}\par
8413 \} {\cf20 // namespace Matchers}\par
8414 \} {\cf20 // namespace Catch}\par
8415 \par
8416 \par
8417 \par
8418 \par
8419 {\cf17 namespace }Catch \{\par
8420 \par
8421     {\cf20 // This is the general overload that takes a any string matcher}\par
8422     {\cf20 // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers}\par
8423     {\cf20 // the Equals matcher (so the header does not mention matchers)}\par
8424     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher {\cf17 const}& matcher ) \{\par
8425         std::string exceptionMessage = Catch::translateActiveException();\par
8426         MatchExpr<std::string, StringMatcher const&> expr( CATCH_MOVE(exceptionMessage), matcher );\par
8427         handler.handleExpr( expr );\par
8428     \}\par
8429 \par
8430 \} {\cf20 // namespace Catch}\par
8431 \par
8432 \par
8433 \par
8434 {\cf21 #include <ostream>}\par
8435 \par
8436 {\cf17 namespace }Catch \{\par
8437 \par
8438     AutomakeReporter::~AutomakeReporter() = {\cf19 default};\par
8439 \par
8440     {\cf18 void} AutomakeReporter::testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) \{\par
8441         {\cf20 // Possible values to emit are PASS, XFAIL, SKIP, FAIL, XPASS and ERROR.}\par
8442         m_stream << {\cf22 ":test-result: "};\par
8443         {\cf19 if} ( _testCaseStats.totals.testCases.skipped > 0 ) \{\par
8444             m_stream << {\cf22 "SKIP"};\par
8445         \} {\cf19 else} {\cf19 if} (_testCaseStats.totals.assertions.allPassed()) \{\par
8446             m_stream << {\cf22 "PASS"};\par
8447         \} {\cf19 else} {\cf19 if} (_testCaseStats.totals.assertions.allOk()) \{\par
8448             m_stream << {\cf22 "XFAIL"};\par
8449         \} {\cf19 else} \{\par
8450             m_stream << {\cf22 "FAIL"};\par
8451         \}\par
8452         m_stream << {\cf23 ' '} << _testCaseStats.testInfo->name << {\cf23 '\\n'};\par
8453         StreamingReporterBase::testCaseEnded(_testCaseStats);\par
8454     \}\par
8455 \par
8456     {\cf18 void} AutomakeReporter::skipTest(TestCaseInfo {\cf17 const}& testInfo) \{\par
8457         m_stream << {\cf22 ":test-result: SKIP "} << testInfo.name << {\cf23 '\\n'};\par
8458     \}\par
8459 \par
8460 \} {\cf20 // end namespace Catch}\par
8461 \par
8462 \par
8463 \par
8464 \par
8465 \par
8466 \par
8467 {\cf17 namespace }Catch \{\par
8468     ReporterBase::ReporterBase( ReporterConfig&& config ):\par
8469         IEventListener( config.fullConfig() ),\par
8470         m_wrapped_stream( CATCH_MOVE(config).takeStream() ),\par
8471         m_stream( m_wrapped_stream->stream() ),\par
8472         m_colour( makeColourImpl( config.colourMode(), m_wrapped_stream.get() ) ),\par
8473         m_customOptions( config.customOptions() )\par
8474     \{\}\par
8475 \par
8476     ReporterBase::~ReporterBase() = {\cf19 default};\par
8477 \par
8478     {\cf18 void} ReporterBase::listReporters(\par
8479         std::vector<ReporterDescription> {\cf17 const}& descriptions ) \{\par
8480         defaultListReporters(m_stream, descriptions, m_config->verbosity());\par
8481     \}\par
8482 \par
8483     {\cf18 void} ReporterBase::listListeners(\par
8484         std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
8485         defaultListListeners( m_stream, descriptions );\par
8486     \}\par
8487 \par
8488     {\cf18 void} ReporterBase::listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
8489         defaultListTests(m_stream,\par
8490                          m_colour.get(),\par
8491                          tests,\par
8492                          m_config->hasTestFilters(),\par
8493                          m_config->verbosity());\par
8494     \}\par
8495 \par
8496     {\cf18 void} ReporterBase::listTags(std::vector<TagInfo> {\cf17 const}& tags) \{\par
8497         defaultListTags( m_stream, tags, m_config->hasTestFilters() );\par
8498     \}\par
8499 \par
8500 \} {\cf20 // namespace Catch}\par
8501 \par
8502 \par
8503 \par
8504 \par
8505 {\cf21 #include <ostream>}\par
8506 \par
8507 {\cf17 namespace }Catch \{\par
8508 {\cf17 namespace }\{\par
8509 \par
8510     {\cf20 // Colour::LightGrey}\par
8511     {\cf17 static} {\cf17 constexpr} Colour::Code compactDimColour = Colour::FileName;\par
8512 \par
8513 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
8514     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactFailedString = {\cf22 "FAILED"}_sr;\par
8515     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactPassedString = {\cf22 "PASSED"}_sr;\par
8516 {\cf21 #else}\par
8517     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactFailedString = {\cf22 "failed"}_sr;\par
8518     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactPassedString = {\cf22 "passed"}_sr;\par
8519 {\cf21 #endif}\par
8520 \par
8521 {\cf20 // Implementation of CompactReporter formatting}\par
8522 {\cf17 class }AssertionPrinter \{\par
8523 {\cf17 public}:\par
8524     AssertionPrinter& operator= (AssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8525     AssertionPrinter(AssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8526     AssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, {\cf18 bool} _printInfoMessages, ColourImpl* colourImpl_)\par
8527         : stream(_stream)\par
8528         , result(_stats.assertionResult)\par
8529         , messages(_stats.infoMessages)\par
8530         , itMessage(_stats.infoMessages.begin())\par
8531         , printInfoMessages(_printInfoMessages)\par
8532         , colourImpl(colourImpl_)\par
8533     \{\}\par
8534 \par
8535     {\cf18 void} print() \{\par
8536         printSourceInfo();\par
8537 \par
8538         itMessage = messages.begin();\par
8539 \par
8540         {\cf19 switch} (result.getResultType()) \{\par
8541         {\cf19 case} ResultWas::Ok:\par
8542             printResultType(Colour::ResultSuccess, compactPassedString);\par
8543             printOriginalExpression();\par
8544             printReconstructedExpression();\par
8545             {\cf19 if} (!result.hasExpression())\par
8546                 printRemainingMessages(Colour::None);\par
8547             {\cf19 else}\par
8548                 printRemainingMessages();\par
8549             {\cf19 break};\par
8550         {\cf19 case} ResultWas::ExpressionFailed:\par
8551             {\cf19 if} (result.isOk())\par
8552                 printResultType(Colour::ResultSuccess, compactFailedString + {\cf22 " - but was ok"}_sr);\par
8553             {\cf19 else}\par
8554                 printResultType(Colour::Error, compactFailedString);\par
8555             printOriginalExpression();\par
8556             printReconstructedExpression();\par
8557             printRemainingMessages();\par
8558             {\cf19 break};\par
8559         {\cf19 case} ResultWas::ThrewException:\par
8560             printResultType(Colour::Error, compactFailedString);\par
8561             printIssue({\cf22 "unexpected exception with message:"});\par
8562             printMessage();\par
8563             printExpressionWas();\par
8564             printRemainingMessages();\par
8565             {\cf19 break};\par
8566         {\cf19 case} ResultWas::FatalErrorCondition:\par
8567             printResultType(Colour::Error, compactFailedString);\par
8568             printIssue({\cf22 "fatal error condition with message:"});\par
8569             printMessage();\par
8570             printExpressionWas();\par
8571             printRemainingMessages();\par
8572             {\cf19 break};\par
8573         {\cf19 case} ResultWas::DidntThrowException:\par
8574             printResultType(Colour::Error, compactFailedString);\par
8575             printIssue({\cf22 "expected exception, got none"});\par
8576             printExpressionWas();\par
8577             printRemainingMessages();\par
8578             {\cf19 break};\par
8579         {\cf19 case} ResultWas::Info:\par
8580             printResultType(Colour::None, {\cf22 "info"}_sr);\par
8581             printMessage();\par
8582             printRemainingMessages();\par
8583             {\cf19 break};\par
8584         {\cf19 case} ResultWas::Warning:\par
8585             printResultType(Colour::None, {\cf22 "warning"}_sr);\par
8586             printMessage();\par
8587             printRemainingMessages();\par
8588             {\cf19 break};\par
8589         {\cf19 case} ResultWas::ExplicitFailure:\par
8590             printResultType(Colour::Error, compactFailedString);\par
8591             printIssue({\cf22 "explicitly"});\par
8592             printRemainingMessages(Colour::None);\par
8593             {\cf19 break};\par
8594         {\cf19 case} ResultWas::ExplicitSkip:\par
8595             printResultType(Colour::Skip, {\cf22 "skipped"}_sr);\par
8596             printMessage();\par
8597             printRemainingMessages();\par
8598             {\cf19 break};\par
8599             {\cf20 // These cases are here to prevent compiler warnings}\par
8600         {\cf19 case} ResultWas::Unknown:\par
8601         {\cf19 case} ResultWas::FailureBit:\par
8602         {\cf19 case} ResultWas::Exception:\par
8603             printResultType(Colour::Error, {\cf22 "** internal error **"});\par
8604             {\cf19 break};\par
8605         \}\par
8606     \}\par
8607 \par
8608 {\cf17 private}:\par
8609     {\cf18 void} printSourceInfo(){\cf17  const }\{\par
8610         stream << colourImpl->guardColour( Colour::FileName )\par
8611                << result.getSourceInfo() << {\cf23 ':'};\par
8612     \}\par
8613 \par
8614     {\cf18 void} printResultType(Colour::Code colour, StringRef passOrFail){\cf17  const }\{\par
8615         {\cf19 if} (!passOrFail.empty()) \{\par
8616             stream << colourImpl->guardColour(colour) << {\cf23 ' '} << passOrFail;\par
8617             stream << {\cf23 ':'};\par
8618         \}\par
8619     \}\par
8620 \par
8621     {\cf18 void} printIssue({\cf18 char} {\cf17 const}* issue){\cf17  const }\{\par
8622         stream << {\cf23 ' '} << issue;\par
8623     \}\par
8624 \par
8625     {\cf18 void} printExpressionWas() \{\par
8626         {\cf19 if} (result.hasExpression()) \{\par
8627             stream << {\cf23 ';'};\par
8628             \{\par
8629                 stream << colourImpl->guardColour(compactDimColour) << {\cf22 " expression was:"};\par
8630             \}\par
8631             printOriginalExpression();\par
8632         \}\par
8633     \}\par
8634 \par
8635     {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
8636         {\cf19 if} (result.hasExpression()) \{\par
8637             stream << {\cf23 ' '} << result.getExpression();\par
8638         \}\par
8639     \}\par
8640 \par
8641     {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
8642         {\cf19 if} (result.hasExpandedExpression()) \{\par
8643             stream << colourImpl->guardColour(compactDimColour) << {\cf22 " for: "};\par
8644             stream << result.getExpandedExpression();\par
8645         \}\par
8646     \}\par
8647 \par
8648     {\cf18 void} printMessage() \{\par
8649         {\cf19 if} (itMessage != messages.end()) \{\par
8650             stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
8651             ++itMessage;\par
8652         \}\par
8653     \}\par
8654 \par
8655     {\cf18 void} printRemainingMessages(Colour::Code colour = compactDimColour) \{\par
8656         {\cf19 if} (itMessage == messages.end())\par
8657             {\cf19 return};\par
8658 \par
8659         {\cf17 const} {\cf17 auto} itEnd = messages.cend();\par
8660         {\cf17 const} {\cf17 auto} N = {\cf17 static_cast<}std::size_t{\cf17 >}(itEnd - itMessage);\par
8661 \par
8662         stream << colourImpl->guardColour( colour ) << {\cf22 " with "}\par
8663                << pluralise( N, {\cf22 "message"}_sr ) << {\cf23 ':'};\par
8664 \par
8665         {\cf19 while} (itMessage != itEnd) \{\par
8666             {\cf20 // If this assertion is a warning ignore any INFO messages}\par
8667             {\cf19 if} (printInfoMessages || itMessage->type != ResultWas::Info) \{\par
8668                 printMessage();\par
8669                 {\cf19 if} (itMessage != itEnd) \{\par
8670                     stream << colourImpl->guardColour(compactDimColour) << {\cf22 " and"};\par
8671                 \}\par
8672                 {\cf19 continue};\par
8673             \}\par
8674             ++itMessage;\par
8675         \}\par
8676     \}\par
8677 \par
8678 {\cf17 private}:\par
8679     std::ostream& stream;\par
8680     AssertionResult {\cf17 const}& result;\par
8681     std::vector<MessageInfo> {\cf17 const}& messages;\par
8682     std::vector<MessageInfo>::const_iterator itMessage;\par
8683     {\cf18 bool} printInfoMessages;\par
8684     ColourImpl* colourImpl;\par
8685 \};\par
8686 \par
8687 \} {\cf20 // anon namespace}\par
8688 \par
8689         std::string CompactReporter::getDescription() \{\par
8690             {\cf19 return} {\cf22 "Reports test results on a single line, suitable for IDEs"};\par
8691         \}\par
8692 \par
8693         {\cf18 void} CompactReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
8694             m_stream << {\cf22 "No test cases matched '"} << unmatchedSpec << {\cf22 "'\\n"};\par
8695         \}\par
8696 \par
8697         {\cf18 void} CompactReporter::testRunStarting( TestRunInfo {\cf17 const}& ) \{\par
8698             {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
8699                 m_stream << m_colour->guardColour( Colour::BrightYellow )\par
8700                          << {\cf22 "Filters: "}\par
8701                          << m_config->testSpec()\par
8702                          << {\cf23 '\\n'};\par
8703             \}\par
8704             m_stream << {\cf22 "RNG seed: "} << getSeed() << {\cf23 '\\n'};\par
8705         \}\par
8706 \par
8707         {\cf18 void} CompactReporter::assertionEnded( AssertionStats {\cf17 const}& _assertionStats ) \{\par
8708             AssertionResult {\cf17 const}& result = _assertionStats.assertionResult;\par
8709 \par
8710             {\cf18 bool} printInfoMessages = {\cf17 true};\par
8711 \par
8712             {\cf20 // Drop out if result was successful and we're not printing those}\par
8713             {\cf19 if}( !m_config->includeSuccessfulResults() && result.isOk() ) \{\par
8714                 {\cf19 if}( result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip )\par
8715                     {\cf19 return};\par
8716                 printInfoMessages = {\cf17 false};\par
8717             \}\par
8718 \par
8719             AssertionPrinter printer( m_stream, _assertionStats, printInfoMessages, m_colour.get() );\par
8720             printer.print();\par
8721 \par
8722             m_stream << {\cf23 '\\n'} << std::flush;\par
8723         \}\par
8724 \par
8725         {\cf18 void} CompactReporter::sectionEnded(SectionStats {\cf17 const}& _sectionStats) \{\par
8726             {\cf18 double} dur = _sectionStats.durationInSeconds;\par
8727             {\cf19 if} ( shouldShowDuration( *m_config, dur ) ) \{\par
8728                 m_stream << getFormattedDuration( dur ) << {\cf22 " s: "} << _sectionStats.sectionInfo.name << {\cf23 '\\n'} << std::flush;\par
8729             \}\par
8730         \}\par
8731 \par
8732         {\cf18 void} CompactReporter::testRunEnded( TestRunStats {\cf17 const}& _testRunStats ) \{\par
8733             printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\par
8734             m_stream << {\cf22 "\\n\\n"} << std::flush;\par
8735             StreamingReporterBase::testRunEnded( _testRunStats );\par
8736         \}\par
8737 \par
8738         CompactReporter::~CompactReporter() = {\cf19 default};\par
8739 \par
8740 \} {\cf20 // end namespace Catch}\par
8741 \par
8742 \par
8743 \par
8744 \par
8745 {\cf21 #include <cstdio>}\par
8746 \par
8747 {\cf21 #if defined(_MSC_VER)}\par
8748 {\cf21 #pragma warning(push)}\par
8749 {\cf21 #pragma warning(disable:4061) }{\cf20 // Not all labels are EXPLICITLY handled in switch}\par
8750  {\cf20 // Note that 4062 (not all labels are handled and default is missing) is enabled}\par
8751 {\cf21 #endif}\par
8752 \par
8753 {\cf21 #if defined(__clang__)}\par
8754 {\cf21 #  pragma clang diagnostic push}\par
8755 {\cf20 // For simplicity, benchmarking-only helpers are always enabled}\par
8756 {\cf21 #  pragma clang diagnostic ignored "-Wunused-function"}\par
8757 {\cf21 #endif}\par
8758 \par
8759 \par
8760 \par
8761 {\cf17 namespace }Catch \{\par
8762 \par
8763 {\cf17 namespace }\{\par
8764 \par
8765 {\cf20 // Formatter impl for ConsoleReporter}\par
8766 {\cf17 class }ConsoleAssertionPrinter \{\par
8767 {\cf17 public}:\par
8768     ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8769     ConsoleAssertionPrinter(ConsoleAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8770     ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, ColourImpl* colourImpl_, {\cf18 bool} _printInfoMessages)\par
8771         : stream(_stream),\par
8772         stats(_stats),\par
8773         result(_stats.assertionResult),\par
8774         colour(Colour::None),\par
8775         messages(_stats.infoMessages),\par
8776         colourImpl(colourImpl_),\par
8777         printInfoMessages(_printInfoMessages) \{\par
8778         {\cf19 switch} (result.getResultType()) \{\par
8779         case ResultWas::Ok:\par
8780             colour = Colour::Success;\par
8781             passOrFail = {\cf22 "PASSED"}_sr;\par
8782             {\cf20 //if( result.hasMessage() )}\par
8783             if (messages.size() == 1)\par
8784                 messageLabel = {\cf22 "with message"}_sr;\par
8785             if (messages.size() > 1)\par
8786                 messageLabel = {\cf22 "with messages"}_sr;\par
8787             break;\par
8788         case ResultWas::ExpressionFailed:\par
8789             if (result.isOk()) \{\par
8790                 colour = Colour::Success;\par
8791                 passOrFail = {\cf22 "FAILED - but was ok"}_sr;\par
8792             \} {\cf19 else} \{\par
8793                 colour = Colour::Error;\par
8794                 passOrFail = {\cf22 "FAILED"}_sr;\par
8795             \}\par
8796             if (messages.size() == 1)\par
8797                 messageLabel = {\cf22 "with message"}_sr;\par
8798             if (messages.size() > 1)\par
8799                 messageLabel = {\cf22 "with messages"}_sr;\par
8800             {\cf19 break};\par
8801         {\cf19 case} ResultWas::ThrewException:\par
8802             colour = Colour::Error;\par
8803             passOrFail = {\cf22 "FAILED"}_sr;\par
8804             {\cf20 // todo switch}\par
8805             switch (messages.size()) \{ case 0:\par
8806                 messageLabel = {\cf22 "due to unexpected exception with "}_sr;\par
8807                 break;\par
8808             case 1:\par
8809                 messageLabel = {\cf22 "due to unexpected exception with message"}_sr;\par
8810                 break;\par
8811             default:\par
8812                 messageLabel = {\cf22 "due to unexpected exception with messages"}_sr;\par
8813                 break;\par
8814             \}\par
8815             {\cf19 break};\par
8816         {\cf19 case} ResultWas::FatalErrorCondition:\par
8817             colour = Colour::Error;\par
8818             passOrFail = {\cf22 "FAILED"}_sr;\par
8819             messageLabel = {\cf22 "due to a fatal error condition"}_sr;\par
8820             {\cf19 break};\par
8821         {\cf19 case} ResultWas::DidntThrowException:\par
8822             colour = Colour::Error;\par
8823             passOrFail = {\cf22 "FAILED"}_sr;\par
8824             messageLabel = {\cf22 "because no exception was thrown where one was expected"}_sr;\par
8825             {\cf19 break};\par
8826         {\cf19 case} ResultWas::Info:\par
8827             messageLabel = {\cf22 "info"}_sr;\par
8828             {\cf19 break};\par
8829         {\cf19 case} ResultWas::Warning:\par
8830             messageLabel = {\cf22 "warning"}_sr;\par
8831             {\cf19 break};\par
8832         {\cf19 case} ResultWas::ExplicitFailure:\par
8833             passOrFail = {\cf22 "FAILED"}_sr;\par
8834             colour = Colour::Error;\par
8835             if (messages.size() == 1)\par
8836                 messageLabel = {\cf22 "explicitly with message"}_sr;\par
8837             if (messages.size() > 1)\par
8838                 messageLabel = {\cf22 "explicitly with messages"}_sr;\par
8839             {\cf19 break};\par
8840         {\cf19 case} ResultWas::ExplicitSkip:\par
8841             colour = Colour::Skip;\par
8842             passOrFail = {\cf22 "SKIPPED"}_sr;\par
8843             if (messages.size() == 1)\par
8844                 messageLabel = {\cf22 "explicitly with message"}_sr;\par
8845             if (messages.size() > 1)\par
8846                 messageLabel = {\cf22 "explicitly with messages"}_sr;\par
8847             {\cf19 break};\par
8848             {\cf20 // These cases are here to prevent compiler warnings}\par
8849         {\cf19 case} ResultWas::Unknown:\par
8850         {\cf19 case} ResultWas::FailureBit:\par
8851         {\cf19 case} ResultWas::Exception:\par
8852             passOrFail = {\cf22 "** internal error **"}_sr;\par
8853             colour = Colour::Error;\par
8854             {\cf19 break};\par
8855         \}\par
8856     \}\par
8857 \par
8858     {\cf18 void} print(){\cf17  const }\{\par
8859         printSourceInfo();\par
8860         {\cf19 if} (stats.totals.assertions.total() > 0) \{\par
8861             printResultType();\par
8862             printOriginalExpression();\par
8863             printReconstructedExpression();\par
8864         \} {\cf19 else} \{\par
8865             stream << {\cf23 '\\n'};\par
8866         \}\par
8867         printMessage();\par
8868     \}\par
8869 \par
8870 {\cf17 private}:\par
8871     {\cf18 void} printResultType(){\cf17  const }\{\par
8872         {\cf19 if} (!passOrFail.empty()) \{\par
8873             stream << colourImpl->guardColour(colour) << passOrFail << {\cf22 ":\\n"};\par
8874         \}\par
8875     \}\par
8876     {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
8877         {\cf19 if} (result.hasExpression()) \{\par
8878             stream << colourImpl->guardColour( Colour::OriginalExpression )\par
8879                    << {\cf22 "  "} << result.getExpressionInMacro() << {\cf23 '\\n'};\par
8880         \}\par
8881     \}\par
8882     {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
8883         {\cf19 if} (result.hasExpandedExpression()) \{\par
8884             stream << {\cf22 "with expansion:\\n"};\par
8885             stream << colourImpl->guardColour( Colour::ReconstructedExpression )\par
8886                    << TextFlow::Column( result.getExpandedExpression() )\par
8887                           .indent( 2 )\par
8888                    << {\cf23 '\\n'};\par
8889         \}\par
8890     \}\par
8891     {\cf18 void} printMessage(){\cf17  const }\{\par
8892         {\cf19 if} (!messageLabel.empty())\par
8893             stream << messageLabel << {\cf23 ':'} << {\cf23 '\\n'};\par
8894         {\cf19 for} ({\cf17 auto} {\cf17 const}& msg : messages) \{\par
8895             {\cf20 // If this assertion is a warning ignore any INFO messages}\par
8896             {\cf19 if} (printInfoMessages || msg.type != ResultWas::Info)\par
8897                 stream << TextFlow::Column(msg.message).indent(2) << {\cf23 '\\n'};\par
8898         \}\par
8899     \}\par
8900     {\cf18 void} printSourceInfo(){\cf17  const }\{\par
8901         stream << colourImpl->guardColour( Colour::FileName )\par
8902                << result.getSourceInfo() << {\cf22 ": "};\par
8903     \}\par
8904 \par
8905     std::ostream& stream;\par
8906     AssertionStats {\cf17 const}& stats;\par
8907     AssertionResult {\cf17 const}& result;\par
8908     Colour::Code colour;\par
8909     StringRef passOrFail;\par
8910     StringRef messageLabel;\par
8911     std::vector<MessageInfo> {\cf17 const}& messages;\par
8912     ColourImpl* colourImpl;\par
8913     {\cf18 bool} printInfoMessages;\par
8914 \};\par
8915 \par
8916 std::size_t makeRatio( std::uint64_t number, std::uint64_t total ) \{\par
8917     {\cf17 const} {\cf17 auto} ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;\par
8918     {\cf19 return} (ratio == 0 && number > 0) ? 1 : {\cf17 static_cast<}std::size_t{\cf17 >}(ratio);\par
8919 \}\par
8920 \par
8921 std::size_t&\par
8922 findMax( std::size_t& i, std::size_t& j, std::size_t& k, std::size_t& l ) \{\par
8923     {\cf19 if} (i > j && i > k && i > l)\par
8924         {\cf19 return} i;\par
8925     {\cf19 else} {\cf19 if} (j > k && j > l)\par
8926         {\cf19 return} j;\par
8927     {\cf19 else} {\cf19 if} (k > l)\par
8928         {\cf19 return} k;\par
8929     {\cf19 else}\par
8930         {\cf19 return} l;\par
8931 \}\par
8932 \par
8933 {\cf17 struct }ColumnBreak \{\};\par
8934 {\cf17 struct }RowBreak \{\};\par
8935 {\cf17 struct }OutputFlush \{\};\par
8936 \par
8937 {\cf17 class }Duration \{\par
8938     {\cf17 enum class} Unit \{\par
8939         Auto,\par
8940         Nanoseconds,\par
8941         Microseconds,\par
8942         Milliseconds,\par
8943         Seconds,\par
8944         Minutes\par
8945     \};\par
8946     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMicrosecond = 1000;\par
8947     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;\par
8948     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;\par
8949     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;\par
8950 \par
8951     {\cf18 double} m_inNanoseconds;\par
8952     Unit m_units;\par
8953 \par
8954 {\cf17 public}:\par
8955     {\cf17 explicit} Duration({\cf18 double} inNanoseconds, Unit units = Unit::Auto)\par
8956         : m_inNanoseconds(inNanoseconds),\par
8957         m_units(units) \{\par
8958         {\cf19 if} (m_units == Unit::Auto) \{\par
8959             {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMicrosecond)\par
8960                 m_units = Unit::Nanoseconds;\par
8961             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMillisecond)\par
8962                 m_units = Unit::Microseconds;\par
8963             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInASecond)\par
8964                 m_units = Unit::Milliseconds;\par
8965             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMinute)\par
8966                 m_units = Unit::Seconds;\par
8967             {\cf19 else}\par
8968                 m_units = Unit::Minutes;\par
8969         \}\par
8970 \par
8971     \}\par
8972 \par
8973     {\cf17 auto} value() const -> {\cf18 double} \{\par
8974         {\cf19 switch} (m_units) \{\par
8975         {\cf19 case} Unit::Microseconds:\par
8976             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMicrosecond);\par
8977         {\cf19 case} Unit::Milliseconds:\par
8978             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMillisecond);\par
8979         {\cf19 case} Unit::Seconds:\par
8980             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInASecond);\par
8981         {\cf19 case} Unit::Minutes:\par
8982             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMinute);\par
8983         {\cf19 default}:\par
8984             {\cf19 return} m_inNanoseconds;\par
8985         \}\par
8986     \}\par
8987     StringRef unitsAsString(){\cf17  const }\{\par
8988         {\cf19 switch} (m_units) \{\par
8989         {\cf19 case} Unit::Nanoseconds:\par
8990             {\cf19 return} {\cf22 "ns"}_sr;\par
8991         {\cf19 case} Unit::Microseconds:\par
8992             {\cf19 return} {\cf22 "us"}_sr;\par
8993         {\cf19 case} Unit::Milliseconds:\par
8994             {\cf19 return} {\cf22 "ms"}_sr;\par
8995         {\cf19 case} Unit::Seconds:\par
8996             {\cf19 return} {\cf22 "s"}_sr;\par
8997         {\cf19 case} Unit::Minutes:\par
8998             {\cf19 return} {\cf22 "m"}_sr;\par
8999         {\cf19 default}:\par
9000             {\cf19 return} {\cf22 "** internal error **"}_sr;\par
9001         \}\par
9002 \par
9003     \}\par
9004     {\cf17 friend} {\cf17 auto} operator << (std::ostream& os, Duration {\cf17 const}& duration) -> std::ostream& \{\par
9005         {\cf19 return} os << duration.value() << {\cf23 ' '} << duration.unitsAsString();\par
9006     \}\par
9007 \};\par
9008 \} {\cf20 // end anon namespace}\par
9009 \par
9010 {\cf17 enum class} Justification \{ Left, Right \};\par
9011 \par
9012 {\cf17 struct }ColumnInfo \{\par
9013     std::string name;\par
9014     std::size_t width;\par
9015     Justification justification;\par
9016 \};\par
9017 \par
9018 {\cf17 class }TablePrinter \{\par
9019     std::ostream& m_os;\par
9020     std::vector<ColumnInfo> m_columnInfos;\par
9021     ReusableStringStream m_oss;\par
9022     {\cf18 int} m_currentColumn = -1;\par
9023     {\cf18 bool} m_isOpen = {\cf17 false};\par
9024 \par
9025 {\cf17 public}:\par
9026     TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )\par
9027     :   m_os( os ),\par
9028         m_columnInfos( CATCH_MOVE( columnInfos ) ) \{\}\par
9029 \par
9030     {\cf17 auto} columnInfos() const -> std::vector<ColumnInfo> const& \{\par
9031         {\cf19 return} m_columnInfos;\par
9032     \}\par
9033 \par
9034     {\cf18 void} open() \{\par
9035         {\cf19 if} (!m_isOpen) \{\par
9036             m_isOpen = {\cf17 true};\par
9037             *{\cf17 this} << RowBreak();\par
9038 \par
9039             TextFlow::Columns headerCols;\par
9040             {\cf19 for} ({\cf17 auto} {\cf17 const}& info : m_columnInfos) \{\par
9041                 assert(info.width > 2);\par
9042                 headerCols += TextFlow::Column(info.name).width(info.width - 2);\par
9043                 headerCols += TextFlow::Spacer( 2 );\par
9044             \}\par
9045             m_os << headerCols << {\cf23 '\\n'};\par
9046 \par
9047             m_os << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
9048         \}\par
9049     \}\par
9050     {\cf18 void} close() \{\par
9051         {\cf19 if} (m_isOpen) \{\par
9052             *{\cf17 this} << RowBreak();\par
9053             m_os << {\cf23 '\\n'} << std::flush;\par
9054             m_isOpen = {\cf17 false};\par
9055         \}\par
9056     \}\par
9057 \par
9058     {\cf17 template}<{\cf17 typename} T>\par
9059     {\cf17 friend} TablePrinter& operator<< (TablePrinter& tp, T {\cf17 const}& value) \{\par
9060         tp.m_oss << value;\par
9061         {\cf19 return} tp;\par
9062     \}\par
9063 \par
9064     {\cf17 friend} TablePrinter& operator<< (TablePrinter& tp, ColumnBreak) \{\par
9065         {\cf17 auto} colStr = tp.m_oss.str();\par
9066         {\cf17 const} {\cf17 auto} strSize = colStr.size();\par
9067         tp.m_oss.str({\cf22 ""});\par
9068         tp.open();\par
9069         {\cf19 if} (tp.m_currentColumn == {\cf17 static_cast<}{\cf18 int}{\cf17 >}(tp.m_columnInfos.size() - 1)) \{\par
9070             tp.m_currentColumn = -1;\par
9071             tp.m_os << {\cf23 '\\n'};\par
9072         \}\par
9073         tp.m_currentColumn++;\par
9074 \par
9075         {\cf17 auto} colInfo = tp.m_columnInfos[tp.m_currentColumn];\par
9076         {\cf17 auto} padding = (strSize + 1 < colInfo.width)\par
9077             ? std::string(colInfo.width - (strSize + 1), {\cf23 ' '})\par
9078             : std::string();\par
9079         {\cf19 if} (colInfo.justification == Justification::Left)\par
9080             tp.m_os << colStr << padding << {\cf23 ' '};\par
9081         {\cf19 else}\par
9082             tp.m_os << padding << colStr << {\cf23 ' '};\par
9083         {\cf19 return} tp;\par
9084     \}\par
9085 \par
9086     {\cf17 friend} TablePrinter& operator<< (TablePrinter& tp, RowBreak) \{\par
9087         {\cf19 if} (tp.m_currentColumn > 0) \{\par
9088             tp.m_os << {\cf23 '\\n'};\par
9089             tp.m_currentColumn = -1;\par
9090         \}\par
9091         {\cf19 return} tp;\par
9092     \}\par
9093 \par
9094     {\cf17 friend} TablePrinter& operator<<(TablePrinter& tp, OutputFlush) \{\par
9095         tp.m_os << std::flush;\par
9096         {\cf19 return} tp;\par
9097     \}\par
9098 \};\par
9099 \par
9100 ConsoleReporter::ConsoleReporter(ReporterConfig&& config):\par
9101     StreamingReporterBase( CATCH_MOVE( config ) ),\par
9102     m_tablePrinter(Detail::make_unique<TablePrinter>(m_stream,\par
9103         [&config]() -> std::vector<ColumnInfo> \{\par
9104         {\cf19 if} (config.fullConfig()->benchmarkNoAnalysis())\par
9105         \{\par
9106             return\{\par
9107                 \{ {\cf22 "benchmark name"}, CATCH_CONFIG_CONSOLE_WIDTH - 43, Justification::Left \},\par
9108                 \{ {\cf22 "     samples"}, 14, Justification::Right \},\par
9109                 \{ {\cf22 "  iterations"}, 14, Justification::Right \},\par
9110                 \{ {\cf22 "        mean"}, 14, Justification::Right \}\par
9111             \};\par
9112         \}\par
9113         {\cf19 else}\par
9114         \{\par
9115             {\cf19 return}\{\par
9116                 \{ {\cf22 "benchmark name"}, CATCH_CONFIG_CONSOLE_WIDTH - 43, Justification::Left \},\par
9117                 \{ {\cf22 "samples      mean       std dev"}, 14, Justification::Right \},\par
9118                 \{ {\cf22 "iterations   low mean   low std dev"}, 14, Justification::Right \},\par
9119                 \{ {\cf22 "est run time high mean  high std dev"}, 14, Justification::Right \}\par
9120             \};\par
9121         \}\par
9122     \}())) \{\}\par
9123 ConsoleReporter::~ConsoleReporter() = {\cf19 default};\par
9124 \par
9125 std::string ConsoleReporter::getDescription() \{\par
9126     {\cf19 return} {\cf22 "Reports test results as plain lines of text"};\par
9127 \}\par
9128 \par
9129 {\cf18 void} ConsoleReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
9130     m_stream << {\cf22 "No test cases matched '"} << unmatchedSpec << {\cf22 "'\\n"};\par
9131 \}\par
9132 \par
9133 {\cf18 void} ConsoleReporter::reportInvalidTestSpec( StringRef arg ) \{\par
9134     m_stream << {\cf22 "Invalid Filter: "} << arg << {\cf23 '\\n'};\par
9135 \}\par
9136 \par
9137 {\cf18 void} ConsoleReporter::assertionStarting(AssertionInfo {\cf17 const}&) \{\}\par
9138 \par
9139 {\cf18 void} ConsoleReporter::assertionEnded(AssertionStats {\cf17 const}& _assertionStats) \{\par
9140     AssertionResult {\cf17 const}& result = _assertionStats.assertionResult;\par
9141 \par
9142     {\cf18 bool} includeResults = m_config->includeSuccessfulResults() || !result.isOk();\par
9143 \par
9144     {\cf20 // Drop out if result was successful but we're not printing them.}\par
9145     {\cf20 // TODO: Make configurable whether skips should be printed}\par
9146     {\cf19 if} (!includeResults && result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip)\par
9147         {\cf19 return};\par
9148 \par
9149     lazyPrint();\par
9150 \par
9151     ConsoleAssertionPrinter printer(m_stream, _assertionStats, m_colour.get(), includeResults);\par
9152     printer.print();\par
9153     m_stream << {\cf23 '\\n'} << std::flush;\par
9154 \}\par
9155 \par
9156 {\cf18 void} ConsoleReporter::sectionStarting(SectionInfo {\cf17 const}& _sectionInfo) \{\par
9157     m_tablePrinter->close();\par
9158     m_headerPrinted = {\cf17 false};\par
9159     StreamingReporterBase::sectionStarting(_sectionInfo);\par
9160 \}\par
9161 {\cf18 void} ConsoleReporter::sectionEnded(SectionStats {\cf17 const}& _sectionStats) \{\par
9162     m_tablePrinter->close();\par
9163     {\cf19 if} (_sectionStats.missingAssertions) \{\par
9164         lazyPrint();\par
9165         {\cf17 auto} guard =\par
9166             m_colour->guardColour( Colour::ResultError ).engage( m_stream );\par
9167         {\cf19 if} (m_sectionStack.size() > 1)\par
9168             m_stream << {\cf22 "\\nNo assertions in section"};\par
9169         {\cf19 else}\par
9170             m_stream << {\cf22 "\\nNo assertions in test case"};\par
9171         m_stream << {\cf22 " '"} << _sectionStats.sectionInfo.name << {\cf22 "'\\n\\n"} << std::flush;\par
9172     \}\par
9173     {\cf18 double} dur = _sectionStats.durationInSeconds;\par
9174     {\cf19 if} (shouldShowDuration(*m_config, dur)) \{\par
9175         m_stream << getFormattedDuration(dur) << {\cf22 " s: "} << _sectionStats.sectionInfo.name << {\cf23 '\\n'} << std::flush;\par
9176     \}\par
9177     {\cf19 if} (m_headerPrinted) \{\par
9178         m_headerPrinted = {\cf17 false};\par
9179     \}\par
9180     StreamingReporterBase::sectionEnded(_sectionStats);\par
9181 \}\par
9182 \par
9183 {\cf18 void} ConsoleReporter::benchmarkPreparing( StringRef name ) \{\par
9184     lazyPrintWithoutClosingBenchmarkTable();\par
9185 \par
9186     {\cf17 auto} nameCol = TextFlow::Column( {\cf17 static_cast<}std::string{\cf17 >}( name ) )\par
9187                        .width( m_tablePrinter->columnInfos()[0].width - 2 );\par
9188 \par
9189     {\cf18 bool} firstLine = {\cf17 true};\par
9190     {\cf19 for} ({\cf17 auto} line : nameCol) \{\par
9191         {\cf19 if} (!firstLine)\par
9192             (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\par
9193         {\cf19 else}\par
9194             firstLine = {\cf17 false};\par
9195 \par
9196         (*m_tablePrinter) << line << ColumnBreak();\par
9197     \}\par
9198 \}\par
9199 \par
9200 {\cf18 void} ConsoleReporter::benchmarkStarting(BenchmarkInfo {\cf17 const}& info) \{\par
9201     (*m_tablePrinter) << info.samples << ColumnBreak()\par
9202         << info.iterations << ColumnBreak();\par
9203     {\cf19 if} ( !m_config->benchmarkNoAnalysis() ) \{\par
9204         ( *m_tablePrinter )\par
9205             << Duration( info.estimatedDuration ) << ColumnBreak();\par
9206     \}\par
9207     ( *m_tablePrinter ) << OutputFlush\{\};\par
9208 \}\par
9209 {\cf18 void} ConsoleReporter::benchmarkEnded(BenchmarkStats<> {\cf17 const}& stats) \{\par
9210     {\cf19 if} (m_config->benchmarkNoAnalysis())\par
9211     \{\par
9212         (*m_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();\par
9213     \}\par
9214     {\cf19 else}\par
9215     \{\par
9216         (*m_tablePrinter) << ColumnBreak()\par
9217             << Duration(stats.mean.point.count()) << ColumnBreak()\par
9218             << Duration(stats.mean.lower_bound.count()) << ColumnBreak()\par
9219             << Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()\par
9220             << Duration(stats.standardDeviation.point.count()) << ColumnBreak()\par
9221             << Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()\par
9222             << Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();\par
9223     \}\par
9224 \}\par
9225 \par
9226 {\cf18 void} ConsoleReporter::benchmarkFailed( StringRef error ) \{\par
9227     {\cf17 auto} guard = m_colour->guardColour( Colour::Red ).engage( m_stream );\par
9228     (*m_tablePrinter)\par
9229         << {\cf22 "Benchmark failed ("} << error << {\cf23 ')'}\par
9230         << ColumnBreak() << RowBreak();\par
9231 \}\par
9232 \par
9233 {\cf18 void} ConsoleReporter::testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) \{\par
9234     m_tablePrinter->close();\par
9235     StreamingReporterBase::testCaseEnded(_testCaseStats);\par
9236     m_headerPrinted = {\cf17 false};\par
9237 \}\par
9238 {\cf18 void} ConsoleReporter::testRunEnded(TestRunStats {\cf17 const}& _testRunStats) \{\par
9239     printTotalsDivider(_testRunStats.totals);\par
9240     printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\par
9241     m_stream << {\cf23 '\\n'} << std::flush;\par
9242     StreamingReporterBase::testRunEnded(_testRunStats);\par
9243 \}\par
9244 {\cf18 void} ConsoleReporter::testRunStarting(TestRunInfo {\cf17 const}& _testRunInfo) \{\par
9245     StreamingReporterBase::testRunStarting(_testRunInfo);\par
9246     {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
9247         m_stream << m_colour->guardColour( Colour::BrightYellow ) << {\cf22 "Filters: "}\par
9248                  << m_config->testSpec() << {\cf23 '\\n'};\par
9249     \}\par
9250     m_stream << {\cf22 "Randomness seeded to: "} << getSeed() << {\cf23 '\\n'};\par
9251 \}\par
9252 \par
9253 {\cf18 void} ConsoleReporter::lazyPrint() \{\par
9254 \par
9255     m_tablePrinter->close();\par
9256     lazyPrintWithoutClosingBenchmarkTable();\par
9257 \}\par
9258 \par
9259 {\cf18 void} ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() \{\par
9260 \par
9261     {\cf19 if} ( !m_testRunInfoPrinted ) \{\par
9262         lazyPrintRunInfo();\par
9263     \}\par
9264     {\cf19 if} (!m_headerPrinted) \{\par
9265         printTestCaseAndSectionHeader();\par
9266         m_headerPrinted = {\cf17 true};\par
9267     \}\par
9268 \}\par
9269 {\cf18 void} ConsoleReporter::lazyPrintRunInfo() \{\par
9270     m_stream << {\cf23 '\\n'}\par
9271              << lineOfChars( {\cf23 '~'} ) << {\cf23 '\\n'}\par
9272              << m_colour->guardColour( Colour::SecondaryText )\par
9273              << currentTestRunInfo.name << {\cf22 " is a Catch2 v"} << libraryVersion()\par
9274              << {\cf22 " host application.\\n"}\par
9275              << {\cf22 "Run with -? for options\\n\\n"};\par
9276 \par
9277     m_testRunInfoPrinted = {\cf17 true};\par
9278 \}\par
9279 {\cf18 void} ConsoleReporter::printTestCaseAndSectionHeader() \{\par
9280     assert(!m_sectionStack.empty());\par
9281     printOpenHeader(currentTestCaseInfo->name);\par
9282 \par
9283     {\cf19 if} (m_sectionStack.size() > 1) \{\par
9284         {\cf17 auto} guard = m_colour->guardColour( Colour::Headers ).engage( m_stream );\par
9285 \par
9286         {\cf17 auto}\par
9287             it = m_sectionStack.begin() + 1, {\cf20 // Skip first section (test case)}\par
9288             itEnd = m_sectionStack.end();\par
9289         {\cf19 for} (; it != itEnd; ++it)\par
9290             printHeaderString(it->name, 2);\par
9291     \}\par
9292 \par
9293     SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;\par
9294 \par
9295 \par
9296     m_stream << lineOfChars( {\cf23 '-'} ) << {\cf23 '\\n'}\par
9297              << m_colour->guardColour( Colour::FileName ) << lineInfo << {\cf23 '\\n'}\par
9298              << lineOfChars( {\cf23 '.'} ) << {\cf22 "\\n\\n"}\par
9299              << std::flush;\par
9300 \}\par
9301 \par
9302 {\cf18 void} ConsoleReporter::printClosedHeader(std::string {\cf17 const}& _name) \{\par
9303     printOpenHeader(_name);\par
9304     m_stream << lineOfChars({\cf23 '.'}) << {\cf23 '\\n'};\par
9305 \}\par
9306 {\cf18 void} ConsoleReporter::printOpenHeader(std::string {\cf17 const}& _name) \{\par
9307     m_stream << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
9308     \{\par
9309         {\cf17 auto} guard = m_colour->guardColour( Colour::Headers ).engage( m_stream );\par
9310         printHeaderString(_name);\par
9311     \}\par
9312 \}\par
9313 \par
9314 {\cf18 void} ConsoleReporter::printHeaderString(std::string {\cf17 const}& _string, std::size_t indent) \{\par
9315     {\cf20 // We want to get a bit fancy with line breaking here, so that subsequent}\par
9316     {\cf20 // lines start after ":" if one is present, e.g.}\par
9317     {\cf20 // ```}\par
9318     {\cf20 // blablabla: Fancy}\par
9319     {\cf20 //            linebreaking}\par
9320     {\cf20 // ```}\par
9321     {\cf20 // but we also want to avoid problems with overly long indentation causing}\par
9322     {\cf20 // the text to take up too many lines, e.g.}\par
9323     {\cf20 // ```}\par
9324     {\cf20 // blablabla: F}\par
9325     {\cf20 //            a}\par
9326     {\cf20 //            n}\par
9327     {\cf20 //            c}\par
9328     {\cf20 //            y}\par
9329     {\cf20 //            .}\par
9330     {\cf20 //            .}\par
9331     {\cf20 //            .}\par
9332     {\cf20 // ```}\par
9333     {\cf20 // So we limit the prefix indentation check to first quarter of the possible}\par
9334     {\cf20 // width}\par
9335     std::size_t idx = _string.find( {\cf22 ": "} );\par
9336     {\cf19 if} ( idx != std::string::npos && idx < CATCH_CONFIG_CONSOLE_WIDTH / 4 ) \{\par
9337         idx += 2;\par
9338     \} {\cf19 else} \{\par
9339         idx = 0;\par
9340     \}\par
9341     m_stream << TextFlow::Column( _string )\par
9342                   .indent( indent + idx )\par
9343                   .initialIndent( indent )\par
9344            << {\cf23 '\\n'};\par
9345 \}\par
9346 \par
9347 {\cf18 void} ConsoleReporter::printTotalsDivider(Totals {\cf17 const}& totals) \{\par
9348     {\cf19 if} (totals.testCases.total() > 0) \{\par
9349         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\par
9350         std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());\par
9351         std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());\par
9352         std::size_t skippedRatio = makeRatio(totals.testCases.skipped, totals.testCases.total());\par
9353         {\cf19 while} (failedRatio + failedButOkRatio + passedRatio + skippedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\par
9354             findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)++;\par
9355         {\cf19 while} (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)\par
9356             findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)--;\par
9357 \par
9358         m_stream << m_colour->guardColour( Colour::Error )\par
9359                  << std::string( failedRatio, {\cf23 '='} )\par
9360                  << m_colour->guardColour( Colour::ResultExpectedFailure )\par
9361                  << std::string( failedButOkRatio, {\cf23 '='} );\par
9362         {\cf19 if} ( totals.testCases.allPassed() ) \{\par
9363             m_stream << m_colour->guardColour( Colour::ResultSuccess )\par
9364                      << std::string( passedRatio, {\cf23 '='} );\par
9365         \} {\cf19 else} \{\par
9366             m_stream << m_colour->guardColour( Colour::Success )\par
9367                      << std::string( passedRatio, {\cf23 '='} );\par
9368         \}\par
9369         m_stream << m_colour->guardColour( Colour::Skip )\par
9370                  << std::string( skippedRatio, {\cf23 '='} );\par
9371     \} {\cf19 else} \{\par
9372         m_stream << m_colour->guardColour( Colour::Warning )\par
9373                  << std::string( CATCH_CONFIG_CONSOLE_WIDTH - 1, {\cf23 '='} );\par
9374     \}\par
9375     m_stream << {\cf23 '\\n'};\par
9376 \}\par
9377 \par
9378 \} {\cf20 // end namespace Catch}\par
9379 \par
9380 {\cf21 #if defined(_MSC_VER)}\par
9381 {\cf21 #pragma warning(pop)}\par
9382 {\cf21 #endif}\par
9383 \par
9384 {\cf21 #if defined(__clang__)}\par
9385 {\cf21 #  pragma clang diagnostic pop}\par
9386 {\cf21 #endif}\par
9387 \par
9388 \par
9389 \par
9390 \par
9391 {\cf21 #include <algorithm>}\par
9392 {\cf21 #include <cassert>}\par
9393 \par
9394 {\cf17 namespace }Catch \{\par
9395     {\cf17 namespace }\{\par
9396         {\cf17 struct }BySectionInfo \{\par
9397             BySectionInfo( SectionInfo {\cf17 const}& other ): m_other( other ) \{\}\par
9398             BySectionInfo( BySectionInfo {\cf17 const}& other ) = {\cf19 default};\par
9399             {\cf18 bool} operator()(\par
9400                 Detail::unique_ptr<CumulativeReporterBase::SectionNode> {\cf17 const}&\par
9401                     node ){\cf17  const }\{\par
9402                 {\cf19 return} (\par
9403                     ( node->stats.sectionInfo.name == m_other.name ) &&\par
9404                     ( node->stats.sectionInfo.lineInfo == m_other.lineInfo ) );\par
9405             \}\par
9406             {\cf18 void} operator=( BySectionInfo {\cf17 const}& ) = {\cf17 delete};\par
9407 \par
9408         {\cf17 private}:\par
9409             SectionInfo {\cf17 const}& m_other;\par
9410         \};\par
9411 \par
9412     \} {\cf20 // namespace}\par
9413 \par
9414     {\cf17 namespace }Detail \{\par
9415         AssertionOrBenchmarkResult::AssertionOrBenchmarkResult(\par
9416             AssertionStats {\cf17 const}& assertion ):\par
9417             m_assertion( assertion ) \{\}\par
9418 \par
9419         AssertionOrBenchmarkResult::AssertionOrBenchmarkResult(\par
9420             BenchmarkStats<> {\cf17 const}& benchmark ):\par
9421             m_benchmark( benchmark ) \{\}\par
9422 \par
9423         {\cf18 bool} AssertionOrBenchmarkResult::isAssertion(){\cf17  const }\{\par
9424             {\cf19 return} m_assertion.some();\par
9425         \}\par
9426         {\cf18 bool} AssertionOrBenchmarkResult::isBenchmark(){\cf17  const }\{\par
9427             {\cf19 return} m_benchmark.some();\par
9428         \}\par
9429 \par
9430         AssertionStats {\cf17 const}& AssertionOrBenchmarkResult::asAssertion(){\cf17  const }\{\par
9431             assert(m_assertion.some());\par
9432 \par
9433             {\cf19 return} *m_assertion;\par
9434         \}\par
9435         BenchmarkStats<> {\cf17 const}& AssertionOrBenchmarkResult::asBenchmark(){\cf17  const }\{\par
9436             assert(m_benchmark.some());\par
9437 \par
9438             {\cf19 return} *m_benchmark;\par
9439         \}\par
9440 \par
9441     \}\par
9442 \par
9443     CumulativeReporterBase::~CumulativeReporterBase() = {\cf19 default};\par
9444 \par
9445     {\cf18 void} CumulativeReporterBase::benchmarkEnded(BenchmarkStats<> {\cf17 const}& benchmarkStats) \{\par
9446         m_sectionStack.back()->assertionsAndBenchmarks.emplace_back(benchmarkStats);\par
9447     \}\par
9448 \par
9449     {\cf18 void}\par
9450     CumulativeReporterBase::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
9451         {\cf20 // We need a copy, because SectionStats expect to take ownership}\par
9452         SectionStats incompleteStats( SectionInfo(sectionInfo), Counts(), 0, {\cf17 false} );\par
9453         SectionNode* node;\par
9454         {\cf19 if} ( m_sectionStack.empty() ) \{\par
9455             {\cf19 if} ( !m_rootSection ) \{\par
9456                 m_rootSection =\par
9457                     Detail::make_unique<SectionNode>( incompleteStats );\par
9458             \}\par
9459             node = m_rootSection.get();\par
9460         \} {\cf19 else} \{\par
9461             SectionNode& parentNode = *m_sectionStack.back();\par
9462             {\cf17 auto} it = std::find_if( parentNode.childSections.begin(),\par
9463                                     parentNode.childSections.end(),\par
9464                                     BySectionInfo( sectionInfo ) );\par
9465             {\cf19 if} ( it == parentNode.childSections.end() ) \{\par
9466                 {\cf17 auto} newNode =\par
9467                     Detail::make_unique<SectionNode>( incompleteStats );\par
9468                 node = newNode.get();\par
9469                 parentNode.childSections.push_back( CATCH_MOVE( newNode ) );\par
9470             \} {\cf19 else} \{\par
9471                 node = it->get();\par
9472             \}\par
9473         \}\par
9474 \par
9475         m_deepestSection = node;\par
9476         m_sectionStack.push_back( node );\par
9477     \}\par
9478 \par
9479     {\cf18 void} CumulativeReporterBase::assertionEnded(\par
9480         AssertionStats {\cf17 const}& assertionStats ) \{\par
9481         assert( !m_sectionStack.empty() );\par
9482         {\cf20 // AssertionResult holds a pointer to a temporary DecomposedExpression,}\par
9483         {\cf20 // which getExpandedExpression() calls to build the expression string.}\par
9484         {\cf20 // Our section stack copy of the assertionResult will likely outlive the}\par
9485         {\cf20 // temporary, so it must be expanded or discarded now to avoid calling}\par
9486         {\cf20 // a destroyed object later.}\par
9487         {\cf19 if} ( m_shouldStoreFailedAssertions &&\par
9488              !assertionStats.assertionResult.isOk() ) \{\par
9489             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(\par
9490                 assertionStats.assertionResult.getExpandedExpression() );\par
9491         \}\par
9492         {\cf19 if} ( m_shouldStoreSuccesfulAssertions &&\par
9493              assertionStats.assertionResult.isOk() ) \{\par
9494             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(\par
9495                 assertionStats.assertionResult.getExpandedExpression() );\par
9496         \}\par
9497         SectionNode& sectionNode = *m_sectionStack.back();\par
9498         sectionNode.assertionsAndBenchmarks.emplace_back( assertionStats );\par
9499     \}\par
9500 \par
9501     {\cf18 void} CumulativeReporterBase::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
9502         assert( !m_sectionStack.empty() );\par
9503         SectionNode& node = *m_sectionStack.back();\par
9504         node.stats = sectionStats;\par
9505         m_sectionStack.pop_back();\par
9506     \}\par
9507 \par
9508     {\cf18 void} CumulativeReporterBase::testCaseEnded(\par
9509         TestCaseStats {\cf17 const}& testCaseStats ) \{\par
9510         {\cf17 auto} node = Detail::make_unique<TestCaseNode>( testCaseStats );\par
9511         assert( m_sectionStack.size() == 0 );\par
9512         node->children.push_back( CATCH_MOVE(m_rootSection) );\par
9513         m_testCases.push_back( CATCH_MOVE(node) );\par
9514 \par
9515         assert( m_deepestSection );\par
9516         m_deepestSection->stdOut = testCaseStats.stdOut;\par
9517         m_deepestSection->stdErr = testCaseStats.stdErr;\par
9518     \}\par
9519 \par
9520 \par
9521     {\cf18 void} CumulativeReporterBase::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
9522         assert(!m_testRun && {\cf22 "CumulativeReporterBase assumes there can only be one test run"});\par
9523         m_testRun = Detail::make_unique<TestRunNode>( testRunStats );\par
9524         m_testRun->children.swap( m_testCases );\par
9525         testRunEndedCumulative();\par
9526     \}\par
9527 \par
9528     {\cf18 bool} CumulativeReporterBase::SectionNode::hasAnyAssertions(){\cf17  const }\{\par
9529         {\cf19 return} std::any_of(\par
9530             assertionsAndBenchmarks.begin(),\par
9531             assertionsAndBenchmarks.end(),\par
9532             []( Detail::AssertionOrBenchmarkResult {\cf17 const}& res ) \{\par
9533                 return res.isAssertion();\par
9534             \} );\par
9535     \}\par
9536 \par
9537 \} {\cf20 // end namespace Catch}\par
9538 \par
9539 \par
9540 \par
9541 \par
9542 {\cf17 namespace }Catch \{\par
9543 \par
9544     {\cf18 void} EventListenerBase::fatalErrorEncountered( StringRef ) \{\}\par
9545 \par
9546     {\cf18 void} EventListenerBase::benchmarkPreparing( StringRef ) \{\}\par
9547     {\cf18 void} EventListenerBase::benchmarkStarting( BenchmarkInfo {\cf17 const}& ) \{\}\par
9548     {\cf18 void} EventListenerBase::benchmarkEnded( BenchmarkStats<> {\cf17 const}& ) \{\}\par
9549     {\cf18 void} EventListenerBase::benchmarkFailed( StringRef ) \{\}\par
9550 \par
9551     {\cf18 void} EventListenerBase::assertionStarting( AssertionInfo {\cf17 const}& ) \{\}\par
9552 \par
9553     {\cf18 void} EventListenerBase::assertionEnded( AssertionStats {\cf17 const}& ) \{\}\par
9554     {\cf18 void} EventListenerBase::listReporters(\par
9555         std::vector<ReporterDescription> {\cf17 const}& ) \{\}\par
9556     {\cf18 void} EventListenerBase::listListeners(\par
9557         std::vector<ListenerDescription> {\cf17 const}& ) \{\}\par
9558     {\cf18 void} EventListenerBase::listTests( std::vector<TestCaseHandle> {\cf17 const}& ) \{\}\par
9559     {\cf18 void} EventListenerBase::listTags( std::vector<TagInfo> {\cf17 const}& ) \{\}\par
9560     {\cf18 void} EventListenerBase::noMatchingTestCases( StringRef ) \{\}\par
9561     {\cf18 void} EventListenerBase::reportInvalidTestSpec( StringRef ) \{\}\par
9562     {\cf18 void} EventListenerBase::testRunStarting( TestRunInfo {\cf17 const}& ) \{\}\par
9563     {\cf18 void} EventListenerBase::testCaseStarting( TestCaseInfo {\cf17 const}& ) \{\}\par
9564     {\cf18 void} EventListenerBase::testCasePartialStarting(TestCaseInfo {\cf17 const}&, uint64_t) \{\}\par
9565     {\cf18 void} EventListenerBase::sectionStarting( SectionInfo {\cf17 const}& ) \{\}\par
9566     {\cf18 void} EventListenerBase::sectionEnded( SectionStats {\cf17 const}& ) \{\}\par
9567     {\cf18 void} EventListenerBase::testCasePartialEnded(TestCaseStats {\cf17 const}&, uint64_t) \{\}\par
9568     {\cf18 void} EventListenerBase::testCaseEnded( TestCaseStats {\cf17 const}& ) \{\}\par
9569     {\cf18 void} EventListenerBase::testRunEnded( TestRunStats {\cf17 const}& ) \{\}\par
9570     {\cf18 void} EventListenerBase::skipTest( TestCaseInfo {\cf17 const}& ) \{\}\par
9571 \} {\cf20 // namespace Catch}\par
9572 \par
9573 \par
9574 \par
9575 \par
9576 {\cf21 #include <algorithm>}\par
9577 {\cf21 #include <cfloat>}\par
9578 {\cf21 #include <cstdio>}\par
9579 {\cf21 #include <ostream>}\par
9580 {\cf21 #include <iomanip>}\par
9581 \par
9582 {\cf17 namespace }Catch \{\par
9583 \par
9584     {\cf17 namespace }\{\par
9585         {\cf18 void} listTestNamesOnly(std::ostream& out,\par
9586                                std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
9587             {\cf19 for} ({\cf17 auto} {\cf17 const}& test : tests) \{\par
9588                 {\cf17 auto} {\cf17 const}& testCaseInfo = test.getTestCaseInfo();\par
9589 \par
9590                 {\cf19 if} (startsWith(testCaseInfo.name, {\cf23 '#'})) \{\par
9591                     out << {\cf23 '"'} << testCaseInfo.name << {\cf23 '"'};\par
9592                 \} {\cf19 else} \{\par
9593                     out << testCaseInfo.name;\par
9594                 \}\par
9595 \par
9596                 out << {\cf23 '\\n'};\par
9597             \}\par
9598             out << std::flush;\par
9599         \}\par
9600     \} {\cf20 // end unnamed namespace}\par
9601 \par
9602 \par
9603     {\cf20 // Because formatting using c++ streams is stateful, drop down to C is}\par
9604     {\cf20 // required Alternatively we could use stringstream, but its performance}\par
9605     {\cf20 // is... not good.}\par
9606     std::string getFormattedDuration( {\cf18 double} duration ) \{\par
9607         {\cf20 // Max exponent + 1 is required to represent the whole part}\par
9608         {\cf20 // + 1 for decimal point}\par
9609         {\cf20 // + 3 for the 3 decimal places}\par
9610         {\cf20 // + 1 for null terminator}\par
9611         {\cf17 const} std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\par
9612         {\cf18 char} buffer[maxDoubleSize];\par
9613 \par
9614         {\cf20 // Save previous errno, to prevent sprintf from overwriting it}\par
9615         ErrnoGuard guard;\par
9616 {\cf21 #ifdef _MSC_VER}\par
9617         {\cf18 size_t} printedLength = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
9618             sprintf_s( buffer, {\cf22 "%.3f"}, duration ) );\par
9619 {\cf21 #else}\par
9620         {\cf18 size_t} printedLength = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
9621             std::snprintf( buffer, maxDoubleSize, {\cf22 "%.3f"}, duration ) );\par
9622 {\cf21 #endif}\par
9623         {\cf19 return} std::string( buffer, printedLength );\par
9624     \}\par
9625 \par
9626     {\cf18 bool} shouldShowDuration( IConfig {\cf17 const}& config, {\cf18 double} duration ) \{\par
9627         {\cf19 if} ( config.showDurations() == ShowDurations::Always ) \{\par
9628             {\cf19 return} {\cf17 true};\par
9629         \}\par
9630         {\cf19 if} ( config.showDurations() == ShowDurations::Never ) \{\par
9631             {\cf19 return} {\cf17 false};\par
9632         \}\par
9633         {\cf17 const} {\cf18 double} min = config.minDuration();\par
9634         {\cf19 return} min >= 0 && duration >= min;\par
9635     \}\par
9636 \par
9637     std::string serializeFilters( std::vector<std::string> {\cf17 const}& filters ) \{\par
9638         {\cf20 // We add a ' ' separator between each filter}\par
9639         {\cf18 size_t} serialized_size = filters.size() - 1;\par
9640         {\cf19 for} ({\cf17 auto} {\cf17 const}& filter : filters) \{\par
9641             serialized_size += filter.size();\par
9642         \}\par
9643 \par
9644         std::string serialized;\par
9645         serialized.reserve(serialized_size);\par
9646         {\cf18 bool} first = {\cf17 true};\par
9647 \par
9648         {\cf19 for} ({\cf17 auto} {\cf17 const}& filter : filters) \{\par
9649             {\cf19 if} (!first) \{\par
9650                 serialized.push_back({\cf23 ' '});\par
9651             \}\par
9652             first = {\cf17 false};\par
9653             serialized.append(filter);\par
9654         \}\par
9655 \par
9656         {\cf19 return} serialized;\par
9657     \}\par
9658 \par
9659     std::ostream& operator<<( std::ostream& out, lineOfChars value ) \{\par
9660         {\cf19 for} ( {\cf18 size_t} idx = 0; idx < CATCH_CONFIG_CONSOLE_WIDTH - 1; ++idx ) \{\par
9661             out.put( value.c );\par
9662         \}\par
9663         {\cf19 return} out;\par
9664     \}\par
9665 \par
9666     {\cf18 void}\par
9667     defaultListReporters( std::ostream& out,\par
9668                           std::vector<ReporterDescription> {\cf17 const}& descriptions,\par
9669                           Verbosity verbosity ) \{\par
9670         out << {\cf22 "Available reporters:\\n"};\par
9671         {\cf17 const} {\cf17 auto} maxNameLen =\par
9672             std::max_element( descriptions.begin(),\par
9673                               descriptions.end(),\par
9674                               []( ReporterDescription {\cf17 const}& lhs,\par
9675                                   ReporterDescription {\cf17 const}& rhs ) \{\par
9676                                   return lhs.name.size() < rhs.name.size();\par
9677                               \} )\par
9678                 ->name.size();\par
9679 \par
9680         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
9681             {\cf19 if} ( verbosity == Verbosity::Quiet ) \{\par
9682                 out << TextFlow::Column( desc.name )\par
9683                            .indent( 2 )\par
9684                            .width( 5 + maxNameLen )\par
9685                     << {\cf23 '\\n'};\par
9686             \} {\cf19 else} \{\par
9687                 out << TextFlow::Column( desc.name + {\cf23 ':'} )\par
9688                                .indent( 2 )\par
9689                                .width( 5 + maxNameLen ) +\par
9690                            TextFlow::Column( desc.description )\par
9691                                .initialIndent( 0 )\par
9692                                .indent( 2 )\par
9693                                .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\par
9694                     << {\cf23 '\\n'};\par
9695             \}\par
9696         \}\par
9697         out << {\cf23 '\\n'} << std::flush;\par
9698     \}\par
9699 \par
9700     {\cf18 void} defaultListListeners( std::ostream& out,\par
9701                                std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
9702         out << {\cf22 "Registered listeners:\\n"};\par
9703 \par
9704         {\cf19 if}(descriptions.empty()) \{\par
9705             {\cf19 return};\par
9706         \}\par
9707 \par
9708         {\cf17 const} {\cf17 auto} maxNameLen =\par
9709             std::max_element( descriptions.begin(),\par
9710                               descriptions.end(),\par
9711                               []( ListenerDescription {\cf17 const}& lhs,\par
9712                                   ListenerDescription {\cf17 const}& rhs ) \{\par
9713                                   return lhs.name.size() < rhs.name.size();\par
9714                               \} )\par
9715                 ->name.size();\par
9716 \par
9717         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
9718             out << TextFlow::Column( static_cast<std::string>( desc.name ) +\par
9719                                      {\cf23 ':'} )\par
9720                            .indent( 2 )\par
9721                            .width( maxNameLen + 5 ) +\par
9722                        TextFlow::Column( desc.description )\par
9723                            .initialIndent( 0 )\par
9724                            .indent( 2 )\par
9725                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\par
9726                 << {\cf23 '\\n'};\par
9727         \}\par
9728 \par
9729         out << {\cf23 '\\n'} << std::flush;\par
9730     \}\par
9731 \par
9732     {\cf18 void} defaultListTags( std::ostream& out,\par
9733                           std::vector<TagInfo> {\cf17 const}& tags,\par
9734                           {\cf18 bool} isFiltered ) \{\par
9735         {\cf19 if} ( isFiltered ) \{\par
9736             out << {\cf22 "Tags for matching test cases:\\n"};\par
9737         \} {\cf19 else} \{\par
9738             out << {\cf22 "All available tags:\\n"};\par
9739         \}\par
9740 \par
9741         {\cf19 for} ( {\cf17 auto} {\cf17 const}& tagCount : tags ) \{\par
9742             ReusableStringStream rss;\par
9743             rss << {\cf22 "  "} << std::setw( 2 ) << tagCount.count << {\cf22 "  "};\par
9744             {\cf17 auto} str = rss.str();\par
9745             {\cf17 auto} wrapper = TextFlow::Column( tagCount.all() )\par
9746                                .initialIndent( 0 )\par
9747                                .indent( str.size() )\par
9748                                .width( CATCH_CONFIG_CONSOLE_WIDTH - 10 );\par
9749             out << str << wrapper << {\cf23 '\\n'};\par
9750         \}\par
9751         out << pluralise(tags.size(), {\cf22 "tag"}_sr) << {\cf22 "\\n\\n"} << std::flush;\par
9752     \}\par
9753 \par
9754     {\cf18 void} defaultListTests(std::ostream& out, ColourImpl* streamColour, std::vector<TestCaseHandle> {\cf17 const}& tests, {\cf18 bool} isFiltered, Verbosity verbosity) \{\par
9755         {\cf20 // We special case this to provide the equivalent of old}\par
9756         {\cf20 // `--list-test-names-only`, which could then be used by the}\par
9757         {\cf20 // `--input-file` option.}\par
9758         {\cf19 if} (verbosity == Verbosity::Quiet) \{\par
9759             listTestNamesOnly(out, tests);\par
9760             {\cf19 return};\par
9761         \}\par
9762 \par
9763         {\cf19 if} (isFiltered) \{\par
9764             out << {\cf22 "Matching test cases:\\n"};\par
9765         \} {\cf19 else} \{\par
9766             out << {\cf22 "All available test cases:\\n"};\par
9767         \}\par
9768 \par
9769         {\cf19 for} ({\cf17 auto} {\cf17 const}& test : tests) \{\par
9770             {\cf17 auto} {\cf17 const}& testCaseInfo = test.getTestCaseInfo();\par
9771             Colour::Code colour = testCaseInfo.isHidden()\par
9772                 ? Colour::SecondaryText\par
9773                 : Colour::None;\par
9774             {\cf17 auto} colourGuard = streamColour->guardColour( colour ).engage( out );\par
9775 \par
9776             out << TextFlow::Column(testCaseInfo.name).indent(2) << {\cf23 '\\n'};\par
9777             {\cf19 if} (verbosity >= Verbosity::High) \{\par
9778                 out << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << {\cf23 '\\n'};\par
9779             \}\par
9780             {\cf19 if} (!testCaseInfo.tags.empty() &&\par
9781                 verbosity > Verbosity::Quiet) \{\par
9782                 out << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << {\cf23 '\\n'};\par
9783             \}\par
9784         \}\par
9785 \par
9786         {\cf19 if} (isFiltered) \{\par
9787             out << pluralise(tests.size(), {\cf22 "matching test case"}_sr);\par
9788         \} {\cf19 else} \{\par
9789             out << pluralise(tests.size(), {\cf22 "test case"}_sr);\par
9790         \}\par
9791         out << {\cf22 "\\n\\n"} << std::flush;\par
9792     \}\par
9793 \par
9794     {\cf17 namespace }\{\par
9795         {\cf17 class }SummaryColumn \{\par
9796         {\cf17 public}:\par
9797             SummaryColumn( std::string suffix, Colour::Code colour ):\par
9798                 m_suffix( CATCH_MOVE( suffix ) ), m_colour( colour ) \{\}\par
9799 \par
9800             SummaryColumn&& addRow( std::uint64_t count ) && \{\par
9801                 std::string row = std::to_string(count);\par
9802                 {\cf17 auto} {\cf17 const} new_width = std::max( m_width, row.size() );\par
9803                 {\cf19 if} ( new_width > m_width ) \{\par
9804                     {\cf19 for} ( {\cf17 auto}& oldRow : m_rows ) \{\par
9805                         oldRow.insert( 0, new_width - m_width, {\cf23 ' '} );\par
9806                     \}\par
9807                 \} {\cf19 else} \{\par
9808                     row.insert( 0, m_width - row.size(), {\cf23 ' '} );\par
9809                 \}\par
9810                 m_width = new_width;\par
9811                 m_rows.push_back( row );\par
9812                 {\cf19 return} std::move( *{\cf17 this} );\par
9813             \}\par
9814 \par
9815             std::string {\cf17 const}& getSuffix(){\cf17  const }\{ {\cf19 return} m_suffix; \}\par
9816             Colour::Code getColour(){\cf17  const }\{ {\cf19 return} m_colour; \}\par
9817             std::string {\cf17 const}& getRow( std::size_t index ){\cf17  const }\{\par
9818                 {\cf19 return} m_rows[index];\par
9819             \}\par
9820 \par
9821         {\cf17 private}:\par
9822             std::string m_suffix;\par
9823             Colour::Code m_colour;\par
9824             std::size_t m_width = 0;\par
9825             std::vector<std::string> m_rows;\par
9826         \};\par
9827 \par
9828         {\cf18 void} printSummaryRow( std::ostream& stream,\par
9829                               ColourImpl& colour,\par
9830                               StringRef label,\par
9831                               std::vector<SummaryColumn> {\cf17 const}& cols,\par
9832                               std::size_t row ) \{\par
9833             {\cf19 for} ( {\cf17 auto} {\cf17 const}& col : cols ) \{\par
9834                 {\cf17 auto} {\cf17 const}& value = col.getRow( row );\par
9835                 {\cf17 auto} {\cf17 const}& suffix = col.getSuffix();\par
9836                 {\cf19 if} ( suffix.empty() ) \{\par
9837                     stream << label << {\cf22 ": "};\par
9838                     {\cf19 if} ( value != {\cf22 "0"} ) \{\par
9839                         stream << value;\par
9840                     \} {\cf19 else} \{\par
9841                         stream << colour.guardColour( Colour::Warning )\par
9842                                << {\cf22 "- none -"};\par
9843                     \}\par
9844                 \} {\cf19 else} {\cf19 if} ( value != {\cf22 "0"} ) \{\par
9845                     stream << colour.guardColour( Colour::LightGrey ) << {\cf22 " | "}\par
9846                            << colour.guardColour( col.getColour() ) << value\par
9847                            << {\cf23 ' '} << suffix;\par
9848                 \}\par
9849             \}\par
9850             stream << {\cf23 '\\n'};\par
9851         \}\par
9852     \} {\cf20 // namespace}\par
9853 \par
9854     {\cf18 void} printTestRunTotals( std::ostream& stream,\par
9855                              ColourImpl& streamColour,\par
9856                              Totals {\cf17 const}& totals ) \{\par
9857         {\cf19 if} ( totals.testCases.total() == 0 ) \{\par
9858             stream << streamColour.guardColour( Colour::Warning )\par
9859                    << {\cf22 "No tests ran\\n"};\par
9860             {\cf19 return};\par
9861         \}\par
9862 \par
9863         {\cf19 if} ( totals.assertions.total() > 0 && totals.testCases.allPassed() ) \{\par
9864             stream << streamColour.guardColour( Colour::ResultSuccess )\par
9865                    << {\cf22 "All tests passed"};\par
9866             stream << {\cf22 " ("}\par
9867                    << pluralise( totals.assertions.passed, {\cf22 "assertion"}_sr )\par
9868                    << {\cf22 " in "}\par
9869                    << pluralise( totals.testCases.passed, {\cf22 "test case"}_sr )\par
9870                    << {\cf23 ')'} << {\cf23 '\\n'};\par
9871             {\cf19 return};\par
9872         \}\par
9873 \par
9874         std::vector<SummaryColumn> columns;\par
9875         {\cf20 // Don't include "skipped assertions" in total count}\par
9876         {\cf17 const} {\cf17 auto} totalAssertionCount =\par
9877             totals.assertions.total() - totals.assertions.skipped;\par
9878         columns.push_back( SummaryColumn( {\cf22 ""}, Colour::None )\par
9879                                .addRow( totals.testCases.total() )\par
9880                                .addRow( totalAssertionCount ) );\par
9881         columns.push_back( SummaryColumn( {\cf22 "passed"}, Colour::Success )\par
9882                                .addRow( totals.testCases.passed )\par
9883                                .addRow( totals.assertions.passed ) );\par
9884         columns.push_back( SummaryColumn( {\cf22 "failed"}, Colour::ResultError )\par
9885                                .addRow( totals.testCases.failed )\par
9886                                .addRow( totals.assertions.failed ) );\par
9887         columns.push_back( SummaryColumn( {\cf22 "skipped"}, Colour::Skip )\par
9888                                .addRow( totals.testCases.skipped )\par
9889                                {\cf20 // Don't print "skipped assertions"}\par
9890                                .addRow( 0 ) );\par
9891         columns.push_back(\par
9892             SummaryColumn( {\cf22 "failed as expected"}, Colour::ResultExpectedFailure )\par
9893                 .addRow( totals.testCases.failedButOk )\par
9894                 .addRow( totals.assertions.failedButOk ) );\par
9895         printSummaryRow( stream, streamColour, {\cf22 "test cases"}_sr, columns, 0 );\par
9896         printSummaryRow( stream, streamColour, {\cf22 "assertions"}_sr, columns, 1 );\par
9897     \}\par
9898 \par
9899 \} {\cf20 // namespace Catch}\par
9900 \par
9901 \par
9902 {\cf20 //}\par
9903 \par
9904 {\cf17 namespace }Catch \{\par
9905     {\cf17 namespace }\{\par
9906         {\cf18 void} writeSourceInfo( JsonObjectWriter& writer,\par
9907                               SourceLineInfo {\cf17 const}& sourceInfo ) \{\par
9908             {\cf17 auto} source_location_writer =\par
9909                 writer.write( {\cf22 "source-location"}_sr ).writeObject();\par
9910             source_location_writer.write( {\cf22 "filename"}_sr )\par
9911                 .write( sourceInfo.file );\par
9912             source_location_writer.write( {\cf22 "line"}_sr ).write( sourceInfo.line );\par
9913         \}\par
9914 \par
9915         {\cf18 void} writeTags( JsonArrayWriter writer, std::vector<Tag> {\cf17 const}& tags ) \{\par
9916             {\cf19 for} ( {\cf17 auto} {\cf17 const}& tag : tags ) \{\par
9917                 writer.write( tag.original );\par
9918             \}\par
9919         \}\par
9920 \par
9921         {\cf18 void} writeProperties( JsonArrayWriter writer,\par
9922                               TestCaseInfo {\cf17 const}& info ) \{\par
9923             {\cf19 if} ( info.isHidden() ) \{ writer.write( {\cf22 "is-hidden"}_sr ); \}\par
9924             {\cf19 if} ( info.okToFail() ) \{ writer.write( {\cf22 "ok-to-fail"}_sr ); \}\par
9925             {\cf19 if} ( info.expectedToFail() ) \{\par
9926                 writer.write( {\cf22 "expected-to-fail"}_sr );\par
9927             \}\par
9928             {\cf19 if} ( info.throws() ) \{ writer.write( {\cf22 "throws"}_sr ); \}\par
9929         \}\par
9930 \par
9931     \} {\cf20 // namespace}\par
9932 \par
9933     JsonReporter::JsonReporter( ReporterConfig&& config ):\par
9934         StreamingReporterBase\{ CATCH_MOVE( config ) \} \{\par
9935 \par
9936         m_preferences.shouldRedirectStdOut = {\cf17 true};\par
9937         {\cf20 // TBD: Do we want to report all assertions? XML reporter does}\par
9938         {\cf20 //      not, but for machine-parseable reporters I think the answer}\par
9939         {\cf20 //      should be yes.}\par
9940         m_preferences.shouldReportAllAssertions = {\cf17 true};\par
9941 \par
9942         m_objectWriters.emplace( m_stream );\par
9943         m_writers.emplace( Writer::Object );\par
9944         {\cf17 auto}& writer = m_objectWriters.top();\par
9945 \par
9946         writer.write( {\cf22 "version"}_sr ).write( 1 );\par
9947 \par
9948         \{\par
9949             {\cf17 auto} metadata_writer = writer.write( {\cf22 "metadata"}_sr ).writeObject();\par
9950             metadata_writer.write( {\cf22 "name"}_sr ).write( m_config->name() );\par
9951             metadata_writer.write( {\cf22 "rng-seed"}_sr ).write( m_config->rngSeed() );\par
9952             metadata_writer.write( {\cf22 "catch2-version"}_sr )\par
9953                 .write( libraryVersion() );\par
9954             {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
9955                 metadata_writer.write( {\cf22 "filters"}_sr )\par
9956                     .write( m_config->testSpec() );\par
9957             \}\par
9958         \}\par
9959     \}\par
9960 \par
9961     JsonReporter::~JsonReporter() \{\par
9962         endListing();\par
9963         {\cf20 // TODO: Ensure this closes the top level object, add asserts}\par
9964         assert( m_writers.size() == 1 && {\cf22 "Only the top level object should be open"} );\par
9965         assert( m_writers.top() == Writer::Object );\par
9966         endObject();\par
9967         m_stream << {\cf23 '\\n'} << std::flush;\par
9968         assert( m_writers.empty() );\par
9969     \}\par
9970 \par
9971     JsonArrayWriter& JsonReporter::startArray() \{\par
9972         m_arrayWriters.emplace( m_arrayWriters.top().writeArray() );\par
9973         m_writers.emplace( Writer::Array );\par
9974         {\cf19 return} m_arrayWriters.top();\par
9975     \}\par
9976     JsonArrayWriter& JsonReporter::startArray( StringRef key ) \{\par
9977         m_arrayWriters.emplace(\par
9978             m_objectWriters.top().write( key ).writeArray() );\par
9979         m_writers.emplace( Writer::Array );\par
9980         {\cf19 return} m_arrayWriters.top();\par
9981     \}\par
9982 \par
9983     JsonObjectWriter& JsonReporter::startObject() \{\par
9984         m_objectWriters.emplace( m_arrayWriters.top().writeObject() );\par
9985         m_writers.emplace( Writer::Object );\par
9986         {\cf19 return} m_objectWriters.top();\par
9987     \}\par
9988     JsonObjectWriter& JsonReporter::startObject( StringRef key ) \{\par
9989         m_objectWriters.emplace(\par
9990             m_objectWriters.top().write( key ).writeObject() );\par
9991         m_writers.emplace( Writer::Object );\par
9992         {\cf19 return} m_objectWriters.top();\par
9993     \}\par
9994 \par
9995     {\cf18 void} JsonReporter::endObject() \{\par
9996         assert( isInside( Writer::Object ) );\par
9997         m_objectWriters.pop();\par
9998         m_writers.pop();\par
9999     \}\par
10000     {\cf18 void} JsonReporter::endArray() \{\par
10001         assert( isInside( Writer::Array ) );\par
10002         m_arrayWriters.pop();\par
10003         m_writers.pop();\par
10004     \}\par
10005 \par
10006     {\cf18 bool} JsonReporter::isInside( Writer writer ) \{\par
10007         {\cf19 return} !m_writers.empty() && m_writers.top() == writer;\par
10008     \}\par
10009 \par
10010     {\cf18 void} JsonReporter::startListing() \{\par
10011         {\cf19 if} ( !m_startedListing ) \{ startObject( {\cf22 "listings"}_sr ); \}\par
10012         m_startedListing = {\cf17 true};\par
10013     \}\par
10014     {\cf18 void} JsonReporter::endListing() \{\par
10015         {\cf19 if} ( m_startedListing ) \{ endObject(); \}\par
10016         m_startedListing = {\cf17 false};\par
10017     \}\par
10018 \par
10019     std::string JsonReporter::getDescription() \{\par
10020         {\cf19 return} {\cf22 "Outputs listings as JSON. Test listing is Work-in-Progress!"};\par
10021     \}\par
10022 \par
10023     {\cf18 void} JsonReporter::testRunStarting( TestRunInfo {\cf17 const}& runInfo ) \{\par
10024         StreamingReporterBase::testRunStarting( runInfo );\par
10025         endListing();\par
10026 \par
10027         assert( isInside( Writer::Object ) );\par
10028         startObject( {\cf22 "test-run"}_sr );\par
10029         startArray( {\cf22 "test-cases"}_sr );\par
10030     \}\par
10031 \par
10032      {\cf17 static} {\cf18 void} writeCounts( JsonObjectWriter&& writer, Counts {\cf17 const}& counts ) \{\par
10033         writer.write( {\cf22 "passed"}_sr ).write( counts.passed );\par
10034         writer.write( {\cf22 "failed"}_sr ).write( counts.failed );\par
10035         writer.write( {\cf22 "fail-but-ok"}_sr ).write( counts.failedButOk );\par
10036         writer.write( {\cf22 "skipped"}_sr ).write( counts.skipped );\par
10037     \}\par
10038 \par
10039     {\cf18 void} JsonReporter::testRunEnded(TestRunStats {\cf17 const}& runStats) \{\par
10040         assert( isInside( Writer::Array ) );\par
10041         {\cf20 // End "test-cases"}\par
10042         endArray();\par
10043 \par
10044         \{\par
10045             {\cf17 auto} totals =\par
10046                 m_objectWriters.top().write( {\cf22 "totals"}_sr ).writeObject();\par
10047             writeCounts( totals.write( {\cf22 "assertions"}_sr ).writeObject(),\par
10048                          runStats.totals.assertions );\par
10049             writeCounts( totals.write( {\cf22 "test-cases"}_sr ).writeObject(),\par
10050                          runStats.totals.testCases );\par
10051         \}\par
10052 \par
10053         {\cf20 // End the "test-run" object}\par
10054         endObject();\par
10055     \}\par
10056 \par
10057     {\cf18 void} JsonReporter::testCaseStarting( TestCaseInfo {\cf17 const}& tcInfo ) \{\par
10058         StreamingReporterBase::testCaseStarting( tcInfo );\par
10059 \par
10060         assert( isInside( Writer::Array ) &&\par
10061                 {\cf22 "We should be in the 'test-cases' array"} );\par
10062         startObject();\par
10063         {\cf20 // "test-info" prelude}\par
10064         \{\par
10065             {\cf17 auto} testInfo =\par
10066                 m_objectWriters.top().write( {\cf22 "test-info"}_sr ).writeObject();\par
10067             {\cf20 // TODO: handle testName vs className!!}\par
10068             testInfo.write( {\cf22 "name"}_sr ).write( tcInfo.name );\par
10069             writeSourceInfo(testInfo, tcInfo.lineInfo);\par
10070             writeTags( testInfo.write( {\cf22 "tags"}_sr ).writeArray(), tcInfo.tags );\par
10071             writeProperties( testInfo.write( {\cf22 "properties"}_sr ).writeArray(),\par
10072                              tcInfo );\par
10073         \}\par
10074 \par
10075 \par
10076         {\cf20 // Start the array for individual test runs (testCasePartial pairs)}\par
10077         startArray( {\cf22 "runs"}_sr );\par
10078     \}\par
10079 \par
10080     {\cf18 void} JsonReporter::testCaseEnded( TestCaseStats {\cf17 const}& tcStats ) \{\par
10081         StreamingReporterBase::testCaseEnded( tcStats );\par
10082 \par
10083         {\cf20 // We need to close the 'runs' array before finishing the test case}\par
10084         assert( isInside( Writer::Array ) );\par
10085         endArray();\par
10086 \par
10087         \{\par
10088             {\cf17 auto} totals =\par
10089                 m_objectWriters.top().write( {\cf22 "totals"}_sr ).writeObject();\par
10090             writeCounts( totals.write( {\cf22 "assertions"}_sr ).writeObject(),\par
10091                          tcStats.totals.assertions );\par
10092             {\cf20 // We do not write the test case totals, because there will always be just one test case here.}\par
10093             {\cf20 // TODO: overall "result" -> success, skip, fail here? Or in partial result?}\par
10094         \}\par
10095         {\cf20 // We do not write out stderr/stdout, because we instead wrote those out in partial runs}\par
10096 \par
10097         {\cf20 // TODO: aborting?}\par
10098 \par
10099         {\cf20 // And we also close this test case's object}\par
10100         assert( isInside( Writer::Object ) );\par
10101         endObject();\par
10102     \}\par
10103 \par
10104     {\cf18 void} JsonReporter::testCasePartialStarting( TestCaseInfo {\cf17 const}& {\cf20 /*tcInfo*/},\par
10105                                                 uint64_t index ) \{\par
10106         startObject();\par
10107         m_objectWriters.top().write( {\cf22 "run-idx"}_sr ).write( index );\par
10108         startArray( {\cf22 "path"}_sr );\par
10109         {\cf20 // TODO: we want to delay most of the printing to the 'root' section}\par
10110         {\cf20 // TODO: childSection key name?}\par
10111     \}\par
10112 \par
10113     {\cf18 void} JsonReporter::testCasePartialEnded( TestCaseStats {\cf17 const}& tcStats,\par
10114                                              uint64_t {\cf20 /*index*/} ) \{\par
10115         {\cf20 // Fixme: the top level section handles this.}\par
10117         endArray();\par
10118         {\cf19 if} ( !tcStats.stdOut.empty() ) \{\par
10119             m_objectWriters.top()\par
10120                 .write( {\cf22 "captured-stdout"}_sr )\par
10121                 .write( tcStats.stdOut );\par
10122         \}\par
10123         {\cf19 if} ( !tcStats.stdErr.empty() ) \{\par
10124             m_objectWriters.top()\par
10125                 .write( {\cf22 "captured-stderr"}_sr )\par
10126                 .write( tcStats.stdErr );\par
10127         \}\par
10128         \{\par
10129             {\cf17 auto} totals =\par
10130                 m_objectWriters.top().write( {\cf22 "totals"}_sr ).writeObject();\par
10131             writeCounts( totals.write( {\cf22 "assertions"}_sr ).writeObject(),\par
10132                          tcStats.totals.assertions );\par
10133             {\cf20 // We do not write the test case totals, because there will}\par
10134             {\cf20 // always be just one test case here.}\par
10135             {\cf20 // TODO: overall "result" -> success, skip, fail here? Or in}\par
10136             {\cf20 // partial result?}\par
10137         \}\par
10138         {\cf20 // TODO: aborting?}\par
10139         {\cf20 // run object}\par
10140         endObject();\par
10141     \}\par
10142 \par
10143     {\cf18 void} JsonReporter::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
10144         assert( isInside( Writer::Array ) &&\par
10145                 {\cf22 "Section should always start inside an object"} );\par
10146         {\cf20 // We want to nest top level sections, even though it shares name}\par
10147         {\cf20 // and source loc with the TEST_CASE}\par
10148         {\cf17 auto}& sectionObject = startObject();\par
10149         sectionObject.write( {\cf22 "kind"}_sr ).write( {\cf22 "section"}_sr );\par
10150         sectionObject.write( {\cf22 "name"}_sr ).write( sectionInfo.name );\par
10151         writeSourceInfo( m_objectWriters.top(), sectionInfo.lineInfo );\par
10152 \par
10153 \par
10154         {\cf20 // TBD: Do we want to create this event lazily? It would become}\par
10155         {\cf20 //      rather complex, but we could do it, and it would look}\par
10156         {\cf20 //      better for empty sections. OTOH, empty sections should}\par
10157         {\cf20 //      be rare.}\par
10158         startArray( {\cf22 "path"}_sr );\par
10159     \}\par
10160     {\cf18 void} JsonReporter::sectionEnded( SectionStats {\cf17 const}& {\cf20 /*sectionStats */}) \{\par
10161         {\cf20 // End the subpath array}\par
10162         endArray();\par
10163         {\cf20 // TODO: metadata}\par
10164         {\cf20 // TODO: what info do we have here?}\par
10165 \par
10166         {\cf20 // End the section object}\par
10167         endObject();\par
10168     \}\par
10169 \par
10170     {\cf18 void} JsonReporter::assertionStarting( AssertionInfo {\cf17 const}& {\cf20 /*assertionInfo*/} ) \{\}\par
10171     {\cf18 void} JsonReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
10172         {\cf20 // TODO: There is lot of different things to handle here, but}\par
10173         {\cf20 //       we can fill it in later, after we show that the basic}\par
10174         {\cf20 //       outline and streaming reporter impl works well enough.}\par
10175         {\cf20 //if ( !m_config->includeSuccessfulResults()}\par
10176         {\cf20 //    && assertionStats.assertionResult.isOk() ) \{}\par
10177         {\cf20 //    return;}\par
10178         {\cf20 //\}}\par
10179         assert( isInside( Writer::Array ) );\par
10180         {\cf17 auto} assertionObject = m_arrayWriters.top().writeObject();\par
10181 \par
10182         assertionObject.write( {\cf22 "kind"}_sr ).write( {\cf22 "assertion"}_sr );\par
10183         writeSourceInfo( assertionObject,\par
10184                          assertionStats.assertionResult.getSourceInfo() );\par
10185         assertionObject.write( {\cf22 "status"}_sr )\par
10186             .write( assertionStats.assertionResult.isOk() );\par
10187         {\cf20 // TODO: handling of result.}\par
10188         {\cf20 // TODO: messages}\par
10189         {\cf20 // TODO: totals?}\par
10190     \}\par
10191 \par
10192 \par
10193     {\cf18 void} JsonReporter::benchmarkPreparing( StringRef name ) \{ (void)name; \}\par
10194     {\cf18 void} JsonReporter::benchmarkStarting( BenchmarkInfo {\cf17 const}& ) \{\}\par
10195     {\cf18 void} JsonReporter::benchmarkEnded( BenchmarkStats<> {\cf17 const}& ) \{\}\par
10196     {\cf18 void} JsonReporter::benchmarkFailed( StringRef error ) \{ (void)error; \}\par
10197 \par
10198     {\cf18 void} JsonReporter::listReporters(\par
10199         std::vector<ReporterDescription> {\cf17 const}& descriptions ) \{\par
10200         startListing();\par
10201 \par
10202         {\cf17 auto} writer =\par
10203             m_objectWriters.top().write( {\cf22 "reporters"}_sr ).writeArray();\par
10204         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
10205             {\cf17 auto} desc_writer = writer.writeObject();\par
10206             desc_writer.write( {\cf22 "name"}_sr ).write( desc.name );\par
10207             desc_writer.write( {\cf22 "description"}_sr ).write( desc.description );\par
10208         \}\par
10209     \}\par
10210     {\cf18 void} JsonReporter::listListeners(\par
10211         std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
10212         startListing();\par
10213 \par
10214         {\cf17 auto} writer =\par
10215             m_objectWriters.top().write( {\cf22 "listeners"}_sr ).writeArray();\par
10216 \par
10217         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
10218             {\cf17 auto} desc_writer = writer.writeObject();\par
10219             desc_writer.write( {\cf22 "name"}_sr ).write( desc.name );\par
10220             desc_writer.write( {\cf22 "description"}_sr ).write( desc.description );\par
10221         \}\par
10222     \}\par
10223     {\cf18 void} JsonReporter::listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) \{\par
10224         startListing();\par
10225 \par
10226         {\cf17 auto} writer = m_objectWriters.top().write( {\cf22 "tests"}_sr ).writeArray();\par
10227 \par
10228         {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : tests ) \{\par
10229             {\cf17 auto} desc_writer = writer.writeObject();\par
10230             {\cf17 auto} {\cf17 const}& info = test.getTestCaseInfo();\par
10231 \par
10232             desc_writer.write( {\cf22 "name"}_sr ).write( info.name );\par
10233             desc_writer.write( {\cf22 "class-name"}_sr ).write( info.className );\par
10234             \{\par
10235                 {\cf17 auto} tag_writer = desc_writer.write( {\cf22 "tags"}_sr ).writeArray();\par
10236                 {\cf19 for} ( {\cf17 auto} {\cf17 const}& tag : info.tags ) \{\par
10237                     tag_writer.write( tag.original );\par
10238                 \}\par
10239             \}\par
10240             writeSourceInfo( desc_writer, info.lineInfo );\par
10241         \}\par
10242     \}\par
10243     {\cf18 void} JsonReporter::listTags( std::vector<TagInfo> {\cf17 const}& tags ) \{\par
10244         startListing();\par
10245 \par
10246         {\cf17 auto} writer = m_objectWriters.top().write( {\cf22 "tags"}_sr ).writeArray();\par
10247         {\cf19 for} ( {\cf17 auto} {\cf17 const}& tag : tags ) \{\par
10248             {\cf17 auto} tag_writer = writer.writeObject();\par
10249             \{\par
10250                 {\cf17 auto} aliases_writer =\par
10251                     tag_writer.write( {\cf22 "aliases"}_sr ).writeArray();\par
10252                 {\cf19 for} ( {\cf17 auto} alias : tag.spellings ) \{\par
10253                     aliases_writer.write( alias );\par
10254                 \}\par
10255             \}\par
10256             tag_writer.write( {\cf22 "count"}_sr ).write( tag.count );\par
10257         \}\par
10258     \}\par
10259 \} {\cf20 // namespace Catch}\par
10260 \par
10261 \par
10262 \par
10263 \par
10264 {\cf21 #include <cassert>}\par
10265 {\cf21 #include <ctime>}\par
10266 {\cf21 #include <algorithm>}\par
10267 {\cf21 #include <iomanip>}\par
10268 \par
10269 {\cf17 namespace }Catch \{\par
10270 \par
10271     {\cf17 namespace }\{\par
10272         std::string getCurrentTimestamp() \{\par
10273             time_t rawtime;\par
10274             std::time(&rawtime);\par
10275 \par
10276             std::tm timeInfo = \{\};\par
10277 {\cf21 #if defined (_MSC_VER) || defined (__MINGW32__)}\par
10278             gmtime_s(&timeInfo, &rawtime);\par
10279 {\cf21 #elif defined (CATCH_PLATFORM_PLAYSTATION)}\par
10280             gmtime_s(&rawtime, &timeInfo);\par
10281 {\cf21 #elif defined (__IAR_SYSTEMS_ICC__)}\par
10282             timeInfo = *std::gmtime(&rawtime);\par
10283 {\cf21 #else}\par
10284             gmtime_r(&rawtime, &timeInfo);\par
10285 {\cf21 #endif}\par
10286 \par
10287             {\cf17 auto} {\cf17 const} timeStampSize = {\cf17 sizeof}({\cf22 "2017-01-16T17:06:45Z"});\par
10288             {\cf18 char} timeStamp[timeStampSize];\par
10289             {\cf17 const} {\cf18 char} * {\cf17 const} fmt = {\cf22 "%Y-%m-%dT%H:%M:%SZ"};\par
10290 \par
10291             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\par
10292 \par
10293             {\cf19 return} std::string(timeStamp, timeStampSize - 1);\par
10294         \}\par
10295 \par
10296         std::string fileNameTag(std::vector<Tag> {\cf17 const}& tags) \{\par
10297             {\cf17 auto} it = std::find_if(begin(tags),\par
10298                                    end(tags),\par
10299                                    [] (Tag {\cf17 const}& tag) \{\par
10300                                        {\cf19 return} tag.original.size() > 0\par
10301                                            && tag.original[0] == {\cf23 '#'}; \});\par
10302             {\cf19 if} (it != tags.end()) \{\par
10303                 {\cf19 return} {\cf17 static_cast<}std::string{\cf17 >}(\par
10304                     it->original.substr(1, it->original.size() - 1)\par
10305                 );\par
10306             \}\par
10307             {\cf19 return} std::string();\par
10308         \}\par
10309 \par
10310         {\cf20 // Formats the duration in seconds to 3 decimal places.}\par
10311         {\cf20 // This is done because some genius defined Maven Surefire schema}\par
10312         {\cf20 // in a way that only accepts 3 decimal places, and tools like}\par
10313         {\cf20 // Jenkins use that schema for validation JUnit reporter output.}\par
10314         std::string formatDuration( {\cf18 double} seconds ) \{\par
10315             ReusableStringStream rss;\par
10316             rss << std::fixed << std::setprecision( 3 ) << seconds;\par
10317             {\cf19 return} rss.str();\par
10318         \}\par
10319 \par
10320         {\cf17 static} {\cf18 void} normalizeNamespaceMarkers(std::string& str) \{\par
10321             std::size_t pos = str.find( {\cf22 "::"} );\par
10322             {\cf19 while} ( pos != std::string::npos ) \{\par
10323                 str.replace( pos, 2, {\cf22 "."} );\par
10324                 pos += 1;\par
10325                 pos = str.find( {\cf22 "::"}, pos );\par
10326             \}\par
10327         \}\par
10328 \par
10329     \} {\cf20 // anonymous namespace}\par
10330 \par
10331     JunitReporter::JunitReporter( ReporterConfig&& _config )\par
10332         :   CumulativeReporterBase( CATCH_MOVE(_config) ),\par
10333             xml( m_stream )\par
10334         \{\par
10335             m_preferences.shouldRedirectStdOut = {\cf17 true};\par
10336             m_preferences.shouldReportAllAssertions = {\cf17 true};\par
10337             m_shouldStoreSuccesfulAssertions = {\cf17 false};\par
10338         \}\par
10339 \par
10340     std::string JunitReporter::getDescription() \{\par
10341         {\cf19 return} {\cf22 "Reports test results in an XML format that looks like Ant's junitreport target"};\par
10342     \}\par
10343 \par
10344     {\cf18 void} JunitReporter::testRunStarting( TestRunInfo {\cf17 const}& runInfo )  \{\par
10345         CumulativeReporterBase::testRunStarting( runInfo );\par
10346         xml.startElement( {\cf22 "testsuites"} );\par
10347         suiteTimer.start();\par
10348         stdOutForSuite.clear();\par
10349         stdErrForSuite.clear();\par
10350         unexpectedExceptions = 0;\par
10351     \}\par
10352 \par
10353     {\cf18 void} JunitReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testCaseInfo ) \{\par
10354         m_okToFail = testCaseInfo.okToFail();\par
10355     \}\par
10356 \par
10357     {\cf18 void} JunitReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
10358         {\cf19 if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )\par
10359             unexpectedExceptions++;\par
10360         CumulativeReporterBase::assertionEnded( assertionStats );\par
10361     \}\par
10362 \par
10363     {\cf18 void} JunitReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
10364         stdOutForSuite += testCaseStats.stdOut;\par
10365         stdErrForSuite += testCaseStats.stdErr;\par
10366         CumulativeReporterBase::testCaseEnded( testCaseStats );\par
10367     \}\par
10368 \par
10369     {\cf18 void} JunitReporter::testRunEndedCumulative() \{\par
10370         {\cf17 const} {\cf17 auto} suiteTime = suiteTimer.getElapsedSeconds();\par
10371         writeRun( *m_testRun, suiteTime );\par
10372         xml.endElement();\par
10373     \}\par
10374 \par
10375     {\cf18 void} JunitReporter::writeRun( TestRunNode {\cf17 const}& testRunNode, {\cf18 double} suiteTime ) \{\par
10376         XmlWriter::ScopedElement e = xml.scopedElement( {\cf22 "testsuite"} );\par
10377 \par
10378         TestRunStats {\cf17 const}& stats = testRunNode.value;\par
10379         xml.writeAttribute( {\cf22 "name"}_sr, stats.runInfo.name );\par
10380         xml.writeAttribute( {\cf22 "errors"}_sr, unexpectedExceptions );\par
10381         xml.writeAttribute( {\cf22 "failures"}_sr, stats.totals.assertions.failed-unexpectedExceptions );\par
10382         xml.writeAttribute( {\cf22 "skipped"}_sr, stats.totals.assertions.skipped );\par
10383         xml.writeAttribute( {\cf22 "tests"}_sr, stats.totals.assertions.total() );\par
10384         xml.writeAttribute( {\cf22 "hostname"}_sr, {\cf22 "tbd"}_sr ); {\cf20 // !TBD}\par
10385         {\cf19 if}( m_config->showDurations() == ShowDurations::Never )\par
10386             xml.writeAttribute( {\cf22 "time"}_sr, {\cf22 ""}_sr );\par
10387         {\cf19 else}\par
10388             xml.writeAttribute( {\cf22 "time"}_sr, formatDuration( suiteTime ) );\par
10389         xml.writeAttribute( {\cf22 "timestamp"}_sr, getCurrentTimestamp() );\par
10390 \par
10391         {\cf20 // Write properties}\par
10392         \{\par
10393             {\cf17 auto} properties = xml.scopedElement({\cf22 "properties"});\par
10394             xml.scopedElement({\cf22 "property"})\par
10395                 .writeAttribute({\cf22 "name"}_sr, {\cf22 "random-seed"}_sr)\par
10396                 .writeAttribute({\cf22 "value"}_sr, m_config->rngSeed());\par
10397             {\cf19 if} (m_config->testSpec().hasFilters()) \{\par
10398                 xml.scopedElement({\cf22 "property"})\par
10399                     .writeAttribute({\cf22 "name"}_sr, {\cf22 "filters"}_sr)\par
10400                     .writeAttribute({\cf22 "value"}_sr, m_config->testSpec());\par
10401             \}\par
10402         \}\par
10403 \par
10404         {\cf20 // Write test cases}\par
10405         {\cf19 for}( {\cf17 auto} {\cf17 const}& child : testRunNode.children )\par
10406             writeTestCase( *child );\par
10407 \par
10408         xml.scopedElement( {\cf22 "system-out"} ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );\par
10409         xml.scopedElement( {\cf22 "system-err"} ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );\par
10410     \}\par
10411 \par
10412     {\cf18 void} JunitReporter::writeTestCase( TestCaseNode {\cf17 const}& testCaseNode ) \{\par
10413         TestCaseStats {\cf17 const}& stats = testCaseNode.value;\par
10414 \par
10415         {\cf20 // All test cases have exactly one section - which represents the}\par
10416         {\cf20 // test case itself. That section may have 0-n nested sections}\par
10417         assert( testCaseNode.children.size() == 1 );\par
10418         SectionNode {\cf17 const}& rootSection = *testCaseNode.children.front();\par
10419 \par
10420         std::string className =\par
10421             {\cf17 static_cast<}std::string{\cf17 >}( stats.testInfo->className );\par
10422 \par
10423         {\cf19 if}( className.empty() ) \{\par
10424             className = fileNameTag(stats.testInfo->tags);\par
10425             {\cf19 if} ( className.empty() ) \{\par
10426                 className = {\cf22 "global"};\par
10427             \}\par
10428         \}\par
10429 \par
10430         {\cf19 if} ( !m_config->name().empty() )\par
10431             className = {\cf17 static_cast<}std::string{\cf17 >}(m_config->name()) + {\cf23 '.'} + className;\par
10432 \par
10433         normalizeNamespaceMarkers(className);\par
10434 \par
10435         writeSection( className, {\cf22 ""}, rootSection, stats.testInfo->okToFail() );\par
10436     \}\par
10437 \par
10438     {\cf18 void} JunitReporter::writeSection( std::string {\cf17 const}& className,\par
10439                                       std::string {\cf17 const}& rootName,\par
10440                                       SectionNode {\cf17 const}& sectionNode,\par
10441                                       {\cf18 bool} testOkToFail) \{\par
10442         std::string name = trim( sectionNode.stats.sectionInfo.name );\par
10443         {\cf19 if}( !rootName.empty() )\par
10444             name = rootName + {\cf23 '/'} + name;\par
10445 \par
10446         {\cf19 if}( sectionNode.hasAnyAssertions()\par
10447            || !sectionNode.stdOut.empty()\par
10448            || !sectionNode.stdErr.empty() ) \{\par
10449             XmlWriter::ScopedElement e = xml.scopedElement( {\cf22 "testcase"} );\par
10450             {\cf19 if}( className.empty() ) \{\par
10451                 xml.writeAttribute( {\cf22 "classname"}_sr, name );\par
10452                 xml.writeAttribute( {\cf22 "name"}_sr, {\cf22 "root"}_sr );\par
10453             \}\par
10454             {\cf19 else} \{\par
10455                 xml.writeAttribute( {\cf22 "classname"}_sr, className );\par
10456                 xml.writeAttribute( {\cf22 "name"}_sr, name );\par
10457             \}\par
10458             xml.writeAttribute( {\cf22 "time"}_sr, formatDuration( sectionNode.stats.durationInSeconds ) );\par
10459             {\cf20 // This is not ideal, but it should be enough to mimic gtest's}\par
10460             {\cf20 // junit output.}\par
10461             {\cf20 // Ideally the JUnit reporter would also handle `skipTest`}\par
10462             {\cf20 // events and write those out appropriately.}\par
10463             xml.writeAttribute( {\cf22 "status"}_sr, {\cf22 "run"}_sr );\par
10464 \par
10465             {\cf19 if} (sectionNode.stats.assertions.failedButOk) \{\par
10466                 xml.scopedElement({\cf22 "skipped"})\par
10467                     .writeAttribute({\cf22 "message"}, {\cf22 "TEST_CASE tagged with !mayfail"});\par
10468             \}\par
10469 \par
10470             writeAssertions( sectionNode );\par
10471 \par
10472 \par
10473             {\cf19 if}( !sectionNode.stdOut.empty() )\par
10474                 xml.scopedElement( {\cf22 "system-out"} ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );\par
10475             {\cf19 if}( !sectionNode.stdErr.empty() )\par
10476                 xml.scopedElement( {\cf22 "system-err"} ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );\par
10477         \}\par
10478         {\cf19 for}( {\cf17 auto} {\cf17 const}& childNode : sectionNode.childSections )\par
10479             {\cf19 if}( className.empty() )\par
10480                 writeSection( name, {\cf22 ""}, *childNode, testOkToFail );\par
10481             {\cf19 else}\par
10482                 writeSection( className, name, *childNode, testOkToFail );\par
10483     \}\par
10484 \par
10485     {\cf18 void} JunitReporter::writeAssertions( SectionNode {\cf17 const}& sectionNode ) \{\par
10486         {\cf19 for} ({\cf17 auto} {\cf17 const}& assertionOrBenchmark : sectionNode.assertionsAndBenchmarks) \{\par
10487             {\cf19 if} (assertionOrBenchmark.isAssertion()) \{\par
10488                 writeAssertion(assertionOrBenchmark.asAssertion());\par
10489             \}\par
10490         \}\par
10491     \}\par
10492 \par
10493     {\cf18 void} JunitReporter::writeAssertion( AssertionStats {\cf17 const}& stats ) \{\par
10494         AssertionResult {\cf17 const}& result = stats.assertionResult;\par
10495         {\cf19 if} ( !result.isOk() ||\par
10496              result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10497             std::string elementName;\par
10498             {\cf19 switch}( result.getResultType() ) \{\par
10499                 {\cf19 case} ResultWas::ThrewException:\par
10500                 {\cf19 case} ResultWas::FatalErrorCondition:\par
10501                     elementName = {\cf22 "error"};\par
10502                     {\cf19 break};\par
10503                 {\cf19 case} ResultWas::ExplicitFailure:\par
10504                 {\cf19 case} ResultWas::ExpressionFailed:\par
10505                 {\cf19 case} ResultWas::DidntThrowException:\par
10506                     elementName = {\cf22 "failure"};\par
10507                     {\cf19 break};\par
10508                 {\cf19 case} ResultWas::ExplicitSkip:\par
10509                     elementName = {\cf22 "skipped"};\par
10510                     {\cf19 break};\par
10511                 {\cf20 // We should never see these here:}\par
10512                 {\cf19 case} ResultWas::Info:\par
10513                 {\cf19 case} ResultWas::Warning:\par
10514                 {\cf19 case} ResultWas::Ok:\par
10515                 {\cf19 case} ResultWas::Unknown:\par
10516                 {\cf19 case} ResultWas::FailureBit:\par
10517                 {\cf19 case} ResultWas::Exception:\par
10518                     elementName = {\cf22 "internalError"};\par
10519                     {\cf19 break};\par
10520             \}\par
10521 \par
10522             XmlWriter::ScopedElement e = xml.scopedElement( elementName );\par
10523 \par
10524             xml.writeAttribute( {\cf22 "message"}_sr, result.getExpression() );\par
10525             xml.writeAttribute( {\cf22 "type"}_sr, result.getTestMacroName() );\par
10526 \par
10527             ReusableStringStream rss;\par
10528             {\cf19 if} ( result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10529                 rss << {\cf22 "SKIPPED\\n"};\par
10530             \} {\cf19 else} \{\par
10531                 rss << {\cf22 "FAILED"} << {\cf22 ":\\n"};\par
10532                 {\cf19 if} (result.hasExpression()) \{\par
10533                     rss << {\cf22 "  "};\par
10534                     rss << result.getExpressionInMacro();\par
10535                     rss << {\cf23 '\\n'};\par
10536                 \}\par
10537                 {\cf19 if} (result.hasExpandedExpression()) \{\par
10538                     rss << {\cf22 "with expansion:\\n"};\par
10539                     rss << TextFlow::Column(result.getExpandedExpression()).indent(2) << {\cf23 '\\n'};\par
10540                 \}\par
10541             \}\par
10542 \par
10543             {\cf19 if}( result.hasMessage() )\par
10544                 rss << result.getMessage() << {\cf23 '\\n'};\par
10545             {\cf19 for}( {\cf17 auto} {\cf17 const}& msg : stats.infoMessages )\par
10546                 {\cf19 if}( msg.type == ResultWas::Info )\par
10547                     rss << msg.message << {\cf23 '\\n'};\par
10548 \par
10549             rss << {\cf22 "at "} << result.getSourceInfo();\par
10550             xml.writeText( rss.str(), XmlFormatting::Newline );\par
10551         \}\par
10552     \}\par
10553 \par
10554 \} {\cf20 // end namespace Catch}\par
10555 \par
10556 \par
10557 \par
10558 \par
10559 {\cf21 #include <ostream>}\par
10560 \par
10561 {\cf17 namespace }Catch \{\par
10562     {\cf18 void} MultiReporter::updatePreferences(IEventListener {\cf17 const}& reporterish) \{\par
10563         m_preferences.shouldRedirectStdOut |=\par
10564             reporterish.getPreferences().shouldRedirectStdOut;\par
10565         m_preferences.shouldReportAllAssertions |=\par
10566             reporterish.getPreferences().shouldReportAllAssertions;\par
10567     \}\par
10568 \par
10569     {\cf18 void} MultiReporter::addListener( IEventListenerPtr&& listener ) \{\par
10570         updatePreferences(*listener);\par
10571         m_reporterLikes.insert(m_reporterLikes.begin() + m_insertedListeners, CATCH_MOVE(listener) );\par
10572         ++m_insertedListeners;\par
10573     \}\par
10574 \par
10575     {\cf18 void} MultiReporter::addReporter( IEventListenerPtr&& reporter ) \{\par
10576         updatePreferences(*reporter);\par
10577 \par
10578         {\cf20 // We will need to output the captured stdout if there are reporters}\par
10579         {\cf20 // that do not want it captured.}\par
10580         {\cf20 // We do not consider listeners, because it is generally assumed that}\par
10581         {\cf20 // listeners are output-transparent, even though they can ask for stdout}\par
10582         {\cf20 // capture to do something with it.}\par
10583         m_haveNoncapturingReporters |= !reporter->getPreferences().shouldRedirectStdOut;\par
10584 \par
10585         {\cf20 // Reporters can always be placed to the back without breaking the}\par
10586         {\cf20 // reporting order}\par
10587         m_reporterLikes.push_back( CATCH_MOVE( reporter ) );\par
10588     \}\par
10589 \par
10590     {\cf18 void} MultiReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
10591         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10592             reporterish->noMatchingTestCases( unmatchedSpec );\par
10593         \}\par
10594     \}\par
10595 \par
10596     {\cf18 void} MultiReporter::fatalErrorEncountered( StringRef error ) \{\par
10597         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10598             reporterish->fatalErrorEncountered( error );\par
10599         \}\par
10600     \}\par
10601 \par
10602     {\cf18 void} MultiReporter::reportInvalidTestSpec( StringRef arg ) \{\par
10603         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10604             reporterish->reportInvalidTestSpec( arg );\par
10605         \}\par
10606     \}\par
10607 \par
10608     {\cf18 void} MultiReporter::benchmarkPreparing( StringRef name ) \{\par
10609         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10610             reporterish->benchmarkPreparing(name);\par
10611         \}\par
10612     \}\par
10613     {\cf18 void} MultiReporter::benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) \{\par
10614         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10615             reporterish->benchmarkStarting( benchmarkInfo );\par
10616         \}\par
10617     \}\par
10618     {\cf18 void} MultiReporter::benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) \{\par
10619         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10620             reporterish->benchmarkEnded( benchmarkStats );\par
10621         \}\par
10622     \}\par
10623 \par
10624     {\cf18 void} MultiReporter::benchmarkFailed( StringRef error ) \{\par
10625         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10626             reporterish->benchmarkFailed(error);\par
10627         \}\par
10628     \}\par
10629 \par
10630     {\cf18 void} MultiReporter::testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) \{\par
10631         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10632             reporterish->testRunStarting( testRunInfo );\par
10633         \}\par
10634     \}\par
10635 \par
10636     {\cf18 void} MultiReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) \{\par
10637         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10638             reporterish->testCaseStarting( testInfo );\par
10639         \}\par
10640     \}\par
10641 \par
10642     {\cf18 void}\par
10643     MultiReporter::testCasePartialStarting( TestCaseInfo {\cf17 const}& testInfo,\par
10644                                                 uint64_t partNumber ) \{\par
10645         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10646             reporterish->testCasePartialStarting( testInfo, partNumber );\par
10647         \}\par
10648     \}\par
10649 \par
10650     {\cf18 void} MultiReporter::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
10651         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10652             reporterish->sectionStarting( sectionInfo );\par
10653         \}\par
10654     \}\par
10655 \par
10656     {\cf18 void} MultiReporter::assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) \{\par
10657         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10658             reporterish->assertionStarting( assertionInfo );\par
10659         \}\par
10660     \}\par
10661 \par
10662     {\cf18 void} MultiReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
10663         {\cf17 const} {\cf18 bool} reportByDefault =\par
10664             assertionStats.assertionResult.getResultType() != ResultWas::Ok ||\par
10665             m_config->includeSuccessfulResults();\par
10666 \par
10667         {\cf19 for} ( {\cf17 auto} & reporterish : m_reporterLikes ) \{\par
10668             {\cf19 if} ( reportByDefault ||\par
10669                  reporterish->getPreferences().shouldReportAllAssertions ) \{\par
10670                     reporterish->assertionEnded( assertionStats );\par
10671             \}\par
10672         \}\par
10673     \}\par
10674 \par
10675     {\cf18 void} MultiReporter::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
10676         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10677             reporterish->sectionEnded( sectionStats );\par
10678         \}\par
10679     \}\par
10680 \par
10681     {\cf18 void} MultiReporter::testCasePartialEnded( TestCaseStats {\cf17 const}& testStats,\par
10682                                                   uint64_t partNumber ) \{\par
10683         {\cf19 if} ( m_preferences.shouldRedirectStdOut &&\par
10684              m_haveNoncapturingReporters ) \{\par
10685             {\cf19 if} ( !testStats.stdOut.empty() ) \{\par
10686                 Catch::cout() << testStats.stdOut << std::flush;\par
10687             \}\par
10688             {\cf19 if} ( !testStats.stdErr.empty() ) \{\par
10689                 Catch::cerr() << testStats.stdErr << std::flush;\par
10690             \}\par
10691         \}\par
10692 \par
10693         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10694             reporterish->testCasePartialEnded( testStats, partNumber );\par
10695         \}\par
10696     \}\par
10697 \par
10698     {\cf18 void} MultiReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
10699         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10700             reporterish->testCaseEnded( testCaseStats );\par
10701         \}\par
10702     \}\par
10703 \par
10704     {\cf18 void} MultiReporter::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
10705         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10706             reporterish->testRunEnded( testRunStats );\par
10707         \}\par
10708     \}\par
10709 \par
10710 \par
10711     {\cf18 void} MultiReporter::skipTest( TestCaseInfo {\cf17 const}& testInfo ) \{\par
10712         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10713             reporterish->skipTest( testInfo );\par
10714         \}\par
10715     \}\par
10716 \par
10717     {\cf18 void} MultiReporter::listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) \{\par
10718         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10719             reporterish->listReporters(descriptions);\par
10720         \}\par
10721     \}\par
10722 \par
10723     {\cf18 void} MultiReporter::listListeners(\par
10724         std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
10725         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10726             reporterish->listListeners( descriptions );\par
10727         \}\par
10728     \}\par
10729 \par
10730     {\cf18 void} MultiReporter::listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
10731         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10732             reporterish->listTests(tests);\par
10733         \}\par
10734     \}\par
10735 \par
10736     {\cf18 void} MultiReporter::listTags(std::vector<TagInfo> {\cf17 const}& tags) \{\par
10737         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10738             reporterish->listTags(tags);\par
10739         \}\par
10740     \}\par
10741 \par
10742 \} {\cf20 // end namespace Catch}\par
10743 \par
10744 \par
10745 \par
10746 \par
10747 \par
10748 {\cf17 namespace }Catch \{\par
10749     {\cf17 namespace }Detail \{\par
10750 \par
10751         {\cf18 void} registerReporterImpl( std::string {\cf17 const}& name,\par
10752                                    IReporterFactoryPtr reporterPtr ) \{\par
10753             CATCH_TRY \{\par
10754                 getMutableRegistryHub().registerReporter(\par
10755                     name, CATCH_MOVE( reporterPtr ) );\par
10756             \}\par
10757             CATCH_CATCH_ALL \{\par
10758                 {\cf20 // Do not throw when constructing global objects, instead}\par
10759                 {\cf20 // register the exception to be processed later}\par
10760                 getMutableRegistryHub().registerStartupException();\par
10761             \}\par
10762         \}\par
10763 \par
10764         {\cf18 void} registerListenerImpl( Detail::unique_ptr<EventListenerFactory> listenerFactory ) \{\par
10765             getMutableRegistryHub().registerListener( CATCH_MOVE(listenerFactory) );\par
10766         \}\par
10767 \par
10768 \par
10769     \} {\cf20 // namespace Detail}\par
10770 \} {\cf20 // namespace Catch}\par
10771 \par
10772 \par
10773 \par
10774 \par
10775 {\cf21 #include <map>}\par
10776 \par
10777 {\cf17 namespace }Catch \{\par
10778 \par
10779     {\cf17 namespace }\{\par
10780         std::string createMetadataString(IConfig {\cf17 const}& config) \{\par
10781             ReusableStringStream sstr;\par
10782             {\cf19 if} ( config.testSpec().hasFilters() ) \{\par
10783                 sstr << {\cf22 "filters='"}\par
10784                          << config.testSpec()\par
10785                          << {\cf22 "' "};\par
10786             \}\par
10787             sstr << {\cf22 "rng-seed="} << config.rngSeed();\par
10788             {\cf19 return} sstr.str();\par
10789         \}\par
10790     \}\par
10791 \par
10792     {\cf18 void} SonarQubeReporter::testRunStarting(TestRunInfo {\cf17 const}& testRunInfo) \{\par
10793         CumulativeReporterBase::testRunStarting(testRunInfo);\par
10794 \par
10795         xml.writeComment( createMetadataString( *m_config ) );\par
10796         xml.startElement({\cf22 "testExecutions"});\par
10797         xml.writeAttribute({\cf22 "version"}_sr, {\cf23 '1'});\par
10798     \}\par
10799 \par
10800     {\cf18 void} SonarQubeReporter::writeRun( TestRunNode {\cf17 const}& runNode ) \{\par
10801         std::map<StringRef, std::vector<TestCaseNode const*>> testsPerFile;\par
10802 \par
10803         {\cf19 for} ( {\cf17 auto} {\cf17 const}& child : runNode.children ) \{\par
10804             testsPerFile[child->value.testInfo->lineInfo.file].push_back(\par
10805                 child.get() );\par
10806         \}\par
10807 \par
10808         {\cf19 for} ( {\cf17 auto} {\cf17 const}& kv : testsPerFile ) \{\par
10809             writeTestFile( kv.first, kv.second );\par
10810         \}\par
10811     \}\par
10812 \par
10813     {\cf18 void} SonarQubeReporter::writeTestFile(StringRef filename, std::vector<TestCaseNode const*> {\cf17 const}& testCaseNodes) \{\par
10814         XmlWriter::ScopedElement e = xml.scopedElement({\cf22 "file"});\par
10815         xml.writeAttribute({\cf22 "path"}_sr, filename);\par
10816 \par
10817         {\cf19 for} ({\cf17 auto} {\cf17 const}& child : testCaseNodes)\par
10818             writeTestCase(*child);\par
10819     \}\par
10820 \par
10821     {\cf18 void} SonarQubeReporter::writeTestCase(TestCaseNode {\cf17 const}& testCaseNode) \{\par
10822         {\cf20 // All test cases have exactly one section - which represents the}\par
10823         {\cf20 // test case itself. That section may have 0-n nested sections}\par
10824         assert(testCaseNode.children.size() == 1);\par
10825         SectionNode {\cf17 const}& rootSection = *testCaseNode.children.front();\par
10826         writeSection({\cf22 ""}, rootSection, testCaseNode.value.testInfo->okToFail());\par
10827     \}\par
10828 \par
10829     {\cf18 void} SonarQubeReporter::writeSection(std::string {\cf17 const}& rootName, SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail) \{\par
10830         std::string name = trim(sectionNode.stats.sectionInfo.name);\par
10831         {\cf19 if} (!rootName.empty())\par
10832             name = rootName + {\cf23 '/'} + name;\par
10833 \par
10834         {\cf19 if} ( sectionNode.hasAnyAssertions()\par
10835             || !sectionNode.stdOut.empty()\par
10836             ||  !sectionNode.stdErr.empty() ) \{\par
10837             XmlWriter::ScopedElement e = xml.scopedElement({\cf22 "testCase"});\par
10838             xml.writeAttribute({\cf22 "name"}_sr, name);\par
10839             xml.writeAttribute({\cf22 "duration"}_sr, {\cf17 static_cast<}{\cf18 long}{\cf17 >}(sectionNode.stats.durationInSeconds * 1000));\par
10840 \par
10841             writeAssertions(sectionNode, okToFail);\par
10842         \}\par
10843 \par
10844         {\cf19 for} ({\cf17 auto} {\cf17 const}& childNode : sectionNode.childSections)\par
10845             writeSection(name, *childNode, okToFail);\par
10846     \}\par
10847 \par
10848     {\cf18 void} SonarQubeReporter::writeAssertions(SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail) \{\par
10849         {\cf19 for} ({\cf17 auto} {\cf17 const}& assertionOrBenchmark : sectionNode.assertionsAndBenchmarks) \{\par
10850             {\cf19 if} (assertionOrBenchmark.isAssertion()) \{\par
10851                 writeAssertion(assertionOrBenchmark.asAssertion(), okToFail);\par
10852             \}\par
10853         \}\par
10854     \}\par
10855 \par
10856     {\cf18 void} SonarQubeReporter::writeAssertion(AssertionStats {\cf17 const}& stats, {\cf18 bool} okToFail) \{\par
10857         AssertionResult {\cf17 const}& result = stats.assertionResult;\par
10858         {\cf19 if} ( !result.isOk() ||\par
10859              result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10860             std::string elementName;\par
10861             {\cf19 if} (okToFail) \{\par
10862                 elementName = {\cf22 "skipped"};\par
10863             \} {\cf19 else} \{\par
10864                 {\cf19 switch} (result.getResultType()) \{\par
10865                 {\cf19 case} ResultWas::ThrewException:\par
10866                 {\cf19 case} ResultWas::FatalErrorCondition:\par
10867                     elementName = {\cf22 "error"};\par
10868                     {\cf19 break};\par
10869                 {\cf19 case} ResultWas::ExplicitFailure:\par
10870                 {\cf19 case} ResultWas::ExpressionFailed:\par
10871                 {\cf19 case} ResultWas::DidntThrowException:\par
10872                     elementName = {\cf22 "failure"};\par
10873                     {\cf19 break};\par
10874                 {\cf19 case} ResultWas::ExplicitSkip:\par
10875                     elementName = {\cf22 "skipped"};\par
10876                     {\cf19 break};\par
10877                     {\cf20 // We should never see these here:}\par
10878                 {\cf19 case} ResultWas::Info:\par
10879                 {\cf19 case} ResultWas::Warning:\par
10880                 {\cf19 case} ResultWas::Ok:\par
10881                 {\cf19 case} ResultWas::Unknown:\par
10882                 {\cf19 case} ResultWas::FailureBit:\par
10883                 {\cf19 case} ResultWas::Exception:\par
10884                     elementName = {\cf22 "internalError"};\par
10885                     {\cf19 break};\par
10886                 \}\par
10887             \}\par
10888 \par
10889             XmlWriter::ScopedElement e = xml.scopedElement(elementName);\par
10890 \par
10891             ReusableStringStream messageRss;\par
10892             messageRss << result.getTestMacroName() << {\cf23 '('} << result.getExpression() << {\cf23 ')'};\par
10893             xml.writeAttribute({\cf22 "message"}_sr, messageRss.str());\par
10894 \par
10895             ReusableStringStream textRss;\par
10896             {\cf19 if} ( result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10897                 textRss << {\cf22 "SKIPPED\\n"};\par
10898             \} {\cf19 else} \{\par
10899                 textRss << {\cf22 "FAILED:\\n"};\par
10900                 {\cf19 if} (result.hasExpression()) \{\par
10901                     textRss << {\cf23 '\\t'} << result.getExpressionInMacro() << {\cf23 '\\n'};\par
10902                 \}\par
10903                 {\cf19 if} (result.hasExpandedExpression()) \{\par
10904                     textRss << {\cf22 "with expansion:\\n\\t"} << result.getExpandedExpression() << {\cf23 '\\n'};\par
10905                 \}\par
10906             \}\par
10907 \par
10908             {\cf19 if} (result.hasMessage())\par
10909                 textRss << result.getMessage() << {\cf23 '\\n'};\par
10910 \par
10911             {\cf19 for} ({\cf17 auto} {\cf17 const}& msg : stats.infoMessages)\par
10912                 {\cf19 if} (msg.type == ResultWas::Info)\par
10913                     textRss << msg.message << {\cf23 '\\n'};\par
10914 \par
10915             textRss << {\cf22 "at "} << result.getSourceInfo();\par
10916             xml.writeText(textRss.str(), XmlFormatting::Newline);\par
10917         \}\par
10918     \}\par
10919 \par
10920 \} {\cf20 // end namespace Catch}\par
10921 \par
10922 \par
10923 \par
10924 {\cf17 namespace }Catch \{\par
10925 \par
10926     StreamingReporterBase::~StreamingReporterBase() = {\cf19 default};\par
10927 \par
10928     {\cf18 void}\par
10929     StreamingReporterBase::testRunStarting( TestRunInfo {\cf17 const}& _testRunInfo ) \{\par
10930         currentTestRunInfo = _testRunInfo;\par
10931     \}\par
10932 \par
10933     {\cf18 void} StreamingReporterBase::testRunEnded( TestRunStats {\cf17 const}& ) \{\par
10934         currentTestCaseInfo = {\cf17 nullptr};\par
10935     \}\par
10936 \par
10937 \} {\cf20 // end namespace Catch}\par
10938 \par
10939 \par
10940 \par
10941 {\cf21 #include <algorithm>}\par
10942 {\cf21 #include <ostream>}\par
10943 \par
10944 {\cf17 namespace }Catch \{\par
10945 \par
10946     {\cf17 namespace }\{\par
10947         {\cf20 // Yes, this has to be outside the class and namespaced by naming.}\par
10948         {\cf20 // Making older compiler happy is hard.}\par
10949         {\cf17 static} {\cf17 constexpr} StringRef tapFailedString = {\cf22 "not ok"}_sr;\par
10950         {\cf17 static} {\cf17 constexpr} StringRef tapPassedString = {\cf22 "ok"}_sr;\par
10951         {\cf17 static} {\cf17 constexpr} Colour::Code tapDimColour = Colour::FileName;\par
10952 \par
10953         {\cf17 class }TapAssertionPrinter \{\par
10954         {\cf17 public}:\par
10955             TapAssertionPrinter& operator= (TapAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
10956             TapAssertionPrinter(TapAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
10957             TapAssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, std::size_t _counter, ColourImpl* colour_)\par
10958                 : stream(_stream)\par
10959                 , result(_stats.assertionResult)\par
10960                 , messages(_stats.infoMessages)\par
10961                 , itMessage(_stats.infoMessages.begin())\par
10962                 , printInfoMessages(true)\par
10963                 , counter(_counter)\par
10964                 , colourImpl( colour_ ) \{\}\par
10965 \par
10966             {\cf18 void} print() \{\par
10967                 itMessage = messages.begin();\par
10968 \par
10969                 {\cf19 switch} (result.getResultType()) \{\par
10970                 {\cf19 case} ResultWas::Ok:\par
10971                     printResultType(tapPassedString);\par
10972                     printOriginalExpression();\par
10973                     printReconstructedExpression();\par
10974                     {\cf19 if} (!result.hasExpression())\par
10975                         printRemainingMessages(Colour::None);\par
10976                     {\cf19 else}\par
10977                         printRemainingMessages();\par
10978                     {\cf19 break};\par
10979                 {\cf19 case} ResultWas::ExpressionFailed:\par
10980                     {\cf19 if} (result.isOk()) \{\par
10981                         printResultType(tapPassedString);\par
10982                     \} {\cf19 else} \{\par
10983                         printResultType(tapFailedString);\par
10984                     \}\par
10985                     printOriginalExpression();\par
10986                     printReconstructedExpression();\par
10987                     {\cf19 if} (result.isOk()) \{\par
10988                         printIssue({\cf22 " # TODO"});\par
10989                     \}\par
10990                     printRemainingMessages();\par
10991                     {\cf19 break};\par
10992                 {\cf19 case} ResultWas::ThrewException:\par
10993                     printResultType(tapFailedString);\par
10994                     printIssue({\cf22 "unexpected exception with message:"}_sr);\par
10995                     printMessage();\par
10996                     printExpressionWas();\par
10997                     printRemainingMessages();\par
10998                     {\cf19 break};\par
10999                 {\cf19 case} ResultWas::FatalErrorCondition:\par
11000                     printResultType(tapFailedString);\par
11001                     printIssue({\cf22 "fatal error condition with message:"}_sr);\par
11002                     printMessage();\par
11003                     printExpressionWas();\par
11004                     printRemainingMessages();\par
11005                     {\cf19 break};\par
11006                 {\cf19 case} ResultWas::DidntThrowException:\par
11007                     printResultType(tapFailedString);\par
11008                     printIssue({\cf22 "expected exception, got none"}_sr);\par
11009                     printExpressionWas();\par
11010                     printRemainingMessages();\par
11011                     {\cf19 break};\par
11012                 {\cf19 case} ResultWas::Info:\par
11013                     printResultType({\cf22 "info"}_sr);\par
11014                     printMessage();\par
11015                     printRemainingMessages();\par
11016                     {\cf19 break};\par
11017                 {\cf19 case} ResultWas::Warning:\par
11018                     printResultType({\cf22 "warning"}_sr);\par
11019                     printMessage();\par
11020                     printRemainingMessages();\par
11021                     {\cf19 break};\par
11022                 {\cf19 case} ResultWas::ExplicitFailure:\par
11023                     printResultType(tapFailedString);\par
11024                     printIssue({\cf22 "explicitly"}_sr);\par
11025                     printRemainingMessages(Colour::None);\par
11026                     {\cf19 break};\par
11027                 {\cf19 case} ResultWas::ExplicitSkip:\par
11028                     printResultType(tapPassedString);\par
11029                     printIssue({\cf22 " # SKIP"}_sr);\par
11030                     printMessage();\par
11031                     printRemainingMessages();\par
11032                     {\cf19 break};\par
11033                     {\cf20 // These cases are here to prevent compiler warnings}\par
11034                 {\cf19 case} ResultWas::Unknown:\par
11035                 {\cf19 case} ResultWas::FailureBit:\par
11036                 {\cf19 case} ResultWas::Exception:\par
11037                     printResultType({\cf22 "** internal error **"}_sr);\par
11038                     {\cf19 break};\par
11039                 \}\par
11040             \}\par
11041 \par
11042         {\cf17 private}:\par
11043             {\cf18 void} printResultType(StringRef passOrFail){\cf17  const }\{\par
11044                 {\cf19 if} (!passOrFail.empty()) \{\par
11045                     stream << passOrFail << {\cf23 ' '} << counter << {\cf22 " -"};\par
11046                 \}\par
11047             \}\par
11048 \par
11049             {\cf18 void} printIssue(StringRef issue){\cf17  const }\{\par
11050                 stream << {\cf23 ' '} << issue;\par
11051             \}\par
11052 \par
11053             {\cf18 void} printExpressionWas() \{\par
11054                 {\cf19 if} (result.hasExpression()) \{\par
11055                     stream << {\cf23 ';'};\par
11056                     stream << colourImpl->guardColour( tapDimColour )\par
11057                            << {\cf22 " expression was:"};\par
11058                     printOriginalExpression();\par
11059                 \}\par
11060             \}\par
11061 \par
11062             {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
11063                 {\cf19 if} (result.hasExpression()) \{\par
11064                     stream << {\cf23 ' '} << result.getExpression();\par
11065                 \}\par
11066             \}\par
11067 \par
11068             {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
11069                 {\cf19 if} (result.hasExpandedExpression()) \{\par
11070                     stream << colourImpl->guardColour( tapDimColour ) << {\cf22 " for: "};\par
11071 \par
11072                     std::string expr = result.getExpandedExpression();\par
11073                     std::replace(expr.begin(), expr.end(), {\cf23 '\\n'}, {\cf23 ' '});\par
11074                     stream << expr;\par
11075                 \}\par
11076             \}\par
11077 \par
11078             {\cf18 void} printMessage() \{\par
11079                 {\cf19 if} (itMessage != messages.end()) \{\par
11080                     stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
11081                     ++itMessage;\par
11082                 \}\par
11083             \}\par
11084 \par
11085             {\cf18 void} printRemainingMessages(Colour::Code colour = tapDimColour) \{\par
11086                 {\cf19 if} (itMessage == messages.end()) \{\par
11087                     {\cf19 return};\par
11088                 \}\par
11089 \par
11090                 {\cf20 // using messages.end() directly (or auto) yields compilation error:}\par
11091                 std::vector<MessageInfo>::const_iterator itEnd = messages.end();\par
11092                 {\cf17 const} std::size_t N = {\cf17 static_cast<}std::size_t{\cf17 >}(itEnd - itMessage);\par
11093 \par
11094                 stream << colourImpl->guardColour( colour ) << {\cf22 " with "}\par
11095                        << pluralise( N, {\cf22 "message"}_sr ) << {\cf23 ':'};\par
11096 \par
11097                 {\cf19 for} (; itMessage != itEnd; ) \{\par
11098                     {\cf20 // If this assertion is a warning ignore any INFO messages}\par
11099                     {\cf19 if} (printInfoMessages || itMessage->type != ResultWas::Info) \{\par
11100                         stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
11101                         {\cf19 if} (++itMessage != itEnd) \{\par
11102                             stream << colourImpl->guardColour(tapDimColour) << {\cf22 " and"};\par
11103                         \}\par
11104                     \}\par
11105                 \}\par
11106             \}\par
11107 \par
11108         {\cf17 private}:\par
11109             std::ostream& stream;\par
11110             AssertionResult {\cf17 const}& result;\par
11111             std::vector<MessageInfo> {\cf17 const}& messages;\par
11112             std::vector<MessageInfo>::const_iterator itMessage;\par
11113             {\cf18 bool} printInfoMessages;\par
11114             std::size_t counter;\par
11115             ColourImpl* colourImpl;\par
11116         \};\par
11117 \par
11118     \} {\cf20 // End anonymous namespace}\par
11119 \par
11120     {\cf18 void} TAPReporter::testRunStarting( TestRunInfo {\cf17 const}& ) \{\par
11121         {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
11122             m_stream << {\cf22 "# filters: "} << m_config->testSpec() << {\cf23 '\\n'};\par
11123         \}\par
11124         m_stream << {\cf22 "# rng-seed: "} << m_config->rngSeed() << {\cf23 '\\n'};\par
11125     \}\par
11126 \par
11127     {\cf18 void} TAPReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
11128         m_stream << {\cf22 "# No test cases matched '"} << unmatchedSpec << {\cf22 "'\\n"};\par
11129     \}\par
11130 \par
11131     {\cf18 void} TAPReporter::assertionEnded(AssertionStats {\cf17 const}& _assertionStats) \{\par
11132         ++counter;\par
11133 \par
11134         m_stream << {\cf22 "# "} << currentTestCaseInfo->name << {\cf23 '\\n'};\par
11135         TapAssertionPrinter printer(m_stream, _assertionStats, counter, m_colour.get());\par
11136         printer.print();\par
11137 \par
11138         m_stream << {\cf23 '\\n'} << std::flush;\par
11139     \}\par
11140 \par
11141     {\cf18 void} TAPReporter::testRunEnded(TestRunStats {\cf17 const}& _testRunStats) \{\par
11142         m_stream << {\cf22 "1.."} << _testRunStats.totals.assertions.total();\par
11143         {\cf19 if} (_testRunStats.totals.testCases.total() == 0) \{\par
11144             m_stream << {\cf22 " # Skipped: No tests ran."};\par
11145         \}\par
11146         m_stream << {\cf22 "\\n\\n"} << std::flush;\par
11147         StreamingReporterBase::testRunEnded(_testRunStats);\par
11148     \}\par
11149 \par
11150 \par
11151 \par
11152 \par
11153 \} {\cf20 // end namespace Catch}\par
11154 \par
11155 \par
11156 \par
11157 \par
11158 {\cf21 #include <cassert>}\par
11159 {\cf21 #include <ostream>}\par
11160 \par
11161 {\cf17 namespace }Catch \{\par
11162 \par
11163     {\cf17 namespace }\{\par
11164         {\cf20 // if string has a : in first line will set indent to follow it on}\par
11165         {\cf20 // subsequent lines}\par
11166         {\cf18 void} printHeaderString(std::ostream& os, std::string {\cf17 const}& _string, std::size_t indent = 0) \{\par
11167             std::size_t i = _string.find({\cf22 ": "});\par
11168             {\cf19 if} (i != std::string::npos)\par
11169                 i += 2;\par
11170             {\cf19 else}\par
11171                 i = 0;\par
11172             os << TextFlow::Column(_string)\par
11173                   .indent(indent + i)\par
11174                   .initialIndent(indent) << {\cf23 '\\n'};\par
11175         \}\par
11176 \par
11177         std::string escape(StringRef str) \{\par
11178             std::string escaped = {\cf17 static_cast<}std::string{\cf17 >}(str);\par
11179             replaceInPlace(escaped, {\cf22 "|"}, {\cf22 "||"});\par
11180             replaceInPlace(escaped, {\cf22 "'"}, {\cf22 "|'"});\par
11181             replaceInPlace(escaped, {\cf22 "\\n"}, {\cf22 "|n"});\par
11182             replaceInPlace(escaped, {\cf22 "\\r"}, {\cf22 "|r"});\par
11183             replaceInPlace(escaped, {\cf22 "["}, {\cf22 "|["});\par
11184             replaceInPlace(escaped, {\cf22 "]"}, {\cf22 "|]"});\par
11185             {\cf19 return} escaped;\par
11186         \}\par
11187     \} {\cf20 // end anonymous namespace}\par
11188 \par
11189 \par
11190     TeamCityReporter::~TeamCityReporter() = {\cf19 default};\par
11191 \par
11192     {\cf18 void} TeamCityReporter::testRunStarting( TestRunInfo {\cf17 const}& runInfo ) \{\par
11193         m_stream << {\cf22 "##teamcity[testSuiteStarted name='"} << escape( runInfo.name )\par
11194                << {\cf22 "']\\n"};\par
11195     \}\par
11196 \par
11197     {\cf18 void} TeamCityReporter::testRunEnded( TestRunStats {\cf17 const}& runStats ) \{\par
11198         m_stream << {\cf22 "##teamcity[testSuiteFinished name='"}\par
11199                << escape( runStats.runInfo.name ) << {\cf22 "']\\n"};\par
11200     \}\par
11201 \par
11202     {\cf18 void} TeamCityReporter::assertionEnded(AssertionStats {\cf17 const}& assertionStats) \{\par
11203         AssertionResult {\cf17 const}& result = assertionStats.assertionResult;\par
11204         {\cf19 if} ( !result.isOk() ||\par
11205              result.getResultType() == ResultWas::ExplicitSkip ) \{\par
11206 \par
11207             ReusableStringStream msg;\par
11208             {\cf19 if} (!m_headerPrintedForThisSection)\par
11209                 printSectionHeader(msg.get());\par
11210             m_headerPrintedForThisSection = {\cf17 true};\par
11211 \par
11212             msg << result.getSourceInfo() << {\cf23 '\\n'};\par
11213 \par
11214             {\cf19 switch} (result.getResultType()) \{\par
11215             {\cf19 case} ResultWas::ExpressionFailed:\par
11216                 msg << {\cf22 "expression failed"};\par
11217                 {\cf19 break};\par
11218             {\cf19 case} ResultWas::ThrewException:\par
11219                 msg << {\cf22 "unexpected exception"};\par
11220                 {\cf19 break};\par
11221             {\cf19 case} ResultWas::FatalErrorCondition:\par
11222                 msg << {\cf22 "fatal error condition"};\par
11223                 {\cf19 break};\par
11224             {\cf19 case} ResultWas::DidntThrowException:\par
11225                 msg << {\cf22 "no exception was thrown where one was expected"};\par
11226                 {\cf19 break};\par
11227             {\cf19 case} ResultWas::ExplicitFailure:\par
11228                 msg << {\cf22 "explicit failure"};\par
11229                 {\cf19 break};\par
11230             {\cf19 case} ResultWas::ExplicitSkip:\par
11231                 msg << {\cf22 "explicit skip"};\par
11232                 {\cf19 break};\par
11233 \par
11234                 {\cf20 // We shouldn't get here because of the isOk() test}\par
11235             {\cf19 case} ResultWas::Ok:\par
11236             {\cf19 case} ResultWas::Info:\par
11237             {\cf19 case} ResultWas::Warning:\par
11238                 CATCH_ERROR({\cf22 "Internal error in TeamCity reporter"});\par
11239                 {\cf20 // These cases are here to prevent compiler warnings}\par
11240             {\cf19 case} ResultWas::Unknown:\par
11241             {\cf19 case} ResultWas::FailureBit:\par
11242             {\cf19 case} ResultWas::Exception:\par
11243                 CATCH_ERROR({\cf22 "Not implemented"});\par
11244             \}\par
11245             {\cf19 if} (assertionStats.infoMessages.size() == 1)\par
11246                 msg << {\cf22 " with message:"};\par
11247             {\cf19 if} (assertionStats.infoMessages.size() > 1)\par
11248                 msg << {\cf22 " with messages:"};\par
11249             {\cf19 for} ({\cf17 auto} {\cf17 const}& messageInfo : assertionStats.infoMessages)\par
11250                 msg << {\cf22 "\\n  \\""} << messageInfo.message << {\cf23 '"'};\par
11251 \par
11252 \par
11253             {\cf19 if} (result.hasExpression()) \{\par
11254                 msg <<\par
11255                     {\cf22 "\\n  "} << result.getExpressionInMacro() << {\cf22 "\\n"}\par
11256                     {\cf22 "with expansion:\\n"}\par
11257                     {\cf22 "  "} << result.getExpandedExpression() << {\cf23 '\\n'};\par
11258             \}\par
11259 \par
11260             {\cf19 if} ( result.getResultType() == ResultWas::ExplicitSkip ) \{\par
11261                 m_stream << {\cf22 "##teamcity[testIgnored"};\par
11262             \} {\cf19 else} {\cf19 if} ( currentTestCaseInfo->okToFail() ) \{\par
11263                 msg << {\cf22 "- failure ignore as test marked as 'ok to fail'\\n"};\par
11264                 m_stream << {\cf22 "##teamcity[testIgnored"};\par
11265             \} {\cf19 else} \{\par
11266                 m_stream << {\cf22 "##teamcity[testFailed"};\par
11267             \}\par
11268             m_stream << {\cf22 " name='"} << escape( currentTestCaseInfo->name ) << {\cf23 '\\''}\par
11269                      << {\cf22 " message='"} << escape( msg.str() ) << {\cf23 '\\''} << {\cf22 "]\\n"};\par
11270         \}\par
11271         m_stream.flush();\par
11272     \}\par
11273 \par
11274     {\cf18 void} TeamCityReporter::testCaseStarting(TestCaseInfo {\cf17 const}& testInfo) \{\par
11275         m_testTimer.start();\par
11276         StreamingReporterBase::testCaseStarting(testInfo);\par
11277         m_stream << {\cf22 "##teamcity[testStarted name='"}\par
11278             << escape(testInfo.name) << {\cf22 "']\\n"};\par
11279         m_stream.flush();\par
11280     \}\par
11281 \par
11282     {\cf18 void} TeamCityReporter::testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) \{\par
11283         StreamingReporterBase::testCaseEnded(testCaseStats);\par
11284         {\cf17 auto} {\cf17 const}& testCaseInfo = *testCaseStats.testInfo;\par
11285         {\cf19 if} (!testCaseStats.stdOut.empty())\par
11286             m_stream << {\cf22 "##teamcity[testStdOut name='"}\par
11287             << escape(testCaseInfo.name)\par
11288             << {\cf22 "' out='"} << escape(testCaseStats.stdOut) << {\cf22 "']\\n"};\par
11289         {\cf19 if} (!testCaseStats.stdErr.empty())\par
11290             m_stream << {\cf22 "##teamcity[testStdErr name='"}\par
11291             << escape(testCaseInfo.name)\par
11292             << {\cf22 "' out='"} << escape(testCaseStats.stdErr) << {\cf22 "']\\n"};\par
11293         m_stream << {\cf22 "##teamcity[testFinished name='"}\par
11294             << escape(testCaseInfo.name) << {\cf22 "' duration='"}\par
11295             << m_testTimer.getElapsedMilliseconds() << {\cf22 "']\\n"};\par
11296         m_stream.flush();\par
11297     \}\par
11298 \par
11299     {\cf18 void} TeamCityReporter::printSectionHeader(std::ostream& os) \{\par
11300         assert(!m_sectionStack.empty());\par
11301 \par
11302         {\cf19 if} (m_sectionStack.size() > 1) \{\par
11303             os << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
11304 \par
11305             std::vector<SectionInfo>::const_iterator\par
11306                 it = m_sectionStack.begin() + 1, {\cf20 // Skip first section (test case)}\par
11307                 itEnd = m_sectionStack.end();\par
11308             {\cf19 for} (; it != itEnd; ++it)\par
11309                 printHeaderString(os, it->name);\par
11310             os << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
11311         \}\par
11312 \par
11313         SourceLineInfo lineInfo = m_sectionStack.front().lineInfo;\par
11314 \par
11315         os << lineInfo << {\cf23 '\\n'};\par
11316         os << lineOfChars({\cf23 '.'}) << {\cf22 "\\n\\n"};\par
11317     \}\par
11318 \par
11319 \} {\cf20 // end namespace Catch}\par
11320 \par
11321 \par
11322 \par
11323 \par
11324 {\cf21 #if defined(_MSC_VER)}\par
11325 {\cf21 #pragma warning(push)}\par
11326 {\cf21 #pragma warning(disable:4061) }{\cf20 // Not all labels are EXPLICITLY handled in switch}\par
11327                               {\cf20 // Note that 4062 (not all labels are handled}\par
11328                               {\cf20 // and default is missing) is enabled}\par
11329 {\cf21 #endif}\par
11330 \par
11331 {\cf17 namespace }Catch \{\par
11332     XmlReporter::XmlReporter( ReporterConfig&& _config )\par
11333     :   StreamingReporterBase( CATCH_MOVE(_config) ),\par
11334         m_xml(m_stream)\par
11335     \{\par
11336         m_preferences.shouldRedirectStdOut = {\cf17 true};\par
11337         m_preferences.shouldReportAllAssertions = {\cf17 true};\par
11338     \}\par
11339 \par
11340     XmlReporter::~XmlReporter() = {\cf19 default};\par
11341 \par
11342     std::string XmlReporter::getDescription() \{\par
11343         {\cf19 return} {\cf22 "Reports test results as an XML document"};\par
11344     \}\par
11345 \par
11346     std::string XmlReporter::getStylesheetRef(){\cf17  const }\{\par
11347         {\cf19 return} std::string();\par
11348     \}\par
11349 \par
11350     {\cf18 void} XmlReporter::writeSourceInfo( SourceLineInfo {\cf17 const}& sourceInfo ) \{\par
11351         m_xml\par
11352             .writeAttribute( {\cf22 "filename"}_sr, sourceInfo.file )\par
11353             .writeAttribute( {\cf22 "line"}_sr, sourceInfo.line );\par
11354     \}\par
11355 \par
11356     {\cf18 void} XmlReporter::testRunStarting( TestRunInfo {\cf17 const}& testInfo ) \{\par
11357         StreamingReporterBase::testRunStarting( testInfo );\par
11358         std::string stylesheetRef = getStylesheetRef();\par
11359         {\cf19 if}( !stylesheetRef.empty() )\par
11360             m_xml.writeStylesheetRef( stylesheetRef );\par
11361         m_xml.startElement({\cf22 "Catch2TestRun"})\par
11362              .writeAttribute({\cf22 "name"}_sr, m_config->name())\par
11363              .writeAttribute({\cf22 "rng-seed"}_sr, m_config->rngSeed())\par
11364              .writeAttribute({\cf22 "xml-format-version"}_sr, 3)\par
11365              .writeAttribute({\cf22 "catch2-version"}_sr, libraryVersion());\par
11366         {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
11367             m_xml.writeAttribute( {\cf22 "filters"}_sr, m_config->testSpec() );\par
11368         \}\par
11369     \}\par
11370 \par
11371     {\cf18 void} XmlReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) \{\par
11372         StreamingReporterBase::testCaseStarting(testInfo);\par
11373         m_xml.startElement( {\cf22 "TestCase"} )\par
11374             .writeAttribute( {\cf22 "name"}_sr, trim( StringRef(testInfo.name) ) )\par
11375             .writeAttribute( {\cf22 "tags"}_sr, testInfo.tagsAsString() );\par
11376 \par
11377         writeSourceInfo( testInfo.lineInfo );\par
11378 \par
11379         {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
11380             m_testCaseTimer.start();\par
11381         m_xml.ensureTagClosed();\par
11382     \}\par
11383 \par
11384     {\cf18 void} XmlReporter::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
11385         StreamingReporterBase::sectionStarting( sectionInfo );\par
11386         {\cf19 if}( m_sectionDepth++ > 0 ) \{\par
11387             m_xml.startElement( {\cf22 "Section"} )\par
11388                 .writeAttribute( {\cf22 "name"}_sr, trim( StringRef(sectionInfo.name) ) );\par
11389             writeSourceInfo( sectionInfo.lineInfo );\par
11390             m_xml.ensureTagClosed();\par
11391         \}\par
11392     \}\par
11393 \par
11394     {\cf18 void} XmlReporter::assertionStarting( AssertionInfo {\cf17 const}& ) \{ \}\par
11395 \par
11396     {\cf18 void} XmlReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
11397 \par
11398         AssertionResult {\cf17 const}& result = assertionStats.assertionResult;\par
11399 \par
11400         {\cf18 bool} includeResults = m_config->includeSuccessfulResults() || !result.isOk();\par
11401 \par
11402         {\cf19 if}( includeResults || result.getResultType() == ResultWas::Warning ) \{\par
11403             {\cf20 // Print any info messages in <Info> tags.}\par
11404             {\cf19 for}( {\cf17 auto} {\cf17 const}& msg : assertionStats.infoMessages ) \{\par
11405                 {\cf19 if}( msg.type == ResultWas::Info && includeResults ) \{\par
11406                     {\cf17 auto} t = m_xml.scopedElement( {\cf22 "Info"} );\par
11407                     writeSourceInfo( msg.lineInfo );\par
11408                     t.writeText( msg.message );\par
11409                 \} {\cf19 else} {\cf19 if} ( msg.type == ResultWas::Warning ) \{\par
11410                     {\cf17 auto} t = m_xml.scopedElement( {\cf22 "Warning"} );\par
11411                     writeSourceInfo( msg.lineInfo );\par
11412                     t.writeText( msg.message );\par
11413                 \}\par
11414             \}\par
11415         \}\par
11416 \par
11417         {\cf20 // Drop out if result was successful but we're not printing them.}\par
11418         {\cf19 if} ( !includeResults && result.getResultType() != ResultWas::Warning &&\par
11419              result.getResultType() != ResultWas::ExplicitSkip ) \{\par
11420             {\cf19 return};\par
11421         \}\par
11422 \par
11423         {\cf20 // Print the expression if there is one.}\par
11424         {\cf19 if}( result.hasExpression() ) \{\par
11425             m_xml.startElement( {\cf22 "Expression"} )\par
11426                 .writeAttribute( {\cf22 "success"}_sr, result.succeeded() )\par
11427                 .writeAttribute( {\cf22 "type"}_sr, result.getTestMacroName() );\par
11428 \par
11429             writeSourceInfo( result.getSourceInfo() );\par
11430 \par
11431             m_xml.scopedElement( {\cf22 "Original"} )\par
11432                 .writeText( result.getExpression() );\par
11433             m_xml.scopedElement( {\cf22 "Expanded"} )\par
11434                 .writeText( result.getExpandedExpression() );\par
11435         \}\par
11436 \par
11437         {\cf20 // And... Print a result applicable to each result type.}\par
11438         {\cf19 switch}( result.getResultType() ) \{\par
11439             {\cf19 case} ResultWas::ThrewException:\par
11440                 m_xml.startElement( {\cf22 "Exception"} );\par
11441                 writeSourceInfo( result.getSourceInfo() );\par
11442                 m_xml.writeText( result.getMessage() );\par
11443                 m_xml.endElement();\par
11444                 {\cf19 break};\par
11445             {\cf19 case} ResultWas::FatalErrorCondition:\par
11446                 m_xml.startElement( {\cf22 "FatalErrorCondition"} );\par
11447                 writeSourceInfo( result.getSourceInfo() );\par
11448                 m_xml.writeText( result.getMessage() );\par
11449                 m_xml.endElement();\par
11450                 {\cf19 break};\par
11451             {\cf19 case} ResultWas::Info:\par
11452                 m_xml.scopedElement( {\cf22 "Info"} )\par
11453                      .writeText( result.getMessage() );\par
11454                 {\cf19 break};\par
11455             {\cf19 case} ResultWas::Warning:\par
11456                 {\cf20 // Warning will already have been written}\par
11457                 {\cf19 break};\par
11458             {\cf19 case} ResultWas::ExplicitFailure:\par
11459                 m_xml.startElement( {\cf22 "Failure"} );\par
11460                 writeSourceInfo( result.getSourceInfo() );\par
11461                 m_xml.writeText( result.getMessage() );\par
11462                 m_xml.endElement();\par
11463                 {\cf19 break};\par
11464             {\cf19 case} ResultWas::ExplicitSkip:\par
11465                 m_xml.startElement( {\cf22 "Skip"} );\par
11466                 writeSourceInfo( result.getSourceInfo() );\par
11467                 m_xml.writeText( result.getMessage() );\par
11468                 m_xml.endElement();\par
11469                 {\cf19 break};\par
11470             {\cf19 default}:\par
11471                 {\cf19 break};\par
11472         \}\par
11473 \par
11474         {\cf19 if}( result.hasExpression() )\par
11475             m_xml.endElement();\par
11476     \}\par
11477 \par
11478     {\cf18 void} XmlReporter::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
11479         StreamingReporterBase::sectionEnded( sectionStats );\par
11480         {\cf19 if} ( --m_sectionDepth > 0 ) \{\par
11481             \{\par
11482                 XmlWriter::ScopedElement e = m_xml.scopedElement( {\cf22 "OverallResults"} );\par
11483                 e.writeAttribute( {\cf22 "successes"}_sr, sectionStats.assertions.passed );\par
11484                 e.writeAttribute( {\cf22 "failures"}_sr, sectionStats.assertions.failed );\par
11485                 e.writeAttribute( {\cf22 "expectedFailures"}_sr, sectionStats.assertions.failedButOk );\par
11486                 e.writeAttribute( {\cf22 "skipped"}_sr, sectionStats.assertions.skipped > 0 );\par
11487 \par
11488                 {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
11489                     e.writeAttribute( {\cf22 "durationInSeconds"}_sr, sectionStats.durationInSeconds );\par
11490             \}\par
11491             {\cf20 // Ends assertion tag}\par
11492             m_xml.endElement();\par
11493         \}\par
11494     \}\par
11495 \par
11496     {\cf18 void} XmlReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
11497         StreamingReporterBase::testCaseEnded( testCaseStats );\par
11498         XmlWriter::ScopedElement e = m_xml.scopedElement( {\cf22 "OverallResult"} );\par
11499         e.writeAttribute( {\cf22 "success"}_sr, testCaseStats.totals.assertions.allOk() );\par
11500         e.writeAttribute( {\cf22 "skips"}_sr, testCaseStats.totals.assertions.skipped );\par
11501 \par
11502         {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
11503             e.writeAttribute( {\cf22 "durationInSeconds"}_sr, m_testCaseTimer.getElapsedSeconds() );\par
11504         {\cf19 if}( !testCaseStats.stdOut.empty() )\par
11505             m_xml.scopedElement( {\cf22 "StdOut"} ).writeText( trim( StringRef(testCaseStats.stdOut) ), XmlFormatting::Newline );\par
11506         {\cf19 if}( !testCaseStats.stdErr.empty() )\par
11507             m_xml.scopedElement( {\cf22 "StdErr"} ).writeText( trim( StringRef(testCaseStats.stdErr) ), XmlFormatting::Newline );\par
11508 \par
11509         m_xml.endElement();\par
11510     \}\par
11511 \par
11512     {\cf18 void} XmlReporter::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
11513         StreamingReporterBase::testRunEnded( testRunStats );\par
11514         m_xml.scopedElement( {\cf22 "OverallResults"} )\par
11515             .writeAttribute( {\cf22 "successes"}_sr, testRunStats.totals.assertions.passed )\par
11516             .writeAttribute( {\cf22 "failures"}_sr, testRunStats.totals.assertions.failed )\par
11517             .writeAttribute( {\cf22 "expectedFailures"}_sr, testRunStats.totals.assertions.failedButOk )\par
11518             .writeAttribute( {\cf22 "skips"}_sr, testRunStats.totals.assertions.skipped );\par
11519         m_xml.scopedElement( {\cf22 "OverallResultsCases"})\par
11520             .writeAttribute( {\cf22 "successes"}_sr, testRunStats.totals.testCases.passed )\par
11521             .writeAttribute( {\cf22 "failures"}_sr, testRunStats.totals.testCases.failed )\par
11522             .writeAttribute( {\cf22 "expectedFailures"}_sr, testRunStats.totals.testCases.failedButOk )\par
11523             .writeAttribute( {\cf22 "skips"}_sr, testRunStats.totals.testCases.skipped );\par
11524         m_xml.endElement();\par
11525     \}\par
11526 \par
11527     {\cf18 void} XmlReporter::benchmarkPreparing( StringRef name ) \{\par
11528         m_xml.startElement({\cf22 "BenchmarkResults"})\par
11529              .writeAttribute({\cf22 "name"}_sr, name);\par
11530     \}\par
11531 \par
11532     {\cf18 void} XmlReporter::benchmarkStarting(BenchmarkInfo {\cf17 const} &info) \{\par
11533         m_xml.writeAttribute({\cf22 "samples"}_sr, info.samples)\par
11534             .writeAttribute({\cf22 "resamples"}_sr, info.resamples)\par
11535             .writeAttribute({\cf22 "iterations"}_sr, info.iterations)\par
11536             .writeAttribute({\cf22 "clockResolution"}_sr, info.clockResolution)\par
11537             .writeAttribute({\cf22 "estimatedDuration"}_sr, info.estimatedDuration)\par
11538             .writeComment({\cf22 "All values in nano seconds"}_sr);\par
11539     \}\par
11540 \par
11541     {\cf18 void} XmlReporter::benchmarkEnded(BenchmarkStats<> {\cf17 const}& benchmarkStats) \{\par
11542         m_xml.scopedElement({\cf22 "mean"})\par
11543             .writeAttribute({\cf22 "value"}_sr, benchmarkStats.mean.point.count())\par
11544             .writeAttribute({\cf22 "lowerBound"}_sr, benchmarkStats.mean.lower_bound.count())\par
11545             .writeAttribute({\cf22 "upperBound"}_sr, benchmarkStats.mean.upper_bound.count())\par
11546             .writeAttribute({\cf22 "ci"}_sr, benchmarkStats.mean.confidence_interval);\par
11547         m_xml.scopedElement({\cf22 "standardDeviation"})\par
11548             .writeAttribute({\cf22 "value"}_sr, benchmarkStats.standardDeviation.point.count())\par
11549             .writeAttribute({\cf22 "lowerBound"}_sr, benchmarkStats.standardDeviation.lower_bound.count())\par
11550             .writeAttribute({\cf22 "upperBound"}_sr, benchmarkStats.standardDeviation.upper_bound.count())\par
11551             .writeAttribute({\cf22 "ci"}_sr, benchmarkStats.standardDeviation.confidence_interval);\par
11552         m_xml.scopedElement({\cf22 "outliers"})\par
11553             .writeAttribute({\cf22 "variance"}_sr, benchmarkStats.outlierVariance)\par
11554             .writeAttribute({\cf22 "lowMild"}_sr, benchmarkStats.outliers.low_mild)\par
11555             .writeAttribute({\cf22 "lowSevere"}_sr, benchmarkStats.outliers.low_severe)\par
11556             .writeAttribute({\cf22 "highMild"}_sr, benchmarkStats.outliers.high_mild)\par
11557             .writeAttribute({\cf22 "highSevere"}_sr, benchmarkStats.outliers.high_severe);\par
11558         m_xml.endElement();\par
11559     \}\par
11560 \par
11561     {\cf18 void} XmlReporter::benchmarkFailed(StringRef error) \{\par
11562         m_xml.scopedElement({\cf22 "failed"}).\par
11563             writeAttribute({\cf22 "message"}_sr, error);\par
11564         m_xml.endElement();\par
11565     \}\par
11566 \par
11567     {\cf18 void} XmlReporter::listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) \{\par
11568         {\cf17 auto} outerTag = m_xml.scopedElement({\cf22 "AvailableReporters"});\par
11569         {\cf19 for} ({\cf17 auto} {\cf17 const}& reporter : descriptions) \{\par
11570             {\cf17 auto} inner = m_xml.scopedElement({\cf22 "Reporter"});\par
11571             m_xml.startElement({\cf22 "Name"}, XmlFormatting::Indent)\par
11572                  .writeText(reporter.name, XmlFormatting::None)\par
11573                  .endElement(XmlFormatting::Newline);\par
11574             m_xml.startElement({\cf22 "Description"}, XmlFormatting::Indent)\par
11575                  .writeText(reporter.description, XmlFormatting::None)\par
11576                  .endElement(XmlFormatting::Newline);\par
11577         \}\par
11578     \}\par
11579 \par
11580     {\cf18 void} XmlReporter::listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) \{\par
11581         {\cf17 auto} outerTag = m_xml.scopedElement( {\cf22 "RegisteredListeners"} );\par
11582         {\cf19 for} ( {\cf17 auto} {\cf17 const}& listener : descriptions ) \{\par
11583             {\cf17 auto} inner = m_xml.scopedElement( {\cf22 "Listener"} );\par
11584             m_xml.startElement( {\cf22 "Name"}, XmlFormatting::Indent )\par
11585                 .writeText( listener.name, XmlFormatting::None )\par
11586                 .endElement( XmlFormatting::Newline );\par
11587             m_xml.startElement( {\cf22 "Description"}, XmlFormatting::Indent )\par
11588                 .writeText( listener.description, XmlFormatting::None )\par
11589                 .endElement( XmlFormatting::Newline );\par
11590         \}\par
11591     \}\par
11592 \par
11593     {\cf18 void} XmlReporter::listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
11594         {\cf17 auto} outerTag = m_xml.scopedElement({\cf22 "MatchingTests"});\par
11595         {\cf19 for} ({\cf17 auto} {\cf17 const}& test : tests) \{\par
11596             {\cf17 auto} innerTag = m_xml.scopedElement({\cf22 "TestCase"});\par
11597             {\cf17 auto} {\cf17 const}& testInfo = test.getTestCaseInfo();\par
11598             m_xml.startElement({\cf22 "Name"}, XmlFormatting::Indent)\par
11599                  .writeText(testInfo.name, XmlFormatting::None)\par
11600                  .endElement(XmlFormatting::Newline);\par
11601             m_xml.startElement({\cf22 "ClassName"}, XmlFormatting::Indent)\par
11602                  .writeText(testInfo.className, XmlFormatting::None)\par
11603                  .endElement(XmlFormatting::Newline);\par
11604             m_xml.startElement({\cf22 "Tags"}, XmlFormatting::Indent)\par
11605                  .writeText(testInfo.tagsAsString(), XmlFormatting::None)\par
11606                  .endElement(XmlFormatting::Newline);\par
11607 \par
11608             {\cf17 auto} sourceTag = m_xml.scopedElement({\cf22 "SourceInfo"});\par
11609             m_xml.startElement({\cf22 "File"}, XmlFormatting::Indent)\par
11610                  .writeText(testInfo.lineInfo.file, XmlFormatting::None)\par
11611                  .endElement(XmlFormatting::Newline);\par
11612             m_xml.startElement({\cf22 "Line"}, XmlFormatting::Indent)\par
11613                  .writeText(std::to_string(testInfo.lineInfo.line), XmlFormatting::None)\par
11614                  .endElement(XmlFormatting::Newline);\par
11615         \}\par
11616     \}\par
11617 \par
11618     {\cf18 void} XmlReporter::listTags(std::vector<TagInfo> {\cf17 const}& tags) \{\par
11619         {\cf17 auto} outerTag = m_xml.scopedElement({\cf22 "TagsFromMatchingTests"});\par
11620         {\cf19 for} ({\cf17 auto} {\cf17 const}& tag : tags) \{\par
11621             {\cf17 auto} innerTag = m_xml.scopedElement({\cf22 "Tag"});\par
11622             m_xml.startElement({\cf22 "Count"}, XmlFormatting::Indent)\par
11623                  .writeText(std::to_string(tag.count), XmlFormatting::None)\par
11624                  .endElement(XmlFormatting::Newline);\par
11625             {\cf17 auto} aliasTag = m_xml.scopedElement({\cf22 "Aliases"});\par
11626             {\cf19 for} ({\cf17 auto} {\cf17 const}& alias : tag.spellings) \{\par
11627                 m_xml.startElement({\cf22 "Alias"}, XmlFormatting::Indent)\par
11628                      .writeText(alias, XmlFormatting::None)\par
11629                      .endElement(XmlFormatting::Newline);\par
11630             \}\par
11631         \}\par
11632     \}\par
11633 \par
11634 \} {\cf20 // end namespace Catch}\par
11635 \par
11636 {\cf21 #if defined(_MSC_VER)}\par
11637 {\cf21 #pragma warning(pop)}\par
11638 {\cf21 #endif}\par
}
}