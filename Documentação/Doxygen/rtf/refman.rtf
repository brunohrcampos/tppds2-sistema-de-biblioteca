{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment Documenta\'E7\'E3o Sistema Biblioteca  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}Documenta\'E7\'E3o Sistema Biblioteca}
{\comment Gerado por doxygen 1.12.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Documenta\'E7\'E3o Sistema Biblioteca}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 1.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespaces\par \pard\plain 
{\tc \v Namespaces}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Namespaces\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os Namespaces com suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Catch} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::Detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::literals} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Matchers::Detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestCaseTracking} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TextFlow} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b mpl_} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice Hier\'E1rquico\par \pard\plain 
{\tc \v \'CDndice Hier\'E1rquico}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Hierarquia de Classes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta lista de hierarquias est\'E1 parcialmente ordenada (ordem alfab\'E9tica):}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::accept_many_t\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Approx\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Args\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::as< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionHandler\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionReaction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionResult\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::AssertionResultData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
B1
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Detail::conjunction< B1 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::disjunction< B1 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Benchmark::Benchmark\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::BenchmarkFunction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::BenchmarkInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::BenchmarkStats< Dummy >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::bootstrap_analysis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Capturer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch_global_namespace_dummy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Chronometer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::ChronometerConcept\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Benchmark::Detail::ChronometerModel< Clock >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::ColumnInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::CompleteInvoker< Result >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::CompleteInvoker< void >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::CompleteType< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::CompleteType< void >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::conditional_t
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Detail::conjunction< B1, Bn... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::disjunction< B1, Bn... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::ConfigData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Context\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Counts\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Decomposer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Emprestimo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EmprestimoLivros\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::EnumInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Environment\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::EnvironmentEstimate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Estimate< Type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Estimate< Benchmark::FDuration >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Estimate< double >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Estimate< FDuration >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::exception
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::GeneratorException\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::ExceptionTranslatorRegistrar\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::ExecutionPlan\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ExprLhs< LhsT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::fake_arg\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::false_type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::is_unary_function< F, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::disjunction<... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::is_range_impl< T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::is_range< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::always_false< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::TestSpec::FilterMatch\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::GeneratorUntypedBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Generators::IGenerator< std::vector< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Generators::ChunkGenerator< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Generators::IGenerator< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMH \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Generators::FilterGenerator< T, Predicate >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::FixedValuesGenerator< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::Generators< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::MapGenerator< T, U, Func >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::RepeatGenerator< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::SingleValueGenerator< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::TakeGenerator< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
Catch::Generators::GeneratorWrapper< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::GeneratorWrapper< U >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GerenciamentoLivros\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GerenciamentoUsuario\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::HelpColumns\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IExceptionTranslator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IExceptionTranslatorRegistry\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IGeneratorTracker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IMutableEnumValuesRegistry\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IMutableRegistryHub\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::integral_constant
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Detail::negation< B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::capture_by_value< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::IRegistryHub\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::IResultCapture\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::is_callable< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::is_callable< Fun(Args...)>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::is_callable_tester\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::is_same
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Benchmark::Detail::is_related< T, U >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Detail::IsStreamInsertable< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ITestInvoker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::TestInvokerAsMethod< C >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::ITransientExpression\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::BinaryExpr< LhsT, RhsT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::UnaryExpr< LhsT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Clara::Detail::LambdaInvoker< ReturnType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::LambdaInvoker< void >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::LazyExpression\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Livro\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::make_void<... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::MessageInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::MessageStream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::MessageBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::NameAndTags\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::NonCopyable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::AutoReg\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::BoundRef\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::BoundFlagRefBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::BoundFlagLambda< L >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::BoundFlagRef\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Clara::Detail::BoundValueRefBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::BoundLambda< L >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::BoundManyLambda< L >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Clara::Detail::BoundValueRef< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::BoundValueRef< std::vector< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
Catch::IConfig\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Config\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::ReusableStringStream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Section\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Session\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TestCaseInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Optional< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Optional< ColourMode >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Optional< std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::OutlierClassification\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::ParserBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::ComposableParserImpl< Arg >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::ParserRefImpl< Arg >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Arg\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
Catch::Clara::Detail::ComposableParserImpl< ExeName >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::ExeName\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Clara::Detail::ComposableParserImpl< Opt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::ParserRefImpl< Opt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Opt\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Help\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
}\par
Catch::Clara::Detail::ComposableParserImpl< DerivedT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::ParserRefImpl< DerivedT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Clara::Parser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Clara::Detail::ParseState\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Generators::RandomFloatingGenerator::PImpl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ProcessedReporterSpec\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ratio_string< Ratio >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ratio_string< std::atto >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ratio_string< std::femto >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ratio_string< std::micro >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ratio_string< std::milli >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ratio_string< std::nano >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ratio_string< std::pico >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::RegistrarForTagAliases\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Detail::repeater< Fun >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ReporterRegistry::ReporterRegistryImpl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ReporterSpec\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::ResultBase\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::ResultValueBase< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::ResultValueBase< void >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::BasicResult< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
Catch::ResultDisposition\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ResultWas\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::SampleAnalysis\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::ScopedMessage\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SectionEndInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SectionInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SignalDefs\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SimplePcg32\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::SourceLineInfo\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StreamEndStop\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< bool >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< Catch::Approx >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char const * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< char[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< double >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< float >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< int >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< long long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< R C::* >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< signed char >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< signed char[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::chrono::duration< Value, Ratio > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::chrono::time_point< Clock, Duration > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::nullptr_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< std::wstring >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< T * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< T[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned char >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned char[SZ]>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned int >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< unsigned long long >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< wchar_t * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringMaker< wchar_t const * >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringRef\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::StringStreams\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TablePrinter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Tag\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TagAlias\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TestCaseHandle\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TestFailureException\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TestSkipException\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::TestSpec\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Timer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Benchmark::Timing< Result >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::Token\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::TokenStream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Totals\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::true_type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Catch::Clara::Detail::is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::conjunction<... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::true_given< typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Catch::Benchmark::Detail::CompleteType< void >::type\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::UnaryLambdaTraits< L >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::unique_ptr< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::unique_ptr< callable >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::unique_ptr< Catch::Config >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Detail::unique_ptr< U >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Usuario\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::Version\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::WaitForKeypress\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::WarnAbout\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Catch::WildcardPattern\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Componentes\par \pard\plain 
{\tc \v \'CDndice dos Componentes}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Classes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Aqui est\'E3o as classes, estruturas, uni\'F5es e interfaces e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b Catch::Clara::accept_many_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::always_false< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Approx} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Arg} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Args} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::as< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionHandler} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionReaction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionResult} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AssertionResultData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::AutoReg} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BasicResult< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Benchmark} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::BenchmarkFunction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::BenchmarkInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::BenchmarkStats< Dummy >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::BinaryExpr< LhsT, RhsT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::bootstrap_analysis} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundFlagLambda< L >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundFlagRef} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundFlagRefBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundLambda< L >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundManyLambda< L >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundRef} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundValueRef< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundValueRef< std::vector< T > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::BoundValueRefBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::capture_by_value< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Capturer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch_global_namespace_dummy} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Chronometer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::ChronometerConcept} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::ChronometerModel< Clock >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::ChunkGenerator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ColumnInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::CompleteInvoker< Result >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::CompleteInvoker< void >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::CompleteType< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::CompleteType< void >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::ComposableParserImpl< DerivedT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Config} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ConfigData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::conjunction<... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::conjunction< B1 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::conjunction< B1, Bn... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Context} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Counts} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Decomposer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::disjunction<... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::disjunction< B1 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::disjunction< B1, Bn... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Emprestimo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EmprestimoLivros} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::EnumInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Environment} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::EnvironmentEstimate} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Estimate< Type >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ExceptionTranslatorRegistrar} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::ExecutionPlan} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::ExeName} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ExprLhs< LhsT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::fake_arg} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::FilterGenerator< T, Predicate >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestSpec::FilterMatch} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::FixedValuesGenerator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::GeneratorException} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::Generators< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::GeneratorUntypedBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::GeneratorWrapper< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GerenciamentoLivros} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GerenciamentoUsuario} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Help} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::HelpColumns} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IConfig} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IExceptionTranslator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IExceptionTranslatorRegistry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::IGenerator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IGeneratorTracker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IMutableEnumValuesRegistry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IMutableRegistryHub} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IRegistryHub} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::IResultCapture} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::is_callable< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::is_callable< Fun(Args...)>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::is_callable_tester} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::is_range< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::is_range_impl< T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::is_related< T, U >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::is_unary_function< F, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::IsStreamInsertable< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ITestInvoker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ITransientExpression} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::LambdaInvoker< ReturnType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::LambdaInvoker< void >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::LazyExpression} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Livro} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::make_void<... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::MapGenerator< T, U, Func >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::MessageBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::MessageInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::MessageStream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::NameAndTags} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::negation< B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::NonCopyable} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deriving classes become noncopyable and nonmovable })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::ObjectStorage< T, Destruct >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Opt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Optional< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::OutlierClassification} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Parser} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::ParserBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::ParserRefImpl< DerivedT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::ParseState} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::RandomFloatingGenerator::PImpl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ProcessedReporterSpec} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ratio_string< Ratio >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ratio_string< std::atto >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ratio_string< std::femto >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ratio_string< std::micro >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ratio_string< std::milli >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ratio_string< std::nano >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ratio_string< std::pico >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::RegistrarForTagAliases} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::repeater< Fun >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::RepeatGenerator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ReporterRegistry::ReporterRegistryImpl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACOJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ReporterSpec} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::ResultBase} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ResultDisposition} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::ResultValueBase< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::ResultValueBase< void >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ResultWas} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ReusableStringStream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::SampleAnalysis} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::ScopedMessage} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Section} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SectionEndInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SectionInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Session} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SignalDefs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SimplePcg32} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::SingleValueGenerator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::SourceLineInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StreamEndStop} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< bool >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< Catch::Approx >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char const * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< char[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< double >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< float >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< int >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< long long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< R C::* >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< signed char >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< signed char[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::chrono::duration< Value, Ratio > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::chrono::time_point< Clock, Duration > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::nullptr_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::string >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< std::wstring >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< T * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< T[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned char >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned char[SZ]>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned int >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< unsigned long long >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< wchar_t * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringMaker< wchar_t const * >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringRef} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::StringStreams} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TablePrinter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Tag} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TagAlias} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Generators::TakeGenerator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestCaseHandle} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestCaseInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestFailureException} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that an assertion macro failed })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestInvokerAsMethod< C >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestSkipException} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that the remainder of a test should be skipped })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::TestSpec} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Timer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Timing< Result >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::Token} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::TokenStream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Totals} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::true_given< typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Benchmark::Detail::CompleteType< void >::type} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::UnaryExpr< LhsT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::UnaryLambdaTraits< L >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Detail::unique_ptr< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Usuario} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::Version} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::WaitForKeypress} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::WarnAbout} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Catch::WildcardPattern} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos Arquivos\par \pard\plain 
{\tc \v \'CDndice dos Arquivos}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de Arquivos\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta \'E9 a lista de todos os arquivos e suas respectivas descri\'E7\'F5es:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b include/{\b Emprestimo.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/{\b Livro.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b include/{\b Usuario.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Emprestimo.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Livro.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Usuario.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b catch_amalgamated.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b catch_amalgamated.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b EmprestimoTest.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b test/{\b UsuarioTest.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch\par \pard\plain 
{\tc\tcl2 \v Catch}
{\xe \v Catch}
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Benchmark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Clara}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Generators}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b literals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Matchers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b TestCaseTracking}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b TextFlow}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b always_false}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Approx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertionHandler}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AssertionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AssertionReaction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertionResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AssertionResultData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AutoReg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BenchmarkInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BenchmarkStats}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BinaryExpr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b capture_by_value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Capturer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ColumnInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Config}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ConfigData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Context}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Counts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Decomposer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExceptionTranslatorRegistrar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExprLhs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GeneratorException}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IConfig}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IExceptionTranslator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IExceptionTranslatorRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IGeneratorTracker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IMutableEnumValuesRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IMutableRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IResultCapture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_callable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_callable< Fun(Args...)>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_callable_tester}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_range}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ITestInvoker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ITransientExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LazyExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MessageInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MessageStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NameAndTags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Optional}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ProcessedReporterSpec}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ratio_string}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ratio_string< std::atto >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ratio_string< std::femto >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ratio_string< std::micro >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ratio_string< std::milli >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ratio_string< std::nano >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ratio_string< std::pico >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RegistrarForTagAliases}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ReporterSpec}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ResultDisposition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ResultWas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ReusableStringStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ScopedMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Section}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SectionEndInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SectionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Session}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SignalDefs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SimplePcg32}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SourceLineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StreamEndStop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< bool >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< Catch::Approx >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< double >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< float >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< R C::* >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< signed char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< signed char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::chrono::duration< Value, Ratio > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::chrono::time_point< Clock, Duration > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::nullptr_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::string >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< std::wstring >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< T[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< unsigned long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< wchar_t * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringMaker< wchar_t const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b StringStreams}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TablePrinter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Tag}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TagAlias}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestCaseHandle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TestCaseInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TestFailureException}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that an assertion macro failed. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestInvokerAsMethod}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TestSkipException}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that the remainder of a test should be skipped. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestSpec}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Timer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Totals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b true_given}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b UnaryExpr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Version}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b WaitForKeypress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b WarnAbout}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WildcardPattern}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b RegistryHubSingleton} = Singleton<RegistryHub, {\b IRegistryHub}, {\b IMutableRegistryHub}>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b IReporterFactoryPtr} = {\b Detail::unique_ptr}<IReporterFactory>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func , typename... U> using {\b FunctionReturnType} = std::remove_reference_t<std::remove_cv_t<std::result_of_t<Func(U...)>>>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b exceptionTranslateFunction} = std::string(*)()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ExceptionTranslators} = std::vector<{\b Detail::unique_ptr}<{\b IExceptionTranslator} const>>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Justification} \{ {\b Left}
, {\b Right}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Verbosity} \{ {\b Quiet} = 0
, {\b Normal}
, {\b High}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b ShowDurations} \{ {\b DefaultForReporter}
, {\b Always}
, {\b Never}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b TestRunOrder} \{ {\b Declared}
, {\b LexicographicallySorted}
, {\b Randomized}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b ColourMode} : std::uint8_t \{ {\b PlatformDefault}
, {\b ANSI}
, {\b Win32}
, {\b None}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b CaseSensitive} \{ {\b Yes}
, {\b No}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b GenerateFrom} \{ {\b Time}
, {\b RandomDevice}
, {\b Default}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b TestCaseProperties} : uint8_t \{ {\b None} = 0
, {\b IsHidden} = 1 << 1
, {\b ShouldFail} = 1 << 2
, {\b MayFail} = 1 << 3
, {\b Throws} = 1 << 4
, {\b NonPortable} = 1 << 5
, {\b Benchmark} = 1 << 6
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b ProcessedReporterSpec} const &lhs, {\b ProcessedReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b getSeed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns Catch2's current RNG seed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRegistryHub} const & {\b getRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IMutableRegistryHub} & {\b getMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cleanUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b translateActiveException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b TestCaseInfo} > {\b makeTestCaseInfo} ({\b StringRef} _className, {\b NameAndTags} const &nameAndTags, {\b SourceLineInfo} const &_lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b TestCaseInfo} const &lhs, {\b TestCaseInfo} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, {\b Version} const &version)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Version} const & {\b libraryVersion} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionMatchExpr} ({\b AssertionHandler} &handler, std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clara::Parser} {\b makeCommandLineParser} ({\b ConfigData} &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< ColourImpl > {\b makeColourImpl} ({\b ColourMode} colourSelection, IStream *stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isColourImplAvailable} ({\b ColourMode} colourSelection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cleanUpContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} & {\b getCurrentMutableContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SimplePcg32} & {\b sharedRng} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b writeToDebugConsole} (std::string const &text)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDebuggerActive} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b formatReconstructedExpression} (std::ostream &os, std::string const &lhs, {\b StringRef} op, std::string const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_exception} (std::exception const &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_logic_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_domain_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_runtime_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b makeStream} (std::string const &filename) -> {\b Detail::unique_ptr}< IStream >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator<<} (std::ostream &os, {\b LazyExpression} const &lazyExpr) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b list} (IEventListener &reporter, {\b Config} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< unsigned int > {\b parseUInt} (std::string const &input, int base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isnan} (float f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isnan} (double d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b nextafter} (float {\b x}, float y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b nextafter} (double {\b x}, double y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b generateRandomSeed} ({\b GenerateFrom} from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b ReporterSpec} const &lhs, {\b ReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ReporterSpec} > {\b parseReporterSpec} ({\b StringRef} reporterSpec)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isOk} ({\b ResultWas::OfType} resultType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isJustInfo} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b operator|} ({\b ResultDisposition::Flags} lhs, {\b ResultDisposition::Flags} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldContinueOnFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldSuppressFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IResultCapture} & {\b getResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b seedRng} ({\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b rngSeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addSingleton} (ISingleton *singleton)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cleanupSingletons} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, {\b SourceLineInfo} const &info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b cout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b cerr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b clog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startsWith} (std::string const &s, std::string const &prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startsWith} ({\b StringRef} s, char prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b endsWith} (std::string const &s, std::string const &suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b endsWith} (std::string const &s, char suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (std::string const &s, std::string const &infix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toLowerInPlace} (std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toLower} (std::string const &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b toLower} (char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b trim} (std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b trim} ({\b StringRef} ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b replaceInPlace} (std::string &str, std::string const &replaceThis, std::string const &withThis)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b splitStringRef} ({\b StringRef} str, char delimiter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, pluralise const &pluraliser)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator<<} (std::ostream &os, {\b StringRef} str) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator+} ({\b StringRef} lhs, {\b StringRef} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator+=} (std::string &lhs, {\b StringRef} rhs) -> std::string &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > {\b sortTests} ({\b IConfig} const &config, std::vector< {\b TestCaseHandle} > const &unsortedTestCases)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isThrowSafe} ({\b TestCaseHandle} const &testCase, {\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > {\b filterTests} (std::vector< {\b TestCaseHandle} > const &testCases, {\b TestSpec} const &testSpec, {\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > const & {\b getAllTestCasesSorted} ({\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_test_failure_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_test_skip_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b ITestInvoker} > {\b makeTestInvoker} (void(*testAsFunction)())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b uncaught_exceptions} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmlFormatting {\b operator|} (XmlFormatting lhs, XmlFormatting rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmlFormatting {\b operator&} (XmlFormatting lhs, XmlFormatting rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, XmlEncode const &xmlEncode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionMatchExpr} ({\b AssertionHandler} &handler, StringMatcher const &matcher)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getFormattedDuration} (double duration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldShowDuration} ({\b IConfig} const &config, double duration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b serializeFilters} (std::vector< std::string > const &filters)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &out, lineOfChars {\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b defaultListReporters} (std::ostream &out, std::vector< ReporterDescription > const &descriptions, {\b Verbosity} verbosity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b defaultListListeners} (std::ostream &out, std::vector< ListenerDescription > const &descriptions)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b defaultListTags} (std::ostream &out, std::vector< TagInfo > const &tags, bool isFiltered)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b defaultListTests} (std::ostream &out, ColourImpl *streamColour, std::vector< {\b TestCaseHandle} > const &tests, bool isFiltered, {\b Verbosity} verbosity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printTestRunTotals} (std::ostream &stream, ColourImpl &streamColour, {\b Totals} const &totals)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} const & {\b getCurrentContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator""_sr} (char const *rawChars, std::size_t size) noexcept -> {\b StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFalseTest} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Range > std::string {\b rangeToString} (Range const &range)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Allocator > std::string {\b rangeToString} (std::vector< bool, Allocator > const &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > {\b Detail::unique_ptr}< {\b ITestInvoker} > {\b makeTestInvoker} (void(C::*testAsMethod)())\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v exceptionTranslateFunction\:Catch}
{\xe \v Catch\:exceptionTranslateFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::exceptionTranslateFunction} = std::string(*)()}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ExceptionTranslators\:Catch}
{\xe \v Catch\:ExceptionTranslators}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::ExceptionTranslators} = std::vector<{\b Detail::unique_ptr}<{\b IExceptionTranslator} const>>}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FunctionReturnType\:Catch}
{\xe \v Catch\:FunctionReturnType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Func , typename... U> using {\b Catch::FunctionReturnType} = std::remove_reference_t<std::remove_cv_t<std::result_of_t<Func(U...)>>>}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IReporterFactoryPtr\:Catch}
{\xe \v Catch\:IReporterFactoryPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::IReporterFactoryPtr} = {\b Detail::unique_ptr}<IReporterFactory>}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RegistryHubSingleton\:Catch}
{\xe \v Catch\:RegistryHubSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::RegistryHubSingleton} = Singleton<RegistryHub, {\b IRegistryHub}, {\b IMutableRegistryHub}>}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 
{\xe \v CaseSensitive\:Catch}
{\xe \v Catch\:CaseSensitive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::CaseSensitive}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Yes\:Catch}
{\xe \v Catch\:Yes}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Yes{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
\cell }{\cell }{\row }
{\xe \v No\:Catch}
{\xe \v Catch\:No}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid No{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3375 \{ Yes, No \};\par
}
}
{\xe \v ColourMode\:Catch}
{\xe \v Catch\:ColourMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::ColourMode} : std::uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PlatformDefault\:Catch}
{\xe \v Catch\:PlatformDefault}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PlatformDefault{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Let Catch2 pick implementation based on platform detection. \par
}\cell }{\row }
{\xe \v ANSI\:Catch}
{\xe \v Catch\:ANSI}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ANSI{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use ANSI colour code escapes. \par
}\cell }{\row }
{\xe \v Win32\:Catch}
{\xe \v Catch\:Win32}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Win32{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use Win32 console colour API. \par
}\cell }{\row }
{\xe \v None\:Catch}
{\xe \v Catch\:None}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid None{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Don't use any colour. \par
}\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1148                           : std::uint8_t \{\par
1150         PlatformDefault,\par
1152         ANSI,\par
1154         Win32,\par
1156         None\par
1157     \};\par
}
}
{\xe \v GenerateFrom\:Catch}
{\xe \v Catch\:GenerateFrom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::GenerateFrom}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Time\:Catch}
{\xe \v Catch\:Time}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Time{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
\cell }{\cell }{\row }
{\xe \v RandomDevice\:Catch}
{\xe \v Catch\:RandomDevice}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid RandomDevice{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
\cell }{\cell }{\row }
{\xe \v Default\:Catch}
{\xe \v Catch\:Default}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Default{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Currently equivalent to RandomDevice, but can change at any point. \par
}\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3629                             \{\par
3630         Time,\par
3631         RandomDevice,\par
3633         Default\par
3634     \};\par
}
}
{\xe \v Justification\:Catch}
{\xe \v Catch\:Justification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::Justification}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Left\:Catch}
{\xe \v Catch\:Left}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Left{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\cell }{\cell }{\row }
{\xe \v Right\:Catch}
{\xe \v Catch\:Right}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Right{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9010 \{ Left, Right \};\par
}
}
{\xe \v ShowDurations\:Catch}
{\xe \v Catch\:ShowDurations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::ShowDurations}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v DefaultForReporter\:Catch}
{\xe \v Catch\:DefaultForReporter}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DefaultForReporter{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
\cell }{\cell }{\row }
{\xe \v Always\:Catch}
{\xe \v Catch\:Always}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Always{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
\cell }{\cell }{\row }
{\xe \v Never\:Catch}
{\xe \v Catch\:Never}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Never{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1138                              \{\par
1139         DefaultForReporter,\par
1140         Always,\par
1141         Never\par
1142     \};\par
}
}
{\xe \v TestCaseProperties\:Catch}
{\xe \v Catch\:TestCaseProperties}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::TestCaseProperties} : uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v None\:Catch}
{\xe \v Catch\:None}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid None{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\cell }{\cell }{\row }
{\xe \v IsHidden\:Catch}
{\xe \v Catch\:IsHidden}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IsHidden{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
\cell }{\cell }{\row }
{\xe \v ShouldFail\:Catch}
{\xe \v Catch\:ShouldFail}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ShouldFail{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
\cell }{\cell }{\row }
{\xe \v MayFail\:Catch}
{\xe \v Catch\:MayFail}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MayFail{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
\cell }{\cell }{\row }
{\xe \v Throws\:Catch}
{\xe \v Catch\:Throws}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Throws{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\cell }{\cell }{\row }
{\xe \v NonPortable\:Catch}
{\xe \v Catch\:NonPortable}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NonPortable{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\cell }{\cell }{\row }
{\xe \v Benchmark\:Catch}
{\xe \v Catch\:Benchmark}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Benchmark{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7040                                   : uint8_t \{\par
7041         None = 0,\par
7042         IsHidden = 1 << 1,\par
7043         ShouldFail = 1 << 2,\par
7044         MayFail = 1 << 3,\par
7045         Throws = 1 << 4,\par
7046         NonPortable = 1 << 5,\par
7047         Benchmark = 1 << 6\par
7048     \};\par
}
}
{\xe \v TestRunOrder\:Catch}
{\xe \v Catch\:TestRunOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::TestRunOrder}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Declared\:Catch}
{\xe \v Catch\:Declared}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Declared{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
\cell }{\cell }{\row }
{\xe \v LexicographicallySorted\:Catch}
{\xe \v Catch\:LexicographicallySorted}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LexicographicallySorted{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
\cell }{\cell }{\row }
{\xe \v Randomized\:Catch}
{\xe \v Catch\:Randomized}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Randomized{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1143                             \{\par
1144         Declared,\par
1145         LexicographicallySorted,\par
1146         Randomized\par
1147     \};\par
}
}
{\xe \v Verbosity\:Catch}
{\xe \v Catch\:Verbosity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::Verbosity}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Quiet\:Catch}
{\xe \v Catch\:Quiet}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Quiet{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\cell }{\cell }{\row }
{\xe \v Normal\:Catch}
{\xe \v Catch\:Normal}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Normal{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
\cell }{\cell }{\row }
{\xe \v High\:Catch}
{\xe \v Catch\:High}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid High{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1124                          \{\par
1125         Quiet = 0,\par
1126         Normal,\par
1127         High\par
1128     \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v addSingleton\:Catch}
{\xe \v Catch\:addSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::addSingleton (ISingleton * singleton)}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6180                                               \{\par
6181         getSingletons()->push_back( singleton );\par
6182     \}\par
}
}
{\xe \v cerr\:Catch}
{\xe \v Catch\:cerr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::cerr ()}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6252 \{ {\cf19 return} std::cerr; \}\par
}
}
{\xe \v cleanUp\:Catch}
{\xe \v Catch\:cleanUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::cleanUp ()}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1144                    \{\par
1145         cleanupSingletons();\par
1146         cleanUpContext();\par
1147     \}\par
}
}
{\xe \v cleanUpContext\:Catch}
{\xe \v Catch\:cleanUpContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::cleanUpContext ()}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3638                           \{\par
3639         {\cf17 delete} Context::currentContext;\par
3640         Context::currentContext = {\cf17 nullptr};\par
3641     \}\par
}
}
{\xe \v cleanupSingletons\:Catch}
{\xe \v Catch\:cleanupSingletons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::cleanupSingletons ()}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6183                              \{\par
6184         {\cf17 auto}& singletons = getSingletons();\par
6185         {\cf19 for}( {\cf17 auto} singleton : *singletons )\par
6186             {\cf17 delete} singleton;\par
6187         {\cf17 delete} singletons;\par
6188         singletons = {\cf17 nullptr};\par
6189     \}\par
}
}
{\xe \v clog\:Catch}
{\xe \v Catch\:clog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::clog ()}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6253 \{ {\cf19 return} std::clog; \}\par
}
}
{\xe \v contains\:Catch}
{\xe \v Catch\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::contains (std::string const & s, std::string const & infix)}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6279                                                                 \{\par
6280         {\cf19 return} s.find( infix ) != std::string::npos;\par
6281     \}\par
}
}
{\xe \v cout\:Catch}
{\xe \v Catch\:cout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::cout ()}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6251 \{ {\cf19 return} std::cout; \}\par
}
}
{\xe \v defaultListListeners\:Catch}
{\xe \v Catch\:defaultListListeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::defaultListListeners (std::ostream & out, std::vector< ListenerDescription > const & descriptions)}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9701                                                                                     \{\par
9702         out << {\cf22 "Registered listeners:\\n"};\par
9703 \par
9704         {\cf19 if}(descriptions.empty()) \{\par
9705             {\cf19 return};\par
9706         \}\par
9707 \par
9708         {\cf17 const} {\cf17 auto} maxNameLen =\par
9709             std::max_element( descriptions.begin(),\par
9710                               descriptions.end(),\par
9711                               []( ListenerDescription {\cf17 const}& lhs,\par
9712                                   ListenerDescription {\cf17 const}& rhs ) \{\par
9713                                   return lhs.name.size() < rhs.name.size();\par
9714                               \} )\par
9715                 ->name.size();\par
9716 \par
9717         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
9718             out << TextFlow::Column( static_cast<std::string>( desc.name ) +\par
9719                                      {\cf23 ':'} )\par
9720                            .indent( 2 )\par
9721                            .width( maxNameLen + 5 ) +\par
9722                        TextFlow::Column( desc.description )\par
9723                            .initialIndent( 0 )\par
9724                            .indent( 2 )\par
9725                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\par
9726                 << {\cf23 '\\n'};\par
9727         \}\par
9728 \par
9729         out << {\cf23 '\\n'} << std::flush;\par
9730     \}\par
}
}
{\xe \v defaultListReporters\:Catch}
{\xe \v Catch\:defaultListReporters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::defaultListReporters (std::ostream & out, std::vector< ReporterDescription > const & descriptions, {\b Verbosity} verbosity)}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9669                                                 \{\par
9670         out << {\cf22 "Available reporters:\\n"};\par
9671         {\cf17 const} {\cf17 auto} maxNameLen =\par
9672             std::max_element( descriptions.begin(),\par
9673                               descriptions.end(),\par
9674                               []( ReporterDescription {\cf17 const}& lhs,\par
9675                                   ReporterDescription {\cf17 const}& rhs ) \{\par
9676                                   return lhs.name.size() < rhs.name.size();\par
9677                               \} )\par
9678                 ->name.size();\par
9679 \par
9680         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
9681             {\cf19 if} ( verbosity == Verbosity::Quiet ) \{\par
9682                 out << TextFlow::Column( desc.name )\par
9683                            .indent( 2 )\par
9684                            .width( 5 + maxNameLen )\par
9685                     << {\cf23 '\\n'};\par
9686             \} {\cf19 else} \{\par
9687                 out << TextFlow::Column( desc.name + {\cf23 ':'} )\par
9688                                .indent( 2 )\par
9689                                .width( 5 + maxNameLen ) +\par
9690                            TextFlow::Column( desc.description )\par
9691                                .initialIndent( 0 )\par
9692                                .indent( 2 )\par
9693                                .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\par
9694                     << {\cf23 '\\n'};\par
9695             \}\par
9696         \}\par
9697         out << {\cf23 '\\n'} << std::flush;\par
9698     \}\par
}
}
{\xe \v defaultListTags\:Catch}
{\xe \v Catch\:defaultListTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::defaultListTags (std::ostream & out, std::vector< TagInfo > const & tags, bool isFiltered)}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9734                                             \{\par
9735         {\cf19 if} ( isFiltered ) \{\par
9736             out << {\cf22 "Tags for matching test cases:\\n"};\par
9737         \} {\cf19 else} \{\par
9738             out << {\cf22 "All available tags:\\n"};\par
9739         \}\par
9740 \par
9741         {\cf19 for} ( {\cf17 auto} {\cf17 const}& tagCount : tags ) \{\par
9742             ReusableStringStream rss;\par
9743             rss << {\cf22 "  "} << std::setw( 2 ) << tagCount.count << {\cf22 "  "};\par
9744             {\cf17 auto} str = rss.str();\par
9745             {\cf17 auto} wrapper = TextFlow::Column( tagCount.all() )\par
9746                                .initialIndent( 0 )\par
9747                                .indent( str.size() )\par
9748                                .width( CATCH_CONFIG_CONSOLE_WIDTH - 10 );\par
9749             out << str << wrapper << {\cf23 '\\n'};\par
9750         \}\par
9751         out << pluralise(tags.size(), {\cf22 "tag"}_sr) << {\cf22 "\\n\\n"} << std::flush;\par
9752     \}\par
}
}
{\xe \v defaultListTests\:Catch}
{\xe \v Catch\:defaultListTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::defaultListTests (std::ostream & out, ColourImpl * streamColour, std::vector< {\b TestCaseHandle} > const & tests, bool isFiltered, {\b Verbosity} verbosity)}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9754                                                                                                                                                    \{\par
9755         {\cf20 // We special case this to provide the equivalent of old}\par
9756         {\cf20 // `--list-test-names-only`, which could then be used by the}\par
9757         {\cf20 // `--input-file` option.}\par
9758         {\cf19 if} (verbosity == Verbosity::Quiet) \{\par
9759             listTestNamesOnly(out, tests);\par
9760             {\cf19 return};\par
9761         \}\par
9762 \par
9763         {\cf19 if} (isFiltered) \{\par
9764             out << {\cf22 "Matching test cases:\\n"};\par
9765         \} {\cf19 else} \{\par
9766             out << {\cf22 "All available test cases:\\n"};\par
9767         \}\par
9768 \par
9769         {\cf19 for} ({\cf17 auto} {\cf17 const}& test : tests) \{\par
9770             {\cf17 auto} {\cf17 const}& testCaseInfo = test.getTestCaseInfo();\par
9771             Colour::Code colour = testCaseInfo.isHidden()\par
9772                 ? Colour::SecondaryText\par
9773                 : Colour::None;\par
9774             {\cf17 auto} colourGuard = streamColour->guardColour( colour ).engage( out );\par
9775 \par
9776             out << TextFlow::Column(testCaseInfo.name).indent(2) << {\cf23 '\\n'};\par
9777             {\cf19 if} (verbosity >= Verbosity::High) \{\par
9778                 out << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << {\cf23 '\\n'};\par
9779             \}\par
9780             {\cf19 if} (!testCaseInfo.tags.empty() &&\par
9781                 verbosity > Verbosity::Quiet) \{\par
9782                 out << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << {\cf23 '\\n'};\par
9783             \}\par
9784         \}\par
9785 \par
9786         {\cf19 if} (isFiltered) \{\par
9787             out << pluralise(tests.size(), {\cf22 "matching test case"}_sr);\par
9788         \} {\cf19 else} \{\par
9789             out << pluralise(tests.size(), {\cf22 "test case"}_sr);\par
9790         \}\par
9791         out << {\cf22 "\\n\\n"} << std::flush;\par
9792     \}\par
}
}
{\xe \v endsWith\:Catch}
{\xe \v Catch\:endsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::endsWith (std::string const & s, char suffix)}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6276                                                      \{\par
6277         {\cf19 return} !s.empty() && s[s.size()-1] == suffix;\par
6278     \}\par
}
}
{\xe \v endsWith\:Catch}
{\xe \v Catch\:endsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::endsWith (std::string const & s, std::string const & suffix)}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6273                                                                  \{\par
6274         {\cf19 return} s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\par
6275     \}\par
}
}
{\xe \v filterTests\:Catch}
{\xe \v Catch\:filterTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b TestCaseHandle} > Catch::filterTests (std::vector< {\b TestCaseHandle} > const & testCases, {\b TestSpec} const & testSpec, {\b IConfig} const & config)}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6598                                                                                                                                          \{\par
6599         std::vector<TestCaseHandle> filtered;\par
6600         filtered.reserve( testCases.size() );\par
6601         {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : testCases) \{\par
6602             {\cf19 if} ((!testSpec.hasFilters() && !testCase.getTestCaseInfo().isHidden()) ||\par
6603                 (testSpec.hasFilters() && matchTest(testCase, testSpec, config))) \{\par
6604                 filtered.push_back(testCase);\par
6605             \}\par
6606         \}\par
6607         {\cf19 return} createShard(filtered, config.shardCount(), config.shardIndex());\par
6608     \}\par
}
}
{\xe \v formatReconstructedExpression\:Catch}
{\xe \v Catch\:formatReconstructedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::formatReconstructedExpression (std::ostream & os, std::string const & lhs, {\b StringRef} op, std::string const & rhs)}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3822                                                                                                                    \{\par
3823         {\cf19 if}( lhs.size() + rhs.size() < 40 &&\par
3824                 lhs.find({\cf23 '\\n'}) == std::string::npos &&\par
3825                 rhs.find({\cf23 '\\n'}) == std::string::npos )\par
3826             os << lhs << {\cf23 ' '} << op << {\cf23 ' '} << rhs;\par
3827         {\cf19 else}\par
3828             os << lhs << {\cf23 '\\n'} << op << {\cf23 '\\n'} << rhs;\par
3829     \}\par
}
}
{\xe \v generateRandomSeed\:Catch}
{\xe \v Catch\:generateRandomSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint32_t Catch::generateRandomSeed ({\b GenerateFrom} from)}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5096                                                         \{\par
5097         {\cf19 switch} ( from ) \{\par
5098         {\cf19 case} GenerateFrom::Time:\par
5099             {\cf19 return} {\cf17 static_cast<}std::uint32_t{\cf17 >}( std::time( {\cf17 nullptr} ) );\par
5100 \par
5101         {\cf19 case} GenerateFrom::Default:\par
5102         {\cf19 case} GenerateFrom::RandomDevice: \{\par
5103             std::random_device rd;\par
5104             {\cf19 return} Detail::fillBitsFrom<std::uint32_t>( rd );\par
5105         \}\par
5106 \par
5107         {\cf19 default}:\par
5108             CATCH_ERROR({\cf22 "Unknown generation method"});\par
5109         \}\par
5110     \}\par
}
}
{\xe \v getAllTestCasesSorted\:Catch}
{\xe \v Catch\:getAllTestCasesSorted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b TestCaseHandle} > const  & Catch::getAllTestCasesSorted ({\b IConfig} const & config)}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6609                                                                                     \{\par
6610         {\cf19 return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );\par
6611     \}\par
}
}
{\xe \v getCurrentContext\:Catch}
{\xe \v Catch\:getCurrentContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Context} const  & Catch::getCurrentContext (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 566                                               \{\par
567         {\cf20 // We duplicate the logic from `getCurrentMutableContext` here,}\par
568         {\cf20 // to avoid paying the call overhead in debug mode.}\par
569         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
570         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
571         {\cf19 return} *Context::currentContext;\par
572     \}\par
}
}
{\xe \v getCurrentMutableContext\:Catch}
{\xe \v Catch\:getCurrentMutableContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Context} & Catch::getCurrentMutableContext ()}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3646                                         \{\par
3647         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
3648         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
3649         {\cf19 return} *Context::currentContext;\par
3650     \}\par
}
}
{\xe \v getFormattedDuration\:Catch}
{\xe \v Catch\:getFormattedDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::getFormattedDuration (double duration)}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9606                                                       \{\par
9607         {\cf20 // Max exponent + 1 is required to represent the whole part}\par
9608         {\cf20 // + 1 for decimal point}\par
9609         {\cf20 // + 3 for the 3 decimal places}\par
9610         {\cf20 // + 1 for null terminator}\par
9611         {\cf17 const} std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\par
9612         {\cf18 char} buffer[maxDoubleSize];\par
9613 \par
9614         {\cf20 // Save previous errno, to prevent sprintf from overwriting it}\par
9615         ErrnoGuard guard;\par
9616 {\cf21 #ifdef _MSC_VER}\par
9617         {\cf18 size_t} printedLength = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
9618             sprintf_s( buffer, {\cf22 "%.3f"}, duration ) );\par
9619 {\cf21 #else}\par
9620         {\cf18 size_t} printedLength = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
9621             std::snprintf( buffer, maxDoubleSize, {\cf22 "%.3f"}, duration ) );\par
9622 {\cf21 #endif}\par
9623         {\cf19 return} std::string( buffer, printedLength );\par
9624     \}\par
}
}
{\xe \v getMutableRegistryHub\:Catch}
{\xe \v Catch\:getMutableRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IMutableRegistryHub} & Catch::getMutableRegistryHub ()}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1141                                                  \{\par
1142         {\cf19 return} RegistryHubSingleton::getMutable();\par
1143     \}\par
}
}
{\xe \v getRegistryHub\:Catch}
{\xe \v Catch\:getRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IRegistryHub} const  & Catch::getRegistryHub ()}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1138                                          \{\par
1139         {\cf19 return} RegistryHubSingleton::get();\par
1140     \}\par
}
}
{\xe \v getResultCapture\:Catch}
{\xe \v Catch\:getResultCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IResultCapture} & Catch::getResultCapture ()}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6095                                        \{\par
6096         {\cf19 if} ({\cf17 auto}* capture = getCurrentContext().getResultCapture())\par
6097             {\cf19 return} *capture;\par
6098         {\cf19 else}\par
6099             CATCH_INTERNAL_ERROR({\cf22 "No result capture instance"});\par
6100     \}\par
}
}
{\xe \v getSeed\:Catch}
{\xe \v Catch\:getSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint32_t Catch::getSeed ()}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns Catch2's current RNG seed. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 956                           \{\par
957         {\cf19 return} getCurrentContext().getConfig()->rngSeed();\par
958     \}\par
}
}
{\xe \v handleExceptionMatchExpr\:Catch}
{\xe \v Catch\:handleExceptionMatchExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::handleExceptionMatchExpr ({\b AssertionHandler} & handler, std::string const & str)}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2579                                                                                      \{\par
2580         handleExceptionMatchExpr( handler, Matchers::Equals( str ) );\par
2581     \}\par
}
}
{\xe \v handleExceptionMatchExpr\:Catch}
{\xe \v Catch\:handleExceptionMatchExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::handleExceptionMatchExpr ({\b AssertionHandler} & handler, StringMatcher const & matcher)}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8424                                                                                              \{\par
8425         std::string exceptionMessage = Catch::translateActiveException();\par
8426         MatchExpr<std::string, StringMatcher const&> expr( CATCH_MOVE(exceptionMessage), matcher );\par
8427         handler.handleExpr( expr );\par
8428     \}\par
}
}
{\xe \v isColourImplAvailable\:Catch}
{\xe \v Catch\:isColourImplAvailable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isColourImplAvailable ({\b ColourMode} colourSelection)}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3610                                                              \{\par
3611         {\cf19 switch} ( colourSelection ) \{\par
3612 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3613         {\cf19 case} ColourMode::Win32:\par
3614 {\cf21 #endif}\par
3615         {\cf19 case} ColourMode::ANSI:\par
3616         {\cf19 case} ColourMode::None:\par
3617         {\cf19 case} ColourMode::PlatformDefault:\par
3618             {\cf19 return} {\cf17 true};\par
3619         {\cf19 default}:\par
3620             {\cf19 return} {\cf17 false};\par
3621         \}\par
3622     \}\par
}
}
{\xe \v isDebuggerActive\:Catch}
{\xe \v Catch\:isDebuggerActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isDebuggerActive ()}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3806 \{ {\cf19 return} {\cf17 false}; \}\par
}
}
{\xe \v isFalseTest\:Catch}
{\xe \v Catch\:isFalseTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isFalseTest (int flags){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 838 \{ {\cf19 return} ( flags & ResultDisposition::FalseTest ) != 0; \}\par
}
}
{\xe \v isJustInfo\:Catch}
{\xe \v Catch\:isJustInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isJustInfo (int flags)}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5358                                  \{\par
5359         {\cf19 return} flags == ResultWas::Info;\par
5360     \}\par
}
}
{\xe \v isnan\:Catch}
{\xe \v Catch\:isnan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isnan (double d)}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5000                          \{\par
5001         {\cf19 return} std::isnan(d);\par
5002     \}\par
}
}
{\xe \v isnan\:Catch}
{\xe \v Catch\:isnan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isnan (float f)}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4997                         \{\par
4998         {\cf19 return} std::isnan(f);\par
4999     \}\par
}
}
{\xe \v isOk\:Catch}
{\xe \v Catch\:isOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isOk ({\b ResultWas::OfType} resultType)}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5355                                             \{\par
5356         {\cf19 return} ( resultType & ResultWas::FailureBit ) == 0;\par
5357     \}\par
}
}
{\xe \v isThrowSafe\:Catch}
{\xe \v Catch\:isThrowSafe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::isThrowSafe ({\b TestCaseHandle} const & testCase, {\b IConfig} const & config)}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6594                                                                               \{\par
6595         {\cf19 return} !testCase.getTestCaseInfo().throws() || config.allowThrows();\par
6596     \}\par
}
}
{\xe \v libraryVersion\:Catch}
{\xe \v Catch\:libraryVersion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Version} const  & Catch::libraryVersion ()}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2275                                     \{\par
2276         {\cf17 static} Version version( 3, 6, 0, {\cf22 ""}, 0 );\par
2277         {\cf19 return} version;\par
2278     \}\par
}
}
{\xe \v list\:Catch}
{\xe \v Catch\:list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::list (IEventListener & reporter, {\b Config} const & config)}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4736                                                                 \{\par
4737         {\cf18 bool} listed = {\cf17 false};\par
4738         {\cf19 if} (config.listTests()) \{\par
4739             listed = {\cf17 true};\par
4740             listTests(reporter, config);\par
4741         \}\par
4742         {\cf19 if} (config.listTags()) \{\par
4743             listed = {\cf17 true};\par
4744             listTags(reporter, config);\par
4745         \}\par
4746         {\cf19 if} (config.listReporters()) \{\par
4747             listed = {\cf17 true};\par
4748             listReporters(reporter);\par
4749         \}\par
4750         {\cf19 if} ( config.listListeners() ) \{\par
4751             listed = {\cf17 true};\par
4752             listListeners( reporter );\par
4753         \}\par
4754         {\cf19 return} listed;\par
4755     \}\par
}
}
{\xe \v makeColourImpl\:Catch}
{\xe \v Catch\:makeColourImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::unique_ptr}< ColourImpl > Catch::makeColourImpl ({\b ColourMode} colourSelection, IStream * stream)}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3582                                                                      \{\par
3583 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3584         {\cf19 if} ( colourSelection == ColourMode::Win32 ) \{\par
3585             {\cf19 return} Detail::make_unique<Win32ColourImpl>( stream );\par
3586         \}\par
3587 {\cf21 #endif}\par
3588         {\cf19 if} ( colourSelection == ColourMode::ANSI ) \{\par
3589             {\cf19 return} Detail::make_unique<ANSIColourImpl>( stream );\par
3590         \}\par
3591         {\cf19 if} ( colourSelection == ColourMode::None ) \{\par
3592             {\cf19 return} Detail::make_unique<NoColourImpl>( stream );\par
3593         \}\par
3594 \par
3595         {\cf19 if} ( colourSelection == ColourMode::PlatformDefault) \{\par
3596 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3597             {\cf19 if} ( Win32ColourImpl::useImplementationForStream( *stream ) ) \{\par
3598                 {\cf19 return} Detail::make_unique<Win32ColourImpl>( stream );\par
3599             \}\par
3600 {\cf21 #endif}\par
3601             {\cf19 if} ( ANSIColourImpl::useImplementationForStream( *stream ) ) \{\par
3602                 {\cf19 return} Detail::make_unique<ANSIColourImpl>( stream );\par
3603             \}\par
3604             {\cf19 return} Detail::make_unique<NoColourImpl>( stream );\par
3605         \}\par
3606 \par
3607         CATCH_ERROR( {\cf22 "Could not create colour impl for selection "} << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(colourSelection) );\par
3608     \}\par
}
}
{\xe \v makeCommandLineParser\:Catch}
{\xe \v Catch\:makeCommandLineParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Clara::Parser} Catch::makeCommandLineParser ({\b ConfigData} & config)}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3074                                                             \{\par
3075 \par
3076         {\cf17 using namespace }Clara;\par
3077 \par
3078         {\cf17 auto} {\cf17 const} setWarning = [&]( std::string {\cf17 const}& warning ) \{\par
3079             {\cf19 if} ( warning == {\cf22 "NoAssertions"} ) \{\par
3080                 config.warnings = {\cf17 static_cast<}WarnAbout::What{\cf17 >}(config.warnings | WarnAbout::NoAssertions);\par
3081                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3082             \} {\cf19 else} {\cf19 if} ( warning == {\cf22 "UnmatchedTestSpec"} ) \{\par
3083                 config.warnings = {\cf17 static_cast<}WarnAbout::What{\cf17 >}(config.warnings | WarnAbout::UnmatchedTestSpec);\par
3084                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3085             \}\par
3086 \par
3087             {\cf19 return} ParserResult ::runtimeError(\par
3088                 {\cf22 "Unrecognised warning option: '"} + warning + {\cf23 '\\''} );\par
3089         \};\par
3090         {\cf17 auto} {\cf17 const} loadTestNamesFromFile = [&]( std::string {\cf17 const}& filename ) \{\par
3091                 std::ifstream f( filename.c_str() );\par
3092                 {\cf19 if}( !f.is_open() )\par
3093                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unable to load input file: '"} + filename + {\cf23 '\\''} );\par
3094 \par
3095                 std::string line;\par
3096                 {\cf19 while}( std::getline( f, line ) ) \{\par
3097                     line = trim(line);\par
3098                     {\cf19 if}( !line.empty() && !startsWith( line, {\cf23 '#'} ) ) \{\par
3099                         {\cf19 if}( !startsWith( line, {\cf23 '"'} ) )\par
3100                             line = {\cf23 '"'} + CATCH_MOVE(line) + {\cf23 '"'};\par
3101                         config.testsOrTags.push_back( line );\par
3102                         config.testsOrTags.emplace_back( {\cf22 ","} );\par
3103                     \}\par
3104                 \}\par
3105                 {\cf20 //Remove comma in the end}\par
3106                 {\cf19 if}(!config.testsOrTags.empty())\par
3107                     config.testsOrTags.erase( config.testsOrTags.end()-1 );\par
3108 \par
3109                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3110             \};\par
3111         {\cf17 auto} {\cf17 const} setTestOrder = [&]( std::string {\cf17 const}& order ) \{\par
3112                 {\cf19 if}( startsWith( {\cf22 "declared"}, order ) )\par
3113                     config.runOrder = TestRunOrder::Declared;\par
3114                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "lexical"}, order ) )\par
3115                     config.runOrder = TestRunOrder::LexicographicallySorted;\par
3116                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "random"}, order ) )\par
3117                     config.runOrder = TestRunOrder::Randomized;\par
3118                 {\cf19 else}\par
3119                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised ordering: '"} + order + {\cf23 '\\''} );\par
3120                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3121             \};\par
3122         {\cf17 auto} {\cf17 const} setRngSeed = [&]( std::string {\cf17 const}& seed ) \{\par
3123                 {\cf19 if}( seed == {\cf22 "time"} ) \{\par
3124                     config.rngSeed = generateRandomSeed(GenerateFrom::Time);\par
3125                     {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
3126                 \} {\cf19 else} {\cf19 if} (seed == {\cf22 "random-device"}) \{\par
3127                     config.rngSeed = generateRandomSeed(GenerateFrom::RandomDevice);\par
3128                     {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
3129                 \}\par
3130 \par
3131                 {\cf20 // TODO: ideally we should be parsing uint32_t directly}\par
3132                 {\cf20 //       fix this later when we add new parse overload}\par
3133                 {\cf17 auto} parsedSeed = parseUInt( seed, 0 );\par
3134                 {\cf19 if} ( !parsedSeed ) \{\par
3135                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Could not parse '"} + seed + {\cf22 "' as seed"} );\par
3136                 \}\par
3137                 config.rngSeed = *parsedSeed;\par
3138                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3139             \};\par
3140         {\cf17 auto} {\cf17 const} setDefaultColourMode = [&]( std::string {\cf17 const}& colourMode ) \{\par
3141             Optional<ColourMode> maybeMode = Catch::Detail::stringToColourMode(toLower( colourMode ));\par
3142             {\cf19 if} ( !maybeMode ) \{\par
3143                 {\cf19 return} ParserResult::runtimeError(\par
3144                     {\cf22 "colour mode must be one of: default, ansi, win32, "}\par
3145                     {\cf22 "or none. '"} +\par
3146                     colourMode + {\cf22 "' is not recognised"} );\par
3147             \}\par
3148             {\cf17 auto} mode = *maybeMode;\par
3149             {\cf19 if} ( !isColourImplAvailable( mode ) ) \{\par
3150                 {\cf19 return} ParserResult::runtimeError(\par
3151                     {\cf22 "colour mode '"} + colourMode +\par
3152                     {\cf22 "' is not supported in this binary"} );\par
3153             \}\par
3154             config.defaultColourMode = mode;\par
3155             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3156         \};\par
3157         {\cf17 auto} {\cf17 const} setWaitForKeypress = [&]( std::string {\cf17 const}& keypress ) \{\par
3158                 {\cf17 auto} keypressLc = toLower( keypress );\par
3159                 {\cf19 if} (keypressLc == {\cf22 "never"})\par
3160                     config.waitForKeypress = WaitForKeypress::Never;\par
3161                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "start"} )\par
3162                     config.waitForKeypress = WaitForKeypress::BeforeStart;\par
3163                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "exit"} )\par
3164                     config.waitForKeypress = WaitForKeypress::BeforeExit;\par
3165                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "both"} )\par
3166                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;\par
3167                 {\cf19 else}\par
3168                     {\cf19 return} ParserResult::runtimeError( {\cf22 "keypress argument must be one of: never, start, exit or both. '"} + keypress + {\cf22 "' not recognised"} );\par
3169             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3170             \};\par
3171         {\cf17 auto} {\cf17 const} setVerbosity = [&]( std::string {\cf17 const}& verbosity ) \{\par
3172             {\cf17 auto} lcVerbosity = toLower( verbosity );\par
3173             {\cf19 if}( lcVerbosity == {\cf22 "quiet"} )\par
3174                 config.verbosity = Verbosity::Quiet;\par
3175             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "normal"} )\par
3176                 config.verbosity = Verbosity::Normal;\par
3177             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "high"} )\par
3178                 config.verbosity = Verbosity::High;\par
3179             {\cf19 else}\par
3180                 {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised verbosity, '"} + verbosity + {\cf23 '\\''} );\par
3181             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3182         \};\par
3183         {\cf17 auto} {\cf17 const} setReporter = [&]( std::string {\cf17 const}& userReporterSpec ) \{\par
3184             {\cf19 if} ( userReporterSpec.empty() ) \{\par
3185                 {\cf19 return} ParserResult::runtimeError( {\cf22 "Received empty reporter spec."} );\par
3186             \}\par
3187 \par
3188             Optional<ReporterSpec> parsed =\par
3189                 parseReporterSpec( userReporterSpec );\par
3190             {\cf19 if} ( !parsed ) \{\par
3191                 {\cf19 return} ParserResult::runtimeError(\par
3192                     {\cf22 "Could not parse reporter spec '"} + userReporterSpec +\par
3193                     {\cf22 "'"} );\par
3194             \}\par
3195 \par
3196             {\cf17 auto} {\cf17 const}& reporterSpec = *parsed;\par
3197 \par
3198             {\cf17 auto} {\cf17 const}& factories =\par
3199                 getRegistryHub().getReporterRegistry().getFactories();\par
3200             {\cf17 auto} result = factories.find( reporterSpec.name() );\par
3201 \par
3202             {\cf19 if} ( result == factories.end() ) \{\par
3203                 {\cf19 return} ParserResult::runtimeError(\par
3204                     {\cf22 "Unrecognized reporter, '"} + reporterSpec.name() +\par
3205                     {\cf22 "'. Check available with --list-reporters"} );\par
3206             \}\par
3207 \par
3208 \par
3209             {\cf17 const} {\cf18 bool} hadOutputFile = reporterSpec.outputFile().some();\par
3210             config.reporterSpecifications.push_back( CATCH_MOVE( *parsed ) );\par
3211             {\cf20 // It would be enough to check this only once at the very end, but}\par
3212             {\cf20 // there is  not a place where we could call this check, so do it}\par
3213             {\cf20 // every time it could fail. For valid inputs, this is still called}\par
3214             {\cf20 // at most once.}\par
3215             {\cf19 if} (!hadOutputFile) \{\par
3216                 {\cf18 int} n_reporters_without_file = 0;\par
3217                 {\cf19 for} ({\cf17 auto} {\cf17 const}& spec : config.reporterSpecifications) \{\par
3218                     {\cf19 if} (spec.outputFile().none()) \{\par
3219                         n_reporters_without_file++;\par
3220                     \}\par
3221                 \}\par
3222                 {\cf19 if} (n_reporters_without_file > 1) \{\par
3223                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Only one reporter may have unspecified output file."} );\par
3224                 \}\par
3225             \}\par
3226 \par
3227             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3228         \};\par
3229         {\cf17 auto} {\cf17 const} setShardCount = [&]( std::string {\cf17 const}& shardCount ) \{\par
3230             {\cf17 auto} parsedCount = parseUInt( shardCount );\par
3231             {\cf19 if} ( !parsedCount ) \{\par
3232                 {\cf19 return} ParserResult::runtimeError(\par
3233                     {\cf22 "Could not parse '"} + shardCount + {\cf22 "' as shard count"} );\par
3234             \}\par
3235             {\cf19 if} ( *parsedCount == 0 ) \{\par
3236                 {\cf19 return} ParserResult::runtimeError(\par
3237                     {\cf22 "Shard count must be positive"} );\par
3238             \}\par
3239             config.shardCount = *parsedCount;\par
3240             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3241         \};\par
3242 \par
3243         {\cf17 auto} {\cf17 const} setShardIndex = [&](std::string {\cf17 const}& shardIndex) \{\par
3244             {\cf17 auto} parsedIndex = parseUInt( shardIndex );\par
3245             {\cf19 if} ( !parsedIndex ) \{\par
3246                 {\cf19 return} ParserResult::runtimeError(\par
3247                     {\cf22 "Could not parse '"} + shardIndex + {\cf22 "' as shard index"} );\par
3248             \}\par
3249             config.shardIndex = *parsedIndex;\par
3250             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3251         \};\par
3252 \par
3253         {\cf17 auto} cli\par
3254             = ExeName( config.processName )\par
3255             | Help( config.showHelp )\par
3256             | Opt( config.showSuccessfulTests )\par
3257                 [{\cf22 "-s"}][{\cf22 "--success"}]\par
3258                 ( {\cf22 "include successful tests in output"} )\par
3259             | Opt( config.shouldDebugBreak )\par
3260                 [{\cf22 "-b"}][{\cf22 "--break"}]\par
3261                 ( {\cf22 "break into debugger on failure"} )\par
3262             | Opt( config.noThrow )\par
3263                 [{\cf22 "-e"}][{\cf22 "--nothrow"}]\par
3264                 ( {\cf22 "skip exception tests"} )\par
3265             | Opt( config.showInvisibles )\par
3266                 [{\cf22 "-i"}][{\cf22 "--invisibles"}]\par
3267                 ( {\cf22 "show invisibles (tabs, newlines)"} )\par
3268             | Opt( config.defaultOutputFilename, {\cf22 "filename"} )\par
3269                 [{\cf22 "-o"}][{\cf22 "--out"}]\par
3270                 ( {\cf22 "default output filename"} )\par
3271             | Opt( accept_many, setReporter, {\cf22 "name[::key=value]*"} )\par
3272                 [{\cf22 "-r"}][{\cf22 "--reporter"}]\par
3273                 ( {\cf22 "reporter to use (defaults to console)"} )\par
3274             | Opt( config.name, {\cf22 "name"} )\par
3275                 [{\cf22 "-n"}][{\cf22 "--name"}]\par
3276                 ( {\cf22 "suite name"} )\par
3277             | Opt( [&]( {\cf18 bool} )\{ config.abortAfter = 1; \} )\par
3278                 [{\cf22 "-a"}][{\cf22 "--abort"}]\par
3279                 ( {\cf22 "abort at first failure"} )\par
3280             | Opt( [&]( {\cf18 int} x )\{ config.abortAfter = x; \}, {\cf22 "no. failures"} )\par
3281                 [{\cf22 "-x"}][{\cf22 "--abortx"}]\par
3282                 ( {\cf22 "abort after x failures"} )\par
3283             | Opt( accept_many, setWarning, {\cf22 "warning name"} )\par
3284                 [{\cf22 "-w"}][{\cf22 "--warn"}]\par
3285                 ( {\cf22 "enable warnings"} )\par
3286             | Opt( [&]( {\cf18 bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, {\cf22 "yes|no"} )\par
3287                 [{\cf22 "-d"}][{\cf22 "--durations"}]\par
3288                 ( {\cf22 "show test durations"} )\par
3289             | Opt( config.minDuration, {\cf22 "seconds"} )\par
3290                 [{\cf22 "-D"}][{\cf22 "--min-duration"}]\par
3291                 ( {\cf22 "show test durations for tests taking at least the given number of seconds"} )\par
3292             | Opt( loadTestNamesFromFile, {\cf22 "filename"} )\par
3293                 [{\cf22 "-f"}][{\cf22 "--input-file"}]\par
3294                 ( {\cf22 "load test names to run from a file"} )\par
3295             | Opt( config.filenamesAsTags )\par
3296                 [{\cf22 "-#"}][{\cf22 "--filenames-as-tags"}]\par
3297                 ( {\cf22 "adds a tag for the filename"} )\par
3298             | Opt( config.sectionsToRun, {\cf22 "section name"} )\par
3299                 [{\cf22 "-c"}][{\cf22 "--section"}]\par
3300                 ( {\cf22 "specify section to run"} )\par
3301             | Opt( setVerbosity, {\cf22 "quiet|normal|high"} )\par
3302                 [{\cf22 "-v"}][{\cf22 "--verbosity"}]\par
3303                 ( {\cf22 "set output verbosity"} )\par
3304             | Opt( config.listTests )\par
3305                 [{\cf22 "--list-tests"}]\par
3306                 ( {\cf22 "list all/matching test cases"} )\par
3307             | Opt( config.listTags )\par
3308                 [{\cf22 "--list-tags"}]\par
3309                 ( {\cf22 "list all/matching tags"} )\par
3310             | Opt( config.listReporters )\par
3311                 [{\cf22 "--list-reporters"}]\par
3312                 ( {\cf22 "list all available reporters"} )\par
3313             | Opt( config.listListeners )\par
3314                 [{\cf22 "--list-listeners"}]\par
3315                 ( {\cf22 "list all listeners"} )\par
3316             | Opt( setTestOrder, {\cf22 "decl|lex|rand"} )\par
3317                 [{\cf22 "--order"}]\par
3318                 ( {\cf22 "test case order (defaults to decl)"} )\par
3319             | Opt( setRngSeed, {\cf22 "'time'|'random-device'|number"} )\par
3320                 [{\cf22 "--rng-seed"}]\par
3321                 ( {\cf22 "set a specific seed for random numbers"} )\par
3322             | Opt( setDefaultColourMode, {\cf22 "ansi|win32|none|default"} )\par
3323                 [{\cf22 "--colour-mode"}]\par
3324                 ( {\cf22 "what color mode should be used as default"} )\par
3325             | Opt( config.libIdentify )\par
3326                 [{\cf22 "--libidentify"}]\par
3327                 ( {\cf22 "report name and version according to libidentify standard"} )\par
3328             | Opt( setWaitForKeypress, {\cf22 "never|start|exit|both"} )\par
3329                 [{\cf22 "--wait-for-keypress"}]\par
3330                 ( {\cf22 "waits for a keypress before exiting"} )\par
3331             | Opt( config.skipBenchmarks)\par
3332                 [{\cf22 "--skip-benchmarks"}]\par
3333                 ( {\cf22 "disable running benchmarks"})\par
3334             | Opt( config.benchmarkSamples, {\cf22 "samples"} )\par
3335                 [{\cf22 "--benchmark-samples"}]\par
3336                 ( {\cf22 "number of samples to collect (default: 100)"} )\par
3337             | Opt( config.benchmarkResamples, {\cf22 "resamples"} )\par
3338                 [{\cf22 "--benchmark-resamples"}]\par
3339                 ( {\cf22 "number of resamples for the bootstrap (default: 100000)"} )\par
3340             | Opt( config.benchmarkConfidenceInterval, {\cf22 "confidence interval"} )\par
3341                 [{\cf22 "--benchmark-confidence-interval"}]\par
3342                 ( {\cf22 "confidence interval for the bootstrap (between 0 and 1, default: 0.95)"} )\par
3343             | Opt( config.benchmarkNoAnalysis )\par
3344                 [{\cf22 "--benchmark-no-analysis"}]\par
3345                 ( {\cf22 "perform only measurements; do not perform any analysis"} )\par
3346             | Opt( config.benchmarkWarmupTime, {\cf22 "benchmarkWarmupTime"} )\par
3347                 [{\cf22 "--benchmark-warmup-time"}]\par
3348                 ( {\cf22 "amount of time in milliseconds spent on warming up each test (default: 100)"} )\par
3349             | Opt( setShardCount, {\cf22 "shard count"} )\par
3350                 [{\cf22 "--shard-count"}]\par
3351                 ( {\cf22 "split the tests to execute into this many groups"} )\par
3352             | Opt( setShardIndex, {\cf22 "shard index"} )\par
3353                 [{\cf22 "--shard-index"}]\par
3354                 ( {\cf22 "index of the group of tests to execute (see --shard-count)"} )\par
3355             | Opt( config.allowZeroTests )\par
3356                 [{\cf22 "--allow-running-no-tests"}]\par
3357                 ( {\cf22 "Treat 'No tests run' as a success"} )\par
3358             | Arg( config.testsOrTags, {\cf22 "test name|pattern|tags"} )\par
3359                 ( {\cf22 "which test or tests to use"} );\par
3360 \par
3361         {\cf19 return} cli;\par
3362     \}\par
}
}
{\xe \v makeStream\:Catch}
{\xe \v Catch\:makeStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::makeStream (std::string const & filename) -> {\b Detail::unique_ptr}<IStream> }}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4441                                                                               \{\par
4442         {\cf19 if} ( filename.empty() || filename == {\cf22 "-"} ) \{\par
4443             {\cf19 return} Detail::make_unique<Detail::CoutStream>();\par
4444         \}\par
4445         {\cf19 if}( filename[0] == {\cf23 '%'} ) \{\par
4446             {\cf19 if} ( filename == {\cf22 "%debug"} ) \{\par
4447                 {\cf19 return} Detail::make_unique<Detail::DebugOutStream>();\par
4448             \} {\cf19 else} {\cf19 if} ( filename == {\cf22 "%stderr"} ) \{\par
4449                 {\cf19 return} Detail::make_unique<Detail::CerrStream>();\par
4450             \} {\cf19 else} {\cf19 if} ( filename == {\cf22 "%stdout"} ) \{\par
4451                 {\cf19 return} Detail::make_unique<Detail::CoutStream>();\par
4452             \} {\cf19 else} \{\par
4453                 CATCH_ERROR( {\cf22 "Unrecognised stream: '"} << filename << {\cf23 '\\''} );\par
4454             \}\par
4455         \}\par
4456         {\cf19 return} Detail::make_unique<Detail::FileStream>( filename );\par
4457     \}\par
}
}
{\xe \v makeTestCaseInfo\:Catch}
{\xe \v Catch\:makeTestCaseInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::unique_ptr}< {\b TestCaseInfo} > Catch::makeTestCaseInfo ({\b StringRef} _className, {\b NameAndTags} const & nameAndTags, {\b SourceLineInfo} const & _lineInfo)}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1619                                                            \{\par
1620         {\cf19 return} Detail::make_unique<TestCaseInfo>(_className, nameAndTags, _lineInfo);\par
1621     \}\par
}
}
{\xe \v makeTestInvoker\:Catch}
{\xe \v Catch\:makeTestInvoker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::unique_ptr}< {\b ITestInvoker} > Catch::makeTestInvoker (void(* testAsFunction\~ )())}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6945                                                                               \{\par
6946         {\cf19 return} Detail::make_unique<TestInvokerAsFunction>( testAsFunction );\par
6947     \}\par
}
}
{\xe \v makeTestInvoker\:Catch}
{\xe \v Catch\:makeTestInvoker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > {\b Detail::unique_ptr}< {\b ITestInvoker} > Catch::makeTestInvoker (void(C::* testAsMethod\~ )())}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6004                                                                           \{\par
6005     {\cf19 return} Detail::make_unique<TestInvokerAsMethod<C>>( testAsMethod );\par
6006 \}\par
}
}
{\xe \v nextafter\:Catch}
{\xe \v Catch\:nextafter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::nextafter (double x, double y)}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5018 \{ return ::nextafter( x, y ); \}\par
}
}
{\xe \v nextafter\:Catch}
{\xe \v Catch\:nextafter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Catch::nextafter (float x, float y)}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5017 \{ return ::nextafterf( x, y ); \}\par
}
}
{\xe \v operator!=\:Catch}
{\xe \v Catch\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::operator!= ({\b SimplePcg32} const & lhs, {\b SimplePcg32} const & rhs)}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5082                                                                     \{\par
5083         {\cf19 return} lhs.m_state != rhs.m_state;\par
5084     \}\par
}
}
{\xe \v operator""_sr\:Catch}
{\xe \v Catch\:operator""_sr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator""_sr (char const * rawChars, std::size_t size) -> {\b StringRef} {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 782                                                                                                 \{\par
783         {\cf19 return} StringRef( rawChars, size );\par
784     \}\par
}
}
{\xe \v operator&\:Catch}
{\xe \v Catch\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XmlFormatting Catch::operator& (XmlFormatting lhs, XmlFormatting rhs)}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7689                                                                     \{\par
7690         {\cf19 return} {\cf17 static_cast<}XmlFormatting{\cf17 >}(\par
7691             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(lhs) &\par
7692             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(rhs)\par
7693         );\par
7694     \}\par
}
}
{\xe \v operator+\:Catch}
{\xe \v Catch\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::operator+ ({\b StringRef} lhs, {\b StringRef} rhs)}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6411                                                       \{\par
6412         std::string ret;\par
6413         ret.reserve(lhs.size() + rhs.size());\par
6414         ret += lhs;\par
6415         ret += rhs;\par
6416         {\cf19 return} ret;\par
6417     \}\par
}
}
{\xe \v operator+=\:Catch}
{\xe \v Catch\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator+= (std::string & lhs, {\b StringRef} rhs) -> std::string& }}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6419                                                                    \{\par
6420         lhs.append(rhs.data(), rhs.size());\par
6421         {\cf19 return} lhs;\par
6422     \}\par
}
}
{\xe \v operator<\:Catch}
{\xe \v Catch\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::operator< ({\b Tag} const & lhs, {\b Tag} const & rhs)}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1607                                                       \{\par
1608         Detail::CaseInsensitiveLess cmp;\par
1609         {\cf19 return} cmp( lhs.original, rhs.original );\par
1610     \}\par
}
}
{\xe \v operator<\:Catch}
{\xe \v Catch\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::operator< ({\b TestCaseInfo} const & lhs, {\b TestCaseInfo} const & rhs)}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1746                                                                        \{\par
1747         {\cf20 // We want to avoid redoing the string comparisons multiple times,}\par
1748         {\cf20 // so we store the result of a three-way comparison before using}\par
1749         {\cf20 // it in the actual comparison logic.}\par
1750         {\cf17 const} {\cf17 auto} cmpName = lhs.name.compare( rhs.name );\par
1751         {\cf19 if} ( cmpName != 0 ) \{\par
1752             {\cf19 return} cmpName < 0;\par
1753         \}\par
1754         {\cf17 const} {\cf17 auto} cmpClassName = lhs.className.compare( rhs.className );\par
1755         {\cf19 if} ( cmpClassName != 0 ) \{\par
1756             {\cf19 return} cmpClassName < 0;\par
1757         \}\par
1758         {\cf19 return} lhs.tags < rhs.tags;\par
1759     \}\par
}
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator<< (std::ostream & os, {\b LazyExpression} const & lazyExpr) -> std::ostream& }}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4607                                                                                      \{\par
4608         {\cf19 if} (lazyExpr.m_isNegated)\par
4609             os << {\cf23 '!'};\par
4610 \par
4611         {\cf19 if} (lazyExpr) \{\par
4612             {\cf19 if} (lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression())\par
4613                 os << {\cf23 '('} << *lazyExpr.m_transientExpression << {\cf23 ')'};\par
4614             {\cf19 else}\par
4615                 os << *lazyExpr.m_transientExpression;\par
4616         \} {\cf19 else} \{\par
4617             os << {\cf22 "\{** error - unchecked empty expression requested **\}"};\par
4618         \}\par
4619         {\cf19 return} os;\par
4620     \}\par
}
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::operator<< (std::ostream & os, pluralise const & pluraliser)}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6357                                                                             \{\par
6358         os << pluraliser.m_count << {\cf23 ' '} << pluraliser.m_label;\par
6359         {\cf19 if}( pluraliser.m_count != 1 )\par
6360             os << {\cf23 's'};\par
6361         {\cf19 return} os;\par
6362     \}\par
}
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::operator<< (std::ostream & os, {\b SourceLineInfo} const & info)}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6209                                                                            \{\par
6210 {\cf21 #ifndef __GNUG__}\par
6211         os << info.file << {\cf23 '('} << info.line << {\cf23 ')'};\par
6212 {\cf21 #else}\par
6213         os << info.file << {\cf23 ':'} << info.line;\par
6214 {\cf21 #endif}\par
6215         {\cf19 return} os;\par
6216     \}\par
}
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::operator<< (std::ostream & os, {\b StringRef} str) -> std::ostream& }}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6407                                                                       \{\par
6408         {\cf19 return} os.write(str.data(), {\cf17 static_cast<}std::streamsize{\cf17 >}(str.size()));\par
6409     \}\par
}
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::operator<< (std::ostream & os, {\b Version} const & version)}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2263                                                                        \{\par
2264         os  << version.majorVersion << {\cf23 '.'}\par
2265             << version.minorVersion << {\cf23 '.'}\par
2266             << version.patchNumber;\par
2267         {\cf20 // branchName is never null -> 0th char is \\0 if it is empty}\par
2268         {\cf19 if} (version.branchName[0]) \{\par
2269             os << {\cf23 '-'} << version.branchName\par
2270                << {\cf23 '.'} << version.buildNumber;\par
2271         \}\par
2272         {\cf19 return} os;\par
2273     \}\par
}
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::operator<< (std::ostream & os, XmlEncode const & xmlEncode)}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7796                                                                            \{\par
7797         xmlEncode.encodeTo( os );\par
7798         {\cf19 return} os;\par
7799     \}\par
}
}
{\xe \v operator<<\:Catch}
{\xe \v Catch\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::operator<< (std::ostream & out, lineOfChars value)}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9659                                                                  \{\par
9660         {\cf19 for} ( {\cf18 size_t} idx = 0; idx < CATCH_CONFIG_CONSOLE_WIDTH - 1; ++idx ) \{\par
9661             out.put( value.c );\par
9662         \}\par
9663         {\cf19 return} out;\par
9664     \}\par
}
}
{\xe \v operator==\:Catch}
{\xe \v Catch\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::operator== ({\b ProcessedReporterSpec} const & lhs, {\b ProcessedReporterSpec} const & rhs)}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 788                                                         \{\par
789         {\cf19 return} lhs.name == rhs.name &&\par
790                lhs.outputFilename == rhs.outputFilename &&\par
791                lhs.colourMode == rhs.colourMode &&\par
792                lhs.customOptions == rhs.customOptions;\par
793     \}\par
}
}
{\xe \v operator==\:Catch}
{\xe \v Catch\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::operator== ({\b ReporterSpec} const & lhs, {\b ReporterSpec} const & rhs)}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5275                                                                         \{\par
5276         {\cf19 return} lhs.m_name == rhs.m_name &&\par
5277                lhs.m_outputFileName == rhs.m_outputFileName &&\par
5278                lhs.m_colourMode == rhs.m_colourMode &&\par
5279                lhs.m_customOptions == rhs.m_customOptions;\par
5280     \}\par
}
}
{\xe \v operator==\:Catch}
{\xe \v Catch\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::operator== ({\b SimplePcg32} const & lhs, {\b SimplePcg32} const & rhs)}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5078                                                                     \{\par
5079         {\cf19 return} lhs.m_state == rhs.m_state;\par
5080     \}\par
}
}
{\xe \v operator==\:Catch}
{\xe \v Catch\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::operator== ({\b Tag} const & lhs, {\b Tag} const & rhs)}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1611                                                       \{\par
1612         Detail::CaseInsensitiveEqualTo cmp;\par
1613         {\cf19 return} cmp( lhs.original, rhs.original );\par
1614     \}\par
}
}
{\xe \v operator|\:Catch}
{\xe \v Catch\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultDisposition::Flags} Catch::operator| ({\b ResultDisposition::Flags} lhs, {\b ResultDisposition::Flags} rhs)}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5362                                                                                                  \{\par
5363         {\cf19 return} {\cf17 static_cast<}ResultDisposition::Flags{\cf17 >}( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( lhs ) | {\cf17 static_cast<}{\cf18 int}{\cf17 >}( rhs ) );\par
5364     \}\par
}
}
{\xe \v operator|\:Catch}
{\xe \v Catch\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XmlFormatting Catch::operator| (XmlFormatting lhs, XmlFormatting rhs)}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7682                                                                     \{\par
7683         {\cf19 return} {\cf17 static_cast<}XmlFormatting{\cf17 >}(\par
7684             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(lhs) |\par
7685             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(rhs)\par
7686         );\par
7687     \}\par
}
}
{\xe \v parseReporterSpec\:Catch}
{\xe \v Catch\:parseReporterSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Optional}< {\b ReporterSpec} > Catch::parseReporterSpec ({\b StringRef} reporterSpec)}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parses provided reporter spec string into\par
Returns empty optional on errors, e.g.{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
field that is not first and not a key+value pair\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
duplicated keys in kv pair\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
unknown catch reporter option\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
empty key/value in an custom kv pair\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
... \par}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5282                                                                        \{\par
5283         {\cf17 auto} parts = Detail::splitReporterSpec( reporterSpec );\par
5284 \par
5285         assert( parts.size() > 0 && {\cf22 "Split should never return empty vector"} );\par
5286 \par
5287         std::map<std::string, std::string> kvPairs;\par
5288         Optional<std::string> outputFileName;\par
5289         Optional<ColourMode> colourMode;\par
5290 \par
5291         {\cf20 // First part is always reporter name, so we skip it}\par
5292         {\cf19 for} ( {\cf18 size_t} i = 1; i < parts.size(); ++i ) \{\par
5293             {\cf17 auto} kv = splitKVPair( parts[i] );\par
5294             {\cf17 auto} key = kv.key, value = kv.value;\par
5295 \par
5296             {\cf19 if} ( key.empty() || value.empty() ) \{ {\cf20 // NOLINT(bugprone-branch-clone)}\par
5297                 {\cf19 return} \{\};\par
5298             \} {\cf19 else} {\cf19 if} ( key[0] == {\cf23 'X'} ) \{\par
5299                 {\cf20 // This is a reporter-specific option, we don't check these}\par
5300                 {\cf20 // apart from basic sanity checks}\par
5301                 {\cf19 if} ( key.size() == 1 ) \{\par
5302                     {\cf19 return} \{\};\par
5303                 \}\par
5304 \par
5305                 {\cf17 auto} ret = kvPairs.emplace( std::string(kv.key), std::string(kv.value) );\par
5306                 {\cf19 if} ( !ret.second ) \{\par
5307                     {\cf20 // Duplicated key. We might want to handle this differently,}\par
5308                     {\cf20 // e.g. by overwriting the existing value?}\par
5309                     {\cf19 return} \{\};\par
5310                 \}\par
5311             \} {\cf19 else} {\cf19 if} ( key == {\cf22 "out"} ) \{\par
5312                 {\cf20 // Duplicated key}\par
5313                 {\cf19 if} ( outputFileName ) \{\par
5314                     {\cf19 return} \{\};\par
5315                 \}\par
5316                 outputFileName = {\cf17 static_cast<}std::string{\cf17 >}( value );\par
5317             \} {\cf19 else} {\cf19 if} ( key == {\cf22 "colour-mode"} ) \{\par
5318                 {\cf20 // Duplicated key}\par
5319                 {\cf19 if} ( colourMode ) \{\par
5320                     {\cf19 return} \{\};\par
5321                 \}\par
5322                 colourMode = Detail::stringToColourMode( value );\par
5323                 {\cf20 // Parsing failed}\par
5324                 {\cf19 if} ( !colourMode ) \{\par
5325                     {\cf19 return} \{\};\par
5326                 \}\par
5327             \} {\cf19 else} \{\par
5328                 {\cf20 // Unrecognized option}\par
5329                 {\cf19 return} \{\};\par
5330             \}\par
5331         \}\par
5332 \par
5333         {\cf19 return} ReporterSpec\{ CATCH_MOVE( parts[0] ),\par
5334                              CATCH_MOVE( outputFileName ),\par
5335                              CATCH_MOVE( colourMode ),\par
5336                              CATCH_MOVE( kvPairs ) \};\par
5337     \}\par
}
}
{\xe \v parseUInt\:Catch}
{\xe \v Catch\:parseUInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Optional}< unsigned int > Catch::parseUInt (std::string const & input, int base)}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4953                                                                        \{\par
4954         {\cf17 auto} trimmed = trim( input );\par
4955         {\cf20 // std::stoull is annoying and accepts numbers starting with '-',}\par
4956         {\cf20 // it just negates them into unsigned int}\par
4957         {\cf19 if} ( trimmed.empty() || trimmed[0] == {\cf23 '-'} ) \{\par
4958             {\cf19 return} \{\};\par
4959         \}\par
4960 \par
4961         CATCH_TRY \{\par
4962             {\cf18 size_t} pos = 0;\par
4963             {\cf17 const} {\cf17 auto} ret = std::stoull( trimmed, &pos, base );\par
4964 \par
4965             {\cf20 // We did not consume the whole input, so there is an issue}\par
4966             {\cf20 // This can be bunch of different stuff, like multiple numbers}\par
4967             {\cf20 // in the input, or invalid digits/characters and so on. Either}\par
4968             {\cf20 // way, we do not want to return the partially parsed result.}\par
4969             {\cf19 if} ( pos != trimmed.size() ) \{\par
4970                 {\cf19 return} \{\};\par
4971             \}\par
4972             {\cf20 // Too large}\par
4973             {\cf19 if} ( ret > std::numeric_limits<unsigned int>::max() ) \{\par
4974                 {\cf19 return} \{\};\par
4975             \}\par
4976             {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(ret);\par
4977         \}\par
4978         CATCH_CATCH_ANON( std::invalid_argument {\cf17 const}& ) \{\par
4979             {\cf20 // no conversion could be performed}\par
4980         \}\par
4981         CATCH_CATCH_ANON( std::out_of_range {\cf17 const}& ) \{\par
4982             {\cf20 // the input does not fit into an unsigned long long}\par
4983         \}\par
4984         {\cf19 return} \{\};\par
4985     \}\par
}
}
{\xe \v printTestRunTotals\:Catch}
{\xe \v Catch\:printTestRunTotals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::printTestRunTotals (std::ostream & stream, ColourImpl & streamColour, {\b Totals} const & totals)}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9856                                                     \{\par
9857         {\cf19 if} ( totals.testCases.total() == 0 ) \{\par
9858             stream << streamColour.guardColour( Colour::Warning )\par
9859                    << {\cf22 "No tests ran\\n"};\par
9860             {\cf19 return};\par
9861         \}\par
9862 \par
9863         {\cf19 if} ( totals.assertions.total() > 0 && totals.testCases.allPassed() ) \{\par
9864             stream << streamColour.guardColour( Colour::ResultSuccess )\par
9865                    << {\cf22 "All tests passed"};\par
9866             stream << {\cf22 " ("}\par
9867                    << pluralise( totals.assertions.passed, {\cf22 "assertion"}_sr )\par
9868                    << {\cf22 " in "}\par
9869                    << pluralise( totals.testCases.passed, {\cf22 "test case"}_sr )\par
9870                    << {\cf23 ')'} << {\cf23 '\\n'};\par
9871             {\cf19 return};\par
9872         \}\par
9873 \par
9874         std::vector<SummaryColumn> columns;\par
9875         {\cf20 // Don't include "skipped assertions" in total count}\par
9876         {\cf17 const} {\cf17 auto} totalAssertionCount =\par
9877             totals.assertions.total() - totals.assertions.skipped;\par
9878         columns.push_back( SummaryColumn( {\cf22 ""}, Colour::None )\par
9879                                .addRow( totals.testCases.total() )\par
9880                                .addRow( totalAssertionCount ) );\par
9881         columns.push_back( SummaryColumn( {\cf22 "passed"}, Colour::Success )\par
9882                                .addRow( totals.testCases.passed )\par
9883                                .addRow( totals.assertions.passed ) );\par
9884         columns.push_back( SummaryColumn( {\cf22 "failed"}, Colour::ResultError )\par
9885                                .addRow( totals.testCases.failed )\par
9886                                .addRow( totals.assertions.failed ) );\par
9887         columns.push_back( SummaryColumn( {\cf22 "skipped"}, Colour::Skip )\par
9888                                .addRow( totals.testCases.skipped )\par
9889                                {\cf20 // Don't print "skipped assertions"}\par
9890                                .addRow( 0 ) );\par
9891         columns.push_back(\par
9892             SummaryColumn( {\cf22 "failed as expected"}, Colour::ResultExpectedFailure )\par
9893                 .addRow( totals.testCases.failedButOk )\par
9894                 .addRow( totals.assertions.failedButOk ) );\par
9895         printSummaryRow( stream, streamColour, {\cf22 "test cases"}_sr, columns, 0 );\par
9896         printSummaryRow( stream, streamColour, {\cf22 "assertions"}_sr, columns, 1 );\par
9897     \}\par
}
}
{\xe \v rangeToString\:Catch}
{\xe \v Catch\:rangeToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Range > std::string Catch::rangeToString (Range const & range)}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2924                                                   \{\par
2925         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );\par
2926     \}\par
}
}
{\xe \v rangeToString\:Catch}
{\xe \v Catch\:rangeToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Allocator > std::string Catch::rangeToString (std::vector< bool, Allocator > const & v)}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2930                                                                    \{\par
2931         ReusableStringStream rss;\par
2932         rss << {\cf22 "\{ "};\par
2933         {\cf18 bool} first = {\cf17 true};\par
2934         {\cf19 for}( {\cf18 bool} b : v ) \{\par
2935             {\cf19 if}( first )\par
2936                 first = {\cf17 false};\par
2937             {\cf19 else}\par
2938                 rss << {\cf22 ", "};\par
2939             rss << ::Catch::Detail::stringify( b );\par
2940         \}\par
2941         rss << {\cf22 " \}"};\par
2942         {\cf19 return} rss.str();\par
2943     \}\par
}
}
{\xe \v replaceInPlace\:Catch}
{\xe \v Catch\:replaceInPlace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::replaceInPlace (std::string & str, std::string const & replaceThis, std::string const & withThis)}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6316                                                                                                    \{\par
6317         std::size_t i = str.find( replaceThis );\par
6318         {\cf19 if} (i == std::string::npos) \{\par
6319             {\cf19 return} {\cf17 false};\par
6320         \}\par
6321         std::size_t copyBegin = 0;\par
6322         std::string origStr = CATCH_MOVE(str);\par
6323         str.clear();\par
6324         {\cf20 // There is at least one replacement, so reserve with the best guess}\par
6325         {\cf20 // we can make without actually counting the number of occurences.}\par
6326         str.reserve(origStr.size() - replaceThis.size() + withThis.size());\par
6327         {\cf19 do} \{\par
6328             str.append(origStr, copyBegin, i-copyBegin );\par
6329             str += withThis;\par
6330             copyBegin = i + replaceThis.size();\par
6331             {\cf19 if}( copyBegin < origStr.size() )\par
6332                 i = origStr.find( replaceThis, copyBegin );\par
6333             {\cf19 else}\par
6334                 i = std::string::npos;\par
6335         \} {\cf19 while}( i != std::string::npos );\par
6336         {\cf19 if} ( copyBegin < origStr.size() ) \{\par
6337             str.append(origStr, copyBegin, origStr.size() );\par
6338         \}\par
6339         {\cf19 return} {\cf17 true};\par
6340     \}\par
}
}
{\xe \v rngSeed\:Catch}
{\xe \v Catch\:rngSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::rngSeed ()}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6106                            \{\par
6107         {\cf19 return} getCurrentContext().getConfig()->rngSeed();\par
6108     \}\par
}
}
{\xe \v seedRng\:Catch}
{\xe \v Catch\:seedRng}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::seedRng ({\b IConfig} const & config)}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6102                                         \{\par
6103         sharedRng().seed(config.rngSeed());\par
6104     \}\par
}
}
{\xe \v serializeFilters\:Catch}
{\xe \v Catch\:serializeFilters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::serializeFilters (std::vector< std::string > const & filters)}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9637                                                                       \{\par
9638         {\cf20 // We add a ' ' separator between each filter}\par
9639         {\cf18 size_t} serialized_size = filters.size() - 1;\par
9640         {\cf19 for} ({\cf17 auto} {\cf17 const}& filter : filters) \{\par
9641             serialized_size += filter.size();\par
9642         \}\par
9643 \par
9644         std::string serialized;\par
9645         serialized.reserve(serialized_size);\par
9646         {\cf18 bool} first = {\cf17 true};\par
9647 \par
9648         {\cf19 for} ({\cf17 auto} {\cf17 const}& filter : filters) \{\par
9649             {\cf19 if} (!first) \{\par
9650                 serialized.push_back({\cf23 ' '});\par
9651             \}\par
9652             first = {\cf17 false};\par
9653             serialized.append(filter);\par
9654         \}\par
9655 \par
9656         {\cf19 return} serialized;\par
9657     \}\par
}
}
{\xe \v sharedRng\:Catch}
{\xe \v Catch\:sharedRng}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SimplePcg32} & Catch::sharedRng ()}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3658                              \{\par
3659         {\cf17 static} SimplePcg32 s_rng;\par
3660         {\cf19 return} s_rng;\par
3661     \}\par
}
}
{\xe \v shouldContinueOnFailure\:Catch}
{\xe \v Catch\:shouldContinueOnFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::shouldContinueOnFailure (int flags)}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5366 \{ {\cf19 return} ( flags & ResultDisposition::ContinueOnFailure ) != 0; \}\par
}
}
{\xe \v shouldShowDuration\:Catch}
{\xe \v Catch\:shouldShowDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::shouldShowDuration ({\b IConfig} const & config, double duration)}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9626                                                                       \{\par
9627         {\cf19 if} ( config.showDurations() == ShowDurations::Always ) \{\par
9628             {\cf19 return} {\cf17 true};\par
9629         \}\par
9630         {\cf19 if} ( config.showDurations() == ShowDurations::Never ) \{\par
9631             {\cf19 return} {\cf17 false};\par
9632         \}\par
9633         {\cf17 const} {\cf18 double} min = config.minDuration();\par
9634         {\cf19 return} min >= 0 && duration >= min;\par
9635     \}\par
}
}
{\xe \v shouldSuppressFailure\:Catch}
{\xe \v Catch\:shouldSuppressFailure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::shouldSuppressFailure (int flags)}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5367 \{ {\cf19 return} ( flags & ResultDisposition::SuppressFail ) != 0; \}\par
}
}
{\xe \v sortTests\:Catch}
{\xe \v Catch\:sortTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b TestCaseHandle} > Catch::sortTests ({\b IConfig} const & config, std::vector< {\b TestCaseHandle} > const & unsortedTestCases)}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6543                                                                                                                      \{\par
6544         {\cf19 switch} (config.runOrder()) \{\par
6545         {\cf19 case} TestRunOrder::Declared:\par
6546             {\cf19 return} unsortedTestCases;\par
6547 \par
6548         {\cf19 case} TestRunOrder::LexicographicallySorted: \{\par
6549             std::vector<TestCaseHandle> sorted = unsortedTestCases;\par
6550             std::sort(\par
6551                 sorted.begin(),\par
6552                 sorted.end(),\par
6553                 []( TestCaseHandle {\cf17 const}& lhs, TestCaseHandle {\cf17 const}& rhs ) \{\par
6554                     return lhs.getTestCaseInfo() < rhs.getTestCaseInfo();\par
6555                 \}\par
6556             );\par
6557             {\cf19 return} sorted;\par
6558         \}\par
6559         {\cf19 case} TestRunOrder::Randomized: \{\par
6560             {\cf17 using }TestWithHash = std::pair<TestCaseInfoHasher::hash_t, TestCaseHandle>;\par
6561 \par
6562             TestCaseInfoHasher h\{ config.rngSeed() \};\par
6563             std::vector<TestWithHash> indexed_tests;\par
6564             indexed_tests.reserve(unsortedTestCases.size());\par
6565 \par
6566             {\cf19 for} ({\cf17 auto} {\cf17 const}& handle : unsortedTestCases) \{\par
6567                 indexed_tests.emplace_back(h(handle.getTestCaseInfo()), handle);\par
6568             \}\par
6569 \par
6570             std::sort( indexed_tests.begin(),\par
6571                        indexed_tests.end(),\par
6572                        []( TestWithHash {\cf17 const}& lhs, TestWithHash {\cf17 const}& rhs ) \{\par
6573                            if ( lhs.first == rhs.first ) \{\par
6574                                return lhs.second.getTestCaseInfo() <\par
6575                                       rhs.second.getTestCaseInfo();\par
6576                            \}\par
6577                            {\cf19 return} lhs.first < rhs.first;\par
6578                        \} );\par
6579 \par
6580             std::vector<TestCaseHandle> randomized;\par
6581             randomized.reserve(indexed_tests.size());\par
6582 \par
6583             {\cf19 for} ({\cf17 auto} {\cf17 const}& indexed : indexed_tests) \{\par
6584                 randomized.push_back(indexed.second);\par
6585             \}\par
6586 \par
6587             {\cf19 return} randomized;\par
6588         \}\par
6589         \}\par
6590 \par
6591         CATCH_INTERNAL_ERROR({\cf22 "Unknown test order value!"});\par
6592     \}\par
}
}
{\xe \v splitStringRef\:Catch}
{\xe \v Catch\:splitStringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b StringRef} > Catch::splitStringRef ({\b StringRef} str, char delimiter)}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6342                                                                          \{\par
6343         std::vector<StringRef> subStrings;\par
6344         std::size_t start = 0;\par
6345         {\cf19 for}(std::size_t pos = 0; pos < str.size(); ++pos ) \{\par
6346             {\cf19 if}( str[pos] == delimiter ) \{\par
6347                 {\cf19 if}( pos - start > 1 )\par
6348                     subStrings.push_back( str.substr( start, pos-start ) );\par
6349                 start = pos+1;\par
6350             \}\par
6351         \}\par
6352         {\cf19 if}( start < str.size() )\par
6353             subStrings.push_back( str.substr( start, str.size()-start ) );\par
6354         {\cf19 return} subStrings;\par
6355     \}\par
}
}
{\xe \v startsWith\:Catch}
{\xe \v Catch\:startsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::startsWith (std::string const & s, std::string const & prefix)}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6267                                                                    \{\par
6268         {\cf19 return} s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\par
6269     \}\par
}
}
{\xe \v startsWith\:Catch}
{\xe \v Catch\:startsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::startsWith ({\b StringRef} s, char prefix)}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6270                                                 \{\par
6271         {\cf19 return} !s.empty() && s[0] == prefix;\par
6272     \}\par
}
}
{\xe \v throw_domain_error\:Catch}
{\xe \v Catch\:throw_domain_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::throw_domain_error (std::string const & msg)}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3853                                                   \{\par
3854         throw_exception(std::domain_error(msg));\par
3855     \}\par
}
}
{\xe \v throw_exception\:Catch}
{\xe \v Catch\:throw_exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::throw_exception (std::exception const & e)}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3840                                                 \{\par
3841         Catch::cerr() << {\cf22 "Catch will terminate because it needed to throw an exception.\\n"}\par
3842                       << {\cf22 "The message was: "} << e.what() << {\cf23 '\\n'};\par
3843         std::terminate();\par
3844     \}\par
}
}
{\xe \v throw_logic_error\:Catch}
{\xe \v Catch\:throw_logic_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::throw_logic_error (std::string const & msg)}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3848                                                  \{\par
3849         throw_exception(std::logic_error(msg));\par
3850     \}\par
}
}
{\xe \v throw_runtime_error\:Catch}
{\xe \v Catch\:throw_runtime_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::throw_runtime_error (std::string const & msg)}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3858                                                    \{\par
3859         throw_exception(std::runtime_error(msg));\par
3860     \}\par
}
}
{\xe \v throw_test_failure_exception\:Catch}
{\xe \v Catch\:throw_test_failure_exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::throw_test_failure_exception ()}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outlines throwing of {\f2 {\b TestFailureException}}  into a single TU\par
Also handles {\f2 CATCH_CONFIG_DISABLE_EXCEPTIONS}  for callers. \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6877                                         \{\par
6878 {\cf21 #if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )}\par
6879         {\cf19 throw} TestFailureException\{\};\par
6880 {\cf21 #else}\par
6881         CATCH_ERROR( {\cf22 "Test failure requires aborting test!"} );\par
6882 {\cf21 #endif}\par
6883     \}\par
}
}
{\xe \v throw_test_skip_exception\:Catch}
{\xe \v Catch\:throw_test_skip_exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::throw_test_skip_exception ()}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Outlines throwing of {\f2 {\b TestSkipException}}  into a single TU\par
Also handles {\f2 CATCH_CONFIG_DISABLE_EXCEPTIONS}  for callers. \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6885                                      \{\par
6886 {\cf21 #if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )}\par
6887         {\cf19 throw} Catch::TestSkipException();\par
6888 {\cf21 #else}\par
6889         CATCH_ERROR( {\cf22 "Explicitly skipping tests during runtime requires exceptions"} );\par
6890 {\cf21 #endif}\par
6891     \}\par
}
}
{\xe \v toLower\:Catch}
{\xe \v Catch\:toLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Catch::toLower (char c)}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6292                          \{\par
6293         {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(std::tolower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c)));\par
6294     \}\par
}
}
{\xe \v toLower\:Catch}
{\xe \v Catch\:toLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::toLower (std::string const & s)}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6287                                             \{\par
6288         std::string lc = s;\par
6289         toLowerInPlace( lc );\par
6290         {\cf19 return} lc;\par
6291     \}\par
}
}
{\xe \v toLowerInPlace\:Catch}
{\xe \v Catch\:toLowerInPlace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::toLowerInPlace (std::string & s)}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6282                                         \{\par
6283         {\cf19 for} ( {\cf18 char}& c : s ) \{\par
6284             c = toLower( c );\par
6285         \}\par
6286     \}\par
}
}
{\xe \v translateActiveException\:Catch}
{\xe \v Catch\:translateActiveException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::translateActiveException ()}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1148                                          \{\par
1149         {\cf19 return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();\par
1150     \}\par
}
}
{\xe \v trim\:Catch}
{\xe \v Catch\:trim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::trim (std::string const & str)}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6296                                            \{\par
6297         {\cf17 static} {\cf18 char} {\cf17 const}* whitespaceChars = {\cf22 "\\n\\r\\t "};\par
6298         std::string::size_type start = str.find_first_not_of( whitespaceChars );\par
6299         std::string::size_type end = str.find_last_not_of( whitespaceChars );\par
6300 \par
6301         {\cf19 return} start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\par
6302     \}\par
}
}
{\xe \v trim\:Catch}
{\xe \v Catch\:trim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::trim ({\b StringRef} ref)}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6304                                   \{\par
6305         {\cf17 const} {\cf17 auto} is_ws = []({\cf18 char} c) \{\par
6306             {\cf19 return} c == {\cf23 ' '} || c == {\cf23 '\\t'} || c == {\cf23 '\\n'} || c == {\cf23 '\\r'};\par
6307         \};\par
6308         {\cf18 size_t} real_begin = 0;\par
6309         {\cf19 while} (real_begin < ref.size() && is_ws(ref[real_begin])) \{ ++real_begin; \}\par
6310         {\cf18 size_t} real_end = ref.size();\par
6311         {\cf19 while} (real_end > real_begin && is_ws(ref[real_end - 1])) \{ --real_end; \}\par
6312 \par
6313         {\cf19 return} ref.substr(real_begin, real_end - real_begin);\par
6314     \}\par
}
}
{\xe \v uncaught_exceptions\:Catch}
{\xe \v Catch\:uncaught_exceptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::uncaught_exceptions ()}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7575                                \{\par
7576 {\cf21 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
7577         {\cf19 return} {\cf17 false};\par
7578 {\cf21 #elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
7579         {\cf19 return} std::uncaught_exceptions() > 0;\par
7580 {\cf21 #else}\par
7581         {\cf19 return} std::uncaught_exception();\par
7582 {\cf21 #endif}\par
7583   \}\par
}
}
{\xe \v writeToDebugConsole\:Catch}
{\xe \v Catch\:writeToDebugConsole}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::writeToDebugConsole (std::string const & text)}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3691                                                           \{\par
3692             {\cf20 // !TBD: Need a version for Mac/ XCode and other IDEs}\par
3693             Catch::cout() << text;\par
3694         \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Benchmark\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark}
{\xe \v Catch::Benchmark}
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Benchmark}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Chronometer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Environment}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EnvironmentEstimate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Estimate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExecutionPlan}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b OutlierClassification}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SampleAnalysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Timing}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b IDuration} = std::chrono::nanoseconds\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b FDuration} = std::chrono::duration<double, std::nano>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > using {\b TimePoint} = typename Clock::time_point\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b default_clock} = std::chrono::steady_clock\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func , typename... Args> using {\b TimingOf} = {\b Timing}<{\b Detail::CompleteType_t}<{\b FunctionReturnType}<Func, Args...>>>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b storage_for} = {\b Detail::ObjectStorage}<T, true>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b destructable_object} = {\b Detail::ObjectStorage}<T, false>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b deoptimize_value} (T &&{\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fn , typename... Args> auto {\b invoke_deoptimized} (Fn &&fn, Args &&... args) -> std::enable_if_t<!std::is_same< void, decltype(fn(args...))>{\b ::value} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun > {\b Detail::CompleteType_t}< {\b FunctionReturnType}< Fun > > {\b user_code} (Fun &&fun)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v default_clock\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:default_clock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::Benchmark::default_clock} = std::chrono::steady_clock}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v destructable_object\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:destructable_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b Catch::Benchmark::destructable_object} = {\b Detail::ObjectStorage}<T, false>}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FDuration\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:FDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::Benchmark::FDuration} = std::chrono::duration<double, std::nano>}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IDuration\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:IDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::Benchmark::IDuration} = std::chrono::nanoseconds}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v storage_for\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:storage_for}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b Catch::Benchmark::storage_for} = {\b Detail::ObjectStorage}<T, true>}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TimePoint\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:TimePoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > using {\b Catch::Benchmark::TimePoint} = typename Clock::time_point}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TimingOf\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:TimingOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Func , typename... Args> using {\b Catch::Benchmark::TimingOf} = {\b Timing}<{\b Detail::CompleteType_t}<{\b FunctionReturnType}<Func, Args...>>>}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v deoptimize_value\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:deoptimize_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void Catch::Benchmark::deoptimize_value (T && x){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1446                                             \{\par
1447             keep_memory(&x);\par
1448         \}\par
}
}
{\xe \v invoke_deoptimized\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:invoke_deoptimized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fn , typename... Args> auto Catch::Benchmark::invoke_deoptimized (Fn && fn, Args &&... args) -> std::enable_if_t<!std::is_same<void, decltype(fn(args...))>{\b ::value}> {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1451                                                                                                                                  \{\par
1452             deoptimize_value(CATCH_FORWARD(fn) (CATCH_FORWARD(args)...));\par
1453         \}\par
}
}
{\xe \v user_code\:Catch::Benchmark}
{\xe \v Catch::Benchmark\:user_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun > {\b Detail::CompleteType_t}< {\b FunctionReturnType}< Fun > > Catch::Benchmark::user_code (Fun && fun)}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1745                                                                            \{\par
1746             {\cf19 return} Detail::complete_invoke(CATCH_FORWARD(fun));\par
1747         \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Benchmark::Detail\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail}
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BenchmarkFunction}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b bootstrap_analysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ChronometerConcept}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ChronometerModel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CompleteInvoker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CompleteInvoker< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CompleteType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CompleteType< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_related}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ObjectStorage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b repeater}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b CompleteType_t} = typename {\b CompleteType}<T>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > using {\b run_for_at_least_argument_t} = std::conditional_t<{\b is_callable}<Fun({\b Chronometer})>{\b ::value}, {\b Chronometer}, int>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sample} = std::vector<double>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b weighted_average_quantile} (int k, int q, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OutlierClassification} {\b classify_outliers} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b mean} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b normal_cdf} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b erfc_inv} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b normal_quantile} (double {\b p})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< double > {\b bootstrap} (double confidence_level, double *first, double *last, {\b sample} const &resample, double(*estimator)(double const *, double const *))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bootstrap_analysis} {\b analyse_samples} (double confidence_level, unsigned int n_resamples, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun > {\b repeater}< std::decay_t< Fun > > {\b repeat} (Fun &&fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun , typename... Args> {\b CompleteType_t}< {\b FunctionReturnType}< Fun, Args... > > {\b complete_invoke} (Fun &&fun, Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun , typename... Args> {\b TimingOf}< Fun, Args... > {\b measure} (Fun &&fun, Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, int > {\b measure_one} (Fun &&fun, int iters, std::false_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, {\b Chronometer} > {\b measure_one} (Fun &&fun, int iters, std::true_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_optimized_away_error} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, {\b run_for_at_least_argument_t}< Clock, Fun > > {\b run_for_at_least} ({\b IDuration} how_long, const int initial_iterations, Fun &&fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > std::vector< double > {\b resolution} (int k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > int {\b warmup} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > {\b EnvironmentEstimate} {\b estimate_clock_resolution} (int iterations)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > {\b EnvironmentEstimate} {\b estimate_clock_cost} ({\b FDuration} {\b resolution})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > {\b Environment} {\b measure_environment} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SampleAnalysis} {\b analyse} (const {\b IConfig} &cfg, {\b FDuration} *first, {\b FDuration} *last)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b warmup_iterations} = 10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b warmup_time} = std::chrono::milliseconds(100)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b minimum_ticks} = 1000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b warmup_seed} = 10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b clock_resolution_estimation_time} = std::chrono::milliseconds(500)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b clock_cost_estimation_time_limit} = std::chrono::seconds(1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b clock_cost_estimation_tick_limit} = 100000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b clock_cost_estimation_time} = std::chrono::milliseconds(10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b clock_cost_estimation_iterations} = 10000\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v CompleteType_t\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:CompleteType_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b Catch::Benchmark::Detail::CompleteType_t} = typename {\b CompleteType}<T>::type}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v run_for_at_least_argument_t\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:run_for_at_least_argument_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock , typename Fun > using {\b Catch::Benchmark::Detail::run_for_at_least_argument_t} = std::conditional_t<{\b is_callable}<Fun({\b Chronometer})>{\b ::value}, {\b Chronometer}, int>}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sample\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:sample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::Benchmark::Detail::sample} = std::vector<double>}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v analyse\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:analyse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SampleAnalysis} Catch::Benchmark::Detail::analyse (const {\b IConfig} & cfg, {\b FDuration} * first, {\b FDuration} * last)}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v analyse_samples\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:analyse_samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bootstrap_analysis} Catch::Benchmark::Detail::analyse_samples (double confidence_level, unsigned int n_resamples, double * first, double * last)}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 501                                                              \{\par
502                 {\cf17 auto} mean = &Detail::mean;\par
503                 {\cf17 auto} stddev = &standard_deviation;\par
504 \par
505 {\cf21 #if defined(CATCH_CONFIG_USE_ASYNC)}\par
506                 {\cf17 auto} Estimate = [=](double(*f)({\cf18 double} {\cf17 const}*, {\cf18 double} {\cf17 const}*)) \{\par
507                     std::random_device rd;\par
508                     {\cf17 auto} seed = rd();\par
509                     {\cf19 return} std::async(std::launch::async, [=] \{\par
510                         SimplePcg32 rng( seed );\par
511                         {\cf17 auto} resampled = resample(rng, n_resamples, first, last, f);\par
512                         {\cf19 return} bootstrap(confidence_level, first, last, resampled, f);\par
513                     \});\par
514                 \};\par
515 \par
516                 {\cf17 auto} mean_future = Estimate(mean);\par
517                 {\cf17 auto} stddev_future = Estimate(stddev);\par
518 \par
519                 {\cf17 auto} mean_estimate = mean_future.get();\par
520                 {\cf17 auto} stddev_estimate = stddev_future.get();\par
521 {\cf21 #else}\par
522                 {\cf17 auto} Estimate = [=](double(*f)({\cf18 double} {\cf17 const}* , {\cf18 double} {\cf17 const}*)) \{\par
523                     std::random_device rd;\par
524                     {\cf17 auto} seed = rd();\par
525                     SimplePcg32 rng( seed );\par
526                     {\cf17 auto} resampled = resample(rng, n_resamples, first, last, f);\par
527                     {\cf19 return} bootstrap(confidence_level, first, last, resampled, f);\par
528                 \};\par
529 \par
530                 {\cf17 auto} mean_estimate = Estimate(mean);\par
531                 {\cf17 auto} stddev_estimate = Estimate(stddev);\par
532 {\cf21 #endif }{\cf20 // CATCH_USE_ASYNC}\par
533 \par
534                 {\cf17 auto} n = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(last - first); {\cf20 // seriously, one can't use integral types without hell in C++}\par
535                 {\cf18 double} outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);\par
536 \par
537                 {\cf19 return} \{ mean_estimate, stddev_estimate, outlier_variance \};\par
538             \}\par
}
}
{\xe \v bootstrap\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:bootstrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Estimate}< double > Catch::Benchmark::Detail::bootstrap (double confidence_level, double * first, double * last, {\b sample} const & resample, double(* estimator\~ )(double const *, double const *))}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 445                                                                                \{\par
446                 {\cf17 auto} n_samples = last - first;\par
447 \par
448                 {\cf18 double} point = estimator( first, last );\par
449                 {\cf20 // Degenerate case with a single sample}\par
450                 {\cf19 if} ( n_samples == 1 )\par
451                     {\cf19 return} \{ point, point, point, confidence_level \};\par
452 \par
453                 sample jack = jackknife( estimator, first, last );\par
454                 {\cf18 double} jack_mean =\par
455                     mean( jack.data(), jack.data() + jack.size() );\par
456                 {\cf18 double} sum_squares = 0, sum_cubes = 0;\par
457                 {\cf19 for} ( {\cf18 double} x : jack ) \{\par
458                     {\cf17 auto} difference = jack_mean - x;\par
459                     {\cf17 auto} square = difference * difference;\par
460                     {\cf17 auto} cube = square * difference;\par
461                     sum_squares += square;\par
462                     sum_cubes += cube;\par
463                 \}\par
464 \par
465                 {\cf18 double} accel = sum_cubes / ( 6 * std::pow( sum_squares, 1.5 ) );\par
466                 {\cf18 long} n = {\cf17 static_cast<}{\cf18 long}{\cf17 >}( resample.size() );\par
467                 {\cf18 double} prob_n =\par
468                     std::count_if( resample.begin(),\par
469                                    resample.end(),\par
470                                    [point]( {\cf18 double} x ) \{ return x < point; \} ) /\par
471                     {\cf17 static_cast<}{\cf18 double}{\cf17 >}( n );\par
472                 {\cf20 // degenerate case with uniform samples}\par
473                 {\cf19 if} ( Catch::Detail::directCompare( prob_n, 0. ) ) \{\par
474                     {\cf19 return} \{ point, point, point, confidence_level \};\par
475                 \}\par
476 \par
477                 {\cf18 double} bias = normal_quantile( prob_n );\par
478                 {\cf18 double} z1 = normal_quantile( ( 1. - confidence_level ) / 2. );\par
479 \par
480                 {\cf17 auto} cumn = [n]( {\cf18 double} x ) -> {\cf18 long} \{\par
481                     {\cf19 return} std::lround( normal_cdf( x ) *\par
482                                         {\cf17 static_cast<}{\cf18 double}{\cf17 >}( n ) );\par
483                 \};\par
484                 {\cf17 auto} a = [bias, accel]( {\cf18 double} b ) \{\par
485                     {\cf19 return} bias + b / ( 1. - accel * b );\par
486                 \};\par
487                 {\cf18 double} b1 = bias + z1;\par
488                 {\cf18 double} b2 = bias - z1;\par
489                 {\cf18 double} a1 = a( b1 );\par
490                 {\cf18 double} a2 = a( b2 );\par
491                 {\cf17 auto} lo = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( (std::max)( cumn( a1 ), 0l ) );\par
492                 {\cf17 auto} hi =\par
493                     {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( (std::min)( cumn( a2 ), n - 1 ) );\par
494 \par
495                 {\cf19 return} \{ point, resample[lo], resample[hi], confidence_level \};\par
496             \}\par
}
}
{\xe \v classify_outliers\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:classify_outliers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OutlierClassification} Catch::Benchmark::Detail::classify_outliers (double const * first, double const * last)}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 378                                                                          \{\par
379                 std::vector<double> copy( first, last );\par
380 \par
381                 {\cf17 auto} q1 = weighted_average_quantile( 1, 4, copy.data(), copy.data() + copy.size() );\par
382                 {\cf17 auto} q3 = weighted_average_quantile( 3, 4, copy.data(), copy.data() + copy.size() );\par
383                 {\cf17 auto} iqr = q3 - q1;\par
384                 {\cf17 auto} los = q1 - ( iqr * 3. );\par
385                 {\cf17 auto} lom = q1 - ( iqr * 1.5 );\par
386                 {\cf17 auto} him = q3 + ( iqr * 1.5 );\par
387                 {\cf17 auto} his = q3 + ( iqr * 3. );\par
388 \par
389                 OutlierClassification o;\par
390                 {\cf19 for} ( ; first != last; ++first ) \{\par
391                     {\cf17 const} {\cf18 double} t = *first;\par
392                     {\cf19 if} ( t < los ) \{\par
393                         ++o.low_severe;\par
394                     \} {\cf19 else} {\cf19 if} ( t < lom ) \{\par
395                         ++o.low_mild;\par
396                     \} {\cf19 else} {\cf19 if} ( t > his ) \{\par
397                         ++o.high_severe;\par
398                     \} {\cf19 else} {\cf19 if} ( t > him ) \{\par
399                         ++o.high_mild;\par
400                     \}\par
401                     ++o.samples_seen;\par
402                 \}\par
403                 {\cf19 return} o;\par
404             \}\par
}
}
{\xe \v complete_invoke\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:complete_invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun , typename... Args> {\b CompleteType_t}< {\b FunctionReturnType}< Fun, Args... > > Catch::Benchmark::Detail::complete_invoke (Fun && fun, Args &&... args)}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1738                                                                                                         \{\par
1739                 {\cf19 return} CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(CATCH_FORWARD(fun), CATCH_FORWARD(args)...);\par
1740             \}\par
}
}
{\xe \v erfc_inv\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:erfc_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Benchmark::Detail::erfc_inv (double x)}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 420                                       \{\par
421                 {\cf19 return} erf_inv(1.0 - x);\par
422             \}\par
}
}
{\xe \v estimate_clock_cost\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:estimate_clock_cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > {\b EnvironmentEstimate} Catch::Benchmark::Detail::estimate_clock_cost ({\b FDuration} resolution)}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1990                                                                           \{\par
1991                 {\cf17 auto} time_limit = (std::min)(\par
1992                     resolution * clock_cost_estimation_tick_limit,\par
1993                     FDuration(clock_cost_estimation_time_limit));\par
1994                 {\cf17 auto} time_clock = []({\cf18 int} k) \{\par
1995                     {\cf19 return} Detail::measure<Clock>([k] \{\par
1996                         {\cf19 for} ({\cf18 int} i = 0; i < k; ++i) \{\par
1997                             {\cf17 volatile} {\cf17 auto} ignored = Clock::now();\par
1998                             (void)ignored;\par
1999                         \}\par
2000                     \}).elapsed;\par
2001                 \};\par
2002                 time_clock(1);\par
2003                 {\cf18 int} iters = clock_cost_estimation_iterations;\par
2004                 {\cf17 auto}&& r = run_for_at_least<Clock>(clock_cost_estimation_time, iters, time_clock);\par
2005                 std::vector<double> times;\par
2006                 {\cf18 int} nsamples = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::ceil(time_limit / r.elapsed));\par
2007                 times.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(nsamples));\par
2008                 {\cf19 for} ( {\cf18 int} s = 0; s < nsamples; ++s ) \{\par
2009                     times.push_back( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(\par
2010                         ( time_clock( r.iterations ) / r.iterations )\par
2011                             .count() ) );\par
2012                 \}\par
2013                 {\cf19 return} \{\par
2014                     FDuration(mean(times.data(), times.data() + times.size())),\par
2015                     classify_outliers(times.data(), times.data() + times.size()),\par
2016                 \};\par
2017             \}\par
}
}
{\xe \v estimate_clock_resolution\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:estimate_clock_resolution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > {\b EnvironmentEstimate} Catch::Benchmark::Detail::estimate_clock_resolution (int iterations)}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1981                                                                           \{\par
1982                 {\cf17 auto} r = run_for_at_least<Clock>(clock_resolution_estimation_time, iterations, &resolution<Clock>)\par
1983                     .result;\par
1984                 {\cf19 return} \{\par
1985                     FDuration(mean(r.data(), r.data() + r.size())),\par
1986                     classify_outliers(r.data(), r.data() + r.size()),\par
1987                 \};\par
1988             \}\par
}
}
{\xe \v mean\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Benchmark::Detail::mean (double const * first, double const * last)}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 406                                                                    \{\par
407                 {\cf17 auto} count = last - first;\par
408                 {\cf18 double} sum = 0.;\par
409                 {\cf19 while} (first != last) \{\par
410                     sum += *first;\par
411                     ++first;\par
412                 \}\par
413                 {\cf19 return} sum / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(count);\par
414             \}\par
}
}
{\xe \v measure\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:measure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock , typename Fun , typename... Args> {\b TimingOf}< Fun, Args... > Catch::Benchmark::Detail::measure (Fun && fun, Args &&... args)}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1781                                                                       \{\par
1782                 {\cf17 auto} start = Clock::now();\par
1783                 {\cf17 auto}&& r = Detail::complete_invoke(fun, CATCH_FORWARD(args)...);\par
1784                 {\cf17 auto} end = Clock::now();\par
1785                 {\cf17 auto} delta = end - start;\par
1786                 {\cf19 return} \{ delta, CATCH_FORWARD(r), 1 \};\par
1787             \}\par
}
}
{\xe \v measure_environment\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:measure_environment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > {\b Environment} Catch::Benchmark::Detail::measure_environment ()}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2020                                               \{\par
2021 {\cf21 #if defined(__clang__)}\par
2022 {\cf21 #    pragma clang diagnostic push}\par
2023 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
2024 {\cf21 #endif}\par
2025                 {\cf17 static} Catch::Detail::unique_ptr<Environment> env;\par
2026 {\cf21 #if defined(__clang__)}\par
2027 {\cf21 #    pragma clang diagnostic pop}\par
2028 {\cf21 #endif}\par
2029                 {\cf19 if} (env) \{\par
2030                     {\cf19 return} *env;\par
2031                 \}\par
2032 \par
2033                 {\cf17 auto} iters = Detail::warmup<Clock>();\par
2034                 {\cf17 auto} resolution = Detail::estimate_clock_resolution<Clock>(iters);\par
2035                 {\cf17 auto} cost = Detail::estimate_clock_cost<Clock>(resolution.mean);\par
2036 \par
2037                 env = Catch::Detail::make_unique<Environment>( Environment\{resolution, cost\} );\par
2038                 {\cf19 return} *env;\par
2039             \}\par
}
}
{\xe \v measure_one\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:measure_one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, int > Catch::Benchmark::Detail::measure_one (Fun && fun, int iters, std::false_type )}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1800                                                                                 \{\par
1801                 {\cf19 return} Detail::measure<Clock>(fun, iters);\par
1802             \}\par
}
}
{\xe \v measure_one\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:measure_one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, {\b Chronometer} > Catch::Benchmark::Detail::measure_one (Fun && fun, int iters, std::true_type )}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1804                                                                                        \{\par
1805                 Detail::ChronometerModel<Clock> meter;\par
1806                 {\cf17 auto}&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));\par
1807 \par
1808                 {\cf19 return} \{ meter.elapsed(), CATCH_MOVE(result), iters \};\par
1809             \}\par
}
}
{\xe \v normal_cdf\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:normal_cdf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Benchmark::Detail::normal_cdf (double x)}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 416                                           \{\par
417                 {\cf19 return} std::erfc( -x / std::sqrt( 2.0 ) ) / 2.0;\par
418             \}\par
}
}
{\xe \v normal_quantile\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:normal_quantile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Benchmark::Detail::normal_quantile (double p)}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 424                                              \{\par
425                 {\cf17 static} {\cf17 const} {\cf18 double} ROOT_TWO = std::sqrt(2.0);\par
426 \par
427                 {\cf18 double} result = 0.0;\par
428                 assert(p >= 0 && p <= 1);\par
429                 {\cf19 if} (p < 0 || p > 1) \{\par
430                     {\cf19 return} result;\par
431                 \}\par
432 \par
433                 result = -erfc_inv(2.0 * p);\par
434                 {\cf20 // result *= normal distribution standard deviation (1.0) * sqrt(2)}\par
435                 result *= {\cf20 /*sd * */} ROOT_TWO;\par
436                 {\cf20 // result += normal disttribution mean (0)}\par
437                 {\cf19 return} result;\par
438             \}\par
}
}
{\xe \v repeat\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:repeat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun > {\b repeater}< std::decay_t< Fun > > Catch::Benchmark::Detail::repeat (Fun && fun)}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1679                                                         \{\par
1680                 {\cf19 return} \{ CATCH_FORWARD(fun) \};\par
1681             \}\par
}
}
{\xe \v resolution\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:resolution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > std::vector< double > Catch::Benchmark::Detail::resolution (int k)}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1948                                                 \{\par
1949                 std::vector<TimePoint<Clock>> times;\par
1950                 times.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k + 1));\par
1951                 {\cf19 for} ( {\cf18 int} i = 0; i < k + 1; ++i ) \{\par
1952                     times.push_back( Clock::now() );\par
1953                 \}\par
1954 \par
1955                 std::vector<double> deltas;\par
1956                 deltas.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k));\par
1957                 {\cf19 for} ( {\cf18 size_t} idx = 1; idx < times.size(); ++idx ) \{\par
1958                     deltas.push_back( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(\par
1959                         ( times[idx] - times[idx - 1] ).count() ) );\par
1960                 \}\par
1961 \par
1962                 {\cf19 return} deltas;\par
1963             \}\par
}
}
{\xe \v run_for_at_least\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:run_for_at_least}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, {\b run_for_at_least_argument_t}< Clock, Fun > > Catch::Benchmark::Detail::run_for_at_least ({\b IDuration} how_long, const int initial_iterations, Fun && fun)}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1822                                             \{\par
1823                 {\cf17 auto} iters = initial_iterations;\par
1824                 {\cf19 while} (iters < (1 << 30)) \{\par
1825                     {\cf17 auto}&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());\par
1826 \par
1827                     {\cf19 if} (Timing.elapsed >= how_long) \{\par
1828                         {\cf19 return} \{ Timing.elapsed, CATCH_MOVE(Timing.result), iters \};\par
1829                     \}\par
1830                     iters *= 2;\par
1831                 \}\par
1832                 throw_optimized_away_error();\par
1833             \}\par
}
}
{\xe \v throw_optimized_away_error\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:throw_optimized_away_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Benchmark::Detail::throw_optimized_away_error ()}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v warmup\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:warmup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > int Catch::Benchmark::Detail::warmup ()}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1976                          \{\par
1977                 {\cf19 return} run_for_at_least<Clock>(warmup_time, warmup_seed, &resolution<Clock>)\par
1978                     .iterations;\par
1979             \}\par
}
}
{\xe \v weighted_average_quantile\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:weighted_average_quantile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Benchmark::Detail::weighted_average_quantile (int k, int q, double * first, double * last)}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 362                                                              \{\par
363                 {\cf17 auto} count = last - first;\par
364                 {\cf18 double} idx = (count - 1) * k / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(q);\par
365                 {\cf18 int} j = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(idx);\par
366                 {\cf18 double} g = idx - j;\par
367                 std::nth_element(first, first + j, last);\par
368                 {\cf17 auto} xj = first[j];\par
369                 {\cf19 if} ( Catch::Detail::directCompare( g, 0 ) ) \{\par
370                     {\cf19 return} xj;\par
371                 \}\par
372 \par
373                 {\cf17 auto} xj1 = *std::min_element(first + (j + 1), last);\par
374                 {\cf19 return} xj + g * (xj1 - xj);\par
375             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 
{\xe \v clock_cost_estimation_iterations\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:clock_cost_estimation_iterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::clock_cost_estimation_iterations = 10000{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clock_cost_estimation_tick_limit\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:clock_cost_estimation_tick_limit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::clock_cost_estimation_tick_limit = 100000{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clock_cost_estimation_time\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:clock_cost_estimation_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::clock_cost_estimation_time = std::chrono::milliseconds(10){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clock_cost_estimation_time_limit\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:clock_cost_estimation_time_limit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::clock_cost_estimation_time_limit = std::chrono::seconds(1){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clock_resolution_estimation_time\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:clock_resolution_estimation_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::clock_resolution_estimation_time = std::chrono::milliseconds(500){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v minimum_ticks\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:minimum_ticks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::minimum_ticks = 1000{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v warmup_iterations\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:warmup_iterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::warmup_iterations = 10000{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v warmup_seed\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:warmup_seed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::warmup_seed = 10000{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v warmup_time\:Catch::Benchmark::Detail}
{\xe \v Catch::Benchmark::Detail\:warmup_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Benchmark::Detail::warmup_time = std::chrono::milliseconds(100){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Clara\par \pard\plain 
{\tc\tcl2 \v Catch::Clara}
{\xe \v Catch::Clara}
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b accept_many_t}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Arg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Args}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExeName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Help}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Opt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Parser}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b ParseResultType} \{ {\b Matched}
, {\b NoMatch}
, {\b ShortCircuitAll}
, {\b ShortCircuitSame}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b accept_many_t} {\b accept_many} \{\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 
{\xe \v ParseResultType\:Catch::Clara}
{\xe \v Catch::Clara\:ParseResultType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::Clara::ParseResultType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Matched\:Catch::Clara}
{\xe \v Catch::Clara\:Matched}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Matched{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
\cell }{\cell }{\row }
{\xe \v NoMatch\:Catch::Clara}
{\xe \v Catch::Clara\:NoMatch}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NoMatch{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
\cell }{\cell }{\row }
{\xe \v ShortCircuitAll\:Catch::Clara}
{\xe \v Catch::Clara\:ShortCircuitAll}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ShortCircuitAll{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
\cell }{\cell }{\row }
{\xe \v ShortCircuitSame\:Catch::Clara}
{\xe \v Catch::Clara\:ShortCircuitSame}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ShortCircuitSame{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4207                                    \{\par
4208             Matched,\par
4209             NoMatch,\par
4210             ShortCircuitAll,\par
4211             ShortCircuitSame\par
4212         \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 
{\xe \v accept_many\:Catch::Clara}
{\xe \v Catch::Clara\:accept_many}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b accept_many_t} Catch::Clara::accept_many \{\}{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4215 \{\};\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Clara::Detail\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail}
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b BasicResult}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundFlagLambda}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundFlagRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundFlagRefBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundLambda}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundManyLambda}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundValueRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundValueRef< std::vector< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b BoundValueRefBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ComposableParserImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b fake_arg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b HelpColumns}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_unary_function}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LambdaInvoker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LambdaInvoker< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ParserBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ParserRefImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ParseState}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ResultBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ResultValueBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ResultValueBase< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Token}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TokenStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UnaryLambdaTraits}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Result} = {\b BasicResult}<void>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ParserResult} = {\b BasicResult}<{\b ParseResultType}>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b InternalParseResult} = {\b BasicResult}<{\b ParseState}>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b TokenType} \{ {\b Option}
, {\b Argument}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b ResultType} \{ {\b Ok}
, {\b LogicError}
, {\b RuntimeError}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Denotes type of a parsing result. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Optionality} \{ {\b Optional}
, {\b Required}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b convertInto} (std::string const &source, std::string &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b convertInto} (std::string const &source, bool &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b ParserResult} {\b convertInto} (std::string const &source, T &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ArgType , typename L > auto {\b invokeLambda} (L const &lambda, std::string const &arg) -> {\b ParserResult}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v InternalParseResult\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:InternalParseResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::Clara::Detail::InternalParseResult} = {\b BasicResult}<{\b ParseState}>}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ParserResult\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:ParserResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::Clara::Detail::ParserResult} = {\b BasicResult}<{\b ParseResultType}>}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Result\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:Result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::Clara::Detail::Result} = {\b BasicResult}<void>}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 
{\xe \v Optionality\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:Optionality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::Clara::Detail::Optionality}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Optional\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:Optional}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Optional{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
\cell }{\cell }{\row }
{\xe \v Required\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:Required}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Required{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4622 \{ Optional, Required \};\par
}
}
{\xe \v ResultType\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:ResultType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::Clara::Detail::ResultType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Denotes type of a parsing result. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Ok\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:Ok}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Ok{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
No errors. \par
}\cell }{\row }
{\xe \v LogicError\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:LogicError}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LogicError{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Error in user-specified arguments for construction. \par
}\cell }{\row }
{\xe \v RuntimeError\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:RuntimeError}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid RuntimeError{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Error in parsing inputs. \par
}\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4298                                   \{\par
4299                 Ok,          \par
4300                 LogicError,  \par
4302                 RuntimeError \par
4303             \};\par
}
}
{\xe \v TokenType\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:TokenType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::Clara::Detail::TokenType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Option\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:Option}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Option{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
\cell }{\cell }{\row }
{\xe \v Argument\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:Argument}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Argument{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4257 \{ Option, Argument \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v convertInto\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:convertInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ParserResult} Catch::Clara::Detail::convertInto (std::string const & source, bool & target)}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2724                                                      \{\par
2725                 std::string srcLC = toLower( source );\par
2726 \par
2727                 {\cf19 if} ( srcLC == {\cf22 "y"} || srcLC == {\cf22 "1"} || srcLC == {\cf22 "true"} ||\par
2728                      srcLC == {\cf22 "yes"} || srcLC == {\cf22 "on"} ) \{\par
2729                     target = {\cf17 true};\par
2730                 \} {\cf19 else} {\cf19 if} ( srcLC == {\cf22 "n"} || srcLC == {\cf22 "0"} || srcLC == {\cf22 "false"} ||\par
2731                             srcLC == {\cf22 "no"} || srcLC == {\cf22 "off"} ) \{\par
2732                     target = {\cf17 false};\par
2733                 \} {\cf19 else} \{\par
2734                     {\cf19 return} ParserResult::runtimeError(\par
2735                         {\cf22 "Expected a boolean value but did not recognise: '"} +\par
2736                         source + {\cf23 '\\''} );\par
2737                 \}\par
2738                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2739             \}\par
}
}
{\xe \v convertInto\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:convertInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ParserResult} Catch::Clara::Detail::convertInto (std::string const & source, std::string & target)}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2718                                                           \{\par
2719                 target = source;\par
2720                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2721             \}\par
}
}
{\xe \v convertInto\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:convertInto}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b ParserResult} Catch::Clara::Detail::convertInto (std::string const & source, T & target)}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4473                                                                            \{\par
4474                 std::stringstream ss( source );\par
4475                 ss >> target;\par
4476                 {\cf19 if} ( ss.fail() ) \{\par
4477                     {\cf19 return} ParserResult::runtimeError(\par
4478                         {\cf22 "Unable to convert '"} + source +\par
4479                         {\cf22 "' to destination type"} );\par
4480                 \} {\cf19 else} \{\par
4481                     {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
4482                 \}\par
4483             \}\par
}
}
{\xe \v invokeLambda\:Catch::Clara::Detail}
{\xe \v Catch::Clara::Detail\:invokeLambda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ArgType , typename L > auto Catch::Clara::Detail::invokeLambda (L const & lambda, std::string const & arg) -> {\b ParserResult} }}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4574                                 \{\par
4575                 ArgType temp\{\};\par
4576                 {\cf17 auto} result = convertInto( arg, temp );\par
4577                 {\cf19 return} !result ? result\par
4578                                : LambdaInvoker<{\cf17 typename} UnaryLambdaTraits<\par
4579                                      L>::ReturnType>::invoke( lambda, temp );\par
4580             \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Detail\par \pard\plain 
{\tc\tcl2 \v Catch::Detail}
{\xe \v Catch::Detail}
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction< B1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction< B1, Bn... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b disjunction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b disjunction< B1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b disjunction< B1, Bn... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EnumInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_range_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IsStreamInsertable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b make_void}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b negation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NonCopyable}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deriving classes become noncopyable and nonmovable. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b unique_ptr}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Ts> using {\b void_t} = typename {\b make_void}<Ts...>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b RemoveCVRef_t} = std::remove_cv_t<std::remove_reference_t<T>>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b convertIntoString} ({\b StringRef} string, bool escapeInvisibles)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases `string in quotes, and optionally escapes invisibles. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b convertIntoString} ({\b StringRef} string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases {\f2 string}  in quotes, and escapes invisibles if user requested it via CLI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b rawMemoryToString} (const void *object, std::size_t size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerTranslatorImpl} ({\b Detail::unique_ptr}< {\b IExceptionTranslator} > &&translator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b parseEnums} ({\b StringRef} enums)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Catch::Detail::unique_ptr}< {\b EnumInfo} > {\b makeEnumInfo} ({\b StringRef} enumName, {\b StringRef} allValueNames, std::vector< int > const &values)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b convertToBits} (float f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b convertToBits} (double d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b directCompare} (float lhs, float rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b directCompare} (double lhs, double rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char const * {\b getEnv} (char const *varName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b splitReporterSpec} ({\b StringRef} reporterSpec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits the reporter spec into reporter name and kv-pair options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ColourMode} > {\b stringToColourMode} ({\b StringRef} colourMode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerReporterImpl} (std::string const &name, {\b IReporterFactoryPtr} reporterPtr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registerListenerImpl} ({\b Detail::unique_ptr}< EventListenerFactory > listenerFactory)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Args> {\b unique_ptr}< T > {\b make_unique} (Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b catch_strnlen} (const char *str, std::size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b rawMemoryToString} (const T &object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > std::string {\b convertUnknownEnumToString} (E e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if_t< !std::is_enum< T >{\b ::value} &&!std::is_base_of< std::exception, T >{\b ::value}, std::string > {\b convertUnstreamable} (T const &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if_t< !std::is_enum< T >{\b ::value} &&std::is_base_of< std::exception, T >{\b ::value}, std::string > {\b convertUnstreamable} (T const &ex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if_t< std::is_enum< T >{\b ::value}, std::string > {\b convertUnstreamable} (T const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b stringify} (const T &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator , typename Sentinel  = InputIterator> std::string {\b rangeToString} (InputIterator first, Sentinel last)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b StringRef} {\b unprintableString} = "\{?\}"_sr\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v RemoveCVRef_t\:Catch::Detail}
{\xe \v Catch::Detail\:RemoveCVRef_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b Catch::Detail::RemoveCVRef_t} = std::remove_cv_t<std::remove_reference_t<T>>}}
\par
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v void_t\:Catch::Detail}
{\xe \v Catch::Detail\:void_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> using {\b Catch::Detail::void_t} = typename {\b make_void}<Ts...>::type}}
\par
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v catch_strnlen\:Catch::Detail}
{\xe \v Catch::Detail\:catch_strnlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::Detail::catch_strnlen (const char * str, std::size_t n){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2463                                                                      \{\par
2464             {\cf17 auto} ret = std::char_traits<char>::find(str, n, {\cf23 '\\0'});\par
2465             {\cf19 if} (ret != {\cf17 nullptr}) \{\par
2466                 {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(ret - str);\par
2467             \}\par
2468             {\cf19 return} n;\par
2469         \}\par
}
}
{\xe \v convertIntoString\:Catch::Detail}
{\xe \v Catch::Detail\:convertIntoString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Detail::convertIntoString ({\b StringRef} string)}}
\par
{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases {\f2 string}  in quotes, and escapes invisibles if user requested it via CLI. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2012                                                   \{\par
2013         {\cf19 return} convertIntoString({\cf18 string}, getCurrentContext().getConfig()->showInvisibles());\par
2014     \}\par
}
}
{\xe \v convertIntoString\:Catch::Detail}
{\xe \v Catch::Detail\:convertIntoString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Detail::convertIntoString ({\b StringRef} string, bool escapeInvisibles)}}
\par
{\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases `string in quotes, and optionally escapes invisibles. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1974                                                                          \{\par
1975         std::string ret;\par
1976         {\cf20 // This is enough for the "don't escape invisibles" case, and a good}\par
1977         {\cf20 // lower bound on the "escape invisibles" case.}\par
1978         ret.reserve({\cf18 string}.size() + 2);\par
1979 \par
1980         {\cf19 if} (!escapeInvisibles) \{\par
1981             ret += {\cf23 '"'};\par
1982             ret += string;\par
1983             ret += {\cf23 '"'};\par
1984             {\cf19 return} ret;\par
1985         \}\par
1986 \par
1987         ret += {\cf23 '"'};\par
1988         {\cf19 for} ({\cf18 char} c : {\cf18 string}) \{\par
1989             {\cf19 switch} (c) \{\par
1990             {\cf19 case} {\cf23 '\\r'}:\par
1991                 ret.append({\cf22 "\\\\r"});\par
1992                 {\cf19 break};\par
1993             {\cf19 case} {\cf23 '\\n'}:\par
1994                 ret.append({\cf22 "\\\\n"});\par
1995                 {\cf19 break};\par
1996             {\cf19 case} {\cf23 '\\t'}:\par
1997                 ret.append({\cf22 "\\\\t"});\par
1998                 {\cf19 break};\par
1999             {\cf19 case} {\cf23 '\\f'}:\par
2000                 ret.append({\cf22 "\\\\f"});\par
2001                 {\cf19 break};\par
2002             {\cf19 default}:\par
2003                 ret.push_back(c);\par
2004                 {\cf19 break};\par
2005             \}\par
2006         \}\par
2007         ret += {\cf23 '"'};\par
2008 \par
2009         {\cf19 return} ret;\par
2010     \}\par
}
}
{\xe \v convertToBits\:Catch::Detail}
{\xe \v Catch::Detail\:convertToBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Catch::Detail::convertToBits (double d)}}
\par
{\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4266                                          \{\par
4267             {\cf17 static_assert}({\cf17 sizeof}(double) == {\cf17 sizeof}(uint64_t), {\cf22 "Important ULP matcher assumption violated"});\par
4268             uint64_t i;\par
4269             std::memcpy(&i, &d, {\cf17 sizeof}(d));\par
4270             {\cf19 return} i;\par
4271         \}\par
}
}
{\xe \v convertToBits\:Catch::Detail}
{\xe \v Catch::Detail\:convertToBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Catch::Detail::convertToBits (float f)}}
\par
{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4259                                         \{\par
4260             {\cf17 static_assert}({\cf17 sizeof}(float) == {\cf17 sizeof}(uint32_t), {\cf22 "Important ULP matcher assumption violated"});\par
4261             uint32_t i;\par
4262             std::memcpy(&i, &f, {\cf17 sizeof}(f));\par
4263             {\cf19 return} i;\par
4264         \}\par
}
}
{\xe \v convertUnknownEnumToString\:Catch::Detail}
{\xe \v Catch::Detail\:convertUnknownEnumToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > std::string Catch::Detail::convertUnknownEnumToString (E e)}}
\par
{\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2574                                                     \{\par
2575             return ::Catch::Detail::stringify({\cf17 static_cast<}std::underlying_type_t<E>{\cf17 >}(e));\par
2576         \}\par
}
}
{\xe \v convertUnstreamable\:Catch::Detail}
{\xe \v Catch::Detail\:convertUnstreamable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::enable_if_t< !std::is_enum< T >{\b ::value} &&!std::is_base_of< std::exception, T >{\b ::value}, std::string > Catch::Detail::convertUnstreamable (T const & )}}
\par
{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2506                                                    \{\par
2507             {\cf19 return} std::string(Detail::unprintableString);\par
2508         \}\par
}
}
{\xe \v convertUnstreamable\:Catch::Detail}
{\xe \v Catch::Detail\:convertUnstreamable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::enable_if_t< !std::is_enum< T >{\b ::value} &&std::is_base_of< std::exception, T >{\b ::value}, std::string > Catch::Detail::convertUnstreamable (T const & ex)}}
\par
{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2512                                                      \{\par
2513             {\cf19 return} ex.what();\par
2514         \}\par
}
}
{\xe \v convertUnstreamable\:Catch::Detail}
{\xe \v Catch::Detail\:convertUnstreamable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::enable_if_t< std::is_enum< T >{\b ::value}, std::string > Catch::Detail::convertUnstreamable (T const & value)}}
\par
{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2520                                                          \{\par
2521             {\cf19 return} convertUnknownEnumToString( value );\par
2522         \}\par
}
}
{\xe \v directCompare\:Catch::Detail}
{\xe \v Catch::Detail\:directCompare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Detail::directCompare (double lhs, double rhs)}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4278 \{ {\cf19 return} lhs == rhs; \}\par
}
}
{\xe \v directCompare\:Catch::Detail}
{\xe \v Catch::Detail\:directCompare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Detail::directCompare (float lhs, float rhs)}}
\par
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4277 \{ {\cf19 return} lhs == rhs; \}\par
}
}
{\xe \v getEnv\:Catch::Detail}
{\xe \v Catch::Detail\:getEnv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char const  * Catch::Detail::getEnv (char const * varName)}}
\par
{\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4301                                                   \{\par
4302 {\cf21 #    if defined( _MSC_VER )}\par
4303 {\cf21 #        pragma warning( push )}\par
4304 {\cf21 #        pragma warning( disable : 4996 ) }{\cf20 // use getenv_s instead of getenv}\par
4305 {\cf21 #    endif}\par
4306 \par
4307             {\cf19 return} std::getenv( varName );\par
4308 \par
4309 {\cf21 #    if defined( _MSC_VER )}\par
4310 {\cf21 #        pragma warning( pop )}\par
4311 {\cf21 #    endif}\par
4312         \}\par
}
}
{\xe \v make_unique\:Catch::Detail}
{\xe \v Catch::Detail\:make_unique}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename... Args> {\b unique_ptr}< T > Catch::Detail::make_unique (Args &&... args)}}
\par
{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 947                                               \{\par
948         {\cf19 return} unique_ptr<T>({\cf17 new} T(CATCH_FORWARD(args)...));\par
949     \}\par
}
}
{\xe \v makeEnumInfo\:Catch::Detail}
{\xe \v Catch::Detail\:makeEnumInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Catch::Detail::unique_ptr}< {\b EnumInfo} > Catch::Detail::makeEnumInfo ({\b StringRef} enumName, {\b StringRef} allValueNames, std::vector< int > const & values)}}
\par
{\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3909                                                                                                                                   \{\par
3910             {\cf17 auto} enumInfo = Catch::Detail::make_unique<EnumInfo>();\par
3911             enumInfo->m_name = enumName;\par
3912             enumInfo->m_values.reserve( values.size() );\par
3913 \par
3914             {\cf17 const} {\cf17 auto} valueNames = Catch::Detail::parseEnums( allValueNames );\par
3915             assert( valueNames.size() == values.size() );\par
3916             std::size_t i = 0;\par
3917             {\cf19 for}( {\cf17 auto} value : values )\par
3918                 enumInfo->m_values.emplace_back(value, valueNames[i++]);\par
3919 \par
3920             {\cf19 return} enumInfo;\par
3921         \}\par
}
}
{\xe \v parseEnums\:Catch::Detail}
{\xe \v Catch::Detail\:parseEnums}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b StringRef} > Catch::Detail::parseEnums ({\b StringRef} enums)}}
\par
{\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3889                                                            \{\par
3890             {\cf17 auto} enumValues = splitStringRef( enums, {\cf23 ','} );\par
3891             std::vector<StringRef> parsed;\par
3892             parsed.reserve( enumValues.size() );\par
3893             {\cf19 for}( {\cf17 auto} {\cf17 const}& enumValue : enumValues ) \{\par
3894                 parsed.push_back(trim(extractInstanceName(enumValue)));\par
3895             \}\par
3896             {\cf19 return} parsed;\par
3897         \}\par
}
}
{\xe \v rangeToString\:Catch::Detail}
{\xe \v Catch::Detail\:rangeToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator , typename Sentinel  = InputIterator> std::string Catch::Detail::rangeToString (InputIterator first, Sentinel last)}}
\par
{\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2763                                                                     \{\par
2764             ReusableStringStream rss;\par
2765             rss << {\cf22 "\{ "};\par
2766             {\cf19 if} (first != last) \{\par
2767                 rss << ::Catch::Detail::stringify(*first);\par
2768                 {\cf19 for} (++first; first != last; ++first)\par
2769                     rss << {\cf22 ", "} << ::Catch::Detail::stringify(*first);\par
2770             \}\par
2771             rss << {\cf22 " \}"};\par
2772             {\cf19 return} rss.str();\par
2773         \}\par
}
}
{\xe \v rawMemoryToString\:Catch::Detail}
{\xe \v Catch::Detail\:rawMemoryToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string Catch::Detail::rawMemoryToString (const T & object)}}
\par
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2483                                                        \{\par
2484           {\cf19 return} rawMemoryToString( &{\cf18 object}, {\cf17 sizeof}({\cf18 object}) );\par
2485         \}\par
}
}
{\xe \v rawMemoryToString\:Catch::Detail}
{\xe \v Catch::Detail\:rawMemoryToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Detail::rawMemoryToString (const void * object, std::size_t size)}}
\par
{\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2016                                                                       \{\par
2017         {\cf20 // Reverse order for little endian architectures}\par
2018         {\cf18 int} i = 0, end = {\cf17 static_cast<}{\cf18 int}{\cf17 >}( size ), inc = 1;\par
2019         {\cf19 if}( Endianness::which() == Endianness::Little ) \{\par
2020             i = end-1;\par
2021             end = inc = -1;\par
2022         \}\par
2023 \par
2024         {\cf18 unsigned} {\cf18 char} {\cf17 const} *bytes = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char} {\cf17 const }*{\cf17 >}(object);\par
2025         ReusableStringStream rss;\par
2026         rss << {\cf22 "0x"} << std::setfill({\cf23 '0'}) << std::hex;\par
2027         {\cf19 for}( ; i != end; i += inc )\par
2028              rss << std::setw(2) << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(bytes[i]);\par
2029        {\cf19 return} rss.str();\par
2030     \}\par
}
}
{\xe \v registerListenerImpl\:Catch::Detail}
{\xe \v Catch::Detail\:registerListenerImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Detail::registerListenerImpl ({\b Detail::unique_ptr}< EventListenerFactory > listenerFactory)}}
\par
{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10764                                                                                             \{\par
10765             getMutableRegistryHub().registerListener( CATCH_MOVE(listenerFactory) );\par
10766         \}\par
}
}
{\xe \v registerReporterImpl\:Catch::Detail}
{\xe \v Catch::Detail\:registerReporterImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Detail::registerReporterImpl (std::string const & name, {\b IReporterFactoryPtr} reporterPtr)}}
\par
{\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10752                                                                      \{\par
10753             CATCH_TRY \{\par
10754                 getMutableRegistryHub().registerReporter(\par
10755                     name, CATCH_MOVE( reporterPtr ) );\par
10756             \}\par
10757             CATCH_CATCH_ALL \{\par
10758                 {\cf20 // Do not throw when constructing global objects, instead}\par
10759                 {\cf20 // register the exception to be processed later}\par
10760                 getMutableRegistryHub().registerStartupException();\par
10761             \}\par
10762         \}\par
}
}
{\xe \v registerTranslatorImpl\:Catch::Detail}
{\xe \v Catch::Detail\:registerTranslatorImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Detail::registerTranslatorImpl ({\b Detail::unique_ptr}< {\b IExceptionTranslator} > && translator)}}
\par
{\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2238                                                                   \{\par
2239             getMutableRegistryHub().registerTranslator(\par
2240                 CATCH_MOVE( translator ) );\par
2241         \}\par
}
}
{\xe \v splitReporterSpec\:Catch::Detail}
{\xe \v Catch::Detail\:splitReporterSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > Catch::Detail::splitReporterSpec ({\b StringRef} reporterSpec)}}
\par
{\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits the reporter spec into reporter name and kv-pair options. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5210                                                                          \{\par
5211             {\cf17 static} {\cf17 constexpr} {\cf17 auto} separator = {\cf22 "::"};\par
5212             {\cf17 static} {\cf17 constexpr} {\cf18 size_t} separatorSize = 2;\par
5213 \par
5214             {\cf18 size_t} separatorPos = 0;\par
5215             {\cf17 auto} findNextSeparator = [&reporterSpec]( {\cf18 size_t} startPos ) \{\par
5216                 {\cf17 static_assert}(\par
5217                     separatorSize == 2,\par
5218                     {\cf22 "The code below currently assumes 2 char separator"} );\par
5219 \par
5220                 {\cf17 auto} currentPos = startPos;\par
5221                 {\cf19 do} \{\par
5222                     {\cf19 while} ( currentPos < reporterSpec.size() &&\par
5223                             reporterSpec[currentPos] != separator[0] ) \{\par
5224                         ++currentPos;\par
5225                     \}\par
5226                     {\cf19 if} ( currentPos + 1 < reporterSpec.size() &&\par
5227                          reporterSpec[currentPos + 1] == separator[1] ) \{\par
5228                         {\cf19 return} currentPos;\par
5229                     \}\par
5230                     ++currentPos;\par
5231                 \} {\cf19 while} ( currentPos < reporterSpec.size() );\par
5232 \par
5233                 {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( -1 );\par
5234             \};\par
5235 \par
5236             std::vector<std::string> parts;\par
5237 \par
5238             {\cf19 while} ( separatorPos < reporterSpec.size() ) \{\par
5239                 {\cf17 const} {\cf17 auto} nextSeparator = findNextSeparator( separatorPos );\par
5240                 parts.push_back( {\cf17 static_cast<}std::string{\cf17 >}( reporterSpec.substr(\par
5241                     separatorPos, nextSeparator - separatorPos ) ) );\par
5242 \par
5243                 {\cf19 if} ( nextSeparator == {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( -1 ) ) \{\par
5244                     {\cf19 break};\par
5245                 \}\par
5246                 separatorPos = nextSeparator + separatorSize;\par
5247             \}\par
5248 \par
5249             {\cf20 // Handle a separator at the end.}\par
5250             {\cf20 // This is not a valid spec, but we want to do validation in a}\par
5251             {\cf20 // centralized place}\par
5252             {\cf19 if} ( separatorPos == reporterSpec.size() ) \{\par
5253                 parts.emplace_back();\par
5254             \}\par
5255 \par
5256             {\cf19 return} parts;\par
5257         \}\par
}
}
{\xe \v stringify\:Catch::Detail}
{\xe \v Catch::Detail\:stringify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::string Catch::Detail::stringify (const T & e)}}
\par
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2569                                         \{\par
2570             return ::Catch::StringMaker<std::remove_cv_t<std::remove_reference_t<T>>>::convert(e);\par
2571         \}\par
}
}
{\xe \v stringToColourMode\:Catch::Detail}
{\xe \v Catch::Detail\:stringToColourMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Optional}< {\b ColourMode} > Catch::Detail::stringToColourMode ({\b StringRef} colourMode)}}
\par
{\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5259                                                                         \{\par
5260             {\cf19 if} ( colourMode == {\cf22 "default"} ) \{\par
5261                 {\cf19 return} ColourMode::PlatformDefault;\par
5262             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "ansi"} ) \{\par
5263                 {\cf19 return} ColourMode::ANSI;\par
5264             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "win32"} ) \{\par
5265                 {\cf19 return} ColourMode::Win32;\par
5266             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "none"} ) \{\par
5267                 {\cf19 return} ColourMode::None;\par
5268             \} {\cf19 else} \{\par
5269                 {\cf19 return} \{\};\par
5270             \}\par
5271         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 
{\xe \v unprintableString\:Catch::Detail}
{\xe \v Catch::Detail\:unprintableString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Detail::unprintableString = "\{?\}"_sr{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Generators\par \pard\plain 
{\tc\tcl2 \v Catch::Generators}
{\xe \v Catch::Generators}
{\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b as}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChunkGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FilterGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FixedValuesGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Generators}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GeneratorUntypedBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GeneratorWrapper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MapGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RepeatGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SingleValueGenerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TakeGenerator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b GeneratorBasePtr} = {\b Catch::Detail::unique_ptr}<{\b GeneratorUntypedBase}>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b GeneratorPtr} = {\b Catch::Detail::unique_ptr}<{\b IGenerator}<T>>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b acquireGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} const &lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b createGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} lineInfo, {\b GeneratorBasePtr} &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename DecayedT  = std::decay_t<T>> {\b GeneratorWrapper}< DecayedT > {\b value} (T &&value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< T > {\b values} (std::initializer_list< T > values)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Ts> {\b GeneratorWrapper}< std::tuple< std::decay_t< Ts >... > > {\b table} (std::initializer_list< std::tuple< std::decay_t< Ts >... > > tuples)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Gs> auto {\b makeGenerators} ({\b GeneratorWrapper}< T > &&generator, Gs &&... moreGenerators) -> {\b Generators}< T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b makeGenerators} ({\b GeneratorWrapper}< T > &&generator) -> {\b Generators}< T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Gs> auto {\b makeGenerators} (T &&val, Gs &&... moreGenerators) -> {\b Generators}< std::decay_t< T > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , typename... Gs> auto {\b makeGenerators} ({\b as}< T >, U &&val, Gs &&... moreGenerators) -> {\b Generators}< T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename L > auto {\b generate} ({\b StringRef} generatorName, {\b SourceLineInfo} const &lineInfo, L const &generatorExpression) -> typename decltype(generatorExpression())::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< T > {\b take} (size_t target, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Predicate > {\b GeneratorWrapper}< T > {\b filter} (Predicate &&pred, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< T > {\b repeat} (size_t repeats, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func , typename U , typename T  = FunctionReturnType<Func, U>> {\b GeneratorWrapper}< T > {\b map} (Func &&function, {\b GeneratorWrapper}< U > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< std::vector< T > > {\b chunk} (size_t size, {\b GeneratorWrapper}< T > &&generator)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es dos tipos\par
\pard\plain 
{\xe \v GeneratorBasePtr\:Catch::Generators}
{\xe \v Catch::Generators\:GeneratorBasePtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b Catch::Detail::unique_ptr}< {\b GeneratorUntypedBase} > {\b Catch::Generators::GeneratorBasePtr} = {\b Catch::Detail::unique_ptr}<{\b GeneratorUntypedBase}>}}
\par
{\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GeneratorPtr\:Catch::Generators}
{\xe \v Catch::Generators\:GeneratorPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b Catch::Generators::GeneratorPtr} = {\b Catch::Detail::unique_ptr}<{\b IGenerator}<T>>}}
\par
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v acquireGeneratorTracker\:Catch::Generators}
{\xe \v Catch::Generators\:acquireGeneratorTracker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IGeneratorTracker} * Catch::Generators::acquireGeneratorTracker ({\b StringRef} generatorName, {\b SourceLineInfo} const & lineInfo)}}
\par
{\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2312                                                                                                          \{\par
2313         {\cf19 return} getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );\par
2314     \}\par
}
}
{\xe \v chunk\:Catch::Generators}
{\xe \v Catch::Generators\:chunk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b GeneratorWrapper}< std::vector< T > > Catch::Generators::chunk (size_t size, {\b GeneratorWrapper}< T > && generator)}}
\par
{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7860                                                                                        \{\par
7861         {\cf19 return} GeneratorWrapper<std::vector<T>>(\par
7862             Catch::Detail::make_unique<ChunkGenerator<T>>(size, CATCH_MOVE(generator))\par
7863         );\par
7864     \}\par
}
}
{\xe \v createGeneratorTracker\:Catch::Generators}
{\xe \v Catch::Generators\:createGeneratorTracker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IGeneratorTracker} * Catch::Generators::createGeneratorTracker ({\b StringRef} generatorName, {\b SourceLineInfo} lineInfo, {\b GeneratorBasePtr} && generator)}}
\par
{\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2318                                                                 \{\par
2319         {\cf19 return} getResultCapture().createGeneratorTracker(\par
2320             generatorName, lineInfo, CATCH_MOVE( generator ) );\par
2321     \}\par
}
}
{\xe \v filter\:Catch::Generators}
{\xe \v Catch::Generators\:filter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Predicate > {\b GeneratorWrapper}< T > Catch::Generators::filter (Predicate && pred, {\b GeneratorWrapper}< T > && generator)}}
\par
{\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7722                                                                                   \{\par
7723         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<FilterGenerator<T, Predicate>>(CATCH_FORWARD(pred), CATCH_MOVE(generator)));\par
7724     \}\par
}
}
{\xe \v generate\:Catch::Generators}
{\xe \v Catch::Generators\:generate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > auto Catch::Generators::generate ({\b StringRef} generatorName, {\b SourceLineInfo} const & lineInfo, L const & generatorExpression) -> typename decltype(generatorExpression())::type }}
\par
{\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7600                                                                                                                                                            \{\par
7601         {\cf17 using }UnderlyingType = {\cf17 typename} {\cf17 decltype}(generatorExpression())::type;\par
7602 \par
7603         IGeneratorTracker* tracker = acquireGeneratorTracker( generatorName, lineInfo );\par
7604         {\cf20 // Creation of tracker is delayed after generator creation, so}\par
7605         {\cf20 // that constructing generator can fail without breaking everything.}\par
7606         {\cf19 if} (!tracker) \{\par
7607             tracker = createGeneratorTracker(\par
7608                 generatorName,\par
7609                 lineInfo,\par
7610                 Catch::Detail::make_unique<Generators<UnderlyingType>>(\par
7611                     generatorExpression() ) );\par
7612         \}\par
7613 \par
7614         {\cf17 auto} {\cf17 const}& generator = {\cf17 static_cast<}IGenerator<UnderlyingType> const&{\cf17 >}( *tracker->getGenerator() );\par
7615         {\cf19 return} generator.get();\par
7616     \}\par
}
}
{\xe \v makeGenerators\:Catch::Generators}
{\xe \v Catch::Generators\:makeGenerators}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , typename... Gs> auto Catch::Generators::makeGenerators ({\b as}< T > , U && val, Gs &&... moreGenerators) -> {\b Generators}<T> }}
\par
{\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7589                                                                                     \{\par
7590         {\cf19 return} makeGenerators( value( T( CATCH_FORWARD( val ) ) ), CATCH_FORWARD( moreGenerators )... );\par
7591     \}\par
}
}
{\xe \v makeGenerators\:Catch::Generators}
{\xe \v Catch::Generators\:makeGenerators}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::Generators::makeGenerators ({\b GeneratorWrapper}< T > && generator) -> {\b Generators}<T> }}
\par
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7581                                                                             \{\par
7582         {\cf19 return} Generators<T>(CATCH_MOVE(generator));\par
7583     \}\par
}
}
{\xe \v makeGenerators\:Catch::Generators}
{\xe \v Catch::Generators\:makeGenerators}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename... Gs> auto Catch::Generators::makeGenerators ({\b GeneratorWrapper}< T > && generator, Gs &&... moreGenerators) -> {\b Generators}<T> }}
\par
{\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7577                                                                                                      \{\par
7578         {\cf19 return} Generators<T>(CATCH_MOVE(generator), CATCH_FORWARD(moreGenerators)...);\par
7579     \}\par
}
}
{\xe \v makeGenerators\:Catch::Generators}
{\xe \v Catch::Generators\:makeGenerators}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename... Gs> auto Catch::Generators::makeGenerators (T && val, Gs &&... moreGenerators) -> {\b Generators}<std::decay_t<T>> }}
\par
{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7585                                                                                          \{\par
7586         {\cf19 return} makeGenerators( value( CATCH_FORWARD( val ) ), CATCH_FORWARD( moreGenerators )... );\par
7587     \}\par
}
}
{\xe \v map\:Catch::Generators}
{\xe \v Catch::Generators\:map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Func , typename U , typename T  = FunctionReturnType<Func, U>> {\b GeneratorWrapper}< T > Catch::Generators::map (Func && function, {\b GeneratorWrapper}< U > && generator)}}
\par
{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7810                                                                               \{\par
7811         {\cf19 return} GeneratorWrapper<T>(\par
7812             Catch::Detail::make_unique<MapGenerator<T, U, Func>>(CATCH_FORWARD(function), CATCH_MOVE(generator))\par
7813         );\par
7814     \}\par
}
}
{\xe \v repeat\:Catch::Generators}
{\xe \v Catch::Generators\:repeat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b GeneratorWrapper}< T > Catch::Generators::repeat (size_t repeats, {\b GeneratorWrapper}< T > && generator)}}
\par
{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7778                                                                                 \{\par
7779         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<RepeatGenerator<T>>(repeats, CATCH_MOVE(generator)));\par
7780     \}\par
}
}
{\xe \v table\:Catch::Generators}
{\xe \v Catch::Generators\:table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> {\b GeneratorWrapper}< std::tuple< std::decay_t< Ts >... > > Catch::Generators::table (std::initializer_list< std::tuple< std::decay_t< Ts >... > > tuples)}}
\par
{\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7568                                                                      \{\par
7569         {\cf19 return} values<std::tuple<Ts...>>( tuples );\par
7570     \}\par
}
}
{\xe \v take\:Catch::Generators}
{\xe \v Catch::Generators\:take}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b GeneratorWrapper}< T > Catch::Generators::take (size_t target, {\b GeneratorWrapper}< T > && generator)}}
\par
{\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7681                                                                              \{\par
7682         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<TakeGenerator<T>>(target, CATCH_MOVE(generator)));\par
7683     \}\par
}
}
{\xe \v value\:Catch::Generators}
{\xe \v Catch::Generators\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename DecayedT  = std::decay_t<T>> {\b GeneratorWrapper}< DecayedT > Catch::Generators::value (T && value)}}
\par
{\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7502                                                   \{\par
7503         {\cf19 return} GeneratorWrapper<DecayedT>(\par
7504             Catch::Detail::make_unique<SingleValueGenerator<DecayedT>>(\par
7505                 CATCH_FORWARD( value ) ) );\par
7506     \}\par
}
}
{\xe \v values\:Catch::Generators}
{\xe \v Catch::Generators\:values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b GeneratorWrapper}< T > Catch::Generators::values (std::initializer_list< T > values)}}
\par
{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7508                                                               \{\par
7509         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<FixedValuesGenerator<T>>(values));\par
7510     \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Generators::Detail\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::Detail}
{\xe \v Catch::Generators::Detail}
{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b throw_generator_exception} (char const *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws {\b GeneratorException} with the provided message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b getSeed} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v getSeed\:Catch::Generators::Detail}
{\xe \v Catch::Generators::Detail\:getSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint32_t Catch::Generators::Detail::getSeed ()}}
\par
{\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2334 \{ {\cf19 return} sharedRng()(); \}\par
}
}
{\xe \v throw_generator_exception\:Catch::Generators::Detail}
{\xe \v Catch::Generators::Detail\:throw_generator_exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Generators::Detail::throw_generator_exception (char const * msg)}}
\par
{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws {\b GeneratorException} with the provided message. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2305                                                     \{\par
2306         Catch::throw_exception(GeneratorException\{ msg \});\par
2307     \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::literals\par \pard\plain 
{\tc\tcl2 \v Catch::literals}
{\xe \v Catch::literals}
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b operator""_a} (long double val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b operator""_a} (unsigned long long val)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator""_a\:Catch::literals}
{\xe \v Catch::literals\:operator""_a}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Approx} Catch::literals::operator""_a (long double val)}}
\par
{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 606                                           \{\par
607         {\cf19 return} Approx(val);\par
608     \}\par
}
}
{\xe \v operator""_a\:Catch::literals}
{\xe \v Catch::literals\:operator""_a}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Approx} Catch::literals::operator""_a (unsigned long long val)}}
\par
{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 609                                                  \{\par
610         {\cf19 return} Approx(val);\par
611     \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers}
{\xe \v Catch::Matchers}
{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IsEmptyMatcher {\b IsEmpty} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HasSizeMatcher {\b SizeIs} (std::size_t sz)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ExceptionMessageMatcher {\b Message} (std::string const &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinUlpsMatcher {\b WithinULP} (double target, uint64_t maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinUlpsMatcher {\b WithinULP} (float target, uint64_t maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinAbsMatcher {\b WithinAbs} (double target, double margin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b WithinRel} (double target, double eps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b WithinRel} (double target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b WithinRel} (float target, float eps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b WithinRel} (float target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IsNaNMatcher {\b IsNaN} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AllTrueMatcher {\b AllTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NoneTrueMatcher {\b NoneTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AnyTrueMatcher {\b AnyTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StringEqualsMatcher {\b Equals} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StringContainsMatcher {\b ContainsSubstring} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EndsWithMatcher {\b EndsWith} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StartsWithMatcher {\b StartsWith} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RegexMatcher {\b Matches} (std::string const &regex, {\b CaseSensitive} caseSensitivity)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v AllTrue\:Catch::Matchers}
{\xe \v Catch::Matchers\:AllTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AllTrueMatcher Catch::Matchers::AllTrue ()}}
\par
{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8264 \{ {\cf19 return} AllTrueMatcher\{\}; \}\par
}
}
{\xe \v AnyTrue\:Catch::Matchers}
{\xe \v Catch::Matchers\:AnyTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AnyTrueMatcher Catch::Matchers::AnyTrue ()}}
\par
{\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8272 \{ {\cf19 return} AnyTrueMatcher\{\}; \}\par
}
}
{\xe \v ContainsSubstring\:Catch::Matchers}
{\xe \v Catch::Matchers\:ContainsSubstring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringContainsMatcher Catch::Matchers::ContainsSubstring (std::string const & str, {\b CaseSensitive} caseSensitivity)}}
\par
{\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8364                                                                                                    \{\par
8365         {\cf19 return} StringContainsMatcher( CasedString( str, caseSensitivity) );\par
8366     \}\par
}
}
{\xe \v EndsWith\:Catch::Matchers}
{\xe \v Catch::Matchers\:EndsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EndsWithMatcher Catch::Matchers::EndsWith (std::string const & str, {\b CaseSensitive} caseSensitivity)}}
\par
{\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8367                                                                                     \{\par
8368         {\cf19 return} EndsWithMatcher( CasedString( str, caseSensitivity) );\par
8369     \}\par
}
}
{\xe \v Equals\:Catch::Matchers}
{\xe \v Catch::Matchers\:Equals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringEqualsMatcher Catch::Matchers::Equals (std::string const & str, {\b CaseSensitive} caseSensitivity)}}
\par
{\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8361                                                                                       \{\par
8362         {\cf19 return} StringEqualsMatcher( CasedString( str, caseSensitivity) );\par
8363     \}\par
}
}
{\xe \v IsEmpty\:Catch::Matchers}
{\xe \v Catch::Matchers\:IsEmpty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IsEmptyMatcher Catch::Matchers::IsEmpty ()}}
\par
{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8001                              \{\par
8002         {\cf19 return} \{\};\par
8003     \}\par
}
}
{\xe \v IsNaN\:Catch::Matchers}
{\xe \v Catch::Matchers\:IsNaN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IsNaNMatcher Catch::Matchers::IsNaN ()}}
\par
{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8242 \{ {\cf19 return} IsNaNMatcher(); \}\par
}
}
{\xe \v Matches\:Catch::Matchers}
{\xe \v Catch::Matchers\:Matches}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
RegexMatcher Catch::Matchers::Matches (std::string const & regex, {\b CaseSensitive} caseSensitivity)}}
\par
{\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8374                                                                                 \{\par
8375         {\cf19 return} RegexMatcher(regex, caseSensitivity);\par
8376     \}\par
}
}
{\xe \v Message\:Catch::Matchers}
{\xe \v Catch::Matchers\:Message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ExceptionMessageMatcher Catch::Matchers::Message (std::string const & message)}}
\par
{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8025                                                           \{\par
8026     {\cf19 return} ExceptionMessageMatcher(message);\par
8027 \}\par
}
}
{\xe \v NoneTrue\:Catch::Matchers}
{\xe \v Catch::Matchers\:NoneTrue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NoneTrueMatcher Catch::Matchers::NoneTrue ()}}
\par
{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8268 \{ {\cf19 return} NoneTrueMatcher\{\}; \}\par
}
}
{\xe \v SizeIs\:Catch::Matchers}
{\xe \v Catch::Matchers\:SizeIs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
HasSizeMatcher Catch::Matchers::SizeIs (std::size_t sz)}}
\par
{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8005                                         \{\par
8006         {\cf19 return} HasSizeMatcher\{ sz \};\par
8007     \}\par
}
}
{\xe \v StartsWith\:Catch::Matchers}
{\xe \v Catch::Matchers\:StartsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StartsWithMatcher Catch::Matchers::StartsWith (std::string const & str, {\b CaseSensitive} caseSensitivity)}}
\par
{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8370                                                                                         \{\par
8371         {\cf19 return} StartsWithMatcher( CasedString( str, caseSensitivity) );\par
8372     \}\par
}
}
{\xe \v WithinAbs\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinAbs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WithinAbsMatcher Catch::Matchers::WithinAbs (double target, double margin)}}
\par
{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8211                                                          \{\par
8212     {\cf19 return} WithinAbsMatcher(target, margin);\par
8213 \}\par
}
}
{\xe \v WithinRel\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinRel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WithinRelMatcher Catch::Matchers::WithinRel (double target)}}
\par
{\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8219                                           \{\par
8220     {\cf19 return} WithinRelMatcher(target, std::numeric_limits<double>::epsilon() * 100);\par
8221 \}\par
}
}
{\xe \v WithinRel\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinRel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WithinRelMatcher Catch::Matchers::WithinRel (double target, double eps)}}
\par
{\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8215                                                       \{\par
8216     {\cf19 return} WithinRelMatcher(target, eps);\par
8217 \}\par
}
}
{\xe \v WithinRel\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinRel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WithinRelMatcher Catch::Matchers::WithinRel (float target)}}
\par
{\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8227                                          \{\par
8228     {\cf19 return} WithinRelMatcher(target, std::numeric_limits<float>::epsilon() * 100);\par
8229 \}\par
}
}
{\xe \v WithinRel\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinRel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WithinRelMatcher Catch::Matchers::WithinRel (float target, float eps)}}
\par
{\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8223                                                     \{\par
8224     {\cf19 return} WithinRelMatcher(target, eps);\par
8225 \}\par
}
}
{\xe \v WithinULP\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinULP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WithinUlpsMatcher Catch::Matchers::WithinULP (double target, uint64_t maxUlpDiff)}}
\par
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8203                                                                 \{\par
8204     {\cf19 return} WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Double);\par
8205 \}\par
}
}
{\xe \v WithinULP\:Catch::Matchers}
{\xe \v Catch::Matchers\:WithinULP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WithinUlpsMatcher Catch::Matchers::WithinULP (float target, uint64_t maxUlpDiff)}}
\par
{\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8207                                                                \{\par
8208     {\cf19 return} WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Float);\par
8209 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::Matchers::Detail\par \pard\plain 
{\tc\tcl2 \v Catch::Matchers::Detail}
{\xe \v Catch::Matchers::Detail}
{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b FloatingPointKind} : uint8_t \{ {\b Float}
, {\b Double}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b describe_multi_matcher} ({\b StringRef} combine, std::string const *descriptions_begin, std::string const *descriptions_end)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 
{\xe \v FloatingPointKind\:Catch::Matchers::Detail}
{\xe \v Catch::Matchers::Detail\:FloatingPointKind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b Catch::Matchers::Detail::FloatingPointKind} : uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Float\:Catch::Matchers::Detail}
{\xe \v Catch::Matchers::Detail\:Float}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Float{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
\cell }{\cell }{\row }
{\xe \v Double\:Catch::Matchers::Detail}
{\xe \v Catch::Matchers::Detail\:Double}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Double{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8087                                  : uint8_t \{\par
8088         Float,\par
8089         Double\par
8090     \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v describe_multi_matcher\:Catch::Matchers::Detail}
{\xe \v Catch::Matchers::Detail\:describe_multi_matcher}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Matchers::Detail::describe_multi_matcher ({\b StringRef} combine, std::string const * descriptions_begin, std::string const * descriptions_end)}}
\par
{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8389                                                                                                                                     \{\par
8390             std::string description;\par
8391             std::size_t combined_size = 4;\par
8392             {\cf19 for} ( {\cf17 auto} desc = descriptions_begin; desc != descriptions_end; ++desc ) \{\par
8393                 combined_size += desc->size();\par
8394             \}\par
8395             combined_size += {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(descriptions_end - descriptions_begin - 1) * combine.size();\par
8396 \par
8397             description.reserve(combined_size);\par
8398 \par
8399             description += {\cf22 "( "};\par
8400             {\cf18 bool} first = {\cf17 true};\par
8401             {\cf19 for}( {\cf17 auto} desc = descriptions_begin; desc != descriptions_end; ++desc ) \{\par
8402                 {\cf19 if}( first )\par
8403                     first = {\cf17 false};\par
8404                 {\cf19 else}\par
8405                     description += combine;\par
8406                 description += *desc;\par
8407             \}\par
8408             description += {\cf22 " )"};\par
8409             {\cf19 return} description;\par
8410         \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::TestCaseTracking\par \pard\plain 
{\tc\tcl2 \v Catch::TestCaseTracking}
{\xe \v Catch::TestCaseTracking}
{\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace Catch::TextFlow\par \pard\plain 
{\tc\tcl2 \v Catch::TextFlow}
{\xe \v Catch::TextFlow}
{\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, Column const &col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Column {\b Spacer} (size_t spaceWidth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, Columns const &cols)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b operator+} (Column const &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b operator+} (Column &&lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns & {\b operator+=} (Columns &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns & {\b operator+=} (Columns &lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b operator+} (Columns const &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b operator+} (Columns &&lhs, Column &&rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator+\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Columns Catch::TextFlow::operator+ (Column && lhs, Column && rhs)}}
\par
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7541                                                         \{\par
7542             Columns cols;\par
7543             cols += CATCH_MOVE( lhs );\par
7544             cols += CATCH_MOVE( rhs );\par
7545             {\cf19 return} cols;\par
7546         \}\par
}
}
{\xe \v operator+\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Columns Catch::TextFlow::operator+ (Column const & lhs, Column const & rhs)}}
\par
{\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7535                                                                   \{\par
7536             Columns cols;\par
7537             cols += lhs;\par
7538             cols += rhs;\par
7539             {\cf19 return} cols;\par
7540         \}\par
}
}
{\xe \v operator+\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Columns Catch::TextFlow::operator+ (Columns && lhs, Column && rhs)}}
\par
{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7561                                                          \{\par
7562             lhs += CATCH_MOVE( rhs );\par
7563             {\cf19 return} CATCH_MOVE( lhs );\par
7564         \}\par
}
}
{\xe \v operator+\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Columns Catch::TextFlow::operator+ (Columns const & lhs, Column const & rhs)}}
\par
{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7556                                                                    \{\par
7557             {\cf17 auto} combined( lhs );\par
7558             combined += rhs;\par
7559             {\cf19 return} combined;\par
7560         \}\par
}
}
{\xe \v operator+=\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Columns & Catch::TextFlow::operator+= (Columns & lhs, Column && rhs)}}
\par
{\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7552                                                           \{\par
7553             lhs.m_columns.push_back( CATCH_MOVE( rhs ) );\par
7554             {\cf19 return} lhs;\par
7555         \}\par
}
}
{\xe \v operator+=\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Columns & Catch::TextFlow::operator+= (Columns & lhs, Column const & rhs)}}
\par
{\bkmkstart AAAAAAACOT}
{\bkmkend AAAAAAACOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7548                                                                \{\par
7549             lhs.m_columns.push_back( rhs );\par
7550             {\cf19 return} lhs;\par
7551         \}\par
}
}
{\xe \v operator<<\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::TextFlow::operator<< (std::ostream & os, Column const & col)}}
\par
{\bkmkstart AAAAAAACOU}
{\bkmkend AAAAAAACOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7448                                                                     \{\par
7449             {\cf18 bool} first = {\cf17 true};\par
7450             {\cf19 for} ( {\cf17 auto} line : col ) \{\par
7451                 {\cf19 if} ( first ) \{\par
7452                     first = {\cf17 false};\par
7453                 \} {\cf19 else} \{\par
7454                     os << {\cf23 '\\n'};\par
7455                 \}\par
7456                 os << line;\par
7457             \}\par
7458             {\cf19 return} os;\par
7459         \}\par
}
}
{\xe \v operator<<\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & Catch::TextFlow::operator<< (std::ostream & os, Columns const & cols)}}
\par
{\bkmkstart AAAAAAACOV}
{\bkmkend AAAAAAACOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7522                                                                       \{\par
7523             {\cf18 bool} first = {\cf17 true};\par
7524             {\cf19 for} ( {\cf17 auto} line : cols ) \{\par
7525                 {\cf19 if} ( first ) \{\par
7526                     first = {\cf17 false};\par
7527                 \} {\cf19 else} \{\par
7528                     os << {\cf23 '\\n'};\par
7529                 \}\par
7530                 os << line;\par
7531             \}\par
7532             {\cf19 return} os;\par
7533         \}\par
}
}
{\xe \v Spacer\:Catch::TextFlow}
{\xe \v Catch::TextFlow\:Spacer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Column Catch::TextFlow::Spacer (size_t spaceWidth)}}
\par
{\bkmkstart AAAAAAACOW}
{\bkmkend AAAAAAACOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7461                                            \{\par
7462             Column ret\{ {\cf22 ""} \};\par
7463             ret.width( spaceWidth );\par
7464             {\cf19 return} ret;\par
7465         \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ref\'EAncia do Namespace mpl_\par \pard\plain 
{\tc\tcl2 \v mpl_}
{\xe \v mpl_}
{\bkmkstart AAAAAAACOX}
{\bkmkend AAAAAAACOX}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Classes{\tc \v Classes}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::accept_many_t\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::accept_many_t}
{\xe \v Catch::Clara::accept_many_t}
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::always_false< T >\par \pard\plain 
{\tc\tcl2 \v Catch::always_false< T >}
{\xe \v Catch::always_false< T >}
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::always_false< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1always__false.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Approx\par \pard\plain 
{\tc\tcl2 \v Catch::Approx}
{\xe \v Catch::Approx}
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} (double {\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b operator-} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} {\b operator()} (T const &{\b value}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} (T const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} & {\b epsilon} (T const &newEpsilon)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} & {\b margin} (T const &newMargin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} & {\b scale} (T const &newScale)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b Approx} {\b custom} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator==} (const T &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator==} ({\b Approx} const &lhs, const T &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator!=} (T const &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator!=} ({\b Approx} const &lhs, T const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator<=} (T const &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator<=} ({\b Approx} const &lhs, T const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator>=} (T const &lhs, {\b Approx} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool {\b operator>=} ({\b Approx} const &lhs, T const &rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Approx\:Catch::Approx}
{\xe \v Catch::Approx\:Approx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Approx::Approx (double value){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 561     :   m_epsilon( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(std::numeric_limits<float>::epsilon())*100. ),\par
562         m_margin( 0.0 ),\par
563         m_scale( 0.0 ),\par
564         m_value( value )\par
565     \{\}\par
}
}
{\xe \v Approx\:Catch::Approx}
{\xe \v Catch::Approx\:Approx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> Catch::Approx::Approx (T const & value){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3124                                          : Approx({\cf17 static_cast<}{\cf18 double}{\cf17 >}(value))\par
3125         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v custom\:Catch::Approx}
{\xe \v Catch::Approx\:custom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Approx} Catch::Approx::custom (){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 567                           \{\par
568         {\cf19 return} Approx( 0 );\par
569     \}\par
}
}
{\xe \v epsilon\:Catch::Approx}
{\xe \v Catch::Approx\:epsilon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} & Catch::Approx::epsilon (T const & newEpsilon){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3170                                                \{\par
3171             {\cf17 const} {\cf17 auto} epsilonAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon);\par
3172             setEpsilon(epsilonAsDouble);\par
3173             {\cf19 return} *{\cf17 this};\par
3174         \}\par
}
}
{\xe \v margin\:Catch::Approx}
{\xe \v Catch::Approx\:margin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} & Catch::Approx::margin (T const & newMargin){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3177                                              \{\par
3178             {\cf17 const} {\cf17 auto} marginAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newMargin);\par
3179             setMargin(marginAsDouble);\par
3180             {\cf19 return} *{\cf17 this};\par
3181         \}\par
}
}
{\xe \v operator()\:Catch::Approx}
{\xe \v Catch::Approx\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} Catch::Approx::operator() (T const & value) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3115                                                   \{\par
3116             Approx approx( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(value) );\par
3117             approx.m_epsilon = m_epsilon;\par
3118             approx.m_margin = m_margin;\par
3119             approx.m_scale = m_scale;\par
3120             {\cf19 return} approx;\par
3121         \}\par
}
}
{\xe \v operator-\:Catch::Approx}
{\xe \v Catch::Approx\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Approx} Catch::Approx::operator- () const}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 571                                    \{\par
572         {\cf17 auto} temp(*{\cf17 this});\par
573         temp.m_value = -temp.m_value;\par
574         {\cf19 return} temp;\par
575     \}\par
}
}
{\xe \v scale\:Catch::Approx}
{\xe \v Catch::Approx\:scale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> {\b Approx} & Catch::Approx::scale (T const & newScale){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3184                                            \{\par
3185             m_scale = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale);\par
3186             {\cf19 return} *{\cf17 this};\par
3187         \}\par
}
}
{\xe \v toString\:Catch::Approx}
{\xe \v Catch::Approx\:toString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Approx::toString () const}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 578                                      \{\par
579         ReusableStringStream rss;\par
580         rss << {\cf22 "Approx( "} << ::Catch::Detail::stringify( m_value ) << {\cf22 " )"};\par
581         {\cf19 return} rss.str();\par
582     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator!=\:Catch::Approx}
{\xe \v Catch::Approx\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator!= ({\b Approx} const & lhs, T const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3145                                                                     \{\par
3146             {\cf19 return} !operator==( rhs, lhs );\par
3147         \}\par
}
}
{\xe \v operator!=\:Catch::Approx}
{\xe \v Catch::Approx\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator!= (T const & lhs, {\b Approx} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3140                                                                     \{\par
3141             {\cf19 return} !operator==( lhs, rhs );\par
3142         \}\par
}
}
{\xe \v operator<=\:Catch::Approx}
{\xe \v Catch::Approx\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator<= ({\b Approx} const & lhs, T const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3155                                                                     \{\par
3156             {\cf19 return} lhs.m_value < {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
3157         \}\par
}
}
{\xe \v operator<=\:Catch::Approx}
{\xe \v Catch::Approx\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator<= (T const & lhs, {\b Approx} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3150                                                                     \{\par
3151             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) < rhs.m_value || lhs == rhs;\par
3152         \}\par
}
}
{\xe \v operator==\:Catch::Approx}
{\xe \v Catch::Approx\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator== ({\b Approx} const & lhs, const T & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3135                                                                     \{\par
3136             {\cf19 return} operator==( rhs, lhs );\par
3137         \}\par
}
}
{\xe \v operator==\:Catch::Approx}
{\xe \v Catch::Approx\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator== (const T & lhs, {\b Approx} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3129                                                                     \{\par
3130             {\cf17 auto} lhs_v = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs);\par
3131             {\cf19 return} rhs.equalityComparisonImpl(lhs_v);\par
3132         \}\par
}
}
{\xe \v operator>=\:Catch::Approx}
{\xe \v Catch::Approx\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator>= ({\b Approx} const & lhs, T const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3165                                                                     \{\par
3166             {\cf19 return} lhs.m_value > {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
3167         \}\par
}
}
{\xe \v operator>=\:Catch::Approx}
{\xe \v Catch::Approx\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = std::enable_if_t<std::is_constructible<double, T>::value>> bool operator>= (T const & lhs, {\b Approx} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3160                                                                     \{\par
3161             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) > rhs.m_value || lhs == rhs;\par
3162         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Arg\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Arg}
{\xe \v Catch::Clara::Arg}
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Arg:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_arg.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::InternalParseResult} {\b parse} (std::string const &, {\b Detail::TokenStream} tokens) const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Arg >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} ({\b accept_many_t}, LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (T &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arg} & {\b operator()} ({\b StringRef} description) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Arg} && {\b operator()} ({\b StringRef} description) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b optional} () -> {\b Arg} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b required} () -> {\b Arg} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isOptional} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b cardinality} () const -> size_t override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b hint} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ComposableParserImpl< Arg >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator|} (T const &other) const -> {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} {\b operator|} (T const &other) const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ParserBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b validate} () const -> {\b Result}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternalParseResult} {\b parse} ({\b Args} const &args) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Arg >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (std::shared_ptr< {\b BoundRef} > const &ref)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Arg >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optionality} {\b m_optionality}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::shared_ptr< {\b BoundRef} > {\b m_ref}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_hint}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_description}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v parse\:Catch::Clara::Arg}
{\xe \v Catch::Clara::Arg\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::InternalParseResult} Catch::Clara::Arg::parse (std::string const & , {\b Detail::TokenStream} tokens) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::ParserBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACAO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2767                                                                                \{\par
2768             {\cf17 auto} validationResult = validate();\par
2769             {\cf19 if} (!validationResult)\par
2770                 {\cf19 return} Detail::InternalParseResult(validationResult);\par
2771 \par
2772             {\cf17 auto} token = *tokens;\par
2773             {\cf19 if} (token.type != Detail::TokenType::Argument)\par
2774                 {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2775                     ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2776 \par
2777             assert(!m_ref->isFlag());\par
2778             {\cf17 auto} valueRef =\par
2779                 {\cf17 static_cast<}Detail::BoundValueRefBase*{\cf17 >}(m_ref.get());\par
2780 \par
2781             {\cf17 auto} result = valueRef->setValue({\cf17 static_cast<}std::string{\cf17 >}(token.token));\par
2782             {\cf19 if} ( !result )\par
2783                 {\cf19 return} Detail::InternalParseResult( result );\par
2784             {\cf19 else}\par
2785                 {\cf19 return} Detail::InternalParseResult::ok(\par
2786                     Detail::ParseState( ParseResultType::Matched,\par
2787                                         CATCH_MOVE( ++tokens ) ) );\par
2788         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Args\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Args}
{\xe \v Catch::Clara::Args}
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Args} (int argc, char const *const *argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Args} (std::initializer_list< {\b StringRef} > args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b exeName} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper over argc + argv, assumes that the inputs outlive it \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Args\:Catch::Clara::Args}
{\xe \v Catch::Clara::Args\:Args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Args::Args (int argc, char const *const * argv)}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3045                                                     :\par
3046             m_exeName(argv[0]), m_args(argv + 1, argv + argc) \{\}\par
}
}
{\xe \v Args\:Catch::Clara::Args}
{\xe \v Catch::Clara::Args\:Args}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Args::Args (std::initializer_list< {\b StringRef} > args)}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3048                                                       :\par
3049             m_exeName(*args.begin()),\par
3050             m_args(args.begin() + 1, args.end()) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v exeName\:Catch::Clara::Args}
{\xe \v Catch::Clara::Args\:exeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Clara::Args::exeName () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4873 \{ {\cf19 return} m_exeName; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Generators::as< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::as< T >}
{\xe \v Catch::Generators::as< T >}
{\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::AssertionHandler\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler}
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionHandler} ({\b StringRef} macroName, {\b SourceLineInfo} const &lineInfo, {\b StringRef} capturedExpression, {\b ResultDisposition::Flags} resultDisposition)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AssertionHandler} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b handleExpr} ({\b ExprLhs}< T > const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExpr} ({\b ITransientExpression} const &expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleMessage} ({\b ResultWas::OfType} resultType, {\b StringRef} message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionThrownAsExpected} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleUnexpectedExceptionNotThrown} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleExceptionNotThrownAsExpected} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleThrowingCallSkipped} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b handleUnexpectedInflightException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b complete} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b allowThrows} () const -> bool\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v AssertionHandler\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:AssertionHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionHandler::AssertionHandler ({\b StringRef} macroName, {\b SourceLineInfo} const & lineInfo, {\b StringRef} capturedExpression, {\b ResultDisposition::Flags} resultDisposition)}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2523     :   m_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},\par
2524         m_resultCapture( getResultCapture() )\par
2525     \{\par
2526         m_resultCapture.notifyAssertionStarted( m_assertionInfo );\par
2527     \}\par
}
}
{\xe \v ~AssertionHandler\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:~AssertionHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionHandler::~AssertionHandler (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5614                             \{\par
5615             {\cf19 if} ( !m_completed ) \{\par
5616                 m_resultCapture.handleIncomplete( m_assertionInfo );\par
5617             \}\par
5618         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v allowThrows\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:allowThrows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::AssertionHandler::allowThrows () const -> bool}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2536                                                      \{\par
2537         {\cf19 return} getCurrentContext().getConfig()->allowThrows();\par
2538     \}\par
}
}
{\xe \v complete\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:complete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::complete ()}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2540                                     \{\par
2541         m_completed = {\cf17 true};\par
2542         {\cf19 if}( m_reaction.shouldDebugBreak ) \{\par
2543 \par
2544             {\cf20 // If you find your debugger stopping you here then go one level up on the}\par
2545             {\cf20 // call-stack for the code that caused it (typically a failed assertion)}\par
2546 \par
2547             {\cf20 // (To go back to the test and change execution, jump over the throw, next)}\par
2548             CATCH_BREAK_INTO_DEBUGGER();\par
2549         \}\par
2550         {\cf19 if} (m_reaction.shouldThrow) \{\par
2551             throw_test_failure_exception();\par
2552         \}\par
2553         {\cf19 if} ( m_reaction.shouldSkip ) \{\par
2554             throw_test_skip_exception();\par
2555         \}\par
2556     \}\par
}
}
{\xe \v handleExceptionNotThrownAsExpected\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExceptionNotThrownAsExpected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleExceptionNotThrownAsExpected ()}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2565                                                               \{\par
2566         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2567     \}\par
}
}
{\xe \v handleExceptionThrownAsExpected\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExceptionThrownAsExpected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleExceptionThrownAsExpected ()}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2562                                                            \{\par
2563         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2564     \}\par
}
}
{\xe \v handleExpr\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void Catch::AssertionHandler::handleExpr ({\b ExprLhs}< T > const & expr){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5622                                                   \{\par
5623             handleExpr( expr.makeUnaryExpr() );\par
5624         \}\par
}
}
{\xe \v handleExpr\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleExpr ({\b ITransientExpression} const & expr)}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2529                                                                         \{\par
2530         m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );\par
2531     \}\par
}
}
{\xe \v handleMessage\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleMessage ({\b ResultWas::OfType} resultType, {\b StringRef} message)}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2532                                                                                       \{\par
2533         m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );\par
2534     \}\par
}
}
{\xe \v handleThrowingCallSkipped\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleThrowingCallSkipped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleThrowingCallSkipped ()}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2573                                                      \{\par
2574         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2575     \}\par
}
}
{\xe \v handleUnexpectedExceptionNotThrown\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleUnexpectedExceptionNotThrown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleUnexpectedExceptionNotThrown ()}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2569                                                               \{\par
2570         m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );\par
2571     \}\par
}
}
{\xe \v handleUnexpectedInflightException\:Catch::AssertionHandler}
{\xe \v Catch::AssertionHandler\:handleUnexpectedInflightException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::AssertionHandler::handleUnexpectedInflightException ()}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2558                                                              \{\par
2559         m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );\par
2560     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::AssertionInfo\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo}
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b macroName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b capturedExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b resultDisposition}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v capturedExpression\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:capturedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::AssertionInfo::capturedExpression}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lineInfo\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::AssertionInfo::lineInfo}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v macroName\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:macroName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::AssertionInfo::macroName}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resultDisposition\:Catch::AssertionInfo}
{\xe \v Catch::AssertionInfo\:resultDisposition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultDisposition::Flags} Catch::AssertionInfo::resultDisposition}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::AssertionReaction\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionReaction}
{\xe \v Catch::AssertionReaction}
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldDebugBreak} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldThrow} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldSkip} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v shouldDebugBreak\:Catch::AssertionReaction}
{\xe \v Catch::AssertionReaction\:shouldDebugBreak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionReaction::shouldDebugBreak = false}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shouldSkip\:Catch::AssertionReaction}
{\xe \v Catch::AssertionReaction\:shouldSkip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionReaction::shouldSkip = false}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shouldThrow\:Catch::AssertionReaction}
{\xe \v Catch::AssertionReaction\:shouldThrow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionReaction::shouldThrow = false}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::AssertionResult\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionResult}
{\xe \v Catch::AssertionResult}
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResult} ({\b AssertionInfo} const &info, {\b AssertionResultData} &&data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isOk} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b succeeded} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultWas::OfType} {\b getResultType} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasExpression} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasMessage} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getExpression} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getExpressionInMacro} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasExpandedExpression} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getExpandedExpression} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b getMessage} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b getSourceInfo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b getTestMacroName} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionInfo} {\b m_info}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResultData} {\b m_resultData}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v AssertionResult\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:AssertionResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionResult::AssertionResult (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AssertionResult\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:AssertionResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionResult::AssertionResult ({\b AssertionInfo} const & info, {\b AssertionResultData} && data)}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 641     :   m_info( info ),\par
642         m_resultData( CATCH_MOVE(data) )\par
643     \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getExpandedExpression\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:getExpandedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::AssertionResult::getExpandedExpression () const}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 697                                                            \{\par
698         std::string expr = m_resultData.reconstructExpression();\par
699         {\cf19 return} expr.empty()\par
700                 ? getExpression()\par
701                 : expr;\par
702     \}\par
}
}
{\xe \v getExpression\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:getExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::AssertionResult::getExpression () const}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 667                                                    \{\par
668         {\cf20 // Possibly overallocating by 3 characters should be basically free}\par
669         std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);\par
670         {\cf19 if} (isFalseTest(m_info.resultDisposition)) \{\par
671             expr += {\cf22 "!("};\par
672         \}\par
673         expr += m_info.capturedExpression;\par
674         {\cf19 if} (isFalseTest(m_info.resultDisposition)) \{\par
675             expr += {\cf23 ')'};\par
676         \}\par
677         {\cf19 return} expr;\par
678     \}\par
}
}
{\xe \v getExpressionInMacro\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:getExpressionInMacro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::AssertionResult::getExpressionInMacro () const}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 680                                                           \{\par
681         {\cf19 if} ( m_info.macroName.empty() ) \{\par
682             {\cf19 return} {\cf17 static_cast<}std::string{\cf17 >}( m_info.capturedExpression );\par
683         \}\par
684         std::string expr;\par
685         expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );\par
686         expr += m_info.macroName;\par
687         expr += {\cf22 "( "};\par
688         expr += m_info.capturedExpression;\par
689         expr += {\cf22 " )"};\par
690         {\cf19 return} expr;\par
691     \}\par
}
}
{\xe \v getMessage\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:getMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::AssertionResult::getMessage () const}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 704                                                 \{\par
705         {\cf19 return} m_resultData.message;\par
706     \}\par
}
}
{\xe \v getResultType\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:getResultType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultWas::OfType} Catch::AssertionResult::getResultType () const}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 655                                                          \{\par
656         {\cf19 return} m_resultData.resultType;\par
657     \}\par
}
}
{\xe \v getSourceInfo\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:getSourceInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::AssertionResult::getSourceInfo () const}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 707                                                         \{\par
708         {\cf19 return} m_info.lineInfo;\par
709     \}\par
}
}
{\xe \v getTestMacroName\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:getTestMacroName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::AssertionResult::getTestMacroName () const}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 711                                                       \{\par
712         {\cf19 return} m_info.macroName;\par
713     \}\par
}
}
{\xe \v hasExpandedExpression\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:hasExpandedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionResult::hasExpandedExpression () const}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 693                                                       \{\par
694         {\cf19 return} hasExpression() && getExpandedExpression() != getExpression();\par
695     \}\par
}
}
{\xe \v hasExpression\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:hasExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionResult::hasExpression () const}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 659                                               \{\par
660         {\cf19 return} !m_info.capturedExpression.empty();\par
661     \}\par
}
}
{\xe \v hasMessage\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:hasMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionResult::hasMessage () const}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 663                                            \{\par
664         {\cf19 return} !m_resultData.message.empty();\par
665     \}\par
}
}
{\xe \v isOk\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:isOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionResult::isOk () const}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 651                                      \{\par
652         {\cf19 return} Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );\par
653     \}\par
}
}
{\xe \v succeeded\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:succeeded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::AssertionResult::succeeded () const}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 646                                           \{\par
647         {\cf19 return} Catch::isOk( m_resultData.resultType );\par
648     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_info\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:m_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionInfo} Catch::AssertionResult::m_info}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_resultData\:Catch::AssertionResult}
{\xe \v Catch::AssertionResult\:m_resultData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AssertionResultData} Catch::AssertionResult::m_resultData}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::AssertionResultData\par \pard\plain 
{\tc\tcl2 \v Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData}
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResultData} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AssertionResultData} ({\b ResultWas::OfType} _resultType, {\b LazyExpression} const &_lazyExpression)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b reconstructExpression} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b message}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b reconstructedExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LazyExpression} {\b lazyExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultWas::OfType} {\b resultType}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v AssertionResultData\:Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData\:AssertionResultData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionResultData::AssertionResultData (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AssertionResultData\:Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData\:AssertionResultData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AssertionResultData::AssertionResultData ({\b ResultWas::OfType} _resultType, {\b LazyExpression} const & _lazyExpression)}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 624                                                                                                                :\par
625         lazyExpression(_lazyExpression),\par
626         resultType(_resultType) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v reconstructExpression\:Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData\:reconstructExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::AssertionResultData::reconstructExpression () const}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 628                                                                \{\par
629 \par
630         {\cf19 if}( reconstructedExpression.empty() ) \{\par
631             {\cf19 if}( lazyExpression ) \{\par
632                 ReusableStringStream rss;\par
633                 rss << lazyExpression;\par
634                 reconstructedExpression = rss.str();\par
635             \}\par
636         \}\par
637         {\cf19 return} reconstructedExpression;\par
638     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v lazyExpression\:Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData\:lazyExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LazyExpression} Catch::AssertionResultData::lazyExpression}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v message\:Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::AssertionResultData::message}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reconstructedExpression\:Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData\:reconstructedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::AssertionResultData::reconstructedExpression{\f2 [mutable]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resultType\:Catch::AssertionResultData}
{\xe \v Catch::AssertionResultData\:resultType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultWas::OfType} Catch::AssertionResultData::resultType}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::AutoReg\par \pard\plain 
{\tc\tcl2 \v Catch::AutoReg}
{\xe \v Catch::AutoReg}
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::AutoReg:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_auto_reg.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AutoReg} ({\b Detail::unique_ptr}< {\b ITestInvoker} > invoker, {\b SourceLineInfo} const &lineInfo, {\b StringRef} classOrMethod, {\b NameAndTags} const &nameAndTags) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v AutoReg\:Catch::AutoReg}
{\xe \v Catch::AutoReg\:AutoReg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::AutoReg::AutoReg ({\b Detail::unique_ptr}< {\b ITestInvoker} > invoker, {\b SourceLineInfo} const & lineInfo, {\b StringRef} classOrMethod, {\b NameAndTags} const & nameAndTags){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6949                                                                                                                                                                \{\par
6950         CATCH_TRY \{\par
6951             getMutableRegistryHub()\par
6952                     .registerTest(\par
6953                         makeTestCaseInfo(\par
6954                             extractClassName( classOrMethod ),\par
6955                             nameAndTags,\par
6956                             lineInfo),\par
6957                         CATCH_MOVE(invoker)\par
6958                     );\par
6959         \} CATCH_CATCH_ALL \{\par
6960             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
6961             getMutableRegistryHub().registerStartupException();\par
6962         \}\par
6963     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Clara::Detail::BasicResult< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >}
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BasicResult< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_detail_1_1_basic_result.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b BasicResult} ({\b BasicResult}< U > const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b type} () const -> {\b ResultType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b errorMessage} () const -> std::string const &\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > static auto {\b ok} (U &&{\b value}) -> {\b BasicResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static auto {\b ok} () -> {\b BasicResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static auto {\b logicError} (std::string &&message) -> {\b BasicResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static auto {\b runtimeError} (std::string &&message) -> {\b BasicResult}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enforceOk} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BasicResult} ({\b ResultType} {\b type}, std::string &&message)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Clara::Detail::ResultValueBase< void >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} &&)=default\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Clara::Detail::ResultBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ResultBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_errorMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultType} {\b m_type}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Clara::Detail::ResultBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultType} {\b m_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BasicResult\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:BasicResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> template<typename U > {\b Catch::Clara::Detail::BasicResult}< T >::BasicResult ({\b BasicResult}< U > const & other){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4393                                                                    :\par
4394                     ResultValueBase<T>( other.type() ),\par
4395                     m_errorMessage( other.errorMessage() ) \{\par
4396                     assert( type() != ResultType::Ok );\par
4397                 \}\par
}
}
{\xe \v BasicResult\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:BasicResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> {\b Catch::Clara::Detail::BasicResult}< T >::BasicResult ({\b ResultType} type, std::string && message){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4436                                                   :\par
4437                     ResultValueBase<T>( type ), m_errorMessage( CATCH_MOVE(message) ) \{\par
4438                     assert( m_type != ResultType::Ok );\par
4439                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v enforceOk\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:enforceOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> void {\b Catch::Clara::Detail::BasicResult}< T >::enforceOk () const{\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::ResultBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4422                                                 \{\par
4423 \par
4424                     {\cf20 // Errors shouldn't reach this point, but if they do}\par
4425                     {\cf20 // the actual error message will be in m_errorMessage}\par
4426                     assert( m_type != ResultType::LogicError );\par
4427                     assert( m_type != ResultType::RuntimeError );\par
4428                     {\cf19 if} ( m_type != ResultType::Ok )\par
4429                         std::abort();\par
4430                 \}\par
}
}
{\xe \v errorMessage\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:errorMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> auto {\b Catch::Clara::Detail::BasicResult}< T >::errorMessage () const -> std::string const& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4417                                                               \{\par
4418                     {\cf19 return} m_errorMessage;\par
4419                 \}\par
}
}
{\xe \v logicError\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:logicError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> static auto {\b Catch::Clara::Detail::BasicResult}< T >::logicError (std::string && message) -> {\b BasicResult} {\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4405                                    \{\par
4406                     {\cf19 return} \{ ResultType::LogicError, CATCH_MOVE(message) \};\par
4407                 \}\par
}
}
{\xe \v ok\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> static auto {\b Catch::Clara::Detail::BasicResult}< T >::ok () -> {\b BasicResult} {\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4403 \{ {\cf19 return} \{ ResultType::Ok \}; \}\par
}
}
{\xe \v ok\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> template<typename U > static auto {\b Catch::Clara::Detail::BasicResult}< T >::ok (U && value) -> {\b BasicResult} {\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4400                                                            \{\par
4401                     {\cf19 return} \{ ResultType::Ok, CATCH_FORWARD(value) \};\par
4402                 \}\par
}
}
{\xe \v operator bool\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> {\b Catch::Clara::Detail::BasicResult}< T >::operator bool () const{\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4413                                                \{\par
4414                     {\cf19 return} m_type == ResultType::Ok;\par
4415                 \}\par
}
}
{\xe \v runtimeError\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:runtimeError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> static auto {\b Catch::Clara::Detail::BasicResult}< T >::runtimeError (std::string && message) -> {\b BasicResult} {\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4409                                    \{\par
4410                     {\cf19 return} \{ ResultType::RuntimeError, CATCH_MOVE(message) \};\par
4411                 \}\par
}
}
{\xe \v type\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> auto {\b Catch::Clara::Detail::BasicResult}< T >::type () const -> {\b ResultType} {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4416 \{ {\cf19 return} m_type; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_errorMessage\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:m_errorMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> std::string {\b Catch::Clara::Detail::BasicResult}< T >::m_errorMessage{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_type\:Catch::Clara::Detail::BasicResult< T >}
{\xe \v Catch::Clara::Detail::BasicResult< T >\:m_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T  = void> {\b ResultType} Catch::Clara::Detail::ResultBase::m_type{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Benchmark\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Benchmark}
{\xe \v Catch::Benchmark::Benchmark}
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Benchmark} (std::string &&benchmarkName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class FUN > {\b Benchmark} (std::string &&benchmarkName, FUN &&func)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > {\b ExecutionPlan} {\b prepare} (const {\b IConfig} &cfg, {\b Environment} env) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock  = default_clock> void {\b run} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun , std::enable_if_t<!{\b Detail::is_related}< Fun, {\b Benchmark} >{\b ::value}, int >  = 0> {\b Benchmark} & {\b operator=} (Fun func)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Benchmark\:Catch::Benchmark::Benchmark}
{\xe \v Catch::Benchmark::Benchmark\:Benchmark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Benchmark::Benchmark (std::string && benchmarkName){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2099                 : name(CATCH_MOVE(benchmarkName)) \{\}\par
}
}
{\xe \v Benchmark\:Catch::Benchmark::Benchmark}
{\xe \v Catch::Benchmark::Benchmark\:Benchmark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class FUN > Catch::Benchmark::Benchmark::Benchmark (std::string && benchmarkName, FUN && func){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2103                 : fun(CATCH_MOVE(func)), name(CATCH_MOVE(benchmarkName)) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator bool\:Catch::Benchmark::Benchmark}
{\xe \v Catch::Benchmark::Benchmark\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Benchmark::operator bool (){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2168                                      \{\par
2169                 {\cf19 return} {\cf17 true};\par
2170             \}\par
}
}
{\xe \v operator=\:Catch::Benchmark::Benchmark}
{\xe \v Catch::Benchmark::Benchmark\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun , std::enable_if_t<!{\b Detail::is_related}< Fun, {\b Benchmark} >{\b ::value}, int >  = 0> {\b Benchmark} & Catch::Benchmark::Benchmark::operator= (Fun func){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2159                                                 \{\par
2160                 {\cf17 auto} {\cf17 const}* cfg = getCurrentContext().getConfig();\par
2161                 {\cf19 if} (!cfg->skipBenchmarks()) \{\par
2162                     fun = Detail::BenchmarkFunction(func);\par
2163                     run();\par
2164                 \}\par
2165                 {\cf19 return} *{\cf17 this};\par
2166             \}\par
}
}
{\xe \v prepare\:Catch::Benchmark::Benchmark}
{\xe \v Catch::Benchmark::Benchmark\:prepare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > {\b ExecutionPlan} Catch::Benchmark::Benchmark::prepare (const {\b IConfig} & cfg, {\b Environment} env) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2106                                                                              \{\par
2107                 {\cf17 auto} min_time = env.clock_resolution.mean * Detail::minimum_ticks;\par
2108                 {\cf17 auto} run_time = std::max(min_time, std::chrono::duration_cast<{\cf17 decltype}(min_time)>(cfg.benchmarkWarmupTime()));\par
2109                 {\cf17 auto}&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<IDuration>(run_time), 1, fun);\par
2110                 {\cf18 int} new_iters = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::ceil(min_time * test.iterations / test.elapsed));\par
2111                 {\cf19 return} \{ new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FDuration>(cfg.benchmarkWarmupTime()), Detail::warmup_iterations \};\par
2112             \}\par
}
}
{\xe \v run\:Catch::Benchmark::Benchmark}
{\xe \v Catch::Benchmark::Benchmark\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock  = default_clock> void Catch::Benchmark::Benchmark::run (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2115                        \{\par
2116                 {\cf17 static_assert}( Clock::is_steady,\par
2117                                {\cf22 "Benchmarking clock should be steady"} );\par
2118                 {\cf17 auto} {\cf17 const}* cfg = getCurrentContext().getConfig();\par
2119 \par
2120                 {\cf17 auto} env = Detail::measure_environment<Clock>();\par
2121 \par
2122                 getResultCapture().benchmarkPreparing(name);\par
2123                 CATCH_TRY\{\par
2124                     {\cf17 auto} plan = user_code([&] \{\par
2125                         {\cf19 return} prepare<Clock>(*cfg, env);\par
2126                     \});\par
2127 \par
2128                     BenchmarkInfo info \{\par
2129                         CATCH_MOVE(name),\par
2130                         plan.estimated_duration.count(),\par
2131                         plan.iterations_per_sample,\par
2132                         cfg->benchmarkSamples(),\par
2133                         cfg->benchmarkResamples(),\par
2134                         env.clock_resolution.mean.count(),\par
2135                         env.clock_cost.mean.count()\par
2136                     \};\par
2137 \par
2138                     getResultCapture().benchmarkStarting(info);\par
2139 \par
2140                     {\cf17 auto} samples = user_code([&] \{\par
2141                         {\cf19 return} plan.template run<Clock>(*cfg, env);\par
2142                     \});\par
2143 \par
2144                     {\cf17 auto} analysis = Detail::analyse(*cfg, samples.data(), samples.data() + samples.size());\par
2145                     BenchmarkStats<> stats\{ CATCH_MOVE(info), CATCH_MOVE(analysis.samples), analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance \};\par
2146                     getResultCapture().benchmarkEnded(stats);\par
2147                 \} CATCH_CATCH_ANON (TestFailureException {\cf17 const}&) \{\par
2148                     getResultCapture().benchmarkFailed({\cf22 "Benchmark failed due to failed assertion"}_sr);\par
2149                 \} CATCH_CATCH_ALL\{\par
2150                     getResultCapture().benchmarkFailed(translateActiveException());\par
2151                     {\cf20 // We let the exception go further up so that the}\par
2152                     {\cf20 // test case is marked as failed.}\par
2153                     std::rethrow_exception(std::current_exception());\par
2154                 \}\par
2155             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Detail::BenchmarkFunction\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction}
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BenchmarkFunction} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun , std::enable_if_t<!{\b is_related}< Fun, {\b BenchmarkFunction} >{\b ::value}, int >  = 0> {\b BenchmarkFunction} (Fun &&fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BenchmarkFunction} ({\b BenchmarkFunction} &&that) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BenchmarkFunction} ({\b BenchmarkFunction} const &that)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BenchmarkFunction} & {\b operator=} ({\b BenchmarkFunction} &&that) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BenchmarkFunction} & {\b operator=} ({\b BenchmarkFunction} const &that)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} ({\b Chronometer} meter) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We need to reinvent std::function because every piece of code that might add overhead in a measurement context needs to have consistent performance characteristics so that we can account for it in the measurement. Implementations of std::function with optimizations that aren't always applicable, like small buffer optimizations, are not uncommon. This is effectively an implementation of std::function without any such optimizations; it may be slow, but it is consistently slow. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BenchmarkFunction\:Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction\:BenchmarkFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Detail::BenchmarkFunction::BenchmarkFunction (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1623                     : f({\cf17 new} model<do_nothing>\{ \{\} \}) \{\}\par
}
}
{\xe \v BenchmarkFunction\:Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction\:BenchmarkFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun , std::enable_if_t<!{\b is_related}< Fun, {\b BenchmarkFunction} >{\b ::value}, int >  = 0> Catch::Benchmark::Detail::BenchmarkFunction::BenchmarkFunction (Fun && fun){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1628                     : f({\cf17 new} model<std::decay_t<Fun>>(CATCH_FORWARD(fun))) \{\}\par
}
}
{\xe \v BenchmarkFunction\:Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction\:BenchmarkFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Detail::BenchmarkFunction::BenchmarkFunction ({\b BenchmarkFunction} && that){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1630                                                                       :\par
1631                     f( CATCH_MOVE( that.f ) ) \{\}\par
}
}
{\xe \v BenchmarkFunction\:Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction\:BenchmarkFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Detail::BenchmarkFunction::BenchmarkFunction ({\b BenchmarkFunction} const & that){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1634                     : f(that.f->clone()) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator()\:Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Benchmark::Detail::BenchmarkFunction::operator() ({\b Chronometer} meter) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1647 \{ f->call(meter); \}\par
}
}
{\xe \v operator=\:Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BenchmarkFunction} & Catch::Benchmark::Detail::BenchmarkFunction::operator= ({\b BenchmarkFunction} && that){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1637                                                                \{\par
1638                     f = CATCH_MOVE( that.f );\par
1639                     {\cf19 return} *{\cf17 this};\par
1640                 \}\par
}
}
{\xe \v operator=\:Catch::Benchmark::Detail::BenchmarkFunction}
{\xe \v Catch::Benchmark::Detail::BenchmarkFunction\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BenchmarkFunction} & Catch::Benchmark::Detail::BenchmarkFunction::operator= ({\b BenchmarkFunction} const & that){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1642                                                                             \{\par
1643                     f = that.f->clone();\par
1644                     {\cf19 return} *{\cf17 this};\par
1645                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::BenchmarkInfo\par \pard\plain 
{\tc\tcl2 \v Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo}
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b estimatedDuration}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iterations}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b samples}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b resamples}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b clockResolution}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b clockCost}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v clockCost\:Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo\:clockCost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::BenchmarkInfo::clockCost}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clockResolution\:Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo\:clockResolution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::BenchmarkInfo::clockResolution}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v estimatedDuration\:Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo\:estimatedDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::BenchmarkInfo::estimatedDuration}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterations\:Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo\:iterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::BenchmarkInfo::iterations}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::BenchmarkInfo::name}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resamples\:Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo\:resamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::BenchmarkInfo::resamples}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v samples\:Catch::BenchmarkInfo}
{\xe \v Catch::BenchmarkInfo\:samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::BenchmarkInfo::samples}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::BenchmarkStats< Dummy >\par \pard\plain 
{\tc\tcl2 \v Catch::BenchmarkStats< Dummy >}
{\xe \v Catch::BenchmarkStats< Dummy >}
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BenchmarkInfo} {\b info}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Benchmark::FDuration} > {\b samples}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Benchmark::Estimate}< {\b Benchmark::FDuration} > {\b mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Benchmark::Estimate}< {\b Benchmark::FDuration} > {\b standardDeviation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Benchmark::OutlierClassification} {\b outliers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b outlierVariance}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v info\:Catch::BenchmarkStats< Dummy >}
{\xe \v Catch::BenchmarkStats< Dummy >\:info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Dummy > {\b BenchmarkInfo} {\b Catch::BenchmarkStats}< Dummy >::info}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mean\:Catch::BenchmarkStats< Dummy >}
{\xe \v Catch::BenchmarkStats< Dummy >\:mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Dummy > {\b Benchmark::Estimate}<{\b Benchmark::FDuration}> {\b Catch::BenchmarkStats}< Dummy >::mean}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outliers\:Catch::BenchmarkStats< Dummy >}
{\xe \v Catch::BenchmarkStats< Dummy >\:outliers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Dummy > {\b Benchmark::OutlierClassification} {\b Catch::BenchmarkStats}< Dummy >::outliers}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outlierVariance\:Catch::BenchmarkStats< Dummy >}
{\xe \v Catch::BenchmarkStats< Dummy >\:outlierVariance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Dummy > double {\b Catch::BenchmarkStats}< Dummy >::outlierVariance}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v samples\:Catch::BenchmarkStats< Dummy >}
{\xe \v Catch::BenchmarkStats< Dummy >\:samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Dummy > std::vector<{\b Benchmark::FDuration}> {\b Catch::BenchmarkStats}< Dummy >::samples}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v standardDeviation\:Catch::BenchmarkStats< Dummy >}
{\xe \v Catch::BenchmarkStats< Dummy >\:standardDeviation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Dummy > {\b Benchmark::Estimate}<{\b Benchmark::FDuration}> {\b Catch::BenchmarkStats}< Dummy >::standardDeviation}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::BinaryExpr< LhsT, RhsT >\par \pard\plain 
{\tc\tcl2 \v Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >}
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::BinaryExpr< LhsT, RhsT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_binary_expr.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b BinaryExpr} (bool comparisonResult, LhsT lhs, {\b StringRef} op, RhsT rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator&&} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator||} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator==} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator!=} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator>} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator<} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator>=} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator<=} (T) const -> {\b BinaryExpr}< LhsT, RhsT const & > const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b isBinaryExpression} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b getResult} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b ITransientExpression} (bool {\b isBinaryExpression}, bool result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} ({\b ITransientExpression} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} & {\b operator=} ({\b ITransientExpression} const &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ITransientExpression} ()=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BinaryExpr\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:BinaryExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > {\b Catch::BinaryExpr}< LhsT, RhsT >::BinaryExpr (bool comparisonResult, LhsT lhs, {\b StringRef} op, RhsT rhs){\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5331         :   ITransientExpression\{ {\cf17 true}, comparisonResult \},\par
5332             m_lhs( lhs ),\par
5333             m_op( op ),\par
5334             m_rhs( rhs )\par
5335         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator!=\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator!= (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5359                                                                             \{\par
5360             {\cf17 static_assert}(always_false<T>::value,\par
5361             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5362             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5363         \}\par
}
}
{\xe \v operator&&\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator&&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator&& (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5338                                                                             \{\par
5339             {\cf17 static_assert}(always_false<T>::value,\par
5340             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5341             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5342         \}\par
}
}
{\xe \v operator<\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator< (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5373                                                                            \{\par
5374             {\cf17 static_assert}(always_false<T>::value,\par
5375             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5376             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5377         \}\par
}
}
{\xe \v operator<=\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator<= (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5387                                                                             \{\par
5388             {\cf17 static_assert}(always_false<T>::value,\par
5389             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5390             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5391         \}\par
}
}
{\xe \v operator==\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator== (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5352                                                                             \{\par
5353             {\cf17 static_assert}(always_false<T>::value,\par
5354             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5355             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5356         \}\par
}
}
{\xe \v operator>\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator> (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5366                                                                            \{\par
5367             {\cf17 static_assert}(always_false<T>::value,\par
5368             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5369             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5370         \}\par
}
}
{\xe \v operator>=\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator>= (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5380                                                                             \{\par
5381             {\cf17 static_assert}(always_false<T>::value,\par
5382             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5383             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5384         \}\par
}
}
{\xe \v operator||\:Catch::BinaryExpr< LhsT, RhsT >}
{\xe \v Catch::BinaryExpr< LhsT, RhsT >\:operator||}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT , typename RhsT > template<typename T > auto {\b Catch::BinaryExpr}< LhsT, RhsT >::operator|| (T ) const -> {\b BinaryExpr}<LhsT, RhsT const&> const {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5345                                                                             \{\par
5346             {\cf17 static_assert}(always_false<T>::value,\par
5347             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5348             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5349         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Detail::bootstrap_analysis\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::bootstrap_analysis}
{\xe \v Catch::Benchmark::Detail::bootstrap_analysis}
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< double > {\b mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< double > {\b standard_deviation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b outlier_variance}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mean\:Catch::Benchmark::Detail::bootstrap_analysis}
{\xe \v Catch::Benchmark::Detail::bootstrap_analysis\:mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Estimate}<double> Catch::Benchmark::Detail::bootstrap_analysis::mean}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outlier_variance\:Catch::Benchmark::Detail::bootstrap_analysis}
{\xe \v Catch::Benchmark::Detail::bootstrap_analysis\:outlier_variance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Benchmark::Detail::bootstrap_analysis::outlier_variance}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v standard_deviation\:Catch::Benchmark::Detail::bootstrap_analysis}
{\xe \v Catch::Benchmark::Detail::bootstrap_analysis\:standard_deviation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Estimate}<double> Catch::Benchmark::Detail::bootstrap_analysis::standard_deviation}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::BoundFlagLambda< L >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundFlagLambda< L >}
{\xe \v Catch::Clara::Detail::BoundFlagLambda< L >}
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundFlagLambda< L >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_flag_lambda.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BoundFlagLambda} (L const &lambda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b setFlag} (bool flag) -> {\b ParserResult} override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundFlagRefBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFlag} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isContainer} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
L {\b m_lambda}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BoundFlagLambda\:Catch::Clara::Detail::BoundFlagLambda< L >}
{\xe \v Catch::Clara::Detail::BoundFlagLambda< L >\:BoundFlagLambda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > {\b Catch::Clara::Detail::BoundFlagLambda}< L >::BoundFlagLambda (L const & lambda){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4613                                                            :\par
4614                     m_lambda( lambda ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v setFlag\:Catch::Clara::Detail::BoundFlagLambda< L >}
{\xe \v Catch::Clara::Detail::BoundFlagLambda< L >\:setFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > auto {\b Catch::Clara::Detail::BoundFlagLambda}< L >::setFlag (bool flag) -> {\b ParserResult}{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::BoundFlagRefBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4616                                                                    \{\par
4617                     {\cf19 return} LambdaInvoker<{\cf17 typename} UnaryLambdaTraits<\par
4618                         L>::ReturnType>::invoke( m_lambda, flag );\par
4619                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_lambda\:Catch::Clara::Detail::BoundFlagLambda< L >}
{\xe \v Catch::Clara::Detail::BoundFlagLambda< L >\:m_lambda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > L {\b Catch::Clara::Detail::BoundFlagLambda}< L >::m_lambda}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::BoundFlagRef\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundFlagRef}
{\xe \v Catch::Clara::Detail::BoundFlagRef}
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundFlagRef:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_flag_ref.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BoundFlagRef} (bool &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b setFlag} (bool flag) override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundFlagRefBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFlag} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isContainer} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool & {\b m_ref}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BoundFlagRef\:Catch::Clara::Detail::BoundFlagRef}
{\xe \v Catch::Clara::Detail::BoundFlagRef\:BoundFlagRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::BoundFlagRef::BoundFlagRef (bool & ref){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4546 : m_ref( ref ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v setFlag\:Catch::Clara::Detail::BoundFlagRef}
{\xe \v Catch::Clara::Detail::BoundFlagRef\:setFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ParserResult} Catch::Clara::Detail::BoundFlagRef::setFlag (bool flag){\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::BoundFlagRefBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2751                                                           \{\par
2752                 m_ref = flag;\par
2753                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2754             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_ref\:Catch::Clara::Detail::BoundFlagRef}
{\xe \v Catch::Clara::Detail::BoundFlagRef\:m_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool& Catch::Clara::Detail::BoundFlagRef::m_ref}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::BoundFlagRefBase\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundFlagRefBase}
{\xe \v Catch::Clara::Detail::BoundFlagRefBase}
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundFlagRefBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_flag_ref_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b setFlag} (bool flag) -> {\b ParserResult}=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFlag} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isContainer} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v isFlag\:Catch::Clara::Detail::BoundFlagRefBase}
{\xe \v Catch::Clara::Detail::BoundFlagRefBase\:isFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Clara::Detail::BoundFlagRefBase::isFlag () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b Catch::Clara::Detail::BoundRef} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2762 \{ {\cf19 return} {\cf17 true}; \}\par
}
}
{\xe \v setFlag\:Catch::Clara::Detail::BoundFlagRefBase}
{\xe \v Catch::Clara::Detail::BoundFlagRefBase\:setFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual auto Catch::Clara::Detail::BoundFlagRefBase::setFlag (bool flag) ->  {\b ParserResult}{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Clara::Detail::BoundFlagLambda< L >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDL \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Clara::Detail::BoundFlagRef} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::BoundLambda< L >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundLambda< L >}
{\xe \v Catch::Clara::Detail::BoundLambda< L >}
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundLambda< L >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_lambda.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BoundLambda} (L const &lambda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b setValue} (std::string const &arg) -> {\b ParserResult} override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundValueRefBase}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isContainer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFlag} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
L {\b m_lambda}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BoundLambda\:Catch::Clara::Detail::BoundLambda< L >}
{\xe \v Catch::Clara::Detail::BoundLambda< L >\:BoundLambda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > {\b Catch::Clara::Detail::BoundLambda}< L >::BoundLambda (L const & lambda){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4588 : m_lambda( lambda ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v setValue\:Catch::Clara::Detail::BoundLambda< L >}
{\xe \v Catch::Clara::Detail::BoundLambda< L >\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > auto {\b Catch::Clara::Detail::BoundLambda}< L >::setValue (std::string const & arg) -> {\b ParserResult}{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::BoundValueRefBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4591                                              \{\par
4592                     {\cf19 return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>(\par
4593                         m_lambda, arg );\par
4594                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_lambda\:Catch::Clara::Detail::BoundLambda< L >}
{\xe \v Catch::Clara::Detail::BoundLambda< L >\:m_lambda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > L {\b Catch::Clara::Detail::BoundLambda}< L >::m_lambda}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::BoundManyLambda< L >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundManyLambda< L >}
{\xe \v Catch::Clara::Detail::BoundManyLambda< L >}
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundManyLambda< L >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_many_lambda.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BoundManyLambda} (L const &lambda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isContainer} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundLambda< L >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BoundLambda} (L const &lambda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b setValue} (std::string const &arg) -> {\b ParserResult} override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundValueRefBase}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFlag} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundLambda< L >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
L {\b m_lambda}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BoundManyLambda\:Catch::Clara::Detail::BoundManyLambda< L >}
{\xe \v Catch::Clara::Detail::BoundManyLambda< L >\:BoundManyLambda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > {\b Catch::Clara::Detail::BoundManyLambda}< L >::BoundManyLambda (L const & lambda){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4598 : BoundLambda<L>( lambda ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v isContainer\:Catch::Clara::Detail::BoundManyLambda< L >}
{\xe \v Catch::Clara::Detail::BoundManyLambda< L >\:isContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L > bool {\b Catch::Clara::Detail::BoundManyLambda}< L >::isContainer () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b Catch::Clara::Detail::BoundRef} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACED \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4599 \{ {\cf19 return} {\cf17 true}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::BoundRef\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundRef}
{\xe \v Catch::Clara::Detail::BoundRef}
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundRef:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_ref.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isContainer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFlag} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~BoundRef\:Catch::Clara::Detail::BoundRef}
{\xe \v Catch::Clara::Detail::BoundRef\:~BoundRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::Clara::Detail::BoundRef::~BoundRef (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v isContainer\:Catch::Clara::Detail::BoundRef}
{\xe \v Catch::Clara::Detail::BoundRef\:isContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Clara::Detail::BoundRef::isContainer () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b Catch::Clara::Detail::BoundManyLambda< L >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEC \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Clara::Detail::BoundValueRef< std::vector< T > >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2758 \{ {\cf19 return} {\cf17 false}; \}\par
}
}
{\xe \v isFlag\:Catch::Clara::Detail::BoundRef}
{\xe \v Catch::Clara::Detail::BoundRef\:isFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Clara::Detail::BoundRef::isFlag () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b Catch::Clara::Detail::BoundFlagRefBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2760 \{ {\cf19 return} {\cf17 false}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::BoundValueRef< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundValueRef< T >}
{\xe \v Catch::Clara::Detail::BoundValueRef< T >}
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundValueRef< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_value_ref.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BoundValueRef} (T &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b setValue} (std::string const &arg) override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundValueRefBase}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isContainer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFlag} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b m_ref}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BoundValueRef\:Catch::Clara::Detail::BoundValueRef< T >}
{\xe \v Catch::Clara::Detail::BoundValueRef< T >\:BoundValueRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::BoundValueRef}< T >::BoundValueRef (T & ref){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4518 : m_ref( ref ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v setValue\:Catch::Clara::Detail::BoundValueRef< T >}
{\xe \v Catch::Clara::Detail::BoundValueRef< T >\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b ParserResult} {\b Catch::Clara::Detail::BoundValueRef}< T >::setValue (std::string const & arg){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::BoundValueRefBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4520                                                                        \{\par
4521                     {\cf19 return} convertInto( arg, m_ref );\par
4522                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_ref\:Catch::Clara::Detail::BoundValueRef< T >}
{\xe \v Catch::Clara::Detail::BoundValueRef< T >\:m_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T& {\b Catch::Clara::Detail::BoundValueRef}< T >::m_ref}}
\par
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::BoundValueRef< std::vector< T > >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundValueRef< std::vector< T > >}
{\xe \v Catch::Clara::Detail::BoundValueRef< std::vector< T > >}
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundValueRef< std::vector< T > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_value_ref_3_01std_1_1vector_3_01_t_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BoundValueRef} (std::vector< T > &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isContainer} () const -> bool override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b setValue} (std::string const &arg) -> {\b ParserResult} override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundValueRefBase}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFlag} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< T > & {\b m_ref}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v BoundValueRef\:Catch::Clara::Detail::BoundValueRef< std::vector< T > >}
{\xe \v Catch::Clara::Detail::BoundValueRef< std::vector< T > >\:BoundValueRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::BoundValueRef}< std::vector< T > >::BoundValueRef (std::vector< T > & ref){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4529 : m_ref( ref ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v isContainer\:Catch::Clara::Detail::BoundValueRef< std::vector< T > >}
{\xe \v Catch::Clara::Detail::BoundValueRef< std::vector< T > >\:isContainer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto {\b Catch::Clara::Detail::BoundValueRef}< std::vector< T > >::isContainer () const -> bool{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b Catch::Clara::Detail::BoundRef} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACED \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4531 \{ {\cf19 return} {\cf17 true}; \}\par
}
}
{\xe \v setValue\:Catch::Clara::Detail::BoundValueRef< std::vector< T > >}
{\xe \v Catch::Clara::Detail::BoundValueRef< std::vector< T > >\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto {\b Catch::Clara::Detail::BoundValueRef}< std::vector< T > >::setValue (std::string const & arg) -> {\b ParserResult}{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::BoundValueRefBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4534                                              \{\par
4535                     T temp;\par
4536                     {\cf17 auto} result = convertInto( arg, temp );\par
4537                     {\cf19 if} ( result )\par
4538                         m_ref.push_back( temp );\par
4539                     {\cf19 return} result;\par
4540                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_ref\:Catch::Clara::Detail::BoundValueRef< std::vector< T > >}
{\xe \v Catch::Clara::Detail::BoundValueRef< std::vector< T > >\:m_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector<T>& {\b Catch::Clara::Detail::BoundValueRef}< std::vector< T > >::m_ref}}
\par
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::BoundValueRefBase\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::BoundValueRefBase}
{\xe \v Catch::Clara::Detail::BoundValueRefBase}
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::BoundValueRefBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1_bound_value_ref_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b setValue} (std::string const &arg) -> {\b ParserResult}=0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~BoundRef} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isContainer} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b isFlag} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v setValue\:Catch::Clara::Detail::BoundValueRefBase}
{\xe \v Catch::Clara::Detail::BoundValueRefBase\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual auto Catch::Clara::Detail::BoundValueRefBase::setValue (std::string const & arg) ->  {\b ParserResult}{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Clara::Detail::BoundLambda< L >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Clara::Detail::BoundValueRef< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEJ \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Clara::Detail::BoundValueRef< std::vector< T > >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::capture_by_value< T >\par \pard\plain 
{\tc\tcl2 \v Catch::capture_by_value< T >}
{\xe \v Catch::capture_by_value< T >}
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::capture_by_value< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1capture__by__value.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Capturer\par \pard\plain 
{\tc\tcl2 \v Catch::Capturer}
{\xe \v Catch::Capturer}
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Capturer} ({\b StringRef} macroName, {\b SourceLineInfo} const &lineInfo, {\b ResultWas::OfType} resultType, {\b StringRef} names)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Capturer} ({\b Capturer} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Capturer} & {\b operator=} ({\b Capturer} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Capturer} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b captureValue} (size_t index, std::string const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b captureValues} (size_t index, T const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Ts> void {\b captureValues} (size_t index, T const &{\b value}, Ts const &... values)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Capturer\:Catch::Capturer}
{\xe \v Catch::Capturer\:Capturer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Capturer::Capturer ({\b StringRef} macroName, {\b SourceLineInfo} const & lineInfo, {\b ResultWas::OfType} resultType, {\b StringRef} names)}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 992                                          :\par
993         m_resultCapture( getResultCapture() ) \{\par
994         {\cf17 auto} trimmed = [&] ({\cf18 size_t} start, {\cf18 size_t} end) \{\par
995             {\cf19 while} (names[start] == {\cf23 ','} || isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(names[start]))) \{\par
996                 ++start;\par
997             \}\par
998             {\cf19 while} (names[end] == {\cf23 ','} || isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(names[end]))) \{\par
999                 --end;\par
1000             \}\par
1001             {\cf19 return} names.substr(start, end - start + 1);\par
1002         \};\par
1003         {\cf17 auto} skipq = [&] ({\cf18 size_t} start, {\cf18 char} quote) \{\par
1004             {\cf19 for} ({\cf17 auto} i = start + 1; i < names.size() ; ++i) \{\par
1005                 {\cf19 if} (names[i] == quote)\par
1006                     {\cf19 return} i;\par
1007                 {\cf19 if} (names[i] == {\cf23 '\\\\'})\par
1008                     ++i;\par
1009             \}\par
1010             CATCH_INTERNAL_ERROR({\cf22 "CAPTURE parsing encountered unmatched quote"});\par
1011         \};\par
1012 \par
1013         {\cf18 size_t} start = 0;\par
1014         std::stack<char> openings;\par
1015         {\cf19 for} ({\cf18 size_t} pos = 0; pos < names.size(); ++pos) \{\par
1016             {\cf18 char} c = names[pos];\par
1017             {\cf19 switch} (c) \{\par
1018             {\cf19 case} {\cf23 '['}:\par
1019             {\cf19 case} {\cf23 '\{'}:\par
1020             {\cf19 case} {\cf23 '('}:\par
1021             {\cf20 // It is basically impossible to disambiguate between}\par
1022             {\cf20 // comparison and start of template args in this context}\par
1023 {\cf20 //            case '<':}\par
1024                 openings.push(c);\par
1025                 {\cf19 break};\par
1026             {\cf19 case} {\cf23 ']'}:\par
1027             {\cf19 case} {\cf23 '\}'}:\par
1028             {\cf19 case} {\cf23 ')'}:\par
1029 {\cf20 //           case '>':}\par
1030                 openings.pop();\par
1031                 {\cf19 break};\par
1032             {\cf19 case} {\cf23 '"'}:\par
1033             {\cf19 case} {\cf23 '\\''}:\par
1034                 pos = skipq(pos, c);\par
1035                 {\cf19 break};\par
1036             {\cf19 case} {\cf23 ','}:\par
1037                 {\cf19 if} (start != pos && openings.empty()) \{\par
1038                     m_messages.emplace_back(macroName, lineInfo, resultType);\par
1039                     m_messages.back().message = {\cf17 static_cast<}std::string{\cf17 >}(trimmed(start, pos));\par
1040                     m_messages.back().message += {\cf22 " := "};\par
1041                     start = pos;\par
1042                 \}\par
1043             {\cf19 default}:; {\cf20 // noop}\par
1044             \}\par
1045         \}\par
1046         assert(openings.empty() && {\cf22 "Mismatched openings"});\par
1047         m_messages.emplace_back(macroName, lineInfo, resultType);\par
1048         m_messages.back().message = {\cf17 static_cast<}std::string{\cf17 >}(trimmed(start, names.size() - 1));\par
1049         m_messages.back().message += {\cf22 " := "};\par
1050     \}\par
}
}
{\xe \v Capturer\:Catch::Capturer}
{\xe \v Catch::Capturer\:Capturer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Capturer::Capturer ({\b Capturer} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~Capturer\:Catch::Capturer}
{\xe \v Catch::Capturer\:~Capturer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Capturer::~Capturer ()}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1051                         \{\par
1052         {\cf19 if} ( !uncaught_exceptions() )\{\par
1053             assert( m_captured == m_messages.size() );\par
1054             {\cf19 for}( {\cf18 size_t} i = 0; i < m_captured; ++i  )\par
1055                 m_resultCapture.popScopedMessage( m_messages[i] );\par
1056         \}\par
1057     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v captureValue\:Catch::Capturer}
{\xe \v Catch::Capturer\:captureValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Capturer::captureValue (size_t index, std::string const & value)}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1059                                                                       \{\par
1060         assert( index < m_messages.size() );\par
1061         m_messages[index].message += value;\par
1062         m_resultCapture.pushScopedMessage( m_messages[index] );\par
1063         m_captured++;\par
1064     \}\par
}
}
{\xe \v captureValues\:Catch::Capturer}
{\xe \v Catch::Capturer\:captureValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void Catch::Capturer::captureValues (size_t index, T const & value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4014                                                            \{\par
4015             captureValue( index, Catch::Detail::stringify( value ) );\par
4016         \}\par
}
}
{\xe \v captureValues\:Catch::Capturer}
{\xe \v Catch::Capturer\:captureValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename... Ts> void Catch::Capturer::captureValues (size_t index, T const & value, Ts const &... values){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4019                                                                                 \{\par
4020             captureValue( index, Catch::Detail::stringify(value) );\par
4021             captureValues( index+1, values... );\par
4022         \}\par
}
}
{\xe \v operator=\:Catch::Capturer}
{\xe \v Catch::Capturer\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Capturer} & Catch::Capturer::operator= ({\b Capturer} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch_global_namespace_dummy\par \pard\plain 
{\tc\tcl2 \v Catch_global_namespace_dummy}
{\xe \v Catch_global_namespace_dummy}
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Chronometer\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Chronometer}
{\xe \v Catch::Benchmark::Chronometer}
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun > void {\b measure} (Fun &&fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b runs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Chronometer} ({\b Detail::ChronometerConcept} &meter, int repeats_)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Chronometer\:Catch::Benchmark::Chronometer}
{\xe \v Catch::Benchmark::Chronometer\:Chronometer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Chronometer::Chronometer ({\b Detail::ChronometerConcept} & meter, int repeats_){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1541                 : impl(&meter)\par
1542                 , repeats(repeats_) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v measure\:Catch::Benchmark::Chronometer}
{\xe \v Catch::Benchmark::Chronometer\:measure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun > void Catch::Benchmark::Chronometer::measure (Fun && fun){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1536 \{ measure(CATCH_FORWARD(fun), is_callable<Fun({\cf18 int})>()); \}\par
}
}
{\xe \v runs\:Catch::Benchmark::Chronometer}
{\xe \v Catch::Benchmark::Chronometer\:runs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::Chronometer::runs () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1538 \{ {\cf19 return} repeats; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Detail::ChronometerConcept\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::ChronometerConcept}
{\xe \v Catch::Benchmark::Detail::ChronometerConcept}
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Benchmark::Detail::ChronometerConcept:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_benchmark_1_1_detail_1_1_chronometer_concept.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b start} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b finish} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ChronometerConcept} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChronometerConcept} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChronometerConcept} ({\b ChronometerConcept} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChronometerConcept} & {\b operator=} ({\b ChronometerConcept} const &)=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~ChronometerConcept\:Catch::Benchmark::Detail::ChronometerConcept}
{\xe \v Catch::Benchmark::Detail::ChronometerConcept\:~ChronometerConcept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::Benchmark::Detail::ChronometerConcept::~ChronometerConcept (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ChronometerConcept\:Catch::Benchmark::Detail::ChronometerConcept}
{\xe \v Catch::Benchmark::Detail::ChronometerConcept\:ChronometerConcept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Detail::ChronometerConcept::ChronometerConcept (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ChronometerConcept\:Catch::Benchmark::Detail::ChronometerConcept}
{\xe \v Catch::Benchmark::Detail::ChronometerConcept\:ChronometerConcept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Benchmark::Detail::ChronometerConcept::ChronometerConcept ({\b ChronometerConcept} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v finish\:Catch::Benchmark::Detail::ChronometerConcept}
{\xe \v Catch::Benchmark::Detail::ChronometerConcept\:finish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::Benchmark::Detail::ChronometerConcept::finish (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Benchmark::Detail::ChronometerModel< Clock >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABZD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:Catch::Benchmark::Detail::ChronometerConcept}
{\xe \v Catch::Benchmark::Detail::ChronometerConcept\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ChronometerConcept} & Catch::Benchmark::Detail::ChronometerConcept::operator= ({\b ChronometerConcept} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v start\:Catch::Benchmark::Detail::ChronometerConcept}
{\xe \v Catch::Benchmark::Detail::ChronometerConcept\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::Benchmark::Detail::ChronometerConcept::start (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Benchmark::Detail::ChronometerModel< Clock >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABZG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Detail::ChronometerModel< Clock >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::ChronometerModel< Clock >}
{\xe \v Catch::Benchmark::Detail::ChronometerModel< Clock >}
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Benchmark::Detail::ChronometerModel< Clock >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_benchmark_1_1_detail_1_1_chronometer_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b start} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b finish} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDuration} {\b elapsed} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Benchmark::Detail::ChronometerConcept}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ChronometerConcept} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChronometerConcept} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChronometerConcept} ({\b ChronometerConcept} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChronometerConcept} & {\b operator=} ({\b ChronometerConcept} const &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimePoint}< Clock > {\b started}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TimePoint}< Clock > {\b finished}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v elapsed\:Catch::Benchmark::Detail::ChronometerModel< Clock >}
{\xe \v Catch::Benchmark::Detail::ChronometerModel< Clock >\:elapsed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > {\b IDuration} {\b Catch::Benchmark::Detail::ChronometerModel}< Clock >::elapsed () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1523                                           \{\par
1524                     {\cf19 return} std::chrono::duration_cast<std::chrono::nanoseconds>(\par
1525                         finished - started );\par
1526                 \}\par
}
}
{\xe \v finish\:Catch::Benchmark::Detail::ChronometerModel< Clock >}
{\xe \v Catch::Benchmark::Detail::ChronometerModel< Clock >\:finish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > void {\b Catch::Benchmark::Detail::ChronometerModel}< Clock >::finish (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Benchmark::Detail::ChronometerConcept} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABZC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1521 \{ finished = Clock::now(); \}\par
}
}
{\xe \v start\:Catch::Benchmark::Detail::ChronometerModel< Clock >}
{\xe \v Catch::Benchmark::Detail::ChronometerModel< Clock >\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > void {\b Catch::Benchmark::Detail::ChronometerModel}< Clock >::start (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Benchmark::Detail::ChronometerConcept} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABZF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1520 \{ started = Clock::now(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v finished\:Catch::Benchmark::Detail::ChronometerModel< Clock >}
{\xe \v Catch::Benchmark::Detail::ChronometerModel< Clock >\:finished}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > {\b TimePoint}<Clock> {\b Catch::Benchmark::Detail::ChronometerModel}< Clock >::finished}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v started\:Catch::Benchmark::Detail::ChronometerModel< Clock >}
{\xe \v Catch::Benchmark::Detail::ChronometerModel< Clock >\:started}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > {\b TimePoint}<Clock> {\b Catch::Benchmark::Detail::ChronometerModel}< Clock >::started}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::ChunkGenerator< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::ChunkGenerator< T >}
{\xe \v Catch::Generators::ChunkGenerator< T >}
{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::ChunkGenerator< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_chunk_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChunkGenerator} (size_t size, {\b GeneratorWrapper}< T > generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< T > const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< std::vector< T > >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< std::vector< T > >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ChunkGenerator\:Catch::Generators::ChunkGenerator< T >}
{\xe \v Catch::Generators::ChunkGenerator< T >\:ChunkGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::ChunkGenerator}< T >::ChunkGenerator (size_t size, {\b GeneratorWrapper}< T > generator){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7830                                                                    :\par
7831             m_chunk_size(size), m_generator(CATCH_MOVE(generator))\par
7832         \{\par
7833             m_chunk.reserve(m_chunk_size);\par
7834             {\cf19 if} (m_chunk_size != 0) \{\par
7835                 m_chunk.push_back(m_generator.get());\par
7836                 {\cf19 for} ({\cf18 size_t} i = 1; i < m_chunk_size; ++i) \{\par
7837                     {\cf19 if} (!m_generator.next()) \{\par
7838                         Detail::throw_generator_exception({\cf22 "Not enough values to initialize the first chunk"});\par
7839                     \}\par
7840                     m_chunk.push_back(m_generator.get());\par
7841                 \}\par
7842             \}\par
7843         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::ChunkGenerator< T >}
{\xe \v Catch::Generators::ChunkGenerator< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::vector< T > const  & {\b Catch::Generators::ChunkGenerator}< T >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< std::vector< T > >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7844                                                  \{\par
7845             {\cf19 return} m_chunk;\par
7846         \}\par
}
}
{\xe \v next\:Catch::Generators::ChunkGenerator< T >}
{\xe \v Catch::Generators::ChunkGenerator< T >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Generators::ChunkGenerator}< T >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7847                              \{\par
7848             m_chunk.clear();\par
7849             {\cf19 for} ({\cf18 size_t} idx = 0; idx < m_chunk_size; ++idx) \{\par
7850                 {\cf19 if} (!m_generator.next()) \{\par
7851                     {\cf19 return} {\cf17 false};\par
7852                 \}\par
7853                 m_chunk.push_back(m_generator.get());\par
7854             \}\par
7855             {\cf19 return} {\cf17 true};\par
7856         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ColumnInfo\par \pard\plain 
{\tc\tcl2 \v Catch::ColumnInfo}
{\xe \v Catch::ColumnInfo}
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b width}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Justification} {\b justification}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v justification\:Catch::ColumnInfo}
{\xe \v Catch::ColumnInfo\:justification}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Justification} Catch::ColumnInfo::justification}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::ColumnInfo}
{\xe \v Catch::ColumnInfo\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::ColumnInfo::name}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v width\:Catch::ColumnInfo}
{\xe \v Catch::ColumnInfo\:width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::ColumnInfo::width}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Detail::CompleteInvoker< Result >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::CompleteInvoker< Result >}
{\xe \v Catch::Benchmark::Detail::CompleteInvoker< Result >}
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun , typename... Args> static Result {\b invoke} (Fun &&fun, Args &&... args)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::Benchmark::Detail::CompleteInvoker< Result >}
{\xe \v Catch::Benchmark::Detail::CompleteInvoker< Result >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Result > template<typename Fun , typename... Args> static Result {\b Catch::Benchmark::Detail::CompleteInvoker}< Result >::invoke (Fun && fun, Args &&... args){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1723                                                                 \{\par
1724                     {\cf19 return} CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);\par
1725                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Detail::CompleteInvoker< void >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::CompleteInvoker< void >}
{\xe \v Catch::Benchmark::Detail::CompleteInvoker< void >}
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun , typename... Args> static {\b CompleteType_t}< void > {\b invoke} (Fun &&fun, Args &&... args)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::Benchmark::Detail::CompleteInvoker< void >}
{\xe \v Catch::Benchmark::Detail::CompleteInvoker< void >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun , typename... Args> static {\b CompleteType_t}< void > {\b Catch::Benchmark::Detail::CompleteInvoker}< void >::invoke (Fun && fun, Args &&... args){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1730                                                                               \{\par
1731                     CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);\par
1732                     {\cf19 return} \{\};\par
1733                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Detail::CompleteType< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::CompleteType< T >}
{\xe \v Catch::Benchmark::Detail::CompleteType< T >}
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v type\:Catch::Benchmark::Detail::CompleteType< T >}
{\xe \v Catch::Benchmark::Detail::CompleteType< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b Catch::Benchmark::Detail::CompleteType}< T >::type = T}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Detail::CompleteType< void >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::CompleteType< void >}
{\xe \v Catch::Benchmark::Detail::CompleteType< void >}
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Clara::Detail::ComposableParserImpl< DerivedT >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::ComposableParserImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ComposableParserImpl< DerivedT >}
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::ComposableParserImpl< DerivedT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_detail_1_1_composable_parser_impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator|} (T const &other) const -> {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Parser} {\b operator|} (T const &other) const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ParserBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b validate} () const -> {\b Result}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b parse} (std::string const &exeName, {\b TokenStream} tokens) const -> {\b InternalParseResult}=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b cardinality} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternalParseResult} {\b parse} ({\b Args} const &args) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator|\:Catch::Clara::Detail::ComposableParserImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ComposableParserImpl< DerivedT >\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > template<typename T > {\b Parser} {\b Catch::Clara::Detail::ComposableParserImpl}< DerivedT >::operator| (T const & other) const}}
\par
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4889                                                                               \{\par
4890                 {\cf19 return} Parser() | {\cf17 static_cast<}DerivedT const&{\cf17 >}(*this) | other;\par
4891             \}\par
}
}
{\xe \v operator|\:Catch::Clara::Detail::ComposableParserImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ComposableParserImpl< DerivedT >\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > template<typename T > auto {\b Catch::Clara::Detail::ComposableParserImpl}< DerivedT >::operator| (T const & other) const ->  {\b Parser}}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Config\par \pard\plain 
{\tc\tcl2 \v Catch::Config}
{\xe \v Catch::Config}
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Config:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_config.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Config} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Config} ({\b ConfigData} const &data)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Config} () override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listTests} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listTags} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listReporters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listListeners} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b ReporterSpec} > const & {\b getReporterSpecs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b ProcessedReporterSpec} > const & {\b getProcessedReporterSpecs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > const & {\b getTestsOrTags} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > const & {\b getSectionsToRun} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestSpec} const & {\b testSpec} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasTestFilters} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b showHelp} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allowThrows} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b name} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b includeSuccessfulResults} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b warnAboutMissingAssertions} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b warnAboutUnmatchedTestSpecs} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b zeroTestsCountAsSuccess} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ShowDurations} {\b showDurations} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minDuration} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestRunOrder} {\b runOrder} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rngSeed} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b shardCount} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b shardIndex} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColourMode} {\b defaultColourMode} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldDebugBreak} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b abortAfter} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b showInvisibles} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Verbosity} {\b verbosity} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b skipBenchmarks} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b benchmarkNoAnalysis} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b benchmarkSamples} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b benchmarkConfidenceInterval} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b benchmarkResamples} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::chrono::milliseconds {\b benchmarkWarmupTime} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::IConfig}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IConfig} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Config\:Catch::Config}
{\xe \v Catch::Config\:Config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Config::Config (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Config\:Catch::Config}
{\xe \v Catch::Config\:Config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Config::Config ({\b ConfigData} const & data)}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 795                                           :\par
796         m_data( data ) \{\par
797         {\cf20 // We need to trim filter specs to avoid trouble with superfluous}\par
798         {\cf20 // whitespace (esp. important for bdd macros, as those are manually}\par
799         {\cf20 // aligned with whitespace).}\par
800 \par
801         {\cf19 for} ({\cf17 auto}& elem : m_data.testsOrTags) \{\par
802             elem = trim(elem);\par
803         \}\par
804         {\cf19 for} ({\cf17 auto}& elem : m_data.sectionsToRun) \{\par
805             elem = trim(elem);\par
806         \}\par
807 \par
808         {\cf20 // Insert the default reporter if user hasn't asked for a specific one}\par
809         {\cf19 if} ( m_data.reporterSpecifications.empty() ) \{\par
810 {\cf21 #if defined( CATCH_CONFIG_DEFAULT_REPORTER )}\par
811             {\cf17 const} {\cf17 auto} default_spec = CATCH_CONFIG_DEFAULT_REPORTER;\par
812 {\cf21 #else}\par
813             {\cf17 const} {\cf17 auto} default_spec = {\cf22 "console"};\par
814 {\cf21 #endif}\par
815             {\cf17 auto} parsed = parseReporterSpec(default_spec);\par
816             CATCH_ENFORCE( parsed,\par
817                            {\cf22 "Cannot parse the provided default reporter spec: '"}\par
818                                << default_spec << {\cf23 '\\''} );\par
819             m_data.reporterSpecifications.push_back( std::move( *parsed ) );\par
820         \}\par
821 \par
822         {\cf19 if} ( enableBazelEnvSupport() ) \{\par
823             readBazelEnvVars();\par
824         \}\par
825 \par
826         {\cf20 // Bazel support can modify the test specs, so parsing has to happen}\par
827         {\cf20 // after reading Bazel env vars.}\par
828         TestSpecParser parser( ITagAliasRegistry::get() );\par
829         {\cf19 if} ( !m_data.testsOrTags.empty() ) \{\par
830             m_hasTestFilters = {\cf17 true};\par
831             {\cf19 for} ( {\cf17 auto} {\cf17 const}& testOrTags : m_data.testsOrTags ) \{\par
832                 parser.parse( testOrTags );\par
833             \}\par
834         \}\par
835         m_testSpec = parser.testSpec();\par
836 \par
837 \par
838         {\cf20 // We now fixup the reporter specs to handle default output spec,}\par
839         {\cf20 // default colour spec, etc}\par
840         {\cf18 bool} defaultOutputUsed = {\cf17 false};\par
841         {\cf19 for} ( {\cf17 auto} {\cf17 const}& reporterSpec : m_data.reporterSpecifications ) \{\par
842             {\cf20 // We do the default-output check separately, while always}\par
843             {\cf20 // using the default output below to make the code simpler}\par
844             {\cf20 // and avoid superfluous copies.}\par
845             {\cf19 if} ( reporterSpec.outputFile().none() ) \{\par
846                 CATCH_ENFORCE( !defaultOutputUsed,\par
847                                {\cf22 "Internal error: cannot use default output for "}\par
848                                {\cf22 "multiple reporters"} );\par
849                 defaultOutputUsed = {\cf17 true};\par
850             \}\par
851 \par
852             m_processedReporterSpecs.push_back( ProcessedReporterSpec\{\par
853                 reporterSpec.name(),\par
854                 reporterSpec.outputFile() ? *reporterSpec.outputFile()\par
855                                           : data.defaultOutputFilename,\par
856                 reporterSpec.colourMode().valueOr( data.defaultColourMode ),\par
857                 reporterSpec.customOptions() \} );\par
858         \}\par
859     \}\par
}
}
{\xe \v ~Config\:Catch::Config}
{\xe \v Catch::Config\:~Config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Config::~Config (){\f2 [override]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v abortAfter\:Catch::Config}
{\xe \v Catch::Config\:abortAfter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Config::abortAfter () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 905 \{ {\cf19 return} m_data.abortAfter; \}\par
}
}
{\xe \v allowThrows\:Catch::Config}
{\xe \v Catch::Config\:allowThrows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::allowThrows () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 887 \{ {\cf19 return} !m_data.noThrow; \}\par
}
}
{\xe \v benchmarkConfidenceInterval\:Catch::Config}
{\xe \v Catch::Config\:benchmarkConfidenceInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Config::benchmarkConfidenceInterval () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 912 \{ {\cf19 return} m_data.benchmarkConfidenceInterval; \}\par
}
}
{\xe \v benchmarkNoAnalysis\:Catch::Config}
{\xe \v Catch::Config\:benchmarkNoAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::benchmarkNoAnalysis () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 910 \{ {\cf19 return} m_data.benchmarkNoAnalysis; \}\par
}
}
{\xe \v benchmarkResamples\:Catch::Config}
{\xe \v Catch::Config\:benchmarkResamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::Config::benchmarkResamples () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 913 \{ {\cf19 return} m_data.benchmarkResamples; \}\par
}
}
{\xe \v benchmarkSamples\:Catch::Config}
{\xe \v Catch::Config\:benchmarkSamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::Config::benchmarkSamples () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 911 \{ {\cf19 return} m_data.benchmarkSamples; \}\par
}
}
{\xe \v benchmarkWarmupTime\:Catch::Config}
{\xe \v Catch::Config\:benchmarkWarmupTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::chrono::milliseconds Catch::Config::benchmarkWarmupTime () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 914 \{ {\cf19 return} std::chrono::milliseconds(m_data.benchmarkWarmupTime); \}\par
}
}
{\xe \v defaultColourMode\:Catch::Config}
{\xe \v Catch::Config\:defaultColourMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ColourMode} Catch::Config::defaultColourMode () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 903 \{ {\cf19 return} m_data.defaultColourMode; \}\par
}
}
{\xe \v getProcessedReporterSpecs\:Catch::Config}
{\xe \v Catch::Config\:getProcessedReporterSpecs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b ProcessedReporterSpec} > const  & Catch::Config::getProcessedReporterSpecs () const}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 877                                             \{\par
878         {\cf19 return} m_processedReporterSpecs;\par
879     \}\par
}
}
{\xe \v getReporterSpecs\:Catch::Config}
{\xe \v Catch::Config\:getReporterSpecs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b ReporterSpec} > const  & Catch::Config::getReporterSpecs () const}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 872                                                                   \{\par
873         {\cf19 return} m_data.reporterSpecifications;\par
874     \}\par
}
}
{\xe \v getSectionsToRun\:Catch::Config}
{\xe \v Catch::Config\:getSectionsToRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > const  & Catch::Config::getSectionsToRun () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 870 \{ {\cf19 return} m_data.sectionsToRun; \}\par
}
}
{\xe \v getTestsOrTags\:Catch::Config}
{\xe \v Catch::Config\:getTestsOrTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > const  & Catch::Config::getTestsOrTags () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 869 \{ {\cf19 return} m_data.testsOrTags; \}\par
}
}
{\xe \v hasTestFilters\:Catch::Config}
{\xe \v Catch::Config\:hasTestFilters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::hasTestFilters () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 882 \{ {\cf19 return} m_hasTestFilters; \}\par
}
}
{\xe \v includeSuccessfulResults\:Catch::Config}
{\xe \v Catch::Config\:includeSuccessfulResults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::includeSuccessfulResults () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 889 \{ {\cf19 return} m_data.showSuccessfulTests; \}\par
}
}
{\xe \v listListeners\:Catch::Config}
{\xe \v Catch::Config\:listListeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::listListeners () const}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 867 \{ {\cf19 return} m_data.listListeners; \}\par
}
}
{\xe \v listReporters\:Catch::Config}
{\xe \v Catch::Config\:listReporters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::listReporters () const}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 866 \{ {\cf19 return} m_data.listReporters; \}\par
}
}
{\xe \v listTags\:Catch::Config}
{\xe \v Catch::Config\:listTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::listTags () const}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 865 \{ {\cf19 return} m_data.listTags; \}\par
}
}
{\xe \v listTests\:Catch::Config}
{\xe \v Catch::Config\:listTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::listTests () const}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 864 \{ {\cf19 return} m_data.listTests; \}\par
}
}
{\xe \v minDuration\:Catch::Config}
{\xe \v Catch::Config\:minDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Config::minDuration () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 898 \{ {\cf19 return} m_data.minDuration; \}\par
}
}
{\xe \v name\:Catch::Config}
{\xe \v Catch::Config\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Config::name () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 888 \{ {\cf19 return} m_data.name.empty() ? m_data.processName : m_data.name; \}\par
}
}
{\xe \v rngSeed\:Catch::Config}
{\xe \v Catch::Config\:rngSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Catch::Config::rngSeed () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 900 \{ {\cf19 return} m_data.rngSeed; \}\par
}
}
{\xe \v runOrder\:Catch::Config}
{\xe \v Catch::Config\:runOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestRunOrder} Catch::Config::runOrder () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 899 \{ {\cf19 return} m_data.runOrder; \}\par
}
}
{\xe \v shardCount\:Catch::Config}
{\xe \v Catch::Config\:shardCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::Config::shardCount () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 901 \{ {\cf19 return} m_data.shardCount; \}\par
}
}
{\xe \v shardIndex\:Catch::Config}
{\xe \v Catch::Config\:shardIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::Config::shardIndex () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 902 \{ {\cf19 return} m_data.shardIndex; \}\par
}
}
{\xe \v shouldDebugBreak\:Catch::Config}
{\xe \v Catch::Config\:shouldDebugBreak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::shouldDebugBreak () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 904 \{ {\cf19 return} m_data.shouldDebugBreak; \}\par
}
}
{\xe \v showDurations\:Catch::Config}
{\xe \v Catch::Config\:showDurations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ShowDurations} Catch::Config::showDurations () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAX \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 897 \{ {\cf19 return} m_data.showDurations; \}\par
}
}
{\xe \v showHelp\:Catch::Config}
{\xe \v Catch::Config\:showHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::showHelp () const}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 884 \{ {\cf19 return} m_data.showHelp; \}\par
}
}
{\xe \v showInvisibles\:Catch::Config}
{\xe \v Catch::Config\:showInvisibles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::showInvisibles () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 906 \{ {\cf19 return} m_data.showInvisibles; \}\par
}
}
{\xe \v skipBenchmarks\:Catch::Config}
{\xe \v Catch::Config\:skipBenchmarks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::skipBenchmarks () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 909 \{ {\cf19 return} m_data.skipBenchmarks; \}\par
}
}
{\xe \v testSpec\:Catch::Config}
{\xe \v Catch::Config\:testSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestSpec} const  & Catch::Config::testSpec () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 881 \{ {\cf19 return} m_testSpec; \}\par
}
}
{\xe \v verbosity\:Catch::Config}
{\xe \v Catch::Config\:verbosity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Verbosity} Catch::Config::verbosity () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 907 \{ {\cf19 return} m_data.verbosity; \}\par
}
}
{\xe \v warnAboutMissingAssertions\:Catch::Config}
{\xe \v Catch::Config\:warnAboutMissingAssertions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::warnAboutMissingAssertions () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 890                                                   \{\par
891         {\cf19 return} !!( m_data.warnings & WarnAbout::NoAssertions );\par
892     \}\par
}
}
{\xe \v warnAboutUnmatchedTestSpecs\:Catch::Config}
{\xe \v Catch::Config\:warnAboutUnmatchedTestSpecs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::warnAboutUnmatchedTestSpecs () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 893                                                    \{\par
894         {\cf19 return} !!( m_data.warnings & WarnAbout::UnmatchedTestSpec );\par
895     \}\par
}
}
{\xe \v zeroTestsCountAsSuccess\:Catch::Config}
{\xe \v Catch::Config\:zeroTestsCountAsSuccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Config::zeroTestsCountAsSuccess () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::IConfig} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 896 \{ {\cf19 return} m_data.allowZeroTests; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ConfigData\par \pard\plain 
{\tc\tcl2 \v Catch::ConfigData}
{\xe \v Catch::ConfigData}
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listTests} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listTags} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listReporters} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b listListeners} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b showSuccessfulTests} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shouldDebugBreak} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b noThrow} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b showHelp} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b showInvisibles} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b filenamesAsTags} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b libIdentify} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allowZeroTests} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b abortAfter} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rngSeed} = {\b generateRandomSeed}({\b GenerateFrom::Default})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b shardCount} = 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b shardIndex} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b skipBenchmarks} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b benchmarkNoAnalysis} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b benchmarkSamples} = 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b benchmarkConfidenceInterval} = 0.95\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b benchmarkResamples} = 100'000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::chrono::milliseconds::rep {\b benchmarkWarmupTime} = 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Verbosity} {\b verbosity} = {\b Verbosity::Normal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WarnAbout::What} {\b warnings} = {\b WarnAbout::Nothing}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ShowDurations} {\b showDurations} = {\b ShowDurations::DefaultForReporter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minDuration} = -1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestRunOrder} {\b runOrder} = {\b TestRunOrder::Declared}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColourMode} {\b defaultColourMode} = {\b ColourMode::PlatformDefault}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WaitForKeypress::When} {\b waitForKeypress} = {\b WaitForKeypress::Never}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b defaultOutputFilename}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b processName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b ReporterSpec} > {\b reporterSpecifications}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b testsOrTags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b sectionsToRun}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v abortAfter\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:abortAfter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::ConfigData::abortAfter = -1}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v allowZeroTests\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:allowZeroTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::allowZeroTests = false}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkConfidenceInterval\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:benchmarkConfidenceInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::ConfigData::benchmarkConfidenceInterval = 0.95}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkNoAnalysis\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:benchmarkNoAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::benchmarkNoAnalysis = false}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkResamples\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:benchmarkResamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::ConfigData::benchmarkResamples = 100'000}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkSamples\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:benchmarkSamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::ConfigData::benchmarkSamples = 100}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkWarmupTime\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:benchmarkWarmupTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::chrono::milliseconds::rep Catch::ConfigData::benchmarkWarmupTime = 100}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v defaultColourMode\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:defaultColourMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ColourMode} Catch::ConfigData::defaultColourMode = {\b ColourMode::PlatformDefault}}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v defaultOutputFilename\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:defaultOutputFilename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::ConfigData::defaultOutputFilename}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v filenamesAsTags\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:filenamesAsTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::filenamesAsTags = false}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v libIdentify\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:libIdentify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::libIdentify = false}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listListeners\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:listListeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::listListeners = false}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listReporters\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:listReporters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::listReporters = false}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listTags\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:listTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::listTags = false}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listTests\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:listTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::listTests = false}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v minDuration\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:minDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::ConfigData::minDuration = -1}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::ConfigData::name}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v noThrow\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:noThrow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::noThrow = false}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v processName\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:processName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::ConfigData::processName}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reporterSpecifications\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:reporterSpecifications}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b ReporterSpec}> Catch::ConfigData::reporterSpecifications}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rngSeed\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:rngSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Catch::ConfigData::rngSeed = {\b generateRandomSeed}({\b GenerateFrom::Default})}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v runOrder\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:runOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestRunOrder} Catch::ConfigData::runOrder = {\b TestRunOrder::Declared}}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionsToRun\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:sectionsToRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> Catch::ConfigData::sectionsToRun}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardCount\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:shardCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::ConfigData::shardCount = 1}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardIndex\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:shardIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::ConfigData::shardIndex = 0}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shouldDebugBreak\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:shouldDebugBreak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::shouldDebugBreak = false}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v showDurations\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:showDurations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ShowDurations} Catch::ConfigData::showDurations = {\b ShowDurations::DefaultForReporter}}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v showHelp\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:showHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::showHelp = false}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v showInvisibles\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:showInvisibles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::showInvisibles = false}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v showSuccessfulTests\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:showSuccessfulTests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::showSuccessfulTests = false}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skipBenchmarks\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:skipBenchmarks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ConfigData::skipBenchmarks = false}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v testsOrTags\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:testsOrTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::string> Catch::ConfigData::testsOrTags}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v verbosity\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:verbosity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Verbosity} Catch::ConfigData::verbosity = {\b Verbosity::Normal}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v waitForKeypress\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:waitForKeypress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WaitForKeypress::When} Catch::ConfigData::waitForKeypress = {\b WaitForKeypress::Never}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v warnings\:Catch::ConfigData}
{\xe \v Catch::ConfigData\:warnings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b WarnAbout::What} Catch::ConfigData::warnings = {\b WarnAbout::Nothing}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::conjunction<... >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::conjunction<... >}
{\xe \v Catch::Detail::conjunction<... >}
{\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::conjunction<... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1conjunction.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::conjunction< B1 >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::conjunction< B1 >}
{\xe \v Catch::Detail::conjunction< B1 >}
{\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::conjunction< B1 >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1conjunction_3_01_b1_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::conjunction< B1, Bn... >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::conjunction< B1, Bn... >}
{\xe \v Catch::Detail::conjunction< B1, Bn... >}
{\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::conjunction< B1, Bn... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1conjunction_3_01_b1_00_01_bn_8_8_8_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Context\par \pard\plain 
{\tc\tcl2 \v Catch::Context}
{\xe \v Catch::Context}
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IResultCapture} * {\b getResultCapture} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IConfig} const * {\b getConfig} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setResultCapture} ({\b IResultCapture} *resultCapture)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setConfig} ({\b IConfig} const *config)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} & {\b getCurrentMutableContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} const & {\b getCurrentContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cleanUpContext} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getConfig\:Catch::Context}
{\xe \v Catch::Context\:getConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IConfig} const  * Catch::Context::getConfig () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 559 \{ {\cf19 return} m_config; \}\par
}
}
{\xe \v getResultCapture\:Catch::Context}
{\xe \v Catch::Context\:getResultCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IResultCapture} * Catch::Context::getResultCapture () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 558 \{ {\cf19 return} m_resultCapture; \}\par
}
}
{\xe \v setConfig\:Catch::Context}
{\xe \v Catch::Context\:setConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Context::setConfig ({\b IConfig} const * config)}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3656 \{ m_config = config; \}\par
}
}
{\xe \v setResultCapture\:Catch::Context}
{\xe \v Catch::Context\:setResultCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Context::setResultCapture ({\b IResultCapture} * resultCapture)}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3652                                                                   \{\par
3653         m_resultCapture = resultCapture;\par
3654     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v cleanUpContext\:Catch::Context}
{\xe \v Catch::Context\:cleanUpContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void cleanUpContext (){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3638                           \{\par
3639         {\cf17 delete} Context::currentContext;\par
3640         Context::currentContext = {\cf17 nullptr};\par
3641     \}\par
}
}
{\xe \v getCurrentContext\:Catch::Context}
{\xe \v Catch::Context\:getCurrentContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Context} const  & getCurrentContext (){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 566                                               \{\par
567         {\cf20 // We duplicate the logic from `getCurrentMutableContext` here,}\par
568         {\cf20 // to avoid paying the call overhead in debug mode.}\par
569         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
570         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
571         {\cf19 return} *Context::currentContext;\par
572     \}\par
}
}
{\xe \v getCurrentMutableContext\:Catch::Context}
{\xe \v Catch::Context\:getCurrentMutableContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Context} & getCurrentMutableContext (){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3646                                         \{\par
3647         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
3648         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
3649         {\cf19 return} *Context::currentContext;\par
3650     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Counts\par \pard\plain 
{\tc\tcl2 \v Catch::Counts}
{\xe \v Catch::Counts}
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b operator-} ({\b Counts} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} & {\b operator+=} ({\b Counts} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint64_t {\b total} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allPassed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allOk} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint64_t {\b passed} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint64_t {\b failed} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint64_t {\b failedButOk} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint64_t {\b skipped} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v allOk\:Catch::Counts}
{\xe \v Catch::Counts\:allOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Counts::allOk () const}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2200                              \{\par
2201         {\cf19 return} failed == 0;\par
2202     \}\par
}
}
{\xe \v allPassed\:Catch::Counts}
{\xe \v Catch::Counts\:allPassed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Counts::allPassed () const}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2197                                  \{\par
2198         {\cf19 return} failed == 0 && failedButOk == 0 && skipped == 0;\par
2199     \}\par
}
}
{\xe \v operator+=\:Catch::Counts}
{\xe \v Catch::Counts\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} & Catch::Counts::operator+= ({\b Counts} const & other)}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2186                                                       \{\par
2187         passed += other.passed;\par
2188         failed += other.failed;\par
2189         failedButOk += other.failedButOk;\par
2190         skipped += other.skipped;\par
2191         {\cf19 return} *{\cf17 this};\par
2192     \}\par
}
}
{\xe \v operator-\:Catch::Counts}
{\xe \v Catch::Counts\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::Counts::operator- ({\b Counts} const & other) const}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2177                                                           \{\par
2178         Counts diff;\par
2179         diff.passed = passed - other.passed;\par
2180         diff.failed = failed - other.failed;\par
2181         diff.failedButOk = failedButOk - other.failedButOk;\par
2182         diff.skipped = skipped - other.skipped;\par
2183         {\cf19 return} diff;\par
2184     \}\par
}
}
{\xe \v total\:Catch::Counts}
{\xe \v Catch::Counts\:total}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint64_t Catch::Counts::total () const}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2194                                     \{\par
2195         {\cf19 return} passed + failed + failedButOk + skipped;\par
2196     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v failed\:Catch::Counts}
{\xe \v Catch::Counts\:failed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint64_t Catch::Counts::failed = 0}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failedButOk\:Catch::Counts}
{\xe \v Catch::Counts\:failedButOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint64_t Catch::Counts::failedButOk = 0}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v passed\:Catch::Counts}
{\xe \v Catch::Counts\:passed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint64_t Catch::Counts::passed = 0}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v skipped\:Catch::Counts}
{\xe \v Catch::Counts\:skipped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint64_t Catch::Counts::skipped = 0}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Decomposer\par \pard\plain 
{\tc\tcl2 \v Catch::Decomposer}
{\xe \v Catch::Decomposer}
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::enable_if_t<!{\b capture_by_value}< {\b Detail::RemoveCVRef_t}< T > >{\b ::value}, int >  = 0> constexpr friend auto {\b operator<=} ({\b Decomposer} &&, T &&lhs) -> {\b ExprLhs}< T const & >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::enable_if_t< {\b capture_by_value}< T >{\b ::value}, int >  = 0> constexpr friend auto {\b operator<=} ({\b Decomposer} &&, T {\b value}) -> {\b ExprLhs}< T >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<=\:Catch::Decomposer}
{\xe \v Catch::Decomposer\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , std::enable_if_t<!{\b capture_by_value}< {\b Detail::RemoveCVRef_t}< T > >{\b ::value}, int >  = 0> friend auto operator<= ({\b Decomposer} && , T && lhs) -> {\b ExprLhs}<T const&> {\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5568                                                                                            \{\par
5569             {\cf19 return} ExprLhs<const T&>\{ lhs \};\par
5570         \}\par
}
}
{\xe \v operator<=\:Catch::Decomposer}
{\xe \v Catch::Decomposer\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , std::enable_if_t< {\b capture_by_value}< T >{\b ::value}, int >  = 0> friend auto operator<= ({\b Decomposer} && , T value) -> {\b ExprLhs}<T> {\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5574                                                                                    \{\par
5575             {\cf19 return} ExprLhs<T>\{ value \};\par
5576         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::disjunction<... >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::disjunction<... >}
{\xe \v Catch::Detail::disjunction<... >}
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::disjunction<... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1disjunction.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::disjunction< B1 >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::disjunction< B1 >}
{\xe \v Catch::Detail::disjunction< B1 >}
{\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::disjunction< B1 >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1disjunction_3_01_b1_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::disjunction< B1, Bn... >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::disjunction< B1, Bn... >}
{\xe \v Catch::Detail::disjunction< B1, Bn... >}
{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::disjunction< B1, Bn... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1disjunction_3_01_b1_00_01_bn_8_8_8_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Emprestimo\par \pard\plain 
{\tc\tcl2 \v Emprestimo}
{\xe \v Emprestimo}
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\par
{
{\f2 #include <Emprestimo.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Emprestimo} (int id, const {\b Usuario} &usuario, const {\b Livro} &livro, const string &dataEmprestimo, const string &dataDevolucao)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getId} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Usuario} {\b getUsuario} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Livro} {\b getLivro} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getDataEmprestimo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getDataDevolucao} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getMulta} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDataDevolucao} (const string &dataDevolucao)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMulta} (double multa)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Emprestimo\:Emprestimo}
{\xe \v Emprestimo\:Emprestimo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Emprestimo::Emprestimo (int id, const {\b Usuario} & usuario, const {\b Livro} & livro, const string & dataEmprestimo, const string & dataDevolucao)}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6     : id({\cf18 id}), usuario(usuario), livro(livro), dataEmprestimo(dataEmprestimo), dataDevolucao(dataDevolucao), multa(0) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getDataDevolucao\:Emprestimo}
{\xe \v Emprestimo\:getDataDevolucao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Emprestimo::getDataDevolucao () const}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25                                           \{\par
26     {\cf19 return} dataDevolucao;\par
27 \}\par
}
}
{\xe \v getDataEmprestimo\:Emprestimo}
{\xe \v Emprestimo\:getDataEmprestimo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Emprestimo::getDataEmprestimo () const}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21                                            \{\par
22     {\cf19 return} dataEmprestimo;\par
23 \}\par
}
}
{\xe \v getId\:Emprestimo}
{\xe \v Emprestimo\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Emprestimo::getId () const}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                             \{\par
10     {\cf19 return} id;\par
11 \}\par
}
}
{\xe \v getLivro\:Emprestimo}
{\xe \v Emprestimo\:getLivro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Livro} Emprestimo::getLivro () const}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17                                  \{\par
18     {\cf19 return} livro;\par
19 \}\par
}
}
{\xe \v getMulta\:Emprestimo}
{\xe \v Emprestimo\:getMulta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Emprestimo::getMulta () const}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29                                   \{\par
30     {\cf19 return} multa;\par
31 \}\par
}
}
{\xe \v getUsuario\:Emprestimo}
{\xe \v Emprestimo\:getUsuario}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Usuario} Emprestimo::getUsuario () const}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                                      \{\par
14     {\cf19 return} usuario;\par
15 \}\par
}
}
{\xe \v setDataDevolucao\:Emprestimo}
{\xe \v Emprestimo\:setDataDevolucao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emprestimo::setDataDevolucao (const string & dataDevolucao)}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 34                                                              \{\par
35     this->dataDevolucao = dataDevolucao;\par
36 \}\par
}
}
{\xe \v setMulta\:Emprestimo}
{\xe \v Emprestimo\:setMulta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Emprestimo::setMulta (double multa)}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 38                                       \{\par
39     this->multa = multa;\par
40 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b Emprestimo.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Emprestimo.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe EmprestimoLivros\par \pard\plain 
{\tc\tcl2 \v EmprestimoLivros}
{\xe \v EmprestimoLivros}
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
\par
{
{\f2 #include <Emprestimo.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b registrarEmprestimo} (const {\b Emprestimo} &emprestimo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b aplicarMulta} (int id, double valor)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b controlarPrazoDevolucao} (int id, const string &novaData)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exibirRelatorioEmprestimos} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v aplicarMulta\:EmprestimoLivros}
{\xe \v EmprestimoLivros\:aplicarMulta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EmprestimoLivros::aplicarMulta (int id, double valor)}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 47                                                         \{\par
48     {\cf19 for} ({\cf17 auto} &emprestimo : emprestimos) \{\par
49         {\cf19 if} (emprestimo.getId() == {\cf18 id}) \{\par
50             emprestimo.setMulta(valor);\par
51             {\cf19 return} {\cf17 true};\par
52         \}\par
53     \}\par
54     {\cf19 return} {\cf17 false};\par
55 \}\par
}
}
{\xe \v controlarPrazoDevolucao\:EmprestimoLivros}
{\xe \v EmprestimoLivros\:controlarPrazoDevolucao}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EmprestimoLivros::controlarPrazoDevolucao (int id, const string & novaData)}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 57                                                                              \{\par
58     {\cf19 for} ({\cf17 auto} &emprestimo : emprestimos) \{\par
59         {\cf19 if} (emprestimo.getId() == {\cf18 id}) \{\par
60             emprestimo.setDataDevolucao(novaData);\par
61             {\cf19 return} {\cf17 true};\par
62         \}\par
63     \}\par
64     {\cf19 return} {\cf17 false};\par
65 \}\par
}
}
{\xe \v exibirRelatorioEmprestimos\:EmprestimoLivros}
{\xe \v EmprestimoLivros\:exibirRelatorioEmprestimos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EmprestimoLivros::exibirRelatorioEmprestimos () const}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                                                         \{\par
68     {\cf19 if} (emprestimos.empty()) \{\par
69         cout << {\cf22 "Nenhum emprestimo registrado."} << endl;\par
70     \} {\cf19 else} \{\par
71         cout << {\cf22 "Relatorio de Emprestimos:"} << endl;\par
72         {\cf19 for} ({\cf17 const} {\cf17 auto}& emprestimo : emprestimos) \{\par
73             cout << {\cf22 "ID do Emprestimo: "} << emprestimo.getId() << endl;\par
74             cout << {\cf22 "Usuario: "} << emprestimo.getUsuario().getNome() << endl;\par
75             cout << {\cf22 "Livro: "} << emprestimo.getLivro().getTitulo() << endl;\par
76             cout << {\cf22 "Data do Emprestimo: "} << emprestimo.getDataEmprestimo() << endl;\par
77             cout << {\cf22 "Data de Devolucao: "} << emprestimo.getDataDevolucao() << endl;\par
78             cout << {\cf22 "Multa: "} << emprestimo.getMulta() << endl;\par
79             cout << {\cf22 "-------------------------------"} << endl;\par
80         \}\par
81     \}\par
82 \}\par
}
}
{\xe \v registrarEmprestimo\:EmprestimoLivros}
{\xe \v EmprestimoLivros\:registrarEmprestimo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EmprestimoLivros::registrarEmprestimo (const {\b Emprestimo} & emprestimo)}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 43                                                                        \{\par
44     emprestimos.push_back(emprestimo);\par
45 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b Emprestimo.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Emprestimo.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Detail::EnumInfo\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::EnumInfo}
{\xe \v Catch::Detail::EnumInfo}
{\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~EnumInfo} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b lookup} (int {\b value}) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::pair< int, {\b StringRef} > > {\b m_values}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~EnumInfo\:Catch::Detail::EnumInfo}
{\xe \v Catch::Detail::EnumInfo\:~EnumInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Detail::EnumInfo::~EnumInfo (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v lookup\:Catch::Detail::EnumInfo}
{\xe \v Catch::Detail::EnumInfo\:lookup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Detail::EnumInfo::lookup (int value) const}}
\par
{\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3901                                                     \{\par
3902             {\cf19 for}( {\cf17 auto} {\cf17 const}& valueToName : m_values ) \{\par
3903                 {\cf19 if}( valueToName.first == value )\par
3904                     {\cf19 return} valueToName.second;\par
3905             \}\par
3906             {\cf19 return} {\cf22 "\{** unexpected enum value **\}"}_sr;\par
3907         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_name\:Catch::Detail::EnumInfo}
{\xe \v Catch::Detail::EnumInfo\:m_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Detail::EnumInfo::m_name}}
\par
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_values\:Catch::Detail::EnumInfo}
{\xe \v Catch::Detail::EnumInfo\:m_values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::pair<int, {\b StringRef}> > Catch::Detail::EnumInfo::m_values}}
\par
{\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Environment\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Environment}
{\xe \v Catch::Benchmark::Environment}
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EnvironmentEstimate} {\b clock_resolution}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EnvironmentEstimate} {\b clock_cost}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v clock_cost\:Catch::Benchmark::Environment}
{\xe \v Catch::Benchmark::Environment\:clock_cost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EnvironmentEstimate} Catch::Benchmark::Environment::clock_cost}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clock_resolution\:Catch::Benchmark::Environment}
{\xe \v Catch::Benchmark::Environment\:clock_resolution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EnvironmentEstimate} Catch::Benchmark::Environment::clock_resolution}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::EnvironmentEstimate\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::EnvironmentEstimate}
{\xe \v Catch::Benchmark::EnvironmentEstimate}
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FDuration} {\b mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OutlierClassification} {\b outliers}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mean\:Catch::Benchmark::EnvironmentEstimate}
{\xe \v Catch::Benchmark::EnvironmentEstimate\:mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FDuration} Catch::Benchmark::EnvironmentEstimate::mean}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outliers\:Catch::Benchmark::EnvironmentEstimate}
{\xe \v Catch::Benchmark::EnvironmentEstimate\:outliers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OutlierClassification} Catch::Benchmark::EnvironmentEstimate::outliers}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Estimate< Type >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Estimate< Type >}
{\xe \v Catch::Benchmark::Estimate< Type >}
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Type {\b point}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Type {\b lower_bound}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Type {\b upper_bound}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b confidence_interval}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v confidence_interval\:Catch::Benchmark::Estimate< Type >}
{\xe \v Catch::Benchmark::Estimate< Type >\:confidence_interval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Type > double {\b Catch::Benchmark::Estimate}< Type >::confidence_interval}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lower_bound\:Catch::Benchmark::Estimate< Type >}
{\xe \v Catch::Benchmark::Estimate< Type >\:lower_bound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Type > Type {\b Catch::Benchmark::Estimate}< Type >::lower_bound}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v point\:Catch::Benchmark::Estimate< Type >}
{\xe \v Catch::Benchmark::Estimate< Type >\:point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Type > Type {\b Catch::Benchmark::Estimate}< Type >::point}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v upper_bound\:Catch::Benchmark::Estimate< Type >}
{\xe \v Catch::Benchmark::Estimate< Type >\:upper_bound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Type > Type {\b Catch::Benchmark::Estimate}< Type >::upper_bound}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ExceptionTranslatorRegistrar\par \pard\plain 
{\tc\tcl2 \v Catch::ExceptionTranslatorRegistrar}
{\xe \v Catch::ExceptionTranslatorRegistrar}
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b ExceptionTranslatorRegistrar} (std::string(*translateFunction)(T const &))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ExceptionTranslatorRegistrar\:Catch::ExceptionTranslatorRegistrar}
{\xe \v Catch::ExceptionTranslatorRegistrar\:ExceptionTranslatorRegistrar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > Catch::ExceptionTranslatorRegistrar::ExceptionTranslatorRegistrar (std::string(* translateFunction\~ )(T const &)){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7199                                                                                   \{\par
7200             Detail::registerTranslatorImpl(\par
7201                 Detail::make_unique<ExceptionTranslator<T>>(\par
7202                     translateFunction ) );\par
7203         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::ExecutionPlan\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::ExecutionPlan}
{\xe \v Catch::Benchmark::ExecutionPlan}
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > std::vector< {\b FDuration} > {\b run} (const {\b IConfig} &cfg, {\b Environment} env) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iterations_per_sample}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FDuration} {\b estimated_duration}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::BenchmarkFunction} {\b benchmark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FDuration} {\b warmup_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b warmup_iterations}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v run\:Catch::Benchmark::ExecutionPlan}
{\xe \v Catch::Benchmark::ExecutionPlan\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock > std::vector< {\b FDuration} > Catch::Benchmark::ExecutionPlan::run (const {\b IConfig} & cfg, {\b Environment} env) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1852                                                                                 \{\par
1853                 {\cf20 // warmup a bit}\par
1854                 Detail::run_for_at_least<Clock>(\par
1855                     std::chrono::duration_cast<IDuration>( warmup_time ),\par
1856                     warmup_iterations,\par
1857                     Detail::repeat( []() \{ {\cf19 return} Clock::now(); \} )\par
1858                 );\par
1859 \par
1860                 std::vector<FDuration> times;\par
1861                 {\cf17 const} {\cf17 auto} num_samples = cfg.benchmarkSamples();\par
1862                 times.reserve( num_samples );\par
1863                 {\cf19 for} ( {\cf18 size_t} i = 0; i < num_samples; ++i ) \{\par
1864                     Detail::ChronometerModel<Clock> model;\par
1865                     this->benchmark( Chronometer( model, iterations_per_sample ) );\par
1866                     {\cf17 auto} sample_time = model.elapsed() - env.clock_cost.mean;\par
1867                     {\cf19 if} ( sample_time < FDuration::zero() ) \{\par
1868                         sample_time = FDuration::zero();\par
1869                     \}\par
1870                     times.push_back(sample_time / iterations_per_sample);\par
1871                 \}\par
1872                 {\cf19 return} times;\par
1873             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v benchmark\:Catch::Benchmark::ExecutionPlan}
{\xe \v Catch::Benchmark::ExecutionPlan\:benchmark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::BenchmarkFunction} Catch::Benchmark::ExecutionPlan::benchmark}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v estimated_duration\:Catch::Benchmark::ExecutionPlan}
{\xe \v Catch::Benchmark::ExecutionPlan\:estimated_duration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FDuration} Catch::Benchmark::ExecutionPlan::estimated_duration}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterations_per_sample\:Catch::Benchmark::ExecutionPlan}
{\xe \v Catch::Benchmark::ExecutionPlan\:iterations_per_sample}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::ExecutionPlan::iterations_per_sample}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v warmup_iterations\:Catch::Benchmark::ExecutionPlan}
{\xe \v Catch::Benchmark::ExecutionPlan\:warmup_iterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::ExecutionPlan::warmup_iterations}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v warmup_time\:Catch::Benchmark::ExecutionPlan}
{\xe \v Catch::Benchmark::ExecutionPlan\:warmup_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FDuration} Catch::Benchmark::ExecutionPlan::warmup_time}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::ExeName\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::ExeName}
{\xe \v Catch::Clara::ExeName}
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::ExeName:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_exe_name.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExeName} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExeName} (std::string &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT > {\b ExeName} (LambdaT const &lambda)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::InternalParseResult} {\b parse} (std::string const &, {\b Detail::TokenStream} tokens) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string const & {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::ParserResult} {\b set} (std::string const &newName)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ComposableParserImpl< ExeName >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator|} (T const &other) const -> {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} {\b operator|} (T const &other) const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ParserBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b validate} () const -> {\b Result}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b cardinality} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternalParseResult} {\b parse} ({\b Args} const &args) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ExeName\:Catch::Clara::ExeName}
{\xe \v Catch::Clara::ExeName\:ExeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::ExeName::ExeName ()}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2888                          :\par
2889             m_name(std::make_shared<std::string>({\cf22 "<executable>"})) \{\}\par
}
}
{\xe \v ExeName\:Catch::Clara::ExeName}
{\xe \v Catch::Clara::ExeName\:ExeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::ExeName::ExeName (std::string & ref){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2891                                        : ExeName() \{\par
2892             m_ref = std::make_shared<Detail::BoundValueRef<std::string>>(ref);\par
2893         \}\par
}
}
{\xe \v ExeName\:Catch::Clara::ExeName}
{\xe \v Catch::Clara::ExeName\:ExeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LambdaT > Catch::Clara::ExeName::ExeName (LambdaT const & lambda){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4785                                                     : ExeName() \{\par
4786                 m_ref = std::make_shared<Detail::BoundLambda<LambdaT>>(lambda);\par
4787             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v name\:Catch::Clara::ExeName}
{\xe \v Catch::Clara::ExeName\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string const  & Catch::Clara::ExeName::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4795 \{ {\cf19 return} *m_name; \}\par
}
}
{\xe \v parse\:Catch::Clara::ExeName}
{\xe \v Catch::Clara::ExeName\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::InternalParseResult} Catch::Clara::ExeName::parse (std::string const & , {\b Detail::TokenStream} tokens) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::ParserBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACAO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2897                                                            \{\par
2898             {\cf19 return} Detail::InternalParseResult::ok(\par
2899                 Detail::ParseState(ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2900         \}\par
}
}
{\xe \v set\:Catch::Clara::ExeName}
{\xe \v Catch::Clara::ExeName\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ParserResult} Catch::Clara::ExeName::set (std::string const & newName)}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2902                                                           \{\par
2903             {\cf17 auto} lastSlash = newName.find_last_of({\cf22 "\\\\/"});\par
2904             {\cf17 auto} filename = (lastSlash == std::string::npos)\par
2905                 ? newName\par
2906                 : newName.substr(lastSlash + 1);\par
2907 \par
2908             *m_name = filename;\par
2909             {\cf19 if} (m_ref)\par
2910                 {\cf19 return} m_ref->setValue(filename);\par
2911             {\cf19 else}\par
2912                 {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
2913         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::ExprLhs< LhsT >\par \pard\plain 
{\tc\tcl2 \v Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >}
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b ExprLhs} (LhsT lhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b makeUnaryExpr} () const -> {\b UnaryExpr}< LhsT >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator&&} ({\b ExprLhs} &&, RhsT &&) -> {\b BinaryExpr}< LhsT, RhsT const & >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename RhsT > auto {\b operator||} ({\b ExprLhs} &&, RhsT &&) -> {\b BinaryExpr}< LhsT, RhsT const & >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ExprLhs\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:ExprLhs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > {\b Catch::ExprLhs}< LhsT >::ExprLhs (LhsT lhs){\f2 [inline]}, {\f2 [explicit]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5414 : m_lhs( lhs ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v makeUnaryExpr\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:makeUnaryExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > auto {\b Catch::ExprLhs}< LhsT >::makeUnaryExpr () const -> {\b UnaryExpr}<LhsT> {\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5559                                                                 \{\par
5560             {\cf19 return} UnaryExpr<LhsT>\{ m_lhs \};\par
5561         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator&&\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator&&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto operator&& ({\b ExprLhs}< LhsT > && , RhsT && ) -> {\b BinaryExpr}<LhsT, RhsT const&> {\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5546                                                                                          \{\par
5547             {\cf17 static_assert}(always_false<RhsT>::value,\par
5548             {\cf22 "operator&& is not supported inside assertions, "}\par
5549             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5550         \}\par
}
}
{\xe \v operator||\:Catch::ExprLhs< LhsT >}
{\xe \v Catch::ExprLhs< LhsT >\:operator||}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > template<typename RhsT > auto operator|| ({\b ExprLhs}< LhsT > && , RhsT && ) -> {\b BinaryExpr}<LhsT, RhsT const&> {\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5553                                                                                          \{\par
5554             {\cf17 static_assert}(always_false<RhsT>::value,\par
5555             {\cf22 "operator|| is not supported inside assertions, "}\par
5556             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5557         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::fake_arg\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::fake_arg}
{\xe \v Catch::Clara::Detail::fake_arg}
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b operator T} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator T\:Catch::Clara::Detail::fake_arg}
{\xe \v Catch::Clara::Detail::fake_arg\:operator T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > Catch::Clara::Detail::fake_arg::operator T ()}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::FilterGenerator< T, Predicate >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::FilterGenerator< T, Predicate >}
{\xe \v Catch::Generators::FilterGenerator< T, Predicate >}
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::FilterGenerator< T, Predicate >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_filter_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename P  = Predicate> {\b FilterGenerator} (P &&pred, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v FilterGenerator\:Catch::Generators::FilterGenerator< T, Predicate >}
{\xe \v Catch::Generators::FilterGenerator< T, Predicate >\:FilterGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Predicate > template<typename P  = Predicate> {\b Catch::Generators::FilterGenerator}< T, Predicate >::FilterGenerator (P && pred, {\b GeneratorWrapper}< T > && generator){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7692                                                                   :\par
7693             m_generator(CATCH_MOVE(generator)),\par
7694             m_predicate(CATCH_FORWARD(pred))\par
7695         \{\par
7696             {\cf19 if} (!m_predicate(m_generator.get())) \{\par
7697                 {\cf20 // It might happen that there are no values that pass the}\par
7698                 {\cf20 // filter. In that case we throw an exception.}\par
7699                 {\cf17 auto} has_initial_value = next();\par
7700                 {\cf19 if} (!has_initial_value) \{\par
7701                     Detail::throw_generator_exception({\cf22 "No valid value found in filtered generator"});\par
7702                 \}\par
7703             \}\par
7704         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::FilterGenerator< T, Predicate >}
{\xe \v Catch::Generators::FilterGenerator< T, Predicate >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Predicate > T const  & {\b Catch::Generators::FilterGenerator}< T, Predicate >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7706                                       \{\par
7707             {\cf19 return} m_generator.get();\par
7708         \}\par
}
}
{\xe \v next\:Catch::Generators::FilterGenerator< T, Predicate >}
{\xe \v Catch::Generators::FilterGenerator< T, Predicate >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Predicate > bool {\b Catch::Generators::FilterGenerator}< T, Predicate >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7710                              \{\par
7711             {\cf18 bool} success = m_generator.next();\par
7712             {\cf19 if} (!success) \{\par
7713                 {\cf19 return} {\cf17 false};\par
7714             \}\par
7715             {\cf19 while} (!m_predicate(m_generator.get()) && (success = m_generator.next()) == {\cf17 true});\par
7716             {\cf19 return} success;\par
7717         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::TestSpec::FilterMatch\par \pard\plain 
{\tc\tcl2 \v Catch::TestSpec::FilterMatch}
{\xe \v Catch::TestSpec::FilterMatch}
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} const  * > {\b tests}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v name\:Catch::TestSpec::FilterMatch}
{\xe \v Catch::TestSpec::FilterMatch\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TestSpec::FilterMatch::name}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tests\:Catch::TestSpec::FilterMatch}
{\xe \v Catch::TestSpec::FilterMatch\:tests}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b TestCaseHandle} const*> Catch::TestSpec::FilterMatch::tests}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::FixedValuesGenerator< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::FixedValuesGenerator< T >}
{\xe \v Catch::Generators::FixedValuesGenerator< T >}
{\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::FixedValuesGenerator< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_fixed_values_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FixedValuesGenerator} (std::initializer_list< T > {\b values})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v FixedValuesGenerator\:Catch::Generators::FixedValuesGenerator< T >}
{\xe \v Catch::Generators::FixedValuesGenerator< T >\:FixedValuesGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::FixedValuesGenerator}< T >::FixedValuesGenerator (std::initializer_list< T > values){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7490 : m_values( values ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::FixedValuesGenerator< T >}
{\xe \v Catch::Generators::FixedValuesGenerator< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Generators::FixedValuesGenerator}< T >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7492                                       \{\par
7493             {\cf19 return} m_values[m_idx];\par
7494         \}\par
}
}
{\xe \v next\:Catch::Generators::FixedValuesGenerator< T >}
{\xe \v Catch::Generators::FixedValuesGenerator< T >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Generators::FixedValuesGenerator}< T >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7495                              \{\par
7496             ++m_idx;\par
7497             {\cf19 return} m_idx < m_values.size();\par
7498         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::GeneratorException\par \pard\plain 
{\tc\tcl2 \v Catch::GeneratorException}
{\xe \v Catch::GeneratorException}
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::GeneratorException:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generator_exception.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorException} (const char *msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b what} () const noexcept override final\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v GeneratorException\:Catch::GeneratorException}
{\xe \v Catch::GeneratorException\:GeneratorException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::GeneratorException::GeneratorException (const char * msg){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7312                                            :\par
7313             m_msg(msg)\par
7314         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v what\:Catch::GeneratorException}
{\xe \v Catch::GeneratorException\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * Catch::GeneratorException::what () const{\f2 [final]}, {\f2 [override]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2287                                                         \{\par
2288         {\cf19 return} m_msg;\par
2289     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::Generators< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::Generators< T >}
{\xe \v Catch::Generators::Generators< T >}
{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::Generators< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_generators.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Gs> {\b Generators} (Gs &&... moreGenerators)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Generators\:Catch::Generators::Generators< T >}
{\xe \v Catch::Generators::Generators< T >\:Generators}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename... Gs> {\b Catch::Generators::Generators}< T >::Generators (Gs &&... moreGenerators){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7544                                             \{\par
7545             m_generators.reserve({\cf17 sizeof}...(Gs));\par
7546             add_generators(CATCH_FORWARD(moreGenerators)...);\par
7547         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::Generators< T >}
{\xe \v Catch::Generators::Generators< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Generators::Generators}< T >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7549                                       \{\par
7550             {\cf19 return} m_generators[m_current].get();\par
7551         \}\par
}
}
{\xe \v next\:Catch::Generators::Generators< T >}
{\xe \v Catch::Generators::Generators< T >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Generators::Generators}< T >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7553                              \{\par
7554             {\cf19 if} (m_current >= m_generators.size()) \{\par
7555                 {\cf19 return} {\cf17 false};\par
7556             \}\par
7557             {\cf17 const} {\cf18 bool} current_status = m_generators[m_current].next();\par
7558             {\cf19 if} (!current_status) \{\par
7559                 ++m_current;\par
7560             \}\par
7561             {\cf19 return} m_current < m_generators.size();\par
7562         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Generators::GeneratorUntypedBase\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase}
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::GeneratorUntypedBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_generator_untyped_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v GeneratorUntypedBase\:Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase\:GeneratorUntypedBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Generators::GeneratorUntypedBase::GeneratorUntypedBase (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GeneratorUntypedBase\:Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase\:GeneratorUntypedBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Generators::GeneratorUntypedBase::GeneratorUntypedBase ({\b GeneratorUntypedBase} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~GeneratorUntypedBase\:Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase\:~GeneratorUntypedBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Generators::GeneratorUntypedBase::~GeneratorUntypedBase (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v countedNext\:Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase\:countedNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Generators::GeneratorUntypedBase::countedNext ()}}
\par
{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Serves as a non-virtual interface to {\f2 next} , so that the top level interface can provide sanity checking and shared features.\par
As with {\f2 next} , returns true iff the move succeeded and the generator has new valid element to provide. \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2389                                                \{\par
2390             {\cf17 auto} ret = next();\par
2391             {\cf19 if} ( ret ) \{\par
2392                 m_stringReprCache.clear();\par
2393                 ++m_currentElementIndex;\par
2394             \}\par
2395             {\cf19 return} ret;\par
2396         \}\par
}
}
{\xe \v currentElementAsString\:Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase\:currentElementAsString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Generators::GeneratorUntypedBase::currentElementAsString () const}}
\par
{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns generator's current element as user-friendly string.\par
By default returns string equivalent to calling {\f2 {\b Catch::Detail::stringify}}  on the current element, but generators can customize their implementation as needed.\par
Not thread-safe due to internal caching.\par
The returned ref is valid only until the generator instance is destructed, or it moves onto the next element, whichever comes first. \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2398                                                                      \{\par
2399             {\cf19 if} ( m_stringReprCache.empty() ) \{\par
2400                 m_stringReprCache = stringifyImpl();\par
2401             \}\par
2402             {\cf19 return} m_stringReprCache;\par
2403         \}\par
}
}
{\xe \v currentElementIndex\:Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase\:currentElementIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::Generators::GeneratorUntypedBase::currentElementIndex () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7378 \{ {\cf19 return} m_currentElementIndex; \}\par
}
}
{\xe \v operator=\:Catch::Generators::GeneratorUntypedBase}
{\xe \v Catch::Generators::GeneratorUntypedBase\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GeneratorUntypedBase} & Catch::Generators::GeneratorUntypedBase::operator= ({\b GeneratorUntypedBase} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::GeneratorWrapper< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::GeneratorWrapper< T >}
{\xe \v Catch::Generators::GeneratorWrapper< T >}
{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorWrapper} ({\b IGenerator}< T > *generator)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes ownership of the passed pointer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorWrapper} ({\b GeneratorPtr}< T > generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v GeneratorWrapper\:Catch::Generators::GeneratorWrapper< T >}
{\xe \v Catch::Generators::GeneratorWrapper< T >\:GeneratorWrapper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::GeneratorWrapper}< T >::GeneratorWrapper ({\b IGenerator}< T > * generator){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Takes ownership of the passed pointer. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7449                                                   :\par
7450             m_generator(generator) \{\}\par
}
}
{\xe \v GeneratorWrapper\:Catch::Generators::GeneratorWrapper< T >}
{\xe \v Catch::Generators::GeneratorWrapper< T >\:GeneratorWrapper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::GeneratorWrapper}< T >::GeneratorWrapper ({\b GeneratorPtr}< T > generator){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7451                                                    :\par
7452             m_generator(CATCH_MOVE(generator)) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::GeneratorWrapper< T >}
{\xe \v Catch::Generators::GeneratorWrapper< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Generators::GeneratorWrapper}< T >::get () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7454                              \{\par
7455             {\cf19 return} m_generator->get();\par
7456         \}\par
}
}
{\xe \v next\:Catch::Generators::GeneratorWrapper< T >}
{\xe \v Catch::Generators::GeneratorWrapper< T >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Generators::GeneratorWrapper}< T >::next (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7457                     \{\par
7458             {\cf19 return} m_generator->countedNext();\par
7459         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe GerenciamentoLivros\par \pard\plain 
{\tc\tcl2 \v GerenciamentoLivros}
{\xe \v GerenciamentoLivros}
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\par
{
{\f2 #include <Livro.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b adicionarLivro} (const {\b Livro} &livro)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removerLivro} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Livro} * {\b consultarLivro} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b verificarDisponibilidade} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exibirRelatorioLivros} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v adicionarLivro\:GerenciamentoLivros}
{\xe \v GerenciamentoLivros\:adicionarLivro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GerenciamentoLivros::adicionarLivro (const {\b Livro} & livro)}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 33                                                            \{\par
34     livros.push_back(livro);\par
35 \}\par
}
}
{\xe \v consultarLivro\:GerenciamentoLivros}
{\xe \v GerenciamentoLivros\:consultarLivro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Livro} * GerenciamentoLivros::consultarLivro (int id)}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 46                                                  \{\par
47     {\cf19 for} ({\cf17 auto} &livro : livros) \{\par
48         {\cf19 if} (livro.getId() == {\cf18 id}) \{\par
49             {\cf19 return} &livro;\par
50         \}\par
51     \}\par
52     {\cf19 return} {\cf17 nullptr};\par
53 \}\par
}
}
{\xe \v exibirRelatorioLivros\:GerenciamentoLivros}
{\xe \v GerenciamentoLivros\:exibirRelatorioLivros}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GerenciamentoLivros::exibirRelatorioLivros () const}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 66                                                       \{\par
67     {\cf19 if} (livros.empty()) \{\par
68         cout << {\cf22 "Sem livros cadastrados."} << endl;\par
69         {\cf19 return};\par
70     \}\par
71     cout << {\cf22 "Relatorio de Livros:"} << endl;\par
72     {\cf19 for} ({\cf17 const} {\cf17 auto}& livro : livros) \{\par
73         cout << {\cf22 "ID: "} << livro.getId() << {\cf22 ", Titulo: "} << livro.getTitulo() << {\cf22 ", Autor: "} << livro.getAutor() << {\cf22 ", Genero: "} << livro.getGenero() << {\cf22 ", Disponivel: "} << (livro.isDisponivel() ? {\cf22 "Sim"} : {\cf22 "Nao"}) << endl;\par
74     \}\par
75 \}\par
}
}
{\xe \v removerLivro\:GerenciamentoLivros}
{\xe \v GerenciamentoLivros\:removerLivro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GerenciamentoLivros::removerLivro (int id)}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 37                                              \{\par
38     {\cf19 for} ({\cf17 auto} it = livros.begin(); it != livros.end(); ++it) \{\par
39         {\cf19 if} (it->getId() == {\cf18 id}) \{\par
40             livros.erase(it);\par
41             {\cf19 break};\par
42         \}\par
43     \}\par
44 \}\par
}
}
{\xe \v verificarDisponibilidade\:GerenciamentoLivros}
{\xe \v GerenciamentoLivros\:verificarDisponibilidade}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GerenciamentoLivros::verificarDisponibilidade (int id)}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55                                                          \{\par
56     Livro* livro = consultarLivro({\cf18 id});\par
57     {\cf19 if} (livro) \{\par
58         {\cf19 if} (livro->isDisponivel()) \{\par
59             cout << {\cf22 "O livro '"} << livro->getTitulo() << {\cf22 "' esta disponivel."} << endl;\par
60         \} {\cf19 else} \{\par
61             cout << {\cf22 "O livro '"} << livro->getTitulo() << {\cf22 "' nao esta disponivel."} << endl;\par
62         \}\par
63     \}\par
64 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b Livro.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Livro.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe GerenciamentoUsuario\par \pard\plain 
{\tc\tcl2 \v GerenciamentoUsuario}
{\xe \v GerenciamentoUsuario}
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
\par
{
{\f2 #include <Usuario.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b adicionarUsuario} (const {\b Usuario} &usuario)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removerUsuario} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Usuario} * {\b consultarUsuario} (int id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exibirRelatorioUsuarios} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v adicionarUsuario\:GerenciamentoUsuario}
{\xe \v GerenciamentoUsuario\:adicionarUsuario}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GerenciamentoUsuario::adicionarUsuario (const {\b Usuario} & usuario)}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 28                                                                   \{\par
29     usuarios.push_back(usuario);\par
30 \}\par
}
}
{\xe \v consultarUsuario\:GerenciamentoUsuario}
{\xe \v GerenciamentoUsuario\:consultarUsuario}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Usuario} * GerenciamentoUsuario::consultarUsuario (int id)}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 41                                                       \{\par
42     {\cf19 for} ({\cf17 auto} &usuario : usuarios) \{\par
43         {\cf19 if} (usuario.getId() == {\cf18 id}) \{\par
44             {\cf19 return} &usuario;\par
45         \}\par
46     \}\par
47     {\cf19 return} {\cf17 nullptr};\par
48 \}\par
}
}
{\xe \v exibirRelatorioUsuarios\:GerenciamentoUsuario}
{\xe \v GerenciamentoUsuario\:exibirRelatorioUsuarios}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GerenciamentoUsuario::exibirRelatorioUsuarios () const}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                                                          \{\par
51     {\cf19 if} (usuarios.empty()) \{\par
52         cout << {\cf22 "Sem usuarios cadastrados."} << endl;\par
53         {\cf19 return};\par
54     \}\par
55     cout << {\cf22 "Relatorio de Usuarios:"} << endl;\par
56     {\cf19 for} ({\cf17 const} {\cf17 auto}& usuario : usuarios) \{\par
57         cout << {\cf22 "ID: "} << usuario.getId() << {\cf22 ", Nome: "} << usuario.getNome() << {\cf22 ", Telefone: "} << usuario.getTelefone() << endl;\par
58     \}\par
59 \}\par
}
}
{\xe \v removerUsuario\:GerenciamentoUsuario}
{\xe \v GerenciamentoUsuario\:removerUsuario}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GerenciamentoUsuario::removerUsuario (int id)}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 32                                                 \{\par
33     {\cf19 for} ({\cf17 auto} it = usuarios.begin(); it != usuarios.end(); ++it) \{\par
34         {\cf19 if} (it->getId() == {\cf18 id}) \{\par
35             usuarios.erase(it);\par
36             {\cf19 break};\par
37         \}\par
38     \}\par
39 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b Usuario.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Usuario.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Help\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Help}
{\xe \v Catch::Clara::Help}
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Help:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_help.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Help} (bool &showHelpFlag)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Opt}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT > {\b Opt} (LambdaT const &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} (bool &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT , typename  = typename std::enable_if_t<                          Detail::is_unary_function<LambdaT>::value>> {\b Opt} (LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT > {\b Opt} ({\b accept_many_t}, LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if_t<                          !Detail::is_unary_function<T>::value>> {\b Opt} (T &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} & {\b operator[]} ({\b StringRef} optName) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} && {\b operator[]} ({\b StringRef} optName) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::HelpColumns} {\b getHelpColumns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isMatch} ({\b StringRef} optToken) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::InternalParseResult} {\b parse} (std::string const &, {\b Detail::TokenStream} tokens) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::Result} {\b validate} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} ({\b accept_many_t}, LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (T &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} & {\b operator()} ({\b StringRef} description) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} && {\b operator()} ({\b StringRef} description) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b optional} () -> {\b Opt} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b required} () -> {\b Opt} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isOptional} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b cardinality} () const -> size_t override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b hint} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ComposableParserImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator|} (T const &other) const -> {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} {\b operator|} (T const &other) const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ParserBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternalParseResult} {\b parse} ({\b Args} const &args) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (std::shared_ptr< {\b BoundRef} > const &ref)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Clara::Opt}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b m_optNames}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optionality} {\b m_optionality}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::shared_ptr< {\b BoundRef} > {\b m_ref}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_hint}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_description}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Help\:Catch::Clara::Help}
{\xe \v Catch::Clara::Help\:Help}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Help::Help (bool & showHelpFlag)}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3053                                       :\par
3054             Opt( [&]( {\cf18 bool} flag ) \{\par
3055                 showHelpFlag = flag;\par
3056                 {\cf19 return} ParserResult::ok( ParseResultType::ShortCircuitAll );\par
3057             \} ) \{\par
3058             {\cf17 static_cast<}Opt&{\cf17 >} ( *this )(\par
3059                 {\cf22 "display usage information"} )[{\cf22 "-?"}][{\cf22 "-h"}][{\cf22 "--help"}]\par
3060                 .optional();\par
3061         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::HelpColumns\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::HelpColumns}
{\xe \v Catch::Clara::Detail::HelpColumns}
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b left}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b descriptions}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v descriptions\:Catch::Clara::Detail::HelpColumns}
{\xe \v Catch::Clara::Detail::HelpColumns\:descriptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Clara::Detail::HelpColumns::descriptions}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v left\:Catch::Clara::Detail::HelpColumns}
{\xe \v Catch::Clara::Detail::HelpColumns\:left}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::Clara::Detail::HelpColumns::left}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IConfig\par \pard\plain 
{\tc\tcl2 \v Catch::IConfig}
{\xe \v Catch::IConfig}
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::IConfig:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_i_config.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IConfig} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b allowThrows} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b StringRef} {\b name} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b includeSuccessfulResults} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b shouldDebugBreak} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b warnAboutMissingAssertions} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b warnAboutUnmatchedTestSpecs} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b zeroTestsCountAsSuccess} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b abortAfter} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b showInvisibles} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ShowDurations} {\b showDurations} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b minDuration} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TestSpec} const & {\b testSpec} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b hasTestFilters} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< std::string > const & {\b getTestsOrTags} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b TestRunOrder} {\b runOrder} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual uint32_t {\b rngSeed} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b shardCount} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b shardIndex} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ColourMode} {\b defaultColourMode} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< std::string > const & {\b getSectionsToRun} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Verbosity} {\b verbosity} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b skipBenchmarks} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b benchmarkNoAnalysis} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b benchmarkSamples} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b benchmarkConfidenceInterval} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual unsigned int {\b benchmarkResamples} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::chrono::milliseconds {\b benchmarkWarmupTime} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IConfig\:Catch::IConfig}
{\xe \v Catch::IConfig\:~IConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IConfig::~IConfig (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v abortAfter\:Catch::IConfig}
{\xe \v Catch::IConfig\:abortAfter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int Catch::IConfig::abortAfter () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v allowThrows\:Catch::IConfig}
{\xe \v Catch::IConfig\:allowThrows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::allowThrows () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v benchmarkConfidenceInterval\:Catch::IConfig}
{\xe \v Catch::IConfig\:benchmarkConfidenceInterval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual double Catch::IConfig::benchmarkConfidenceInterval () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v benchmarkNoAnalysis\:Catch::IConfig}
{\xe \v Catch::IConfig\:benchmarkNoAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::benchmarkNoAnalysis () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v benchmarkResamples\:Catch::IConfig}
{\xe \v Catch::IConfig\:benchmarkResamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int Catch::IConfig::benchmarkResamples () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v benchmarkSamples\:Catch::IConfig}
{\xe \v Catch::IConfig\:benchmarkSamples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int Catch::IConfig::benchmarkSamples () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v benchmarkWarmupTime\:Catch::IConfig}
{\xe \v Catch::IConfig\:benchmarkWarmupTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::chrono::milliseconds Catch::IConfig::benchmarkWarmupTime () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v defaultColourMode\:Catch::IConfig}
{\xe \v Catch::IConfig\:defaultColourMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b ColourMode} Catch::IConfig::defaultColourMode () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getSectionsToRun\:Catch::IConfig}
{\xe \v Catch::IConfig\:getSectionsToRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< std::string > const  & Catch::IConfig::getSectionsToRun () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v getTestsOrTags\:Catch::IConfig}
{\xe \v Catch::IConfig\:getTestsOrTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< std::string > const  & Catch::IConfig::getTestsOrTags () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v hasTestFilters\:Catch::IConfig}
{\xe \v Catch::IConfig\:hasTestFilters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::hasTestFilters () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v includeSuccessfulResults\:Catch::IConfig}
{\xe \v Catch::IConfig\:includeSuccessfulResults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::includeSuccessfulResults () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v minDuration\:Catch::IConfig}
{\xe \v Catch::IConfig\:minDuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual double Catch::IConfig::minDuration () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v name\:Catch::IConfig}
{\xe \v Catch::IConfig\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b StringRef} Catch::IConfig::name () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v rngSeed\:Catch::IConfig}
{\xe \v Catch::IConfig\:rngSeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual uint32_t Catch::IConfig::rngSeed () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v runOrder\:Catch::IConfig}
{\xe \v Catch::IConfig\:runOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b TestRunOrder} Catch::IConfig::runOrder () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v shardCount\:Catch::IConfig}
{\xe \v Catch::IConfig\:shardCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int Catch::IConfig::shardCount () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v shardIndex\:Catch::IConfig}
{\xe \v Catch::IConfig\:shardIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual unsigned int Catch::IConfig::shardIndex () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v shouldDebugBreak\:Catch::IConfig}
{\xe \v Catch::IConfig\:shouldDebugBreak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::shouldDebugBreak () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v showDurations\:Catch::IConfig}
{\xe \v Catch::IConfig\:showDurations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b ShowDurations} Catch::IConfig::showDurations () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v showInvisibles\:Catch::IConfig}
{\xe \v Catch::IConfig\:showInvisibles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::showInvisibles () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABAZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v skipBenchmarks\:Catch::IConfig}
{\xe \v Catch::IConfig\:skipBenchmarks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::skipBenchmarks () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v testSpec\:Catch::IConfig}
{\xe \v Catch::IConfig\:testSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b TestSpec} const  & Catch::IConfig::testSpec () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v verbosity\:Catch::IConfig}
{\xe \v Catch::IConfig\:verbosity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Verbosity} Catch::IConfig::verbosity () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v warnAboutMissingAssertions\:Catch::IConfig}
{\xe \v Catch::IConfig\:warnAboutMissingAssertions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::warnAboutMissingAssertions () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v warnAboutUnmatchedTestSpecs\:Catch::IConfig}
{\xe \v Catch::IConfig\:warnAboutUnmatchedTestSpecs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::warnAboutUnmatchedTestSpecs () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v zeroTestsCountAsSuccess\:Catch::IConfig}
{\xe \v Catch::IConfig\:zeroTestsCountAsSuccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IConfig::zeroTestsCountAsSuccess () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Config} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABBL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IExceptionTranslator\par \pard\plain 
{\tc\tcl2 \v Catch::IExceptionTranslator}
{\xe \v Catch::IExceptionTranslator}
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IExceptionTranslator} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b translate} (ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd) const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IExceptionTranslator\:Catch::IExceptionTranslator}
{\xe \v Catch::IExceptionTranslator\:~IExceptionTranslator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IExceptionTranslator::~IExceptionTranslator (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v translate\:Catch::IExceptionTranslator}
{\xe \v Catch::IExceptionTranslator\:translate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string Catch::IExceptionTranslator::translate (ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IExceptionTranslatorRegistry\par \pard\plain 
{\tc\tcl2 \v Catch::IExceptionTranslatorRegistry}
{\xe \v Catch::IExceptionTranslatorRegistry}
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IExceptionTranslatorRegistry} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b translateActiveException} () const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IExceptionTranslatorRegistry\:Catch::IExceptionTranslatorRegistry}
{\xe \v Catch::IExceptionTranslatorRegistry\:~IExceptionTranslatorRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v translateActiveException\:Catch::IExceptionTranslatorRegistry}
{\xe \v Catch::IExceptionTranslatorRegistry\:translateActiveException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string Catch::IExceptionTranslatorRegistry::translateActiveException () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::IGenerator< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::IGenerator< T >}
{\xe \v Catch::Generators::IGenerator< T >}
{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::IGenerator< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_i_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual T const & {\b get} () const =0\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v type\:Catch::Generators::IGenerator< T >}
{\xe \v Catch::Generators::IGenerator< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b Catch::Generators::IGenerator}< T >::type = T}}
\par
{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::IGenerator< T >}
{\xe \v Catch::Generators::IGenerator< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > virtual T const  & {\b Catch::Generators::IGenerator}< T >::get () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Generators::ChunkGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLF \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Generators::FilterGenerator< T, Predicate >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLL \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Generators::FixedValuesGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLP \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Generators::Generators< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLT \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Generators::MapGenerator< T, U, Func >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMJ \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Generators::RepeatGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMK \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Generators::SingleValueGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACML \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Generators::TakeGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACMM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IGeneratorTracker\par \pard\plain 
{\tc\tcl2 \v Catch::IGeneratorTracker}
{\xe \v Catch::IGeneratorTracker}
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IGeneratorTracker} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b hasGenerator} () const -> bool=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b getGenerator} () const -> {\b Generators::GeneratorBasePtr} const &=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setGenerator} ({\b Generators::GeneratorBasePtr} &&generator)=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IGeneratorTracker\:Catch::IGeneratorTracker}
{\xe \v Catch::IGeneratorTracker\:~IGeneratorTracker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IGeneratorTracker::~IGeneratorTracker (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getGenerator\:Catch::IGeneratorTracker}
{\xe \v Catch::IGeneratorTracker\:getGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual auto Catch::IGeneratorTracker::getGenerator () const ->  {\b Generators::GeneratorBasePtr} const &{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hasGenerator\:Catch::IGeneratorTracker}
{\xe \v Catch::IGeneratorTracker\:hasGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual auto Catch::IGeneratorTracker::hasGenerator () const ->  bool{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setGenerator\:Catch::IGeneratorTracker}
{\xe \v Catch::IGeneratorTracker\:setGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IGeneratorTracker::setGenerator ({\b Generators::GeneratorBasePtr} && generator){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IMutableEnumValuesRegistry\par \pard\plain 
{\tc\tcl2 \v Catch::IMutableEnumValuesRegistry}
{\xe \v Catch::IMutableEnumValuesRegistry}
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IMutableEnumValuesRegistry} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Detail::EnumInfo} const & {\b registerEnum} ({\b StringRef} enumName, {\b StringRef} allEnums, std::vector< int > const &values)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > {\b Detail::EnumInfo} const & {\b registerEnum} ({\b StringRef} enumName, {\b StringRef} allEnums, std::initializer_list< E > values)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IMutableEnumValuesRegistry\:Catch::IMutableEnumValuesRegistry}
{\xe \v Catch::IMutableEnumValuesRegistry\:~IMutableEnumValuesRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v registerEnum\:Catch::IMutableEnumValuesRegistry}
{\xe \v Catch::IMutableEnumValuesRegistry\:registerEnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename E > {\b Detail::EnumInfo} const  & Catch::IMutableEnumValuesRegistry::registerEnum ({\b StringRef} enumName, {\b StringRef} allEnums, std::initializer_list< E > values){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2429                                                                                                                     \{\par
2430             {\cf17 static_assert}({\cf17 sizeof}(int) >= {\cf17 sizeof}(E), {\cf22 "Cannot serialize enum to int"});\par
2431             std::vector<int> intValues;\par
2432             intValues.reserve( values.size() );\par
2433             {\cf19 for}( {\cf17 auto} enumValue : values )\par
2434                 intValues.push_back( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( enumValue ) );\par
2435             {\cf19 return} registerEnum( enumName, allEnums, intValues );\par
2436         \}\par
}
}
{\xe \v registerEnum\:Catch::IMutableEnumValuesRegistry}
{\xe \v Catch::IMutableEnumValuesRegistry\:registerEnum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b Detail::EnumInfo} const  & Catch::IMutableEnumValuesRegistry::registerEnum ({\b StringRef} enumName, {\b StringRef} allEnums, std::vector< int > const & values){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IMutableRegistryHub\par \pard\plain 
{\tc\tcl2 \v Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub}
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerReporter} (std::string const &name, {\b IReporterFactoryPtr} factory)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerListener} ({\b Detail::unique_ptr}< EventListenerFactory > factory)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerTest} ({\b Detail::unique_ptr}< {\b TestCaseInfo} > &&testInfo, {\b Detail::unique_ptr}< {\b ITestInvoker} > &&invoker)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerTranslator} ({\b Detail::unique_ptr}< {\b IExceptionTranslator} > &&translator)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerTagAlias} (std::string const &alias, std::string const &tag, {\b SourceLineInfo} const &lineInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b registerStartupException} () noexcept=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b IMutableEnumValuesRegistry} & {\b getMutableEnumValuesRegistry} ()=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IMutableRegistryHub\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:~IMutableRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IMutableRegistryHub::~IMutableRegistryHub (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getMutableEnumValuesRegistry\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:getMutableEnumValuesRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b IMutableEnumValuesRegistry} & Catch::IMutableRegistryHub::getMutableEnumValuesRegistry (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerListener\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerListener}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerListener ({\b Detail::unique_ptr}< EventListenerFactory > factory){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerReporter\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerReporter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerReporter (std::string const & name, {\b IReporterFactoryPtr} factory){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerStartupException\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerStartupException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerStartupException (){\f2 [pure virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerTagAlias\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerTagAlias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerTagAlias (std::string const & alias, std::string const & tag, {\b SourceLineInfo} const & lineInfo){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerTest\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerTest ({\b Detail::unique_ptr}< {\b TestCaseInfo} > && testInfo, {\b Detail::unique_ptr}< {\b ITestInvoker} > && invoker){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v registerTranslator\:Catch::IMutableRegistryHub}
{\xe \v Catch::IMutableRegistryHub\:registerTranslator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IMutableRegistryHub::registerTranslator ({\b Detail::unique_ptr}< {\b IExceptionTranslator} > && translator){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IRegistryHub\par \pard\plain 
{\tc\tcl2 \v Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub}
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual ReporterRegistry const & {\b getReporterRegistry} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual ITestCaseRegistry const & {\b getTestCaseRegistry} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual ITagAliasRegistry const & {\b getTagAliasRegistry} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b IExceptionTranslatorRegistry} const & {\b getExceptionTranslatorRegistry} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual StartupExceptionRegistry const & {\b getStartupExceptionRegistry} () const =0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IRegistryHub\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:~IRegistryHub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IRegistryHub::~IRegistryHub (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getExceptionTranslatorRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getExceptionTranslatorRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b IExceptionTranslatorRegistry} const  & Catch::IRegistryHub::getExceptionTranslatorRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getReporterRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getReporterRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual ReporterRegistry const  & Catch::IRegistryHub::getReporterRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getStartupExceptionRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getStartupExceptionRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual StartupExceptionRegistry const  & Catch::IRegistryHub::getStartupExceptionRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getTagAliasRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getTagAliasRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual ITagAliasRegistry const  & Catch::IRegistryHub::getTagAliasRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getTestCaseRegistry\:Catch::IRegistryHub}
{\xe \v Catch::IRegistryHub\:getTestCaseRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual ITestCaseRegistry const  & Catch::IRegistryHub::getTestCaseRegistry () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::IResultCapture\par \pard\plain 
{\tc\tcl2 \v Catch::IResultCapture}
{\xe \v Catch::IResultCapture}
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~IResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b notifyAssertionStarted} ({\b AssertionInfo} const &info)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b sectionStarted} ({\b StringRef} sectionName, {\b SourceLineInfo} const &sectionLineInfo, {\b Counts} &assertions)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b sectionEnded} ({\b SectionEndInfo} &&endInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b sectionEndedEarly} ({\b SectionEndInfo} &&endInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b IGeneratorTracker} * {\b acquireGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} const &lineInfo)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b IGeneratorTracker} * {\b createGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} lineInfo, {\b Generators::GeneratorBasePtr} &&generator)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b benchmarkPreparing} ({\b StringRef} name)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b benchmarkStarting} ({\b BenchmarkInfo} const &info)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b benchmarkEnded} ({\b BenchmarkStats}<> const &stats)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b benchmarkFailed} ({\b StringRef} error)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b pushScopedMessage} ({\b MessageInfo} const &message)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b popScopedMessage} ({\b MessageInfo} const &message)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b emplaceUnscopedMessage} ({\b MessageBuilder} &&builder)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleFatalErrorCondition} ({\b StringRef} message)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleExpr} ({\b AssertionInfo} const &info, {\b ITransientExpression} const &expr, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleMessage} ({\b AssertionInfo} const &info, {\b ResultWas::OfType} resultType, {\b StringRef} message, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleUnexpectedExceptionNotThrown} ({\b AssertionInfo} const &info, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleUnexpectedInflightException} ({\b AssertionInfo} const &info, std::string &&message, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleIncomplete} ({\b AssertionInfo} const &info)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b handleNonExpr} ({\b AssertionInfo} const &info, {\b ResultWas::OfType} resultType, {\b AssertionReaction} &reaction)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b lastAssertionPassed} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b assertionPassed} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b getCurrentTestName} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b AssertionResult} * {\b getLastResult} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b exceptionEarlyReported} ()=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~IResultCapture\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:~IResultCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::IResultCapture::~IResultCapture (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v acquireGeneratorTracker\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:acquireGeneratorTracker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b IGeneratorTracker} * Catch::IResultCapture::acquireGeneratorTracker ({\b StringRef} generatorName, {\b SourceLineInfo} const & lineInfo){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v assertionPassed\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:assertionPassed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::assertionPassed (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkEnded\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:benchmarkEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::benchmarkEnded ({\b BenchmarkStats}<> const & stats){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkFailed\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:benchmarkFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::benchmarkFailed ({\b StringRef} error){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkPreparing\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:benchmarkPreparing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::benchmarkPreparing ({\b StringRef} name){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v benchmarkStarting\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:benchmarkStarting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::benchmarkStarting ({\b BenchmarkInfo} const & info){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v createGeneratorTracker\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:createGeneratorTracker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b IGeneratorTracker} * Catch::IResultCapture::createGeneratorTracker ({\b StringRef} generatorName, {\b SourceLineInfo} lineInfo, {\b Generators::GeneratorBasePtr} && generator){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v emplaceUnscopedMessage\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:emplaceUnscopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::emplaceUnscopedMessage ({\b MessageBuilder} && builder){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v exceptionEarlyReported\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:exceptionEarlyReported}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::exceptionEarlyReported (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getCurrentTestName\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:getCurrentTestName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string Catch::IResultCapture::getCurrentTestName () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getLastResult\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:getLastResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const {\b AssertionResult} * Catch::IResultCapture::getLastResult () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleExpr\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleExpr ({\b AssertionInfo} const & info, {\b ITransientExpression} const & expr, {\b AssertionReaction} & reaction){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleFatalErrorCondition\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleFatalErrorCondition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleFatalErrorCondition ({\b StringRef} message){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleIncomplete\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleIncomplete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleIncomplete ({\b AssertionInfo} const & info){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleMessage\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleMessage ({\b AssertionInfo} const & info, {\b ResultWas::OfType} resultType, {\b StringRef} message, {\b AssertionReaction} & reaction){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleNonExpr\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleNonExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleNonExpr ({\b AssertionInfo} const & info, {\b ResultWas::OfType} resultType, {\b AssertionReaction} & reaction){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleUnexpectedExceptionNotThrown\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleUnexpectedExceptionNotThrown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleUnexpectedExceptionNotThrown ({\b AssertionInfo} const & info, {\b AssertionReaction} & reaction){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v handleUnexpectedInflightException\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:handleUnexpectedInflightException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::handleUnexpectedInflightException ({\b AssertionInfo} const & info, std::string && message, {\b AssertionReaction} & reaction){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lastAssertionPassed\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:lastAssertionPassed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IResultCapture::lastAssertionPassed (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v notifyAssertionStarted\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:notifyAssertionStarted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::notifyAssertionStarted ({\b AssertionInfo} const & info){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v popScopedMessage\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:popScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::popScopedMessage ({\b MessageInfo} const & message){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pushScopedMessage\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:pushScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::pushScopedMessage ({\b MessageInfo} const & message){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionEnded\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:sectionEnded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::sectionEnded ({\b SectionEndInfo} && endInfo){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionEndedEarly\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:sectionEndedEarly}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::IResultCapture::sectionEndedEarly ({\b SectionEndInfo} && endInfo){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionStarted\:Catch::IResultCapture}
{\xe \v Catch::IResultCapture\:sectionStarted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool Catch::IResultCapture::sectionStarted ({\b StringRef} sectionName, {\b SourceLineInfo} const & sectionLineInfo, {\b Counts} & assertions){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::is_callable< T >\par \pard\plain 
{\tc\tcl2 \v Catch::is_callable< T >}
{\xe \v Catch::is_callable< T >}
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::is_callable< Fun(Args...)>\par \pard\plain 
{\tc\tcl2 \v Catch::is_callable< Fun(Args...)>}
{\xe \v Catch::is_callable< Fun(Args...)>}
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::is_callable_tester\par \pard\plain 
{\tc\tcl2 \v Catch::is_callable_tester}
{\xe \v Catch::is_callable_tester}
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun , typename... Args> static {\b true_given}< decltype(std::declval< Fun >()(std::declval< Args >()...))> {\b test} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... > static std::false_type {\b test} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v test\:Catch::is_callable_tester}
{\xe \v Catch::is_callable_tester\:test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... > static std::false_type Catch::is_callable_tester::test ( ...){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test\:Catch::is_callable_tester}
{\xe \v Catch::is_callable_tester\:test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun , typename... Args> static {\b true_given}< decltype(std::declval< Fun >()(std::declval< Args >()...))> Catch::is_callable_tester::test (int ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::is_range< T >\par \pard\plain 
{\tc\tcl2 \v Catch::is_range< T >}
{\xe \v Catch::is_range< T >}
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::is_range< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1is__range.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::is_range_impl< T, typename >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::is_range_impl< T, typename >}
{\xe \v Catch::Detail::is_range_impl< T, typename >}
{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::is_range_impl< T, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1is__range__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >}
{\xe \v Catch::Detail::is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >}
{\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1is__range__impl_3_01_t_00_01void__t_3_01decltype_07begin_07std_1_1dec681e5cda5b1af15a654a16d6f3e6af9b.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Detail::is_related< T, U >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::is_related< T, U >}
{\xe \v Catch::Benchmark::Detail::is_related< T, U >}
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Benchmark::Detail::is_related< T, U >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_benchmark_1_1_detail_1_1is__related.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::is_unary_function< F, typename >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::is_unary_function< F, typename >}
{\xe \v Catch::Clara::Detail::is_unary_function< F, typename >}
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::is_unary_function< F, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1is__unary__function.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >}
{\xe \v Catch::Clara::Detail::is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >}
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_clara_1_1_detail_1_1is__unary__function_3_01_f_00_01_catch_1_1_detail_1_1void__ceae41f2fd42d0f40903422d3a1f8f01.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Detail::IsStreamInsertable< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::IsStreamInsertable< T >}
{\xe \v Catch::Detail::IsStreamInsertable< T >}
{\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b value} = decltype(test<std::ostream, const T&>(0))::value\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v value\:Catch::Detail::IsStreamInsertable< T >}
{\xe \v Catch::Detail::IsStreamInsertable< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const bool {\b Catch::Detail::IsStreamInsertable}< T >::value = decltype(test<std::ostream, const T&>(0))::value{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ITestInvoker\par \pard\plain 
{\tc\tcl2 \v Catch::ITestInvoker}
{\xe \v Catch::ITestInvoker}
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::ITestInvoker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_i_test_invoker.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b invoke} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITestInvoker} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~ITestInvoker\:Catch::ITestInvoker}
{\xe \v Catch::ITestInvoker\:~ITestInvoker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ITestInvoker::~ITestInvoker (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::ITestInvoker}
{\xe \v Catch::ITestInvoker\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::ITestInvoker::invoke () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::TestInvokerAsMethod< C >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABGT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ITransientExpression\par \pard\plain 
{\tc\tcl2 \v Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression}
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::ITransientExpression:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_i_transient_expression.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b isBinaryExpression} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b getResult} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b streamReconstructedExpression} (std::ostream &os) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function {\b has}  to be overriden by the derived class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b ITransientExpression} (bool {\b isBinaryExpression}, bool result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} ({\b ITransientExpression} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} & {\b operator=} ({\b ITransientExpression} const &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ITransientExpression} ()=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &out, {\b ITransientExpression} const &expr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ITransientExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:ITransientExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ITransientExpression::ITransientExpression (bool isBinaryExpression, bool result){\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5299         :   m_isBinaryExpression( isBinaryExpression ),\par
5300             m_result( result )\par
5301         \{\}\par
}
}
{\xe \v ITransientExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:ITransientExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ITransientExpression::ITransientExpression (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ITransientExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:ITransientExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ITransientExpression::ITransientExpression ({\b ITransientExpression} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~ITransientExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:~ITransientExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ITransientExpression::~ITransientExpression (){\f2 [protected]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getResult\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:getResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::ITransientExpression::getResult () const -> bool {\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5294 \{ {\cf19 return} m_result; \}\par
}
}
{\xe \v isBinaryExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:isBinaryExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::ITransientExpression::isBinaryExpression () const -> bool {\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5293 \{ {\cf19 return} m_isBinaryExpression; \}\par
}
}
{\xe \v operator=\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ITransientExpression} & Catch::ITransientExpression::operator= ({\b ITransientExpression} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v streamReconstructedExpression\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:streamReconstructedExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::ITransientExpression::streamReconstructedExpression (std::ostream & os) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function {\b has}  to be overriden by the derived class. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3816                                \{\par
3817         {\cf20 // We can't make this function pure virtual to keep ITransientExpression}\par
3818         {\cf20 // constexpr, so we write error message instead}\par
3819         os << {\cf22 "Some class derived from ITransientExpression without overriding streamReconstructedExpression"};\par
3820     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<<\:Catch::ITransientExpression}
{\xe \v Catch::ITransientExpression\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream & out, {\b ITransientExpression} const & expr){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5307                                                                                          \{\par
5308             expr.streamReconstructedExpression(out);\par
5309             {\cf19 return} out;\par
5310         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::LambdaInvoker< ReturnType >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::LambdaInvoker< ReturnType >}
{\xe \v Catch::Clara::Detail::LambdaInvoker< ReturnType >}
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename L , typename ArgType > static auto {\b invoke} (L const &lambda, ArgType const &arg) -> {\b ParserResult}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::Clara::Detail::LambdaInvoker< ReturnType >}
{\xe \v Catch::Clara::Detail::LambdaInvoker< ReturnType >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ReturnType > template<typename L , typename ArgType > static auto {\b Catch::Clara::Detail::LambdaInvoker}< ReturnType >::invoke (L const & lambda, ArgType const & arg) -> {\b ParserResult} {\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4558                                     \{\par
4559                     {\cf19 return} lambda( arg );\par
4560                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::LambdaInvoker< void >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::LambdaInvoker< void >}
{\xe \v Catch::Clara::Detail::LambdaInvoker< void >}
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename L , typename ArgType > static auto {\b invoke} (L const &lambda, ArgType const &arg) -> {\b ParserResult}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::Clara::Detail::LambdaInvoker< void >}
{\xe \v Catch::Clara::Detail::LambdaInvoker< void >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename L , typename ArgType > static auto {\b Catch::Clara::Detail::LambdaInvoker}< void >::invoke (L const & lambda, ArgType const & arg) -> {\b ParserResult} {\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4566                                     \{\par
4567                     lambda( arg );\par
4568                     {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
4569                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::LazyExpression\par \pard\plain 
{\tc\tcl2 \v Catch::LazyExpression}
{\xe \v Catch::LazyExpression}
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LazyExpression} (bool isNegated)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LazyExpression} ({\b LazyExpression} const &other)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LazyExpression} & {\b operator=} ({\b LazyExpression} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AssertionHandler}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AssertionStats}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RunContext}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator<<} (std::ostream &os, {\b LazyExpression} const &lazyExpr) -> std::ostream &\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v LazyExpression\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:LazyExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::LazyExpression::LazyExpression (bool isNegated){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3287                                         :\par
3288             m_isNegated(isNegated)\par
3289         \{\}\par
}
}
{\xe \v LazyExpression\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:LazyExpression}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::LazyExpression::LazyExpression ({\b LazyExpression} const & other){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator bool\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::LazyExpression::operator bool () const{\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3293                                        \{\par
3294             {\cf19 return} m_transientExpression != {\cf17 nullptr};\par
3295         \}\par
}
}
{\xe \v operator=\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LazyExpression} & Catch::LazyExpression::operator= ({\b LazyExpression} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v AssertionHandler\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:AssertionHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b AssertionHandler}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v AssertionStats\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:AssertionStats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend struct AssertionStats{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto operator<< (std::ostream & os, {\b LazyExpression} const & lazyExpr) -> std::ostream&{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4607                                                                                      \{\par
4608         {\cf19 if} (lazyExpr.m_isNegated)\par
4609             os << {\cf23 '!'};\par
4610 \par
4611         {\cf19 if} (lazyExpr) \{\par
4612             {\cf19 if} (lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression())\par
4613                 os << {\cf23 '('} << *lazyExpr.m_transientExpression << {\cf23 ')'};\par
4614             {\cf19 else}\par
4615                 os << *lazyExpr.m_transientExpression;\par
4616         \} {\cf19 else} \{\par
4617             os << {\cf22 "\{** error - unchecked empty expression requested **\}"};\par
4618         \}\par
4619         {\cf19 return} os;\par
4620     \}\par
}
}
{\xe \v RunContext\:Catch::LazyExpression}
{\xe \v Catch::LazyExpression\:RunContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class RunContext{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Livro\par \pard\plain 
{\tc\tcl2 \v Livro}
{\xe \v Livro}
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
\par
{
{\f2 #include <Livro.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Livro} (int id, const string &titulo, const string &autor, const string &genero)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getId} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getTitulo} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getAutor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getGenero} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDisponivel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDisponivel} (bool disponivel)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Livro\:Livro}
{\xe \v Livro\:Livro}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Livro::Livro (int id, const string & titulo, const string & autor, const string & genero)}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7     : id({\cf18 id}), titulo(titulo), autor(autor), genero(genero), disponivel({\cf17 true}) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getAutor\:Livro}
{\xe \v Livro\:getAutor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Livro::getAutor () const}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 17                              \{\par
18     {\cf19 return} autor;\par
19 \}\par
}
}
{\xe \v getGenero\:Livro}
{\xe \v Livro\:getGenero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Livro::getGenero () const}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21                               \{\par
22     {\cf19 return} genero;\par
23 \}\par
}
}
{\xe \v getId\:Livro}
{\xe \v Livro\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Livro::getId () const}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9                        \{\par
10     {\cf19 return} id;\par
11 \}\par
}
}
{\xe \v getTitulo\:Livro}
{\xe \v Livro\:getTitulo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Livro::getTitulo () const}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                               \{\par
14     {\cf19 return} titulo;\par
15 \}\par
}
}
{\xe \v isDisponivel\:Livro}
{\xe \v Livro\:isDisponivel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Livro::isDisponivel () const}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25                                \{\par
26     {\cf19 return} disponivel;\par
27 \}\par
}
}
{\xe \v setDisponivel\:Livro}
{\xe \v Livro\:setDisponivel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Livro::setDisponivel (bool disponivel)}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 29                                          \{\par
30     this->disponivel = disponivel;\par
31 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b Livro.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Livro.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::make_void<... >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::make_void<... >}
{\xe \v Catch::Detail::make_void<... >}
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v type\:Catch::Detail::make_void<... >}
{\xe \v Catch::Detail::make_void<... >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... > using {\b Catch::Detail::make_void}<... >::type = void}}
\par
{\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::MapGenerator< T, U, Func >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::MapGenerator< T, U, Func >}
{\xe \v Catch::Generators::MapGenerator< T, U, Func >}
{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::MapGenerator< T, U, Func >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_map_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F2  = Func> {\b MapGenerator} (F2 &&function, {\b GeneratorWrapper}< U > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MapGenerator\:Catch::Generators::MapGenerator< T, U, Func >}
{\xe \v Catch::Generators::MapGenerator< T, U, Func >\:MapGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , typename Func > template<typename F2  = Func> {\b Catch::Generators::MapGenerator}< T, U, Func >::MapGenerator (F2 && function, {\b GeneratorWrapper}< U > && generator){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7791                                                                      :\par
7792             m_generator(CATCH_MOVE(generator)),\par
7793             m_function(CATCH_FORWARD(function)),\par
7794             m_cache(m_function(m_generator.get()))\par
7795         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::MapGenerator< T, U, Func >}
{\xe \v Catch::Generators::MapGenerator< T, U, Func >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , typename Func > T const  & {\b Catch::Generators::MapGenerator}< T, U, Func >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7797                                       \{\par
7798             {\cf19 return} m_cache;\par
7799         \}\par
}
}
{\xe \v next\:Catch::Generators::MapGenerator< T, U, Func >}
{\xe \v Catch::Generators::MapGenerator< T, U, Func >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , typename Func > bool {\b Catch::Generators::MapGenerator}< T, U, Func >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7800                              \{\par
7801             {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7802             {\cf19 if} (success) \{\par
7803                 m_cache = m_function(m_generator.get());\par
7804             \}\par
7805             {\cf19 return} success;\par
7806         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::MessageBuilder\par \pard\plain 
{\tc\tcl2 \v Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder}
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::MessageBuilder:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_message_builder.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageBuilder} ({\b StringRef} macroName, {\b SourceLineInfo} const &lineInfo, {\b ResultWas::OfType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b MessageBuilder} && {\b operator<<} (T const &{\b value}) &&\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::MessageStream}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b MessageStream} & {\b operator<<} (T const &{\b value})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageInfo} {\b m_info}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos P\'FAblicos herdados de {\b Catch::MessageStream}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReusableStringStream} {\b m_stream}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MessageBuilder\:Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder\:MessageBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::MessageBuilder::MessageBuilder ({\b StringRef} macroName, {\b SourceLineInfo} const & lineInfo, {\b ResultWas::OfType} type){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3976                                               :\par
3977             m_info(macroName, lineInfo, type) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<<\:Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b MessageBuilder} && Catch::MessageBuilder::operator<< (T const & value) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3980                                                            \{\par
3981             m_stream << value;\par
3982             {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
3983         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_info\:Catch::MessageBuilder}
{\xe \v Catch::MessageBuilder\:m_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageInfo} Catch::MessageBuilder::m_info}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::MessageInfo\par \pard\plain 
{\tc\tcl2 \v Catch::MessageInfo}
{\xe \v Catch::MessageInfo}
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageInfo} ({\b StringRef} _macroName, {\b SourceLineInfo} const &_lineInfo, {\b ResultWas::OfType} _type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b MessageInfo} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b MessageInfo} const &other) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b macroName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b message}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultWas::OfType} {\b type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b sequence}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v MessageInfo\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:MessageInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::MessageInfo::MessageInfo ({\b StringRef} _macroName, {\b SourceLineInfo} const & _lineInfo, {\b ResultWas::OfType} _type)}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4796     :   macroName( _macroName ),\par
4797         lineInfo( _lineInfo ),\par
4798         type( _type ),\par
4799         sequence( ++globalCount )\par
4800     \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::MessageInfo::operator< ({\b MessageInfo} const & other) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3943                                                          \{\par
3944             {\cf19 return} sequence < other.sequence;\par
3945         \}\par
}
}
{\xe \v operator==\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::MessageInfo::operator== ({\b MessageInfo} const & other) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3940                                                           \{\par
3941             {\cf19 return} sequence == other.sequence;\par
3942         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v lineInfo\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::MessageInfo::lineInfo}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v macroName\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:macroName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::MessageInfo::macroName}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v message\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::MessageInfo::message}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sequence\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Catch::MessageInfo::sequence}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:Catch::MessageInfo}
{\xe \v Catch::MessageInfo\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultWas::OfType} Catch::MessageInfo::type}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::MessageStream\par \pard\plain 
{\tc\tcl2 \v Catch::MessageStream}
{\xe \v Catch::MessageStream}
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::MessageStream:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_message_stream.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b MessageStream} & {\b operator<<} (T const &{\b value})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReusableStringStream} {\b m_stream}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<<\:Catch::MessageStream}
{\xe \v Catch::MessageStream\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b MessageStream} & Catch::MessageStream::operator<< (T const & value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3965                                                       \{\par
3966             m_stream << value;\par
3967             {\cf19 return} *{\cf17 this};\par
3968         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_stream\:Catch::MessageStream}
{\xe \v Catch::MessageStream\:m_stream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ReusableStringStream} Catch::MessageStream::m_stream}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::NameAndTags\par \pard\plain 
{\tc\tcl2 \v Catch::NameAndTags}
{\xe \v Catch::NameAndTags}
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b NameAndTags} ({\b StringRef} name_={\b StringRef}(), {\b StringRef} tags_={\b StringRef}()) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b tags}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v NameAndTags\:Catch::NameAndTags}
{\xe \v Catch::NameAndTags\:NameAndTags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::NameAndTags::NameAndTags ({\b StringRef} name_ = {\f2 {\b StringRef}()}, {\b StringRef} tags_ = {\f2 {\b StringRef}()}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6010                                                                    :\par
6011         name( name_ ), tags( tags_ ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v name\:Catch::NameAndTags}
{\xe \v Catch::NameAndTags\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::NameAndTags::name}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tags\:Catch::NameAndTags}
{\xe \v Catch::NameAndTags\:tags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::NameAndTags::tags}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Detail::negation< B >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::negation< B >}
{\xe \v Catch::Detail::negation< B >}
{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::negation< B >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_detail_1_1negation.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Detail::NonCopyable\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::NonCopyable}
{\xe \v Catch::Detail::NonCopyable}
{\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deriving classes become noncopyable and nonmovable. }}\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Detail::NonCopyable:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_detail_1_1_non_copyable.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deriving classes become noncopyable and nonmovable. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v NonCopyable\:Catch::Detail::NonCopyable}
{\xe \v Catch::Detail::NonCopyable\:NonCopyable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Detail::NonCopyable::NonCopyable (){\f2 [protected]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\xe \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObjectStorage} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObjectStorage} (const {\b ObjectStorage} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObjectStorage} ({\b ObjectStorage} &&other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ObjectStorage} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Args> void {\b construct} (Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool AllowManualDestruction = !Destruct> std::enable_if_t< AllowManualDestruction > {\b destruct} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ObjectStorage\:Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\xe \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\:ObjectStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool Destruct> {\b Catch::Benchmark::Detail::ObjectStorage}< T, Destruct >::ObjectStorage (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ObjectStorage\:Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\xe \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\:ObjectStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool Destruct> {\b Catch::Benchmark::Detail::ObjectStorage}< T, Destruct >::ObjectStorage (const {\b ObjectStorage}< T, Destruct > & other){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2226                 \{\par
2227                     {\cf17 new}(&data) T(other.stored_object());\par
2228                 \}\par
}
}
{\xe \v ObjectStorage\:Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\xe \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\:ObjectStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool Destruct> {\b Catch::Benchmark::Detail::ObjectStorage}< T, Destruct >::ObjectStorage ({\b ObjectStorage}< T, Destruct > && other){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2231                 \{\par
2232                     {\cf17 new}(data) T(CATCH_MOVE(other.stored_object()));\par
2233                 \}\par
}
}
{\xe \v ~ObjectStorage\:Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\xe \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\:~ObjectStorage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool Destruct> {\b Catch::Benchmark::Detail::ObjectStorage}< T, Destruct >::~{\b ObjectStorage} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2235 \{ destruct_on_exit<T>(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v construct\:Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\xe \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool Destruct> template<typename... Args> void {\b Catch::Benchmark::Detail::ObjectStorage}< T, Destruct >::construct (Args &&... args){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2239                 \{\par
2240                     {\cf17 new} (data) T(CATCH_FORWARD(args)...);\par
2241                 \}\par
}
}
{\xe \v destruct\:Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}
{\xe \v Catch::Benchmark::Detail::ObjectStorage< T, Destruct >\:destruct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool Destruct> template<bool AllowManualDestruction = !Destruct> std::enable_if_t< AllowManualDestruction > {\b Catch::Benchmark::Detail::ObjectStorage}< T, Destruct >::destruct (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2245                 \{\par
2246                     stored_object().~T();\par
2247                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Opt\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt}
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Opt:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_opt.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT > {\b Opt} (LambdaT const &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} (bool &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT , typename  = typename std::enable_if_t<                          Detail::is_unary_function<LambdaT>::value>> {\b Opt} (LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT > {\b Opt} ({\b accept_many_t}, LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if_t<                          !Detail::is_unary_function<T>::value>> {\b Opt} (T &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} & {\b operator[]} ({\b StringRef} optName) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} && {\b operator[]} ({\b StringRef} optName) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::HelpColumns} {\b getHelpColumns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isMatch} ({\b StringRef} optToken) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::InternalParseResult} {\b parse} (std::string const &, {\b Detail::TokenStream} tokens) const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::Result} {\b validate} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} ({\b accept_many_t}, LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (T &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} & {\b operator()} ({\b StringRef} description) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Opt} && {\b operator()} ({\b StringRef} description) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b optional} () -> {\b Opt} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b required} () -> {\b Opt} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isOptional} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b cardinality} () const -> size_t override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b hint} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ComposableParserImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator|} (T const &other) const -> {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} {\b operator|} (T const &other) const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ParserBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternalParseResult} {\b parse} ({\b Args} const &args) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b m_optNames}\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optionality} {\b m_optionality}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::shared_ptr< {\b BoundRef} > {\b m_ref}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_hint}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_description}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Clara::Detail::ParserRefImpl< Opt >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (std::shared_ptr< {\b BoundRef} > const &ref)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Opt\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:Opt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LambdaT > Catch::Clara::Opt::Opt (LambdaT const & ref){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4731                                              :\par
4732                 ParserRefImpl(\par
4733                     std::make_shared<Detail::BoundFlagLambda<LambdaT>>(ref)) \{\}\par
}
}
{\xe \v Opt\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:Opt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Opt::Opt (bool & ref){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2790                           :\par
2791             ParserRefImpl(std::make_shared<Detail::BoundFlagRef>(ref)) \{\}\par
}
}
{\xe \v Opt\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:Opt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LambdaT , typename  = typename std::enable_if_t<                          Detail::is_unary_function<LambdaT>::value>> Catch::Clara::Opt::Opt (LambdaT const & ref, {\b StringRef} hint){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4740                                                      :\par
4741                 ParserRefImpl( ref, hint ) \{\}\par
}
}
{\xe \v Opt\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:Opt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LambdaT > Catch::Clara::Opt::Opt ({\b accept_many_t} , LambdaT const & ref, {\b StringRef} hint){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4744                                                                     :\par
4745                 ParserRefImpl( accept_many, ref, hint ) \{\}\par
}
}
{\xe \v Opt\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:Opt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = typename std::enable_if_t<                          !Detail::is_unary_function<T>::value>> Catch::Clara::Opt::Opt (T & ref, {\b StringRef} hint){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4750                                          :\par
4751                 ParserRefImpl( ref, hint ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getHelpColumns\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:getHelpColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::HelpColumns} Catch::Clara::Opt::getHelpColumns () const}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2793                                                     \{\par
2794             ReusableStringStream oss;\par
2795             {\cf18 bool} first = {\cf17 true};\par
2796             {\cf19 for} ({\cf17 auto} {\cf17 const}& opt : m_optNames) \{\par
2797                 {\cf19 if} (first)\par
2798                     first = {\cf17 false};\par
2799                 {\cf19 else}\par
2800                     oss << {\cf22 ", "};\par
2801                 oss << opt;\par
2802             \}\par
2803             {\cf19 if} (!m_hint.empty())\par
2804                 oss << {\cf22 " <"} << m_hint << {\cf23 '>'};\par
2805             {\cf19 return} \{ oss.str(), m_description \};\par
2806         \}\par
}
}
{\xe \v isMatch\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:isMatch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::Clara::Opt::isMatch ({\b StringRef} optToken) const}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2808                                                   \{\par
2809             {\cf17 auto} normalisedToken = normaliseOpt(optToken);\par
2810             {\cf19 for} ({\cf17 auto} {\cf17 const}& name : m_optNames) \{\par
2811                 {\cf19 if} (normaliseOpt(name) == normalisedToken)\par
2812                     {\cf19 return} {\cf17 true};\par
2813             \}\par
2814             {\cf19 return} {\cf17 false};\par
2815         \}\par
}
}
{\xe \v operator[]\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Opt} & Catch::Clara::Opt::operator[] ({\b StringRef} optName) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4753                                                    \{\par
4754                 m_optNames.push_back(optName);\par
4755                 {\cf19 return} *{\cf17 this};\par
4756             \}\par
}
}
{\xe \v operator[]\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Opt} && Catch::Clara::Opt::operator[] ({\b StringRef} optName) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4757                                                      \{\par
4758                 m_optNames.push_back( optName );\par
4759                 {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
4760             \}\par
}
}
{\xe \v parse\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::InternalParseResult} Catch::Clara::Opt::parse (std::string const & , {\b Detail::TokenStream} tokens) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::ParserBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACAO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2818                                                                        \{\par
2819             {\cf17 auto} validationResult = validate();\par
2820             {\cf19 if} (!validationResult)\par
2821                 {\cf19 return} Detail::InternalParseResult(validationResult);\par
2822 \par
2823             {\cf19 if} (tokens &&\par
2824                 tokens->type == Detail::TokenType::Option) \{\par
2825                 {\cf17 auto} {\cf17 const}& token = *tokens;\par
2826                 {\cf19 if} (isMatch(token.token)) \{\par
2827                     {\cf19 if} (m_ref->isFlag()) \{\par
2828                         {\cf17 auto} flagRef =\par
2829                             {\cf17 static_cast<}Detail::BoundFlagRefBase*{\cf17 >}(\par
2830                                 m_ref.get());\par
2831                         {\cf17 auto} result = flagRef->setFlag({\cf17 true});\par
2832                         {\cf19 if} (!result)\par
2833                             {\cf19 return} Detail::InternalParseResult(result);\par
2834                         {\cf19 if} (result.value() ==\par
2835                             ParseResultType::ShortCircuitAll)\par
2836                             {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2837                                 result.value(), CATCH_MOVE(tokens)));\par
2838                     \} {\cf19 else} \{\par
2839                         {\cf17 auto} valueRef =\par
2840                             {\cf17 static_cast<}Detail::BoundValueRefBase*{\cf17 >}(\par
2841                                 m_ref.get());\par
2842                         ++tokens;\par
2843                         {\cf19 if} (!tokens)\par
2844                             {\cf19 return} Detail::InternalParseResult::runtimeError(\par
2845                                 {\cf22 "Expected argument following "} +\par
2846                                 token.token);\par
2847                         {\cf17 auto} {\cf17 const}& argToken = *tokens;\par
2848                         {\cf19 if} (argToken.type != Detail::TokenType::Argument)\par
2849                             {\cf19 return} Detail::InternalParseResult::runtimeError(\par
2850                                 {\cf22 "Expected argument following "} +\par
2851                                 token.token);\par
2852                         {\cf17 const} {\cf17 auto} result = valueRef->setValue({\cf17 static_cast<}std::string{\cf17 >}(argToken.token));\par
2853                         {\cf19 if} (!result)\par
2854                             {\cf19 return} Detail::InternalParseResult(result);\par
2855                         {\cf19 if} (result.value() ==\par
2856                             ParseResultType::ShortCircuitAll)\par
2857                             {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2858                                 result.value(), CATCH_MOVE(tokens)));\par
2859                     \}\par
2860                     {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2861                         ParseResultType::Matched, CATCH_MOVE(++tokens)));\par
2862                 \}\par
2863             \}\par
2864             {\cf19 return} Detail::InternalParseResult::ok(\par
2865                 Detail::ParseState(ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2866         \}\par
}
}
{\xe \v validate\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:validate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::Result} Catch::Clara::Opt::validate () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b Catch::Clara::Detail::ParserBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2868                                          \{\par
2869             {\cf19 if} (m_optNames.empty())\par
2870                 {\cf19 return} Detail::Result::logicError({\cf22 "No options supplied to Opt"});\par
2871             {\cf19 for} ({\cf17 auto} {\cf17 const}& name : m_optNames) \{\par
2872                 {\cf19 if} (name.empty())\par
2873                     {\cf19 return} Detail::Result::logicError(\par
2874                         {\cf22 "Option name cannot be empty"});\par
2875 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
2876                 {\cf19 if} (name[0] != {\cf23 '-'} && name[0] != {\cf23 '/'})\par
2877                     {\cf19 return} Detail::Result::logicError(\par
2878                         {\cf22 "Option name must begin with '-' or '/'"});\par
2879 {\cf21 #else}\par
2880                 {\cf19 if} (name[0] != {\cf23 '-'})\par
2881                     {\cf19 return} Detail::Result::logicError(\par
2882                         {\cf22 "Option name must begin with '-'"});\par
2883 {\cf21 #endif}\par
2884             \}\par
2885             {\cf19 return} ParserRefImpl::validate();\par
2886         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_optNames\:Catch::Clara::Opt}
{\xe \v Catch::Clara::Opt\:m_optNames}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b StringRef}> Catch::Clara::Opt::m_optNames{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Optional< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Optional< T >}
{\xe \v Catch::Optional< T >}
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Optional} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} (T const &_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} (T &&_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} & {\b operator=} (T const &_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} & {\b operator=} (T &&_value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} ({\b Optional} const &_other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} ({\b Optional} &&_other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} & {\b operator=} ({\b Optional} const &_other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional} & {\b operator=} ({\b Optional} &&_other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator*} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b operator*} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b operator->} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T * {\b operator->} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b valueOr} (T const &defaultValue) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b some} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b none} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b Optional} const &a, {\b Optional} const &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} ({\b Optional} const &a, {\b Optional} const &b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Optional\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:Optional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Optional}< T >::Optional (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3523 : nullableValue( {\cf17 nullptr} ) \{\}\par
}
}
{\xe \v ~Optional\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:~Optional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Optional}< T >::~{\b Optional} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3524 \{ reset(); \}\par
}
}
{\xe \v Optional\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:Optional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Optional}< T >::Optional (T const & _value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3526                                    :\par
3527             nullableValue( {\cf17 new} ( storage ) T( _value ) ) \{\}\par
}
}
{\xe \v Optional\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:Optional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Optional}< T >::Optional (T && _value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3528                               :\par
3529             nullableValue( {\cf17 new} ( storage ) T( CATCH_MOVE( _value ) ) ) \{\}\par
}
}
{\xe \v Optional\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:Optional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Optional}< T >::Optional ({\b Optional}< T > const & _other){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3542                                           :\par
3543             nullableValue( _other ? {\cf17 new} ( storage ) T( *_other ) : {\cf17 nullptr} ) \{\}\par
}
}
{\xe \v Optional\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:Optional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Optional}< T >::Optional ({\b Optional}< T > && _other){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3544                                      :\par
3545             nullableValue( _other ? {\cf17 new} ( storage ) T( CATCH_MOVE( *_other ) )\par
3546                                   : {\cf17 nullptr} ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v none\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:none}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Optional}< T >::none () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3592 \{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
}
}
{\xe \v operator bool\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Optional}< T >::operator bool () const{\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3595                                        \{\par
3596             {\cf19 return} some();\par
3597         \}\par
}
}
{\xe \v operator!\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Optional}< T >::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3594 \{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
}
}
{\xe \v operator*\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T & {\b Catch::Optional}< T >::operator* (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3570                        \{\par
3571             assert(nullableValue);\par
3572             {\cf19 return} *nullableValue;\par
3573         \}\par
}
}
{\xe \v operator*\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Optional}< T >::operator* () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3574                                    \{\par
3575             assert(nullableValue);\par
3576             {\cf19 return} *nullableValue;\par
3577         \}\par
}
}
{\xe \v operator->\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b Catch::Optional}< T >::operator-> (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3578                         \{\par
3579             assert(nullableValue);\par
3580             {\cf19 return} nullableValue;\par
3581         \}\par
}
}
{\xe \v operator->\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const T * {\b Catch::Optional}< T >::operator-> () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3582                                     \{\par
3583             assert(nullableValue);\par
3584             {\cf19 return} nullableValue;\par
3585         \}\par
}
}
{\xe \v operator=\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Optional} & {\b Catch::Optional}< T >::operator= ({\b Optional}< T > && _other){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3555                                                  \{\par
3556             {\cf19 if} ( &_other != {\cf17 this} ) \{\par
3557                 reset();\par
3558                 {\cf19 if} ( _other ) \{\par
3559                     nullableValue = {\cf17 new} ( storage ) T( CATCH_MOVE( *_other ) );\par
3560                 \}\par
3561             \}\par
3562             {\cf19 return} *{\cf17 this};\par
3563         \}\par
}
}
{\xe \v operator=\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Optional} & {\b Catch::Optional}< T >::operator= ({\b Optional}< T > const & _other){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3548                                                       \{\par
3549             {\cf19 if} ( &_other != {\cf17 this} ) \{\par
3550                 reset();\par
3551                 {\cf19 if} ( _other ) \{ nullableValue = {\cf17 new} ( storage ) T( *_other ); \}\par
3552             \}\par
3553             {\cf19 return} *{\cf17 this};\par
3554         \}\par
}
}
{\xe \v operator=\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Optional} & {\b Catch::Optional}< T >::operator= (T && _value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3536                                           \{\par
3537             reset();\par
3538             nullableValue = {\cf17 new} ( storage ) T( CATCH_MOVE( _value ) );\par
3539             {\cf19 return} *{\cf17 this};\par
3540         \}\par
}
}
{\xe \v operator=\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Optional} & {\b Catch::Optional}< T >::operator= (T const & _value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3531                                                \{\par
3532             reset();\par
3533             nullableValue = {\cf17 new} ( storage ) T( _value );\par
3534             {\cf19 return} *{\cf17 this};\par
3535         \}\par
}
}
{\xe \v reset\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b Catch::Optional}< T >::reset (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3565                      \{\par
3566             {\cf19 if} ( nullableValue ) \{ nullableValue->~T(); \}\par
3567             nullableValue = {\cf17 nullptr};\par
3568         \}\par
}
}
{\xe \v some\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:some}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Optional}< T >::some () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3591 \{ {\cf19 return} nullableValue != {\cf17 nullptr}; \}\par
}
}
{\xe \v valueOr\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:valueOr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b Catch::Optional}< T >::valueOr (T const & defaultValue) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3587                                                  \{\par
3588             {\cf19 return} nullableValue ? *nullableValue : defaultValue;\par
3589         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator!=\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b operator!}= ({\b Optional}< T > const & a, {\b Optional}< T > const & b){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3608                                                                      \{\par
3609             {\cf19 return} !( a == b );\par
3610         \}\par
}
}
{\xe \v operator==\:Catch::Optional< T >}
{\xe \v Catch::Optional< T >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool operator== ({\b Optional}< T > const & a, {\b Optional}< T > const & b){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3599                                                                      \{\par
3600             {\cf19 if} (a.none() && b.none()) \{\par
3601                 {\cf19 return} {\cf17 true};\par
3602             \} {\cf19 else} {\cf19 if} (a.some() && b.some()) \{\par
3603                 {\cf19 return} *a == *b;\par
3604             \} {\cf19 else} \{\par
3605                 {\cf19 return} {\cf17 false};\par
3606             \}\par
3607         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::OutlierClassification\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::OutlierClassification}
{\xe \v Catch::Benchmark::OutlierClassification}
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b total} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b samples_seen} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b low_severe} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b low_mild} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b high_mild} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b high_severe} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v total\:Catch::Benchmark::OutlierClassification}
{\xe \v Catch::Benchmark::OutlierClassification\:total}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::OutlierClassification::total () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1305                               \{\par
1306                 {\cf19 return} low_severe + low_mild + high_mild + high_severe;\par
1307             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v high_mild\:Catch::Benchmark::OutlierClassification}
{\xe \v Catch::Benchmark::OutlierClassification\:high_mild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::OutlierClassification::high_mild = 0}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v high_severe\:Catch::Benchmark::OutlierClassification}
{\xe \v Catch::Benchmark::OutlierClassification\:high_severe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::OutlierClassification::high_severe = 0}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v low_mild\:Catch::Benchmark::OutlierClassification}
{\xe \v Catch::Benchmark::OutlierClassification\:low_mild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::OutlierClassification::low_mild = 0}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v low_severe\:Catch::Benchmark::OutlierClassification}
{\xe \v Catch::Benchmark::OutlierClassification\:low_severe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::OutlierClassification::low_severe = 0}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v samples_seen\:Catch::Benchmark::OutlierClassification}
{\xe \v Catch::Benchmark::OutlierClassification\:samples_seen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Benchmark::OutlierClassification::samples_seen = 0}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Parser\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser}
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Parser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_parser.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator|=} ({\b ExeName} const &exeName) -> {\b Parser} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator|=} ({\b Arg} const &arg) -> {\b Parser} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} & {\b operator|=} ({\b Parser} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Detail::HelpColumns} > {\b getHelpColumns} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b writeToStream} (std::ostream &os) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::Result} {\b validate} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::InternalParseResult} {\b parse} (std::string const &exeName, {\b Detail::TokenStream} tokens) const override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} & {\b operator|=} ({\b Parser} &{\b p}, {\b Opt} const &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Parser} & {\b operator|=} ({\b Parser} &{\b p}, {\b Opt} &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Parser} {\b operator|} ({\b Parser} const &{\b p}, T &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Parser} {\b operator|} ({\b Parser} &&{\b p}, T &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator<<} (std::ostream &os, {\b Parser} const &parser) -> std::ostream &\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getHelpColumns\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:getHelpColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b Detail::HelpColumns} > Catch::Clara::Parser::getHelpColumns () const}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2927                                                                   \{\par
2928             std::vector<Detail::HelpColumns> cols;\par
2929             cols.reserve( m_options.size() );\par
2930             {\cf19 for} ( {\cf17 auto} {\cf17 const}& o : m_options ) \{\par
2931                 cols.push_back(o.getHelpColumns());\par
2932             \}\par
2933             {\cf19 return} cols;\par
2934         \}\par
}
}
{\xe \v operator|=\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Clara::Parser::operator|= ({\b Arg} const & arg) -> {\b Parser}& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4813                                                        \{\par
4814                 m_args.push_back(arg);\par
4815                 {\cf19 return} *{\cf17 this};\par
4816             \}\par
}
}
{\xe \v operator|=\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Clara::Parser::operator|= ({\b ExeName} const & exeName) -> {\b Parser}& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4808                                                                \{\par
4809                 m_exeName = exeName;\par
4810                 {\cf19 return} *{\cf17 this};\par
4811             \}\par
}
}
{\xe \v operator|=\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Parser} & Catch::Clara::Parser::operator|= ({\b Parser} const & other)}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2918                                                         \{\par
2919             m_options.insert( m_options.end(),\par
2920                               other.m_options.begin(),\par
2921                               other.m_options.end() );\par
2922             m_args.insert(\par
2923                 m_args.end(), other.m_args.begin(), other.m_args.end() );\par
2924             {\cf19 return} *{\cf17 this};\par
2925         \}\par
}
}
{\xe \v parse\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::InternalParseResult} Catch::Clara::Parser::parse (std::string const & exeName, {\b Detail::TokenStream} tokens) const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Clara::Detail::ParserBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACAO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2996                                                         \{\par
2997 \par
2998             {\cf17 struct }ParserInfo \{\par
2999                 ParserBase {\cf17 const}* parser = {\cf17 nullptr};\par
3000                 {\cf18 size_t} count = 0;\par
3001             \};\par
3002             std::vector<ParserInfo> parseInfos;\par
3003             parseInfos.reserve( m_options.size() + m_args.size() );\par
3004             {\cf19 for} ( {\cf17 auto} {\cf17 const}& opt : m_options ) \{\par
3005                 parseInfos.push_back( \{ &opt, 0 \} );\par
3006             \}\par
3007             {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
3008                 parseInfos.push_back( \{ &arg, 0 \} );\par
3009             \}\par
3010 \par
3011             m_exeName.set( exeName );\par
3012 \par
3013             {\cf17 auto} result = Detail::InternalParseResult::ok(\par
3014                 Detail::ParseState( ParseResultType::NoMatch, CATCH_MOVE(tokens) ) );\par
3015             {\cf19 while} ( result.value().remainingTokens() ) \{\par
3016                 {\cf18 bool} tokenParsed = {\cf17 false};\par
3017 \par
3018                 {\cf19 for} ( {\cf17 auto}& parseInfo : parseInfos ) \{\par
3019                     {\cf19 if} ( parseInfo.parser->cardinality() == 0 ||\par
3020                          parseInfo.count < parseInfo.parser->cardinality() ) \{\par
3021                         result = parseInfo.parser->parse(\par
3022                             exeName, CATCH_MOVE(result).value().remainingTokens() );\par
3023                         {\cf19 if} ( !result )\par
3024                             {\cf19 return} result;\par
3025                         {\cf19 if} ( result.value().type() !=\par
3026                              ParseResultType::NoMatch ) \{\par
3027                             tokenParsed = {\cf17 true};\par
3028                             ++parseInfo.count;\par
3029                             {\cf19 break};\par
3030                         \}\par
3031                     \}\par
3032                 \}\par
3033 \par
3034                 {\cf19 if} ( result.value().type() == ParseResultType::ShortCircuitAll )\par
3035                     {\cf19 return} result;\par
3036                 {\cf19 if} ( !tokenParsed )\par
3037                     {\cf19 return} Detail::InternalParseResult::runtimeError(\par
3038                         {\cf22 "Unrecognised token: "} +\par
3039                         result.value().remainingTokens()->token );\par
3040             \}\par
3041             {\cf20 // !TBD Check missing required options}\par
3042             {\cf19 return} result;\par
3043         \}\par
}
}
{\xe \v validate\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:validate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Detail::Result} Catch::Clara::Parser::validate () const{\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b Catch::Clara::Detail::ParserBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACBO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2980                                             \{\par
2981             {\cf19 for} ( {\cf17 auto} {\cf17 const}& opt : m_options ) \{\par
2982                 {\cf17 auto} result = opt.validate();\par
2983                 {\cf19 if} ( !result )\par
2984                     {\cf19 return} result;\par
2985             \}\par
2986             {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
2987                 {\cf17 auto} result = arg.validate();\par
2988                 {\cf19 if} ( !result )\par
2989                     {\cf19 return} result;\par
2990             \}\par
2991             {\cf19 return} Detail::Result::ok();\par
2992         \}\par
}
}
{\xe \v writeToStream\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:writeToStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Clara::Parser::writeToStream (std::ostream & os) const}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2936                                                          \{\par
2937             {\cf19 if} ( !m_exeName.name().empty() ) \{\par
2938                 os << {\cf22 "usage:\\n"}\par
2939                    << {\cf22 "  "} << m_exeName.name() << {\cf23 ' '};\par
2940                 {\cf18 bool} required = {\cf17 true}, first = {\cf17 true};\par
2941                 {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
2942                     {\cf19 if} ( first )\par
2943                         first = {\cf17 false};\par
2944                     {\cf19 else}\par
2945                         os << {\cf23 ' '};\par
2946                     {\cf19 if} ( arg.isOptional() && required ) \{\par
2947                         os << {\cf23 '['};\par
2948                         required = {\cf17 false};\par
2949                     \}\par
2950                     os << {\cf23 '<'} << arg.hint() << {\cf23 '>'};\par
2951                     {\cf19 if} ( arg.cardinality() == 0 )\par
2952                         os << {\cf22 " ... "};\par
2953                 \}\par
2954                 {\cf19 if} ( !required )\par
2955                     os << {\cf23 ']'};\par
2956                 {\cf19 if} ( !m_options.empty() )\par
2957                     os << {\cf22 " options"};\par
2958                 os << {\cf22 "\\n\\nwhere options are:\\n"};\par
2959             \}\par
2960 \par
2961             {\cf17 auto} rows = getHelpColumns();\par
2962             {\cf18 size_t} consoleWidth = CATCH_CONFIG_CONSOLE_WIDTH;\par
2963             {\cf18 size_t} optWidth = 0;\par
2964             {\cf19 for} ( {\cf17 auto} {\cf17 const}& cols : rows )\par
2965                 optWidth = ( std::max )( optWidth, cols.left.size() + 2 );\par
2966 \par
2967             optWidth = ( std::min )( optWidth, consoleWidth / 2 );\par
2968 \par
2969             {\cf19 for} ( {\cf17 auto}& cols : rows ) \{\par
2970                 {\cf17 auto} row = TextFlow::Column( CATCH_MOVE(cols.left) )\par
2971                                .width( optWidth )\par
2972                                .indent( 2 ) +\par
2973                            TextFlow::Spacer( 4 ) +\par
2974                            TextFlow::Column( {\cf17 static_cast<}std::string{\cf17 >}(cols.descriptions) )\par
2975                                .width( consoleWidth - 7 - optWidth );\par
2976                 os << row << {\cf23 '\\n'};\par
2977             \}\par
2978         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<<\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto operator<< (std::ostream & os, {\b Parser} const & parser) -> std::ostream& {\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4847                                \{\par
4848                 parser.writeToStream(os);\par
4849                 {\cf19 return} os;\par
4850             \}\par
}
}
{\xe \v operator|\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Parser} operator| ({\b Parser} && p, T && rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4837                                                            \{\par
4838                 p |= CATCH_FORWARD(rhs);\par
4839                 {\cf19 return} CATCH_MOVE(p);\par
4840             \}\par
}
}
{\xe \v operator|\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Parser} operator| ({\b Parser} const & p, T && rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4830                                                                 \{\par
4831                 Parser temp( p );\par
4832                 temp |= rhs;\par
4833                 {\cf19 return} temp;\par
4834             \}\par
}
}
{\xe \v operator|=\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Parser} & operator|= ({\b Parser} & p, {\b Opt} && opt){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4822                                                               \{\par
4823                 p.m_options.push_back( CATCH_MOVE(opt) );\par
4824                 {\cf19 return} p;\par
4825             \}\par
}
}
{\xe \v operator|=\:Catch::Clara::Parser}
{\xe \v Catch::Clara::Parser\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Parser} & operator|= ({\b Parser} & p, {\b Opt} const & opt){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4818                                                                    \{\par
4819                 p.m_options.push_back( opt );\par
4820                 {\cf19 return} p;\par
4821             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Detail::ParserBase\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::ParserBase}
{\xe \v Catch::Clara::Detail::ParserBase}
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::ParserBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_detail_1_1_parser_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ParserBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b validate} () const -> {\b Result}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b parse} (std::string const &exeName, {\b TokenStream} tokens) const -> {\b InternalParseResult}=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b cardinality} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternalParseResult} {\b parse} ({\b Args} const &args) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ~ParserBase\:Catch::Clara::Detail::ParserBase}
{\xe \v Catch::Clara::Detail::ParserBase\:~ParserBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Catch::Clara::Detail::ParserBase::~ParserBase (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v cardinality\:Catch::Clara::Detail::ParserBase}
{\xe \v Catch::Clara::Detail::ParserBase\:cardinality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Catch::Clara::Detail::ParserBase::cardinality () const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b Catch::Clara::Detail::ParserRefImpl< DerivedT >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFH \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Clara::Detail::ParserRefImpl< Arg >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFH \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Clara::Detail::ParserRefImpl< Opt >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2741 \{ {\cf19 return} 1; \}\par
}
}
{\xe \v parse\:Catch::Clara::Detail::ParserBase}
{\xe \v Catch::Clara::Detail::ParserBase\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b InternalParseResult} Catch::Clara::Detail::ParserBase::parse ({\b Args} const & args) const}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2743                                                                           \{\par
2744                 {\cf19 return} parse( {\cf17 static_cast<}std::string{\cf17 >}(args.exeName()), TokenStream( args ) );\par
2745             \}\par
}
}
{\xe \v parse\:Catch::Clara::Detail::ParserBase}
{\xe \v Catch::Clara::Detail::ParserBase\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual auto Catch::Clara::Detail::ParserBase::parse (std::string const & exeName, {\b TokenStream} tokens) const ->  {\b InternalParseResult}{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Clara::Arg} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACAN \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Clara::ExeName} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACAY \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b Catch::Clara::Opt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACBM \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Clara::Parser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACBV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v validate\:Catch::Clara::Detail::ParserBase}
{\xe \v Catch::Clara::Detail::ParserBase\:validate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual auto Catch::Clara::Detail::ParserBase::validate () const -> {\b Result} {\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementado por {\b Catch::Clara::Opt} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACBN \\*MERGEFORMAT}{\fldrslt pagenum}}}) e {\b Catch::Clara::Parser} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACBW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4627 \{ {\cf19 return} Result::ok(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Clara::Detail::ParserRefImpl< DerivedT >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::ParserRefImpl< DerivedT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_detail_1_1_parser_ref_impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT > {\b ParserRefImpl} ({\b accept_many_t}, LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename  = typename std::enable_if_t<                              !Detail::is_unary_function<T>::value>> {\b ParserRefImpl} (T &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LambdaT , typename  = typename std::enable_if_t<                              Detail::is_unary_function<LambdaT>::value>> {\b ParserRefImpl} (LambdaT const &ref, {\b StringRef} {\b hint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DerivedT & {\b operator()} ({\b StringRef} description) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DerivedT && {\b operator()} ({\b StringRef} description) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b optional} () -> DerivedT &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b required} () -> DerivedT &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b isOptional} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b cardinality} () const -> size_t override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b hint} () const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ComposableParserImpl< DerivedT >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator|} (T const &other) const -> {\b Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b Parser} {\b operator|} (T const &other) const\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Clara::Detail::ParserBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ParserBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b validate} () const -> {\b Result}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual auto {\b parse} (std::string const &exeName, {\b TokenStream} tokens) const -> {\b InternalParseResult}=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternalParseResult} {\b parse} ({\b Args} const &args) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserRefImpl} (std::shared_ptr< {\b BoundRef} > const &ref)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optionality} {\b m_optionality} = {\b Optionality::Optional}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::shared_ptr< {\b BoundRef} > {\b m_ref}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_hint}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b m_description}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ParserRefImpl\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:ParserRefImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::ParserRefImpl (std::shared_ptr< {\b BoundRef} > const & ref){\f2 [inline]}, {\f2 [explicit]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4652                                                                             :\par
4653                     m_ref( ref ) \{\}\par
}
}
{\xe \v ParserRefImpl\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:ParserRefImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > template<typename LambdaT > {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::ParserRefImpl ({\b accept_many_t} , LambdaT const & ref, {\b StringRef} hint){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4659                                                :\par
4660                     m_ref( std::make_shared<BoundManyLambda<LambdaT>>( ref ) ),\par
4661                     m_hint( hint ) \{\}\par
}
}
{\xe \v ParserRefImpl\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:ParserRefImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > template<typename T , typename  = typename std::enable_if_t<                              !Detail::is_unary_function<T>::value>> {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::ParserRefImpl (T & ref, {\b StringRef} hint){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4666                                                        :\par
4667                     m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\par
4668                     m_hint( hint ) \{\}\par
}
}
{\xe \v ParserRefImpl\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:ParserRefImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > template<typename LambdaT , typename  = typename std::enable_if_t<                              Detail::is_unary_function<LambdaT>::value>> {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::ParserRefImpl (LambdaT const & ref, {\b StringRef} hint){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4673                                                                    :\par
4674                     m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\par
4675                     m_hint( hint ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v cardinality\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:cardinality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > auto {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::cardinality () const -> size_t{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplementa {\b Catch::Clara::Detail::ParserBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4700                                                             \{\par
4701                     {\cf19 if} ( m_ref->isContainer() )\par
4702                         {\cf19 return} 0;\par
4703                     {\cf19 else}\par
4704                         {\cf19 return} 1;\par
4705                 \}\par
}
}
{\xe \v hint\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:hint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > {\b StringRef} {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::hint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4707 \{ {\cf19 return} m_hint; \}\par
}
}
{\xe \v isOptional\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:isOptional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > auto {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::isOptional () const -> bool {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4696                                                 \{\par
4697                     {\cf19 return} m_optionality == Optionality::Optional;\par
4698                 \}\par
}
}
{\xe \v operator()\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > DerivedT & {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::operator() ({\b StringRef} description) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4677                                                                 \{\par
4678                     m_description = description;\par
4679                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4680                 \}\par
}
}
{\xe \v operator()\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > DerivedT && {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::operator() ({\b StringRef} description) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4681                                                                   \{\par
4682                     m_description = description;\par
4683                     {\cf19 return} {\cf17 static_cast<}DerivedT&&{\cf17 >}( *this );\par
4684                 \}\par
}
}
{\xe \v optional\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:optional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > auto {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::optional () -> DerivedT& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4686                                              \{\par
4687                     m_optionality = Optionality::Optional;\par
4688                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4689                 \}\par
}
}
{\xe \v required\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:required}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > auto {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::required () -> DerivedT& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4691                                              \{\par
4692                     m_optionality = Optionality::Required;\par
4693                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4694                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_description\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:m_description}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > {\b StringRef} {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::m_description{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_hint\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:m_hint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > {\b StringRef} {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::m_hint{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_optionality\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:m_optionality}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > {\b Optionality} {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::m_optionality = {\b Optionality::Optional}{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_ref\:Catch::Clara::Detail::ParserRefImpl< DerivedT >}
{\xe \v Catch::Clara::Detail::ParserRefImpl< DerivedT >\:m_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename DerivedT > std::shared_ptr<{\b BoundRef}> {\b Catch::Clara::Detail::ParserRefImpl}< DerivedT >::m_ref{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Detail::ParseState\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::ParseState}
{\xe \v Catch::Clara::Detail::ParseState}
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParseState} ({\b ParseResultType} {\b type}, {\b TokenStream} {\b remainingTokens})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParseResultType} {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TokenStream} const & {\b remainingTokens} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TokenStream} && {\b remainingTokens} () &&\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ParseState\:Catch::Clara::Detail::ParseState}
{\xe \v Catch::Clara::Detail::ParseState\:ParseState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ParseState::ParseState ({\b ParseResultType} type, {\b TokenStream} remainingTokens)}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2748                                                                  :\par
2749                 m_type( type ), m_remainingTokens( CATCH_MOVE(remainingTokens) ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v remainingTokens\:Catch::Clara::Detail::ParseState}
{\xe \v Catch::Clara::Detail::ParseState\:remainingTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TokenStream} && Catch::Clara::Detail::ParseState::remainingTokens () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4454                                                    \{\par
4455                     {\cf19 return} CATCH_MOVE( m_remainingTokens );\par
4456                 \}\par
}
}
{\xe \v remainingTokens\:Catch::Clara::Detail::ParseState}
{\xe \v Catch::Clara::Detail::ParseState\:remainingTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TokenStream} const  & Catch::Clara::Detail::ParseState::remainingTokens () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4451                                                             \{\par
4452                     {\cf19 return} m_remainingTokens;\par
4453                 \}\par
}
}
{\xe \v type\:Catch::Clara::Detail::ParseState}
{\xe \v Catch::Clara::Detail::ParseState\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ParseResultType} Catch::Clara::Detail::ParseState::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4450 \{ {\cf19 return} m_type; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Generators::RandomFloatingGenerator::PImpl\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::RandomFloatingGenerator::PImpl}
{\xe \v Catch::Generators::RandomFloatingGenerator::PImpl}
{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PImpl} (long double a, long double b, uint32_t seed)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Catch::SimplePcg32} {\b rng}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uniform_real_distribution< long double > {\b dist}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v PImpl\:Catch::Generators::RandomFloatingGenerator::PImpl}
{\xe \v Catch::Generators::RandomFloatingGenerator::PImpl\:PImpl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Generators::RandomFloatingGenerator::PImpl::PImpl (long double a, long double b, uint32_t seed){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2338                                                                 :\par
2339                 rng( seed ), dist( a, b ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v dist\:Catch::Generators::RandomFloatingGenerator::PImpl}
{\xe \v Catch::Generators::RandomFloatingGenerator::PImpl\:dist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uniform_real_distribution<long double> Catch::Generators::RandomFloatingGenerator::PImpl::dist}}
\par
{\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rng\:Catch::Generators::RandomFloatingGenerator::PImpl}
{\xe \v Catch::Generators::RandomFloatingGenerator::PImpl\:rng}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Catch::SimplePcg32} Catch::Generators::RandomFloatingGenerator::PImpl::rng}}
\par
{\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ProcessedReporterSpec\par \pard\plain 
{\tc\tcl2 \v Catch::ProcessedReporterSpec}
{\xe \v Catch::ProcessedReporterSpec}
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b outputFilename}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ColourMode} {\b colourMode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, std::string > {\b customOptions}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b ProcessedReporterSpec} const &lhs, {\b ProcessedReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} ({\b ProcessedReporterSpec} const &lhs, {\b ProcessedReporterSpec} const &rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 {\b ReporterSpec}}  but with the defaults filled in.\par
Like {\f2 {\b ReporterSpec}} , the semantics are unchecked. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator!=\:Catch::ProcessedReporterSpec}
{\xe \v Catch::ProcessedReporterSpec\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= ({\b ProcessedReporterSpec} const & lhs, {\b ProcessedReporterSpec} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3741                                                                    \{\par
3742             {\cf19 return} !( lhs == rhs );\par
3743         \}\par
}
}
{\xe \v operator==\:Catch::ProcessedReporterSpec}
{\xe \v Catch::ProcessedReporterSpec\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== ({\b ProcessedReporterSpec} const & lhs, {\b ProcessedReporterSpec} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 788                                                         \{\par
789         {\cf19 return} lhs.name == rhs.name &&\par
790                lhs.outputFilename == rhs.outputFilename &&\par
791                lhs.colourMode == rhs.colourMode &&\par
792                lhs.customOptions == rhs.customOptions;\par
793     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v colourMode\:Catch::ProcessedReporterSpec}
{\xe \v Catch::ProcessedReporterSpec\:colourMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ColourMode} Catch::ProcessedReporterSpec::colourMode}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v customOptions\:Catch::ProcessedReporterSpec}
{\xe \v Catch::ProcessedReporterSpec\:customOptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<std::string, std::string> Catch::ProcessedReporterSpec::customOptions}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::ProcessedReporterSpec}
{\xe \v Catch::ProcessedReporterSpec\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::ProcessedReporterSpec::name}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outputFilename\:Catch::ProcessedReporterSpec}
{\xe \v Catch::ProcessedReporterSpec\:outputFilename}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::ProcessedReporterSpec::outputFilename}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::ratio_string< Ratio >\par \pard\plain 
{\tc\tcl2 \v Catch::ratio_string< Ratio >}
{\xe \v Catch::ratio_string< Ratio >}
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b symbol} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v symbol\:Catch::ratio_string< Ratio >}
{\xe \v Catch::ratio_string< Ratio >\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Ratio > static std::string {\b Catch::ratio_string}< Ratio >::symbol (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2972                               \{\par
2973         Catch::ReusableStringStream rss;\par
2974         rss << {\cf23 '['} << Ratio::num << {\cf23 '/'}\par
2975             << Ratio::den << {\cf23 ']'};\par
2976         {\cf19 return} rss.str();\par
2977     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ratio_string< std::atto >\par \pard\plain 
{\tc\tcl2 \v Catch::ratio_string< std::atto >}
{\xe \v Catch::ratio_string< std::atto >}
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b symbol} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v symbol\:Catch::ratio_string< std::atto >}
{\xe \v Catch::ratio_string< std::atto >\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char {\b Catch::ratio_string}< std::atto >::symbol (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2982 \{ {\cf19 return} {\cf23 'a'}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ratio_string< std::femto >\par \pard\plain 
{\tc\tcl2 \v Catch::ratio_string< std::femto >}
{\xe \v Catch::ratio_string< std::femto >}
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b symbol} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v symbol\:Catch::ratio_string< std::femto >}
{\xe \v Catch::ratio_string< std::femto >\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char {\b Catch::ratio_string}< std::femto >::symbol (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2986 \{ {\cf19 return} {\cf23 'f'}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ratio_string< std::micro >\par \pard\plain 
{\tc\tcl2 \v Catch::ratio_string< std::micro >}
{\xe \v Catch::ratio_string< std::micro >}
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b symbol} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v symbol\:Catch::ratio_string< std::micro >}
{\xe \v Catch::ratio_string< std::micro >\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char {\b Catch::ratio_string}< std::micro >::symbol (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2998 \{ {\cf19 return} {\cf23 'u'}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ratio_string< std::milli >\par \pard\plain 
{\tc\tcl2 \v Catch::ratio_string< std::milli >}
{\xe \v Catch::ratio_string< std::milli >}
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b symbol} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v symbol\:Catch::ratio_string< std::milli >}
{\xe \v Catch::ratio_string< std::milli >\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char {\b Catch::ratio_string}< std::milli >::symbol (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3002 \{ {\cf19 return} {\cf23 'm'}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ratio_string< std::nano >\par \pard\plain 
{\tc\tcl2 \v Catch::ratio_string< std::nano >}
{\xe \v Catch::ratio_string< std::nano >}
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b symbol} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v symbol\:Catch::ratio_string< std::nano >}
{\xe \v Catch::ratio_string< std::nano >\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char {\b Catch::ratio_string}< std::nano >::symbol (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2994 \{ {\cf19 return} {\cf23 'n'}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ratio_string< std::pico >\par \pard\plain 
{\tc\tcl2 \v Catch::ratio_string< std::pico >}
{\xe \v Catch::ratio_string< std::pico >}
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b symbol} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v symbol\:Catch::ratio_string< std::pico >}
{\xe \v Catch::ratio_string< std::pico >\:symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char {\b Catch::ratio_string}< std::pico >::symbol (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2990 \{ {\cf19 return} {\cf23 'p'}; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::RegistrarForTagAliases\par \pard\plain 
{\tc\tcl2 \v Catch::RegistrarForTagAliases}
{\xe \v Catch::RegistrarForTagAliases}
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RegistrarForTagAliases} (char const *alias, char const *tag, {\b SourceLineInfo} const &lineInfo)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v RegistrarForTagAliases\:Catch::RegistrarForTagAliases}
{\xe \v Catch::RegistrarForTagAliases\:RegistrarForTagAliases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::RegistrarForTagAliases::RegistrarForTagAliases (char const * alias, char const * tag, {\b SourceLineInfo} const & lineInfo)}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1500                                                                                                                      \{\par
1501         CATCH_TRY \{\par
1502             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);\par
1503         \} CATCH_CATCH_ALL \{\par
1504             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
1505             getMutableRegistryHub().registerStartupException();\par
1506         \}\par
1507     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Detail::repeater< Fun >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::repeater< Fun >}
{\xe \v Catch::Benchmark::Detail::repeater< Fun >}
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (int k) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fun {\b fun}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator()\:Catch::Benchmark::Detail::repeater< Fun >}
{\xe \v Catch::Benchmark::Detail::repeater< Fun >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun > void {\b Catch::Benchmark::Detail::repeater}< Fun >::operator() (int k) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1671                                              \{\par
1672                     {\cf19 for} ({\cf18 int} i = 0; i < k; ++i) \{\par
1673                         fun();\par
1674                     \}\par
1675                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v fun\:Catch::Benchmark::Detail::repeater< Fun >}
{\xe \v Catch::Benchmark::Detail::repeater< Fun >\:fun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Fun > Fun {\b Catch::Benchmark::Detail::repeater}< Fun >::fun}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::RepeatGenerator< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::RepeatGenerator< T >}
{\xe \v Catch::Generators::RepeatGenerator< T >}
{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::RepeatGenerator< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_repeat_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RepeatGenerator} (size_t repeats, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v RepeatGenerator\:Catch::Generators::RepeatGenerator< T >}
{\xe \v Catch::Generators::RepeatGenerator< T >\:RepeatGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::RepeatGenerator}< T >::RepeatGenerator (size_t repeats, {\b GeneratorWrapper}< T > && generator){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7737                                                                         :\par
7738             m_generator(CATCH_MOVE(generator)),\par
7739             m_target_repeats(repeats)\par
7740         \{\par
7741             assert(m_target_repeats > 0 && {\cf22 "Repeat generator must repeat at least once"});\par
7742         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::RepeatGenerator< T >}
{\xe \v Catch::Generators::RepeatGenerator< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Generators::RepeatGenerator}< T >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7744                                       \{\par
7745             {\cf19 if} (m_current_repeat == 0) \{\par
7746                 m_returned.push_back(m_generator.get());\par
7747                 {\cf19 return} m_returned.back();\par
7748             \}\par
7749             {\cf19 return} m_returned[m_repeat_index];\par
7750         \}\par
}
}
{\xe \v next\:Catch::Generators::RepeatGenerator< T >}
{\xe \v Catch::Generators::RepeatGenerator< T >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Generators::RepeatGenerator}< T >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7752                              \{\par
7753             {\cf20 // There are 2 basic cases:}\par
7754             {\cf20 // 1) We are still reading the generator}\par
7755             {\cf20 // 2) We are reading our own cache}\par
7756 \par
7757             {\cf20 // In the first case, we need to poke the underlying generator.}\par
7758             {\cf20 // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache}\par
7759             {\cf19 if} (m_current_repeat == 0) \{\par
7760                 {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7761                 {\cf19 if} (!success) \{\par
7762                     ++m_current_repeat;\par
7763                 \}\par
7764                 {\cf19 return} m_current_repeat < m_target_repeats;\par
7765             \}\par
7766 \par
7767             {\cf20 // In the second case, we need to move indices forward and check that we haven't run up against the end}\par
7768             ++m_repeat_index;\par
7769             {\cf19 if} (m_repeat_index == m_returned.size()) \{\par
7770                 m_repeat_index = 0;\par
7771                 ++m_current_repeat;\par
7772             \}\par
7773             {\cf19 return} m_current_repeat < m_target_repeats;\par
7774         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ReporterRegistry::ReporterRegistryImpl\par \pard\plain 
{\tc\tcl2 \v Catch::ReporterRegistry::ReporterRegistryImpl}
{\xe \v Catch::ReporterRegistry::ReporterRegistryImpl}
{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Detail::unique_ptr}< EventListenerFactory > > {\b listeners}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, {\b IReporterFactoryPtr}, Detail::CaseInsensitiveLess > {\b factories}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v factories\:Catch::ReporterRegistry::ReporterRegistryImpl}
{\xe \v Catch::ReporterRegistry::ReporterRegistryImpl\:factories}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<std::string, {\b IReporterFactoryPtr}, Detail::CaseInsensitiveLess> Catch::ReporterRegistry::ReporterRegistryImpl::factories}}
\par
{\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v listeners\:Catch::ReporterRegistry::ReporterRegistryImpl}
{\xe \v Catch::ReporterRegistry::ReporterRegistryImpl\:listeners}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Detail::unique_ptr}<EventListenerFactory> > Catch::ReporterRegistry::ReporterRegistryImpl::listeners}}
\par
{\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ReporterSpec\par \pard\plain 
{\tc\tcl2 \v Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec}
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReporterSpec} (std::string {\b name}, {\b Optional}< std::string > outputFileName, {\b Optional}< {\b ColourMode} > {\b colourMode}, std::map< std::string, std::string > {\b customOptions})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string const & {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< std::string > const & {\b outputFile} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ColourMode} > const & {\b colourMode} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, std::string > const & {\b customOptions} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b ReporterSpec} const &lhs, {\b ReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} ({\b ReporterSpec} const &lhs, {\b ReporterSpec} const &rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structured reporter spec that a reporter can be created from\par
Parsing has been validated, but semantics have not. This means e.g. that the colour mode is known to Catch2, but it might not be compiled into the binary, and the output filename might not be openable. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ReporterSpec\:Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec\:ReporterSpec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ReporterSpec::ReporterSpec (std::string name, {\b Optional}< std::string > outputFileName, {\b Optional}< {\b ColourMode} > colourMode, std::map< std::string, std::string > customOptions)}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5343                                                     :\par
5344         m_name( CATCH_MOVE( name ) ),\par
5345         m_outputFileName( CATCH_MOVE( outputFileName ) ),\par
5346         m_colourMode( CATCH_MOVE( colourMode ) ),\par
5347         m_customOptions( CATCH_MOVE( customOptions ) ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v colourMode\:Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec\:colourMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Optional}< {\b ColourMode} > const  & Catch::ReporterSpec::colourMode () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3696 \{ {\cf19 return} m_colourMode; \}\par
}
}
{\xe \v customOptions\:Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec\:customOptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map< std::string, std::string > const  & Catch::ReporterSpec::customOptions () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3698                                                                   \{\par
3699             {\cf19 return} m_customOptions;\par
3700         \}\par
}
}
{\xe \v name\:Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string const  & Catch::ReporterSpec::name () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3690 \{ {\cf19 return} m_name; \}\par
}
}
{\xe \v outputFile\:Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec\:outputFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Optional}< std::string > const  & Catch::ReporterSpec::outputFile () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3692                                                       \{\par
3693             {\cf19 return} m_outputFileName;\par
3694         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator!=\:Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= ({\b ReporterSpec} const & lhs, {\b ReporterSpec} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3679                                                           \{\par
3680             {\cf19 return} !( lhs == rhs );\par
3681         \}\par
}
}
{\xe \v operator==\:Catch::ReporterSpec}
{\xe \v Catch::ReporterSpec\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== ({\b ReporterSpec} const & lhs, {\b ReporterSpec} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5275                                                                         \{\par
5276         {\cf19 return} lhs.m_name == rhs.m_name &&\par
5277                lhs.m_outputFileName == rhs.m_outputFileName &&\par
5278                lhs.m_colourMode == rhs.m_colourMode &&\par
5279                lhs.m_customOptions == rhs.m_customOptions;\par
5280     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Detail::ResultBase\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase}
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::ResultBase:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_detail_1_1_result_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ResultBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b enforceOk} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultType} {\b m_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ResultBase\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:ResultBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ResultBase::ResultBase ({\b ResultType} type){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4307 : m_type( type ) \{\}\par
}
}
{\xe \v ~ResultBase\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:~ResultBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ResultBase::~ResultBase (){\f2 [protected]}, {\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ResultBase\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:ResultBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ResultBase::ResultBase ({\b ResultBase} const & ){\f2 [protected]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ResultBase\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:ResultBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ResultBase::ResultBase ({\b ResultBase} && ){\f2 [protected]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v enforceOk\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:enforceOk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Catch::Clara::Detail::ResultBase::enforceOk () const{\f2 [protected]}, {\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementado por {\b Catch::Clara::Detail::BasicResult< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACCY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultBase} & Catch::Clara::Detail::ResultBase::operator= ({\b ResultBase} && ){\f2 [protected]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultBase} & Catch::Clara::Detail::ResultBase::operator= ({\b ResultBase} const & ){\f2 [protected]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_type\:Catch::Clara::Detail::ResultBase}
{\xe \v Catch::Clara::Detail::ResultBase\:m_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ResultType} Catch::Clara::Detail::ResultBase::m_type{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ResultDisposition\par \pard\plain 
{\tc\tcl2 \v Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition}
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Flags} \{ {\b Normal} = 0x01
, {\b ContinueOnFailure} = 0x02
, {\b FalseTest} = 0x04
, {\b SuppressFail} = 0x08
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v Flags\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::ResultDisposition::Flags}}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Normal\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:Normal}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Normal{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
\cell }{\cell }{\row }
{\xe \v ContinueOnFailure\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:ContinueOnFailure}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ContinueOnFailure{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
\cell }{\cell }{\row }
{\xe \v FalseTest\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:FalseTest}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FalseTest{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
\cell }{\cell }{\row }
{\xe \v SuppressFail\:Catch::ResultDisposition}
{\xe \v Catch::ResultDisposition\:SuppressFail}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SuppressFail{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 827                              \{ {\cf17 enum} Flags \{\par
828         Normal = 0x01,\par
829 \par
830         ContinueOnFailure = 0x02,   {\cf20 // Failures fail test, but execution continues}\par
831         FalseTest = 0x04,           {\cf20 // Prefix expression with !}\par
832         SuppressFail = 0x08         {\cf20 // Failures are reported but do not fail the test}\par
833     \}; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Clara::Detail::ResultValueBase< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >}
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::ResultValueBase< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_detail_1_1_result_value_base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b value} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T && {\b value} () &&\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultValueBase} ({\b ResultType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultValueBase} ({\b ResultValueBase} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultValueBase} ({\b ResultValueBase} &&other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultValueBase} ({\b ResultType}, T const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultValueBase} ({\b ResultType}, T &&{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultValueBase} & {\b operator=} ({\b ResultValueBase} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultValueBase} & {\b operator=} ({\b ResultValueBase} &&other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ResultValueBase} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Clara::Detail::ResultBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ResultBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b enforceOk} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos Protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ T {\b m_value}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Clara::Detail::ResultBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultType} {\b m_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ResultValueBase\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:ResultValueBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::ResultValueBase}< T >::ResultValueBase ({\b ResultType} type){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4334 : ResultBase( type ) \{\}\par
}
}
{\xe \v ResultValueBase\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:ResultValueBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::ResultValueBase}< T >::ResultValueBase ({\b ResultValueBase}< T > const & other){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4336                                                                :\par
4337                     ResultBase( other ) \{\par
4338                     {\cf19 if} ( m_type == ResultType::Ok )\par
4339                         {\cf17 new} ( &m_value ) T( other.m_value );\par
4340                 \}\par
}
}
{\xe \v ResultValueBase\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:ResultValueBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::ResultValueBase}< T >::ResultValueBase ({\b ResultValueBase}< T > && other){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4341                                                           :\par
4342                     ResultBase( other ) \{\par
4343                     {\cf19 if} ( m_type == ResultType::Ok )\par
4344                         {\cf17 new} ( &m_value ) T( CATCH_MOVE(other.m_value) );\par
4345                 \}\par
}
}
{\xe \v ResultValueBase\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:ResultValueBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::ResultValueBase}< T >::ResultValueBase ({\b ResultType} , T const & value){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4348                                                              :\par
4349                     ResultBase( ResultType::Ok ) \{\par
4350                     {\cf17 new} ( &m_value ) T( value );\par
4351                 \}\par
}
}
{\xe \v ResultValueBase\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:ResultValueBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::ResultValueBase}< T >::ResultValueBase ({\b ResultType} , T && value){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4352                                                         :\par
4353                     ResultBase( ResultType::Ok ) \{\par
4354                     {\cf17 new} ( &m_value ) T( CATCH_MOVE(value) );\par
4355                 \}\par
}
}
{\xe \v ~ResultValueBase\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:~ResultValueBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Clara::Detail::ResultValueBase}< T >::~{\b ResultValueBase} (){\f2 [inline]}, {\f2 [override]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4374                                             \{\par
4375                     {\cf19 if} ( m_type == ResultType::Ok )\par
4376                         m_value.~T();\par
4377                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator=\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b ResultValueBase} & {\b Catch::Clara::Detail::ResultValueBase}< T >::operator= ({\b ResultValueBase}< T > && other){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4365                                                                       \{\par
4366                     {\cf19 if} ( m_type == ResultType::Ok ) m_value.~T();\par
4367                     ResultBase::operator=( other );\par
4368                     {\cf19 if} ( m_type == ResultType::Ok )\par
4369                         {\cf17 new} ( &m_value ) T( CATCH_MOVE(other.m_value) );\par
4370                     {\cf19 return} *{\cf17 this};\par
4371                 \}\par
}
}
{\xe \v operator=\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b ResultValueBase} & {\b Catch::Clara::Detail::ResultValueBase}< T >::operator= ({\b ResultValueBase}< T > const & other){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4357                                                                            \{\par
4358                     {\cf19 if} ( m_type == ResultType::Ok )\par
4359                         m_value.~T();\par
4360                     ResultBase::operator=( other );\par
4361                     {\cf19 if} ( m_type == ResultType::Ok )\par
4362                         {\cf17 new} ( &m_value ) T( other.m_value );\par
4363                     {\cf19 return} *{\cf17 this};\par
4364                 \}\par
}
}
{\xe \v value\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T && {\b Catch::Clara::Detail::ResultValueBase}< T >::value () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4328                                \{\par
4329                     enforceOk();\par
4330                     {\cf19 return} CATCH_MOVE( m_value );\par
4331                 \}\par
}
}
{\xe \v value\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Clara::Detail::ResultValueBase}< T >::value () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4324                                         \{\par
4325                     enforceOk();\par
4326                     {\cf19 return} m_value;\par
4327                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  {\b Catch::Clara::Detail::ResultValueBase}< T >{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_value\:Catch::Clara::Detail::ResultValueBase< T >}
{\xe \v Catch::Clara::Detail::ResultValueBase< T >\:m_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b Catch::Clara::Detail::ResultValueBase}< T >::m_value}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Detail::ResultValueBase< void >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::ResultValueBase< void >}
{\xe \v Catch::Clara::Detail::ResultValueBase< void >}
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Clara::Detail::ResultValueBase< void >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_clara_1_1_detail_1_1_result_value_base_3_01void_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros protegidos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} &&)=default\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Clara::Detail::ResultBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultType} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ResultBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} ({\b ResultBase} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultBase} & {\b operator=} ({\b ResultBase} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b enforceOk} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Atributos Protegidos herdados de {\b Catch::Clara::Detail::ResultBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultType} {\b m_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v ResultBase\:Catch::Clara::Detail::ResultValueBase< void >}
{\xe \v Catch::Clara::Detail::ResultValueBase< void >\:ResultBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ResultBase::ResultBase ({\b ResultBase} && ){\f2 [protected]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ResultBase\:Catch::Clara::Detail::ResultValueBase< void >}
{\xe \v Catch::Clara::Detail::ResultValueBase< void >\:ResultBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ResultBase::ResultBase ({\b ResultBase} const & ){\f2 [protected]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ResultBase\:Catch::Clara::Detail::ResultValueBase< void >}
{\xe \v Catch::Clara::Detail::ResultValueBase< void >\:ResultBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::ResultBase::ResultBase ({\b ResultType} type){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4307 : m_type( type ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::ResultWas\par \pard\plain 
{\tc\tcl2 \v Catch::ResultWas}
{\xe \v Catch::ResultWas}
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b OfType} \{ {\b Unknown} = -1
, {\b Ok} = 0
, {\b Info} = 1
, {\b Warning} = 2
, {\b ExplicitSkip} = 4
, {\b FailureBit} = 0x10
, {\b ExpressionFailed} = FailureBit | 1
, {\b ExplicitFailure} = FailureBit | 2
, {\b Exception} = 0x100 | FailureBit
, {\b ThrewException} = Exception | 1
, {\b DidntThrowException} = Exception | 2
, {\b FatalErrorCondition} = 0x200 | FailureBit
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v OfType\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:OfType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::ResultWas::OfType}}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Unknown\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Unknown}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Unknown{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
\cell }{\cell }{\row }
{\xe \v Ok\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Ok}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Ok{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
\cell }{\cell }{\row }
{\xe \v Info\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Info}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Info{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
\cell }{\cell }{\row }
{\xe \v Warning\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Warning}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Warning{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
\cell }{\cell }{\row }
{\xe \v ExplicitSkip\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:ExplicitSkip}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExplicitSkip{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
\cell }{\cell }{\row }
{\xe \v FailureBit\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:FailureBit}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FailureBit{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
\cell }{\cell }{\row }
{\xe \v ExpressionFailed\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:ExpressionFailed}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExpressionFailed{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
\cell }{\cell }{\row }
{\xe \v ExplicitFailure\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:ExplicitFailure}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExplicitFailure{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
\cell }{\cell }{\row }
{\xe \v Exception\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:Exception}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Exception{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
\cell }{\cell }{\row }
{\xe \v ThrewException\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:ThrewException}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ThrewException{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
\cell }{\cell }{\row }
{\xe \v DidntThrowException\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:DidntThrowException}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DidntThrowException{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
\cell }{\cell }{\row }
{\xe \v FatalErrorCondition\:Catch::ResultWas}
{\xe \v Catch::ResultWas\:FatalErrorCondition}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FatalErrorCondition{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 800                      \{ {\cf17 enum} OfType \{\par
801         Unknown = -1,\par
802         Ok = 0,\par
803         Info = 1,\par
804         Warning = 2,\par
805         {\cf20 // TODO: Should explicit skip be considered "not OK" (cf. isOk)? I.e., should it have the failure bit?}\par
806         ExplicitSkip = 4,\par
807 \par
808         FailureBit = 0x10,\par
809 \par
810         ExpressionFailed = FailureBit | 1,\par
811         ExplicitFailure = FailureBit | 2,\par
812 \par
813         Exception = 0x100 | FailureBit,\par
814 \par
815         ThrewException = Exception | 1,\par
816         DidntThrowException = Exception | 2,\par
817 \par
818         FatalErrorCondition = 0x200 | FailureBit\par
819 \par
820     \}; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ReusableStringStream\par \pard\plain 
{\tc\tcl2 \v Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream}
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::ReusableStringStream:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_reusable_string_stream.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReusableStringStream} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ReusableStringStream} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b str} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the serialized state. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b str} (std::string const &str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets internal state to {\f2 str}  }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b operator<<} (T const &{\b value}) -> {\b ReusableStringStream} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b get} () -> std::ostream &\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ReusableStringStream\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:ReusableStringStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ReusableStringStream::ReusableStringStream ()}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5404     :   m_index( Singleton<StringStreams>::getMutable().add() ),\par
5405         m_oss( Singleton<StringStreams>::getMutable().m_streams[m_index].get() )\par
5406     \{\}\par
}
}
{\xe \v ~ReusableStringStream\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:~ReusableStringStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ReusableStringStream::~ReusableStringStream ()}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5408                                                 \{\par
5409         {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str({\cf22 ""});\par
5410         m_oss->clear();\par
5411         Singleton<StringStreams>::getMutable().release( m_index );\par
5412     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::ReusableStringStream::get () -> std::ostream& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2376 \{ {\cf19 return} *m_oss; \}\par
}
}
{\xe \v operator<<\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > auto Catch::ReusableStringStream::operator<< (T const & value) -> {\b ReusableStringStream}& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2368                                                                      \{\par
2369             *m_oss << value;\par
2370             {\cf19 return} *{\cf17 this};\par
2371         \}\par
}
}
{\xe \v str\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::ReusableStringStream::str () const}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the serialized state. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5414                                               \{\par
5415         {\cf19 return} {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str();\par
5416     \}\par
}
}
{\xe \v str\:Catch::ReusableStringStream}
{\xe \v Catch::ReusableStringStream\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::ReusableStringStream::str (std::string const & str)}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets internal state to {\f2 str}  }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5418                                                          \{\par
5419         {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str( str );\par
5420     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::SampleAnalysis\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::SampleAnalysis}
{\xe \v Catch::Benchmark::SampleAnalysis}
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b FDuration} > {\b samples}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< {\b FDuration} > {\b mean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< {\b FDuration} > {\b standard_deviation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OutlierClassification} {\b outliers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b outlier_variance}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v mean\:Catch::Benchmark::SampleAnalysis}
{\xe \v Catch::Benchmark::SampleAnalysis\:mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Estimate}<{\b FDuration}> Catch::Benchmark::SampleAnalysis::mean}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outlier_variance\:Catch::Benchmark::SampleAnalysis}
{\xe \v Catch::Benchmark::SampleAnalysis\:outlier_variance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::Benchmark::SampleAnalysis::outlier_variance}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v outliers\:Catch::Benchmark::SampleAnalysis}
{\xe \v Catch::Benchmark::SampleAnalysis\:outliers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OutlierClassification} Catch::Benchmark::SampleAnalysis::outliers}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v samples\:Catch::Benchmark::SampleAnalysis}
{\xe \v Catch::Benchmark::SampleAnalysis\:samples}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b FDuration}> Catch::Benchmark::SampleAnalysis::samples}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v standard_deviation\:Catch::Benchmark::SampleAnalysis}
{\xe \v Catch::Benchmark::SampleAnalysis\:standard_deviation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Estimate}<{\b FDuration}> Catch::Benchmark::SampleAnalysis::standard_deviation}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::ScopedMessage\par \pard\plain 
{\tc\tcl2 \v Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage}
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedMessage} ({\b MessageBuilder} &&builder)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedMessage} ({\b ScopedMessage} &duplicate)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ScopedMessage} ({\b ScopedMessage} &&old) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ScopedMessage} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MessageInfo} {\b m_info}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_moved} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v ScopedMessage\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:ScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ScopedMessage::ScopedMessage ({\b MessageBuilder} && builder){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 971                                                           :\par
972         m_info( CATCH_MOVE(builder.m_info) ) \{\par
973         m_info.message = builder.m_stream.str();\par
974         getResultCapture().pushScopedMessage( m_info );\par
975     \}\par
}
}
{\xe \v ScopedMessage\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:ScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ScopedMessage::ScopedMessage ({\b ScopedMessage} & duplicate){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ScopedMessage\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:ScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ScopedMessage::ScopedMessage ({\b ScopedMessage} && old){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 977                                                               :\par
978         m_info( CATCH_MOVE( old.m_info ) ) \{\par
979         old.m_moved = {\cf17 true};\par
980     \}\par
}
}
{\xe \v ~ScopedMessage\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:~ScopedMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::ScopedMessage::~ScopedMessage ()}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 982                                   \{\par
983         {\cf19 if} ( !uncaught_exceptions() && !m_moved )\{\par
984             getResultCapture().popScopedMessage(m_info);\par
985         \}\par
986     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_info\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:m_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MessageInfo} Catch::ScopedMessage::m_info}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_moved\:Catch::ScopedMessage}
{\xe \v Catch::ScopedMessage\:m_moved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::ScopedMessage::m_moved = false}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Section\par \pard\plain 
{\tc\tcl2 \v Catch::Section}
{\xe \v Catch::Section}
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Section:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_section.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Section} ({\b SectionInfo} &&info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Section} ({\b SourceLineInfo} const &_lineInfo, {\b StringRef} _name, const char *const =nullptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Section} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Section\:Catch::Section}
{\xe \v Catch::Section\:Section}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Section::Section ({\b SectionInfo} && info)}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6116                                         :\par
6117         m_info( CATCH_MOVE( info ) ),\par
6118         m_sectionIncluded(\par
6119             getResultCapture().sectionStarted( m_info.name, m_info.lineInfo, m_assertions ) ) \{\par
6120         {\cf20 // Non-"included" sections will not use the timing information}\par
6121         {\cf20 // anyway, so don't bother with the potential syscall.}\par
6122         {\cf19 if} (m_sectionIncluded) \{\par
6123             m_timer.start();\par
6124         \}\par
6125     \}\par
}
}
{\xe \v Section\:Catch::Section}
{\xe \v Catch::Section\:Section}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Section::Section ({\b SourceLineInfo} const & _lineInfo, {\b StringRef} _name, const char * const  = {\f2 nullptr})}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6129                                          :\par
6130         m_info( \{ {\cf22 "invalid"}, {\cf17 static_cast<}std::size_t{\cf17 >}( -1 ) \}, std::string\{\} ),\par
6131         m_sectionIncluded(\par
6132             getResultCapture().sectionStarted( _name, _lineInfo, m_assertions ) ) \{\par
6133         {\cf20 // We delay initialization the SectionInfo member until we know}\par
6134         {\cf20 // this section needs it, so we avoid allocating std::string for name.}\par
6135         {\cf20 // We also delay timer start to avoid the potential syscall unless we}\par
6136         {\cf20 // will actually use the result.}\par
6137         {\cf19 if} ( m_sectionIncluded ) \{\par
6138             m_info.name = {\cf17 static_cast<}std::string{\cf17 >}( _name );\par
6139             m_info.lineInfo = _lineInfo;\par
6140             m_timer.start();\par
6141         \}\par
6142     \}\par
}
}
{\xe \v ~Section\:Catch::Section}
{\xe \v Catch::Section\:~Section}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Section::~Section ()}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6144                       \{\par
6145         {\cf19 if}( m_sectionIncluded ) \{\par
6146             SectionEndInfo endInfo\{ CATCH_MOVE(m_info), m_assertions, m_timer.getElapsedSeconds() \};\par
6147             {\cf19 if} ( uncaught_exceptions() ) \{\par
6148                 getResultCapture().sectionEndedEarly( CATCH_MOVE(endInfo) );\par
6149             \} {\cf19 else} \{\par
6150                 getResultCapture().sectionEnded( CATCH_MOVE( endInfo ) );\par
6151             \}\par
6152         \}\par
6153     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator bool\:Catch::Section}
{\xe \v Catch::Section\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Section::operator bool () const{\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6156                                  \{\par
6157         {\cf19 return} m_sectionIncluded;\par
6158     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::SectionEndInfo\par \pard\plain 
{\tc\tcl2 \v Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo}
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SectionInfo} {\b sectionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b prevAssertions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b durationInSeconds}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v durationInSeconds\:Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo\:durationInSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Catch::SectionEndInfo::durationInSeconds}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v prevAssertions\:Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo\:prevAssertions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::SectionEndInfo::prevAssertions}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sectionInfo\:Catch::SectionEndInfo}
{\xe \v Catch::SectionEndInfo\:sectionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SectionInfo} Catch::SectionEndInfo::sectionInfo}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::SectionInfo\par \pard\plain 
{\tc\tcl2 \v Catch::SectionInfo}
{\xe \v Catch::SectionInfo}
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SectionInfo} ({\b SourceLineInfo} const &_lineInfo, std::string _name, const char *const =nullptr)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v SectionInfo\:Catch::SectionInfo}
{\xe \v Catch::SectionInfo\:SectionInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SectionInfo::SectionInfo ({\b SourceLineInfo} const & _lineInfo, std::string _name, const char * const  = {\f2 nullptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4137                                                  :\par
4138             name(CATCH_MOVE(_name)),\par
4139             lineInfo(_lineInfo)\par
4140             \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v lineInfo\:Catch::SectionInfo}
{\xe \v Catch::SectionInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::SectionInfo::lineInfo}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::SectionInfo}
{\xe \v Catch::SectionInfo\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::SectionInfo::name}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Session\par \pard\plain 
{\tc\tcl2 \v Catch::Session}
{\xe \v Catch::Session}
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Session:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_session.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Session} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Session} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showHelp} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b libIdentify} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b applyCommandLine} (int argc, char const *const *argv)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b useConfigData} ({\b ConfigData} const &{\b configData})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharT > int {\b run} (int argc, CharT const *const argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b run} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clara::Parser} const & {\b cli} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b cli} ({\b Clara::Parser} const &newParser)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ConfigData} & {\b configData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Config} & {\b config} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Session\:Catch::Session}
{\xe \v Catch::Session\:Session}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Session::Session ()}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1277                      \{\par
1278         {\cf17 static} {\cf18 bool} alreadyInstantiated = {\cf17 false};\par
1279         {\cf19 if}( alreadyInstantiated ) \{\par
1280             CATCH_TRY \{ CATCH_INTERNAL_ERROR( {\cf22 "Only one instance of Catch::Session can ever be used"} ); \}\par
1281             CATCH_CATCH_ALL \{ getMutableRegistryHub().registerStartupException(); \}\par
1282         \}\par
1283 \par
1284         {\cf20 // There cannot be exceptions at startup in no-exception mode.}\par
1285 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
1286         {\cf17 const} {\cf17 auto}& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();\par
1287         {\cf19 if} ( !exceptions.empty() ) \{\par
1288             config();\par
1289             getCurrentMutableContext().setConfig(m_config.get());\par
1290 \par
1291             m_startupExceptions = {\cf17 true};\par
1292             {\cf17 auto} errStream = makeStream( {\cf22 "%stderr"} );\par
1293             {\cf17 auto} colourImpl = makeColourImpl(\par
1294                 ColourMode::PlatformDefault, errStream.get() );\par
1295             {\cf17 auto} guard = colourImpl->guardColour( Colour::Red );\par
1296             errStream->stream() << {\cf22 "Errors occurred during startup!"} << {\cf23 '\\n'};\par
1297             {\cf20 // iterate over all exceptions and notify user}\par
1298             {\cf19 for} ( {\cf17 const} {\cf17 auto}& ex_ptr : exceptions ) \{\par
1299                 {\cf19 try} \{\par
1300                     std::rethrow_exception(ex_ptr);\par
1301                 \} {\cf19 catch} ( std::exception {\cf17 const}& ex ) \{\par
1302                     errStream->stream() << TextFlow::Column( ex.what() ).indent(2) << {\cf23 '\\n'};\par
1303                 \}\par
1304             \}\par
1305         \}\par
1306 {\cf21 #endif}\par
1307 \par
1308         alreadyInstantiated = {\cf17 true};\par
1309         m_cli = makeCommandLineParser( m_configData );\par
1310     \}\par
}
}
{\xe \v ~Session\:Catch::Session}
{\xe \v Catch::Session\:~Session}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Session::~Session ()}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1311                       \{\par
1312         Catch::cleanUp();\par
1313     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v applyCommandLine\:Catch::Session}
{\xe \v Catch::Session\:applyCommandLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Session::applyCommandLine (int argc, char const *const * argv)}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1329                                                                        \{\par
1330         {\cf19 if}( m_startupExceptions )\par
1331             {\cf19 return} 1;\par
1332 \par
1333         {\cf17 auto} result = m_cli.parse( Clara::Args( argc, argv ) );\par
1334 \par
1335         {\cf19 if}( !result ) \{\par
1336             config();\par
1337             getCurrentMutableContext().setConfig(m_config.get());\par
1338             {\cf17 auto} errStream = makeStream( {\cf22 "%stderr"} );\par
1339             {\cf17 auto} colour = makeColourImpl( ColourMode::PlatformDefault, errStream.get() );\par
1340 \par
1341             errStream->stream()\par
1342                 << colour->guardColour( Colour::Red )\par
1343                 << {\cf22 "\\nError(s) in input:\\n"}\par
1344                 << TextFlow::Column( result.errorMessage() ).indent( 2 )\par
1345                 << {\cf22 "\\n\\n"};\par
1346             errStream->stream() << {\cf22 "Run with -? for usage\\n\\n"} << std::flush;\par
1347             {\cf19 return} MaxExitCode;\par
1348         \}\par
1349 \par
1350         {\cf19 if}( m_configData.showHelp )\par
1351             showHelp();\par
1352         {\cf19 if}( m_configData.libIdentify )\par
1353             libIdentify();\par
1354 \par
1355         m_config.reset();\par
1356         {\cf19 return} 0;\par
1357     \}\par
}
}
{\xe \v cli\:Catch::Session}
{\xe \v Catch::Session\:cli}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Clara::Parser} const  & Catch::Session::cli () const}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1401                                           \{\par
1402         {\cf19 return} m_cli;\par
1403     \}\par
}
}
{\xe \v cli\:Catch::Session}
{\xe \v Catch::Session\:cli}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Session::cli ({\b Clara::Parser} const & newParser)}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1404                                                     \{\par
1405         m_cli = newParser;\par
1406     \}\par
}
}
{\xe \v config\:Catch::Session}
{\xe \v Catch::Session\:config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Config} & Catch::Session::config ()}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1410                             \{\par
1411         {\cf19 if}( !m_config )\par
1412             m_config = Detail::make_unique<Config>( m_configData );\par
1413         {\cf19 return} *m_config;\par
1414     \}\par
}
}
{\xe \v configData\:Catch::Session}
{\xe \v Catch::Session\:configData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ConfigData} & Catch::Session::configData ()}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1407                                     \{\par
1408         {\cf19 return} m_configData;\par
1409     \}\par
}
}
{\xe \v libIdentify\:Catch::Session}
{\xe \v Catch::Session\:libIdentify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Session::libIdentify ()}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1321                               \{\par
1322         Catch::cout()\par
1323                 << std::left << std::setw(16) << {\cf22 "description: "} << {\cf22 "A Catch2 test executable\\n"}\par
1324                 << std::left << std::setw(16) << {\cf22 "category: "} << {\cf22 "testframework\\n"}\par
1325                 << std::left << std::setw(16) << {\cf22 "framework: "} << {\cf22 "Catch2\\n"}\par
1326                 << std::left << std::setw(16) << {\cf22 "version: "} << libraryVersion() << {\cf23 '\\n'} << std::flush;\par
1327     \}\par
}
}
{\xe \v run\:Catch::Session}
{\xe \v Catch::Session\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::Session::run ()}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1388                      \{\par
1389         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) \{\par
1390             Catch::cout() << {\cf22 "...waiting for enter/ return before starting\\n"} << std::flush;\par
1391             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
1392         \}\par
1393         {\cf18 int} exitCode = runInternal();\par
1394         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) \{\par
1395             Catch::cout() << {\cf22 "...waiting for enter/ return before exiting, with code: "} << exitCode << {\cf23 '\\n'} << std::flush;\par
1396             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
1397         \}\par
1398         {\cf19 return} exitCode;\par
1399     \}\par
}
}
{\xe \v run\:Catch::Session}
{\xe \v Catch::Session\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharT > int Catch::Session::run (int argc, CharT const *const argv[]){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4936                                                       \{\par
4937             {\cf19 if} (m_startupExceptions)\par
4938                 {\cf19 return} 1;\par
4939             {\cf18 int} returnCode = applyCommandLine(argc, argv);\par
4940             {\cf19 if} (returnCode == 0)\par
4941                 returnCode = run();\par
4942             {\cf19 return} returnCode;\par
4943         \}\par
}
}
{\xe \v showHelp\:Catch::Session}
{\xe \v Catch::Session\:showHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Session::showHelp () const}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1315                                  \{\par
1316         Catch::cout()\par
1317                 << {\cf22 "\\nCatch2 v"} << libraryVersion() << {\cf23 '\\n'}\par
1318                 << m_cli << {\cf23 '\\n'}\par
1319                 << {\cf22 "For more detailed usage please see the project docs\\n\\n"} << std::flush;\par
1320     \}\par
}
}
{\xe \v useConfigData\:Catch::Session}
{\xe \v Catch::Session\:useConfigData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Session::useConfigData ({\b ConfigData} const & configData)}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1383                                                               \{\par
1384         m_configData = configData;\par
1385         m_config.reset();\par
1386     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::SignalDefs\par \pard\plain 
{\tc\tcl2 \v Catch::SignalDefs}
{\xe \v Catch::SignalDefs}
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b name}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v id\:Catch::SignalDefs}
{\xe \v Catch::SignalDefs\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::SignalDefs::id}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::SignalDefs}
{\xe \v Catch::SignalDefs\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Catch::SignalDefs::name}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::SimplePcg32\par \pard\plain 
{\tc\tcl2 \v Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32}
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b result_type} = std::uint32_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SimplePcg32} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SimplePcg32} ({\b result_type} seed_)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b seed} ({\b result_type} seed_)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b discard} (uint64_t skip)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result_type} {\b operator()} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b result_type} {\b min} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b result_type} {\b max} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v result_type\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:result_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::SimplePcg32::result_type} = std::uint32_t}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v SimplePcg32\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:SimplePcg32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SimplePcg32::SimplePcg32 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7902 :SimplePcg32(0xed743cc4U) \{\}\par
}
}
{\xe \v SimplePcg32\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:SimplePcg32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SimplePcg32::SimplePcg32 ({\b result_type} seed_){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5047                                               \{\par
5048         seed(seed_);\par
5049     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v discard\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:discard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::SimplePcg32::discard (uint64_t skip)}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5059                                            \{\par
5060         {\cf20 // We could implement this to run in O(log n) steps, but this}\par
5061         {\cf20 // should suffice for our use case.}\par
5062         {\cf19 for} (uint64_t s = 0; s < skip; ++s) \{\par
5063             {\cf17 static_cast<}{\cf18 void}{\cf17 >}((*this)());\par
5064         \}\par
5065     \}\par
}
}
{\xe \v max\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static constexpr {\b result_type} Catch::SimplePcg32::max (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7897                                              \{\par
7898             {\cf19 return} {\cf17 static_cast<}result_type{\cf17 >}(-1);\par
7899         \}\par
}
}
{\xe \v min\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:min}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static constexpr {\b result_type} Catch::SimplePcg32::min (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7894                                              \{\par
7895             {\cf19 return} 0;\par
7896         \}\par
}
}
{\xe \v operator()\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SimplePcg32::result_type} Catch::SimplePcg32::operator() ()}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5067                                                    \{\par
5068         {\cf20 // prepare the output value}\par
5069         {\cf17 const} uint32_t xorshifted = {\cf17 static_cast<}uint32_t{\cf17 >}(((m_state >> 18u) ^ m_state) >> 27u);\par
5070         {\cf17 const} {\cf17 auto} output = rotate_right(xorshifted, m_state >> 59u);\par
5071 \par
5072         {\cf20 // advance state}\par
5073         m_state = m_state * 6364136223846793005ULL + s_inc;\par
5074 \par
5075         {\cf19 return} output;\par
5076     \}\par
}
}
{\xe \v seed\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:seed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::SimplePcg32::seed ({\b result_type} seed_)}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5052                                             \{\par
5053         m_state = 0;\par
5054         (*this)();\par
5055         m_state += seed_;\par
5056         (*this)();\par
5057     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator!=\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= ({\b SimplePcg32} const & lhs, {\b SimplePcg32} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5082                                                                     \{\par
5083         {\cf19 return} lhs.m_state != rhs.m_state;\par
5084     \}\par
}
}
{\xe \v operator==\:Catch::SimplePcg32}
{\xe \v Catch::SimplePcg32\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== ({\b SimplePcg32} const & lhs, {\b SimplePcg32} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5078                                                                     \{\par
5079         {\cf19 return} lhs.m_state == rhs.m_state;\par
5080     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::SingleValueGenerator< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::SingleValueGenerator< T >}
{\xe \v Catch::Generators::SingleValueGenerator< T >}
{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::SingleValueGenerator< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_single_value_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SingleValueGenerator} (T const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SingleValueGenerator} (T &&{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v SingleValueGenerator\:Catch::Generators::SingleValueGenerator< T >}
{\xe \v Catch::Generators::SingleValueGenerator< T >\:SingleValueGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::SingleValueGenerator}< T >::SingleValueGenerator (T const & value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7467                                              :\par
7468             m_value(value)\par
7469         \{\}\par
}
}
{\xe \v SingleValueGenerator\:Catch::Generators::SingleValueGenerator< T >}
{\xe \v Catch::Generators::SingleValueGenerator< T >\:SingleValueGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::SingleValueGenerator}< T >::SingleValueGenerator (T && value){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7470                                        :\par
7471             m_value(CATCH_MOVE(value))\par
7472         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::SingleValueGenerator< T >}
{\xe \v Catch::Generators::SingleValueGenerator< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Generators::SingleValueGenerator}< T >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7474                                       \{\par
7475             {\cf19 return} m_value;\par
7476         \}\par
}
}
{\xe \v next\:Catch::Generators::SingleValueGenerator< T >}
{\xe \v Catch::Generators::SingleValueGenerator< T >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Generators::SingleValueGenerator}< T >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7477                              \{\par
7478             {\cf19 return} {\cf17 false};\par
7479         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::SourceLineInfo\par \pard\plain 
{\tc\tcl2 \v Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo}
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b SourceLineInfo} (char const *_file, std::size_t _line) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b SourceLineInfo} const &other) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b SourceLineInfo} const &other) const noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char const  * {\b file}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b line}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, {\b SourceLineInfo} const &info)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v SourceLineInfo\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:SourceLineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SourceLineInfo::SourceLineInfo (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SourceLineInfo\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:SourceLineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::SourceLineInfo::SourceLineInfo (char const * _file, std::size_t _line){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3229                                                                                :\par
3230             file( _file ),\par
3231             line( _line )\par
3232         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator<\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::SourceLineInfo::operator< ({\b SourceLineInfo} const & other) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6203                                                                                  \{\par
6204         {\cf20 // We can assume that the same file will usually have the same pointer.}\par
6205         {\cf20 // Thus, if the pointers are the same, there is no point in calling the strcmp}\par
6206         {\cf19 return} line < other.line || ( line == other.line && file != other.file && (std::strcmp(file, other.file) < 0));\par
6207     \}\par
}
}
{\xe \v operator==\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::SourceLineInfo::operator== ({\b SourceLineInfo} const & other) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6200                                                                                   \{\par
6201         {\cf19 return} line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);\par
6202     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<<\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream & os, {\b SourceLineInfo} const & info){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6209                                                                            \{\par
6210 {\cf21 #ifndef __GNUG__}\par
6211         os << info.file << {\cf23 '('} << info.line << {\cf23 ')'};\par
6212 {\cf21 #else}\par
6213         os << info.file << {\cf23 ':'} << info.line;\par
6214 {\cf21 #endif}\par
6215         {\cf19 return} os;\par
6216     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v file\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char const* Catch::SourceLineInfo::file}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line\:Catch::SourceLineInfo}
{\xe \v Catch::SourceLineInfo\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t Catch::SourceLineInfo::line}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StreamEndStop\par \pard\plain 
{\tc\tcl2 \v Catch::StreamEndStop}
{\xe \v Catch::StreamEndStop}
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b StringRef} {\b operator+} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > constexpr friend T const & {\b operator+} (T const &{\b value}, {\b StreamEndStop})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator+\:Catch::StreamEndStop}
{\xe \v Catch::StreamEndStop\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::StreamEndStop::operator+ () const{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3908 \{ {\cf19 return} StringRef(); \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator+\:Catch::StreamEndStop}
{\xe \v Catch::StreamEndStop\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > friend T const  & operator+ (T const & value, {\b StreamEndStop} ){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3911                                                                              \{\par
3912             {\cf19 return} value;\par
3913         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< T, typename >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< T, typename >}
{\xe \v Catch::StringMaker< T, typename >}
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fake  = T> static std::enable_if_t<{\b ::Catch::Detail::IsStreamInsertable}< Fake >{\b ::value}, std::string > {\b convert} (const Fake &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fake  = T> static std::enable_if_t<!{\b ::Catch::Detail::IsStreamInsertable}< Fake >{\b ::value}, std::string > {\b convert} (const Fake &{\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< T, typename >}
{\xe \v Catch::StringMaker< T, typename >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = void> template<typename Fake  = T> static std::enable_if_t<{\b ::Catch::Detail::IsStreamInsertable}< Fake >{\b ::value}, std::string > {\b Catch::StringMaker}< T, typename >::convert (const Fake & value){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2544                                        \{\par
2545                 ReusableStringStream rss;\par
2546                 {\cf20 // NB: call using the function-like syntax to avoid ambiguity with}\par
2547                 {\cf20 // user-defined templated operator<< under clang.}\par
2548                 rss.operator<<(value);\par
2549                 {\cf19 return} rss.str();\par
2550         \}\par
}
}
{\xe \v convert\:Catch::StringMaker< T, typename >}
{\xe \v Catch::StringMaker< T, typename >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename  = void> template<typename Fake  = T> static std::enable_if_t<!{\b ::Catch::Detail::IsStreamInsertable}< Fake >{\b ::value}, std::string > {\b Catch::StringMaker}< T, typename >::convert (const Fake & value){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2555                                          \{\par
2556 {\cf21 #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)}\par
2557             {\cf19 return} Detail::convertUnstreamable(value);\par
2558 {\cf21 #else}\par
2559             {\cf19 return} CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\par
2560 {\cf21 #endif}\par
2561         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< bool >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< bool >}
{\xe \v Catch::StringMaker< bool >}
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (bool b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< bool >}
{\xe \v Catch::StringMaker< bool >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< bool >::convert (bool b){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2690                                          \{\par
2691             {\cf17 using namespace }std::string_literals;\par
2692             {\cf19 return} b ? {\cf22 "true"}s : {\cf22 "false"}s;\par
2693         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< Catch::Approx >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< Catch::Approx >}
{\xe \v Catch::StringMaker< Catch::Approx >}
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} ({\b Catch::Approx} const &{\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< Catch::Approx >}
{\xe \v Catch::StringMaker< Catch::Approx >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< {\b Catch::Approx} >::convert ({\b Catch::Approx} const & value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 614                                                                     \{\par
615     {\cf19 return} value.toString();\par
616 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< char * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char * >}
{\xe \v Catch::StringMaker< char * >}
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (char *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char * >}
{\xe \v Catch::StringMaker< char * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< char * >::convert (char * str){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2058                                                \{ {\cf20 // NOLINT(readability-non-const-parameter)}\par
2059     {\cf19 if} (str) \{\par
2060         {\cf19 return} Detail::convertIntoString( str );\par
2061     \} {\cf19 else} \{\par
2062         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2063     \}\par
2064 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< char >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char >}
{\xe \v Catch::StringMaker< char >}
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (char c)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char >}
{\xe \v Catch::StringMaker< char >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< char >::convert (char c){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2152                                            \{\par
2153     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 signed} {\cf18 char}{\cf17 >}(c));\par
2154 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< char const * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char const * >}
{\xe \v Catch::StringMaker< char const * >}
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (char const *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char const * >}
{\xe \v Catch::StringMaker< char const * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< char const * >::convert (char const * str){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< char[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< char[SZ]>}
{\xe \v Catch::StringMaker< char[SZ]>}
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (char const *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< char[SZ]>}
{\xe \v Catch::StringMaker< char[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t SZ> static std::string {\b Catch::StringMaker}< char[SZ]>::convert (char const * str){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2635                                                   \{\par
2636             {\cf19 return} Detail::convertIntoString(\par
2637                 StringRef( str, Detail::catch_strnlen( str, SZ ) ) );\par
2638         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< double >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< double >}
{\xe \v Catch::StringMaker< double >}
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (double {\b value})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b CATCH_EXPORT} int {\b precision} = std::numeric_limits<double>::max_digits10\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< double >}
{\xe \v Catch::StringMaker< double >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< double >::convert (double value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2167                                                    \{\par
2168     {\cf19 return} Detail::fpToString(value, precision);\par
2169 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v precision\:Catch::StringMaker< double >}
{\xe \v Catch::StringMaker< double >\:precision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Catch::StringMaker}< double >::precision = std::numeric_limits<double>::max_digits10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< float >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< float >}
{\xe \v Catch::StringMaker< float >}
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (float {\b value})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b CATCH_EXPORT} int {\b precision} = std::numeric_limits<float>::max_digits10\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< float >}
{\xe \v Catch::StringMaker< float >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< float >::convert (float value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2161                                                  \{\par
2162     {\cf19 return} Detail::fpToString(value, precision) + {\cf23 'f'};\par
2163 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v precision\:Catch::StringMaker< float >}
{\xe \v Catch::StringMaker< float >\:precision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b Catch::StringMaker}< float >::precision = std::numeric_limits<float>::max_digits10{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< int >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< int >}
{\xe \v Catch::StringMaker< int >}
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (int {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< int >}
{\xe \v Catch::StringMaker< int >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< int >::convert (int value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2105                                              \{\par
2106     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2107 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< long >}
{\xe \v Catch::StringMaker< long >}
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (long {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< long >}
{\xe \v Catch::StringMaker< long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< long >::convert (long value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2108                                                \{\par
2109     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2110 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< long long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< long long >}
{\xe \v Catch::StringMaker< long long >}
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (long long {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< long long >}
{\xe \v Catch::StringMaker< long long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< long long >::convert (long long value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< R C::* >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< R C::* >}
{\xe \v Catch::StringMaker< R C::* >}
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (R C::*{\b p})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< R C::* >}
{\xe \v Catch::StringMaker< R C::* >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename R , typename C > static std::string {\b Catch::StringMaker}< R C::* >::convert (R C::* p){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2743                                          \{\par
2744             {\cf19 if} (p) \{\par
2745                 return ::Catch::Detail::rawMemoryToString(p);\par
2746             \} {\cf19 else} \{\par
2747                 {\cf19 return} {\cf22 "nullptr"};\par
2748             \}\par
2749         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >}
{\xe \v Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >}
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (R const &range)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >}
{\xe \v Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename R > static std::string {\b Catch::StringMaker}< R, std::enable_if_t< {\b is_range}< R >{\b ::value} &&!{\b ::Catch::Detail::IsStreamInsertable}< R >{\b ::value} > >::convert (R const & range){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2947                                                    \{\par
2948             {\cf19 return} rangeToString( range );\par
2949         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< signed char >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< signed char >}
{\xe \v Catch::StringMaker< signed char >}
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (signed char {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< signed char >}
{\xe \v Catch::StringMaker< signed char >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< signed char >::convert (signed char value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< signed char[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< signed char[SZ]>}
{\xe \v Catch::StringMaker< signed char[SZ]>}
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (signed char const *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< signed char[SZ]>}
{\xe \v Catch::StringMaker< signed char[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t SZ> static std::string {\b Catch::StringMaker}< signed char[SZ]>::convert (signed char const * str){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2642                                                          \{\par
2643             {\cf17 auto} reinterpreted = {\cf17 reinterpret_cast<}{\cf18 char} const*{\cf17 >}(str);\par
2644             {\cf19 return} Detail::convertIntoString(\par
2645                 StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\par
2646         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< std::chrono::duration< Value, Ratio > >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::chrono::duration< Value, Ratio > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, Ratio > >}
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::chrono::duration< Value, Ratio > const &duration)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::chrono::duration< Value, Ratio > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, Ratio > >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value , typename Ratio > static std::string {\b Catch::StringMaker}< std::chrono::duration< Value, Ratio > >::convert (std::chrono::duration< Value, Ratio > const & duration){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3009                                                                                   \{\par
3010             ReusableStringStream rss;\par
3011             rss << duration.count() << {\cf23 ' '} << ratio_string<Ratio>::symbol() << {\cf23 's'};\par
3012             {\cf19 return} rss.str();\par
3013         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >}
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::chrono::duration< Value, std::ratio< 1 > > const &duration)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > static std::string {\b Catch::StringMaker}< std::chrono::duration< Value, std::ratio< 1 > > >::convert (std::chrono::duration< Value, std::ratio< 1 > > const & duration){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3017                                                                                         \{\par
3018             ReusableStringStream rss;\par
3019             rss << duration.count() << {\cf22 " s"};\par
3020             {\cf19 return} rss.str();\par
3021         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >}
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::chrono::duration< Value, std::ratio< 3600 > > const &duration)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > static std::string {\b Catch::StringMaker}< std::chrono::duration< Value, std::ratio< 3600 > > >::convert (std::chrono::duration< Value, std::ratio< 3600 > > const & duration){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3033                                                                                            \{\par
3034             ReusableStringStream rss;\par
3035             rss << duration.count() << {\cf22 " h"};\par
3036             {\cf19 return} rss.str();\par
3037         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >}
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::chrono::duration< Value, std::ratio< 60 > > const &duration)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >}
{\xe \v Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > static std::string {\b Catch::StringMaker}< std::chrono::duration< Value, std::ratio< 60 > > >::convert (std::chrono::duration< Value, std::ratio< 60 > > const & duration){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3025                                                                                          \{\par
3026             ReusableStringStream rss;\par
3027             rss << duration.count() << {\cf22 " m"};\par
3028             {\cf19 return} rss.str();\par
3029         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< std::chrono::time_point< Clock, Duration > >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::chrono::time_point< Clock, Duration > >}
{\xe \v Catch::StringMaker< std::chrono::time_point< Clock, Duration > >}
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::chrono::time_point< Clock, Duration > const &time_point)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::chrono::time_point< Clock, Duration > >}
{\xe \v Catch::StringMaker< std::chrono::time_point< Clock, Duration > >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Clock , typename Duration > static std::string {\b Catch::StringMaker}< std::chrono::time_point< Clock, Duration > >::convert (std::chrono::time_point< Clock, Duration > const & time_point){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3045                                                                                          \{\par
3046             return ::Catch::Detail::stringify(time_point.time_since_epoch()) + {\cf22 " since epoch"};\par
3047         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >}
{\xe \v Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >}
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::chrono::time_point< std::chrono::system_clock, Duration > const &time_point)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >}
{\xe \v Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Duration > static std::string {\b Catch::StringMaker}< std::chrono::time_point< std::chrono::system_clock, Duration > >::convert (std::chrono::time_point< std::chrono::system_clock, Duration > const & time_point){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3052                                                                                                          \{\par
3053             {\cf17 auto} converted = std::chrono::system_clock::to_time_t(time_point);\par
3054 \par
3055 {\cf21 #ifdef _MSC_VER}\par
3056             std::tm timeInfo = \{\};\par
3057             gmtime_s(&timeInfo, &converted);\par
3058 {\cf21 #else}\par
3059             std::tm* timeInfo = std::gmtime(&converted);\par
3060 {\cf21 #endif}\par
3061 \par
3062             {\cf17 auto} {\cf17 const} timeStampSize = {\cf17 sizeof}({\cf22 "2017-01-16T17:06:45Z"});\par
3063             {\cf18 char} timeStamp[timeStampSize];\par
3064             {\cf17 const} {\cf18 char} * {\cf17 const} fmt = {\cf22 "%Y-%m-%dT%H:%M:%SZ"};\par
3065 \par
3066 {\cf21 #ifdef _MSC_VER}\par
3067             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\par
3068 {\cf21 #else}\par
3069             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\par
3070 {\cf21 #endif}\par
3071             {\cf19 return} std::string(timeStamp, timeStampSize - 1);\par
3072         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< std::nullptr_t >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::nullptr_t >}
{\xe \v Catch::StringMaker< std::nullptr_t >}
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (std::nullptr_t)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::nullptr_t >}
{\xe \v Catch::StringMaker< std::nullptr_t >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< std::nullptr_t >::convert (std::nullptr_t ){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2711                                                \{\par
2712             {\cf17 using namespace }std::string_literals;\par
2713             {\cf19 return} {\cf22 "nullptr"}s;\par
2714         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< std::string >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::string >}
{\xe \v Catch::StringMaker< std::string >}
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (const std::string &str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::string >}
{\xe \v Catch::StringMaker< std::string >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< std::string >::convert (const std::string & str){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2041                                                               \{\par
2042     {\cf19 return} Detail::convertIntoString( str );\par
2043 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< std::wstring >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< std::wstring >}
{\xe \v Catch::StringMaker< std::wstring >}
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (const std::wstring &wstr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< std::wstring >}
{\xe \v Catch::StringMaker< std::wstring >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< std::wstring >::convert (const std::wstring & wstr){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2067                                                                  \{\par
2068     std::string s;\par
2069     s.reserve(wstr.size());\par
2070     {\cf19 for} ({\cf17 auto} c : wstr) \{\par
2071         s += (c <= 0xff) ? static_cast<char>(c) : {\cf22 '?'};\par
2072     \}\par
2073     return ::Catch::Detail::stringify(s);\par
2074 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< T * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< T * >}
{\xe \v Catch::StringMaker< T * >}
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > static std::string {\b convert} (U *{\b p})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< T * >}
{\xe \v Catch::StringMaker< T * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > static std::string {\b Catch::StringMaker}< T * >::convert (U * p){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2732                                        \{\par
2733             {\cf19 if} (p) \{\par
2734                 return ::Catch::Detail::rawMemoryToString(p);\par
2735             \} {\cf19 else} \{\par
2736                 {\cf19 return} {\cf22 "nullptr"};\par
2737             \}\par
2738         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< T[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< T[SZ]>}
{\xe \v Catch::StringMaker< T[SZ]>}
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (T const(&arr)[SZ])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< T[SZ]>}
{\xe \v Catch::StringMaker< T[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , size_t SZ> static std::string {\b Catch::StringMaker}< T[SZ]>::convert (T const(&) arr[SZ]){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2954                                                     \{\par
2955             {\cf19 return} rangeToString(arr);\par
2956         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned char >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned char >}
{\xe \v Catch::StringMaker< unsigned char >}
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned char {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned char >}
{\xe \v Catch::StringMaker< unsigned char >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned char >::convert (unsigned char value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::StringMaker< unsigned char[SZ]>\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned char[SZ]>}
{\xe \v Catch::StringMaker< unsigned char[SZ]>}
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned char const *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned char[SZ]>}
{\xe \v Catch::StringMaker< unsigned char[SZ]>\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t SZ> static std::string {\b Catch::StringMaker}< unsigned char[SZ]>::convert (unsigned char const * str){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2650                                                            \{\par
2651             {\cf17 auto} reinterpreted = {\cf17 reinterpret_cast<}{\cf18 char} const*{\cf17 >}(str);\par
2652             {\cf19 return} Detail::convertIntoString(\par
2653                 StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\par
2654         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned int >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned int >}
{\xe \v Catch::StringMaker< unsigned int >}
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned int {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned int >}
{\xe \v Catch::StringMaker< unsigned int >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned int >::convert (unsigned int value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned long >}
{\xe \v Catch::StringMaker< unsigned long >}
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned long {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned long >}
{\xe \v Catch::StringMaker< unsigned long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned long >::convert (unsigned long value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< unsigned long long >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< unsigned long long >}
{\xe \v Catch::StringMaker< unsigned long long >}
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (unsigned long long {\b value})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< unsigned long long >}
{\xe \v Catch::StringMaker< unsigned long long >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< unsigned long long >::convert (unsigned long long value){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< wchar_t * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< wchar_t * >}
{\xe \v Catch::StringMaker< wchar_t * >}
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (wchar_t *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< wchar_t * >}
{\xe \v Catch::StringMaker< wchar_t * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string {\b Catch::StringMaker}< wchar_t * >::convert (wchar_t * str){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2089                                                        \{\par
2090     {\cf19 if} (str) \{\par
2091         return ::Catch::Detail::stringify(std::wstring\{ str \});\par
2092     \} {\cf19 else} \{\par
2093         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2094     \}\par
2095 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringMaker< wchar_t const * >\par \pard\plain 
{\tc\tcl2 \v Catch::StringMaker< wchar_t const * >}
{\xe \v Catch::StringMaker< wchar_t const * >}
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b convert} (wchar_t const *str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v convert\:Catch::StringMaker< wchar_t const * >}
{\xe \v Catch::StringMaker< wchar_t const * >\:convert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string {\b Catch::StringMaker}< wchar_t const * >::convert (wchar_t const * str){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::StringRef\par \pard\plain 
{\tc\tcl2 \v Catch::StringRef}
{\xe \v Catch::StringRef}
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b size_type} = std::size_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_iterator} = const char*\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b StringRef} () noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} (char const *rawChars) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b StringRef} (char const *rawChars, {\b size_type} {\b size}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} (std::string const &stdString) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator==} ({\b StringRef} other) const noexcept -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b operator!=} ({\b StringRef} other) const noexcept -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator[]} ({\b size_type} index) const noexcept -> char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b StringRef} rhs) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b empty} () const noexcept -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b size} () const noexcept -> {\b size_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b StringRef} {\b substr} ({\b size_type} start, {\b size_type} length) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr char const * {\b data} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b const_iterator} {\b begin} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b const_iterator} {\b end} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b compare} ({\b StringRef} rhs) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b size_type} {\b npos} \{ static_cast<{\b size_type}>( -1 ) \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string & {\b operator+=} (std::string &lhs, {\b StringRef} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, {\b StringRef} str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator+} ({\b StringRef} lhs, {\b StringRef} rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A non-owning string class (similar to the forthcoming std::string_view) Note that, because a {\b StringRef} may be a substring of another string, it may not be null terminated. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v const_iterator\:Catch::StringRef}
{\xe \v Catch::StringRef\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::StringRef::const_iterator} = const char*}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size_type\:Catch::StringRef}
{\xe \v Catch::StringRef\:size_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::StringRef::size_type} = std::size_t}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (){\f2 [constexpr]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (char const * rawChars){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6375     : StringRef( rawChars, std::strlen(rawChars) )\par
6376     \{\}\par
}
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (char const * rawChars, {\b size_type} size){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 710         :   m_start( rawChars ),\par
711             m_size( size )\par
712         \{\}\par
}
}
{\xe \v StringRef\:Catch::StringRef}
{\xe \v Catch::StringRef\:StringRef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::StringRef (std::string const & stdString){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 715         :   m_start( stdString.c_str() ),\par
716             m_size( stdString.size() )\par
717         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v begin\:Catch::StringRef}
{\xe \v Catch::StringRef\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} Catch::StringRef::begin () const{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 764 \{ {\cf19 return} m_start; \}\par
}
}
{\xe \v compare\:Catch::StringRef}
{\xe \v Catch::StringRef\:compare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Catch::StringRef::compare ({\b StringRef} rhs) const}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides a three-way comparison with rhs\par
Returns negative number if lhs < rhs, 0 if lhs == rhs, and a positive number if lhs > rhs \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6386                                                 \{\par
6387         {\cf17 auto} cmpResult =\par
6388             strncmp( m_start, rhs.m_start, std::min( m_size, rhs.m_size ) );\par
6389 \par
6390         {\cf20 // This means that strncmp found a difference before the strings}\par
6391         {\cf20 // ended, and we can return it directly}\par
6392         {\cf19 if} ( cmpResult != 0 ) \{\par
6393             {\cf19 return} cmpResult;\par
6394         \}\par
6395 \par
6396         {\cf20 // If strings are equal up to length, then their comparison results on}\par
6397         {\cf20 // their size}\par
6398         {\cf19 if} ( m_size < rhs.m_size ) \{\par
6399             {\cf19 return} -1;\par
6400         \} {\cf19 else} {\cf19 if} ( m_size > rhs.m_size ) \{\par
6401             {\cf19 return} 1;\par
6402         \} {\cf19 else} \{\par
6403             {\cf19 return} 0;\par
6404         \}\par
6405     \}\par
}
}
{\xe \v data\:Catch::StringRef}
{\xe \v Catch::StringRef\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char const  * Catch::StringRef::data () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 760                                                     \{\par
761             {\cf19 return} m_start;\par
762         \}\par
}
}
{\xe \v empty\:Catch::StringRef}
{\xe \v Catch::StringRef\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::empty () const -> bool {\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 740                                                       \{\par
741             {\cf19 return} m_size == 0;\par
742         \}\par
}
}
{\xe \v end\:Catch::StringRef}
{\xe \v Catch::StringRef\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} Catch::StringRef::end () const{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 765 \{ {\cf19 return} m_start + m_size; \}\par
}
}
{\xe \v operator std::string\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator std::string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::StringRef::operator std::string () const{\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 719                                             \{\par
720             {\cf19 return} std::string(m_start, m_size);\par
721         \}\par
}
}
{\xe \v operator!=\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::operator!= ({\b StringRef} other) const -> bool {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 728                                                                   \{\par
729             {\cf19 return} !(*{\cf17 this} == other);\par
730         \}\par
}
}
{\xe \v operator<\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::StringRef::operator< ({\b StringRef} rhs) const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6379                                                           \{\par
6380         {\cf19 if} (m_size < rhs.m_size) \{\par
6381             {\cf19 return} strncmp(m_start, rhs.m_start, m_size) <= 0;\par
6382         \}\par
6383         {\cf19 return} strncmp(m_start, rhs.m_start, rhs.m_size) < 0;\par
6384     \}\par
}
}
{\xe \v operator==\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::operator== ({\b StringRef} other) const -> bool {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 724                                                                     \{\par
725             {\cf19 return} m_size == other.m_size\par
726                 && (std::memcmp( m_start, other.m_start, m_size ) == 0);\par
727         \}\par
}
}
{\xe \v operator[]\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::operator[] ({\b size_type} index) const -> char {\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 732                                                                              \{\par
733             assert(index < m_size);\par
734             {\cf19 return} m_start[index];\par
735         \}\par
}
}
{\xe \v size\:Catch::StringRef}
{\xe \v Catch::StringRef\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringRef::size () const -> {\b size_type} {\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 743                                                           \{\par
744             {\cf19 return} m_size;\par
745         \}\par
}
}
{\xe \v substr\:Catch::StringRef}
{\xe \v Catch::StringRef\:substr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::StringRef::substr ({\b size_type} start, {\b size_type} length) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 750                                                                                      \{\par
751             {\cf19 if} (start < m_size) \{\par
752                 {\cf17 const} {\cf17 auto} shortened_size = m_size - start;\par
753                 {\cf19 return} StringRef(m_start + start, (shortened_size < length) ? shortened_size : length);\par
754             \} {\cf19 else} \{\par
755                 {\cf19 return} StringRef();\par
756             \}\par
757         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator+\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string operator+ ({\b StringRef} lhs, {\b StringRef} rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6411                                                       \{\par
6412         std::string ret;\par
6413         ret.reserve(lhs.size() + rhs.size());\par
6414         ret += lhs;\par
6415         ret += rhs;\par
6416         {\cf19 return} ret;\par
6417     \}\par
}
}
{\xe \v operator+=\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string & operator+= (std::string & lhs, {\b StringRef} rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6419                                                                    \{\par
6420         lhs.append(rhs.data(), rhs.size());\par
6421         {\cf19 return} lhs;\par
6422     \}\par
}
}
{\xe \v operator<<\:Catch::StringRef}
{\xe \v Catch::StringRef\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream & os, {\b StringRef} str){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6407                                                                       \{\par
6408         {\cf19 return} os.write(str.data(), {\cf17 static_cast<}std::streamsize{\cf17 >}(str.size()));\par
6409     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v npos\:Catch::StringRef}
{\xe \v Catch::StringRef\:npos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_type} Catch::StringRef::npos \{ static_cast<{\b size_type}>( -1 ) \}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 696 \{ {\cf17 static_cast<}size_type{\cf17 >}( -1 ) \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::StringStreams\par \pard\plain 
{\tc\tcl2 \v Catch::StringStreams}
{\xe \v Catch::StringStreams}
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b add} () -> std::size_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b release} (std::size_t index)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Detail::unique_ptr}< std::ostringstream > > {\b m_streams}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::size_t > {\b m_unused}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostringstream {\b m_referenceStream}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v add\:Catch::StringStreams}
{\xe \v Catch::StringStreams\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::StringStreams::add () -> std::size_t {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5385                                 \{\par
5386             {\cf19 if}( m_unused.empty() ) \{\par
5387                 m_streams.push_back( Detail::make_unique<std::ostringstream>() );\par
5388                 {\cf19 return} m_streams.size()-1;\par
5389             \}\par
5390             {\cf19 else} \{\par
5391                 {\cf17 auto} index = m_unused.back();\par
5392                 m_unused.pop_back();\par
5393                 {\cf19 return} index;\par
5394             \}\par
5395         \}\par
}
}
{\xe \v release\:Catch::StringStreams}
{\xe \v Catch::StringStreams\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::StringStreams::release (std::size_t index){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5397                                         \{\par
5398             m_streams[index]->copyfmt( m_referenceStream ); {\cf20 // Restore initial flags and other state}\par
5399             m_unused.push_back(index);\par
5400         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v m_referenceStream\:Catch::StringStreams}
{\xe \v Catch::StringStreams\:m_referenceStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostringstream Catch::StringStreams::m_referenceStream}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_streams\:Catch::StringStreams}
{\xe \v Catch::StringStreams\:m_streams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Detail::unique_ptr}<std::ostringstream> > Catch::StringStreams::m_streams}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_unused\:Catch::StringStreams}
{\xe \v Catch::StringStreams\:m_unused}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<std::size_t> Catch::StringStreams::m_unused}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::TablePrinter\par \pard\plain 
{\tc\tcl2 \v Catch::TablePrinter}
{\xe \v Catch::TablePrinter}
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TablePrinter} (std::ostream &os, std::vector< {\b ColumnInfo} > {\b columnInfos})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b columnInfos} () const -> std::vector< {\b ColumnInfo} > const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b open} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b TablePrinter} & {\b operator<<} ({\b TablePrinter} &tp, T const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TablePrinter} & {\b operator<<} ({\b TablePrinter} &tp, ColumnBreak)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TablePrinter} & {\b operator<<} ({\b TablePrinter} &tp, RowBreak)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TablePrinter} & {\b operator<<} ({\b TablePrinter} &tp, OutputFlush)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TablePrinter\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:TablePrinter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::TablePrinter::TablePrinter (std::ostream & os, std::vector< {\b ColumnInfo} > columnInfos){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9027     :   m_os( os ),\par
9028         m_columnInfos( CATCH_MOVE( columnInfos ) ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v close\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::TablePrinter::close (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9050                  \{\par
9051         {\cf19 if} (m_isOpen) \{\par
9052             *{\cf17 this} << RowBreak();\par
9053             m_os << {\cf23 '\\n'} << std::flush;\par
9054             m_isOpen = {\cf17 false};\par
9055         \}\par
9056     \}\par
}
}
{\xe \v columnInfos\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:columnInfos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::TablePrinter::columnInfos () const -> std::vector<{\b ColumnInfo}> const& {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9030                                                              \{\par
9031         {\cf19 return} m_columnInfos;\par
9032     \}\par
}
}
{\xe \v open\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::TablePrinter::open (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9034                 \{\par
9035         {\cf19 if} (!m_isOpen) \{\par
9036             m_isOpen = {\cf17 true};\par
9037             *{\cf17 this} << RowBreak();\par
9038 \par
9039             TextFlow::Columns headerCols;\par
9040             {\cf19 for} ({\cf17 auto} {\cf17 const}& info : m_columnInfos) \{\par
9041                 assert(info.width > 2);\par
9042                 headerCols += TextFlow::Column(info.name).width(info.width - 2);\par
9043                 headerCols += TextFlow::Spacer( 2 );\par
9044             \}\par
9045             m_os << headerCols << {\cf23 '\\n'};\par
9046 \par
9047             m_os << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
9048         \}\par
9049     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<<\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TablePrinter} & operator<< ({\b TablePrinter} & tp, ColumnBreak ){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9064                                                                     \{\par
9065         {\cf17 auto} colStr = tp.m_oss.str();\par
9066         {\cf17 const} {\cf17 auto} strSize = colStr.size();\par
9067         tp.m_oss.str({\cf22 ""});\par
9068         tp.open();\par
9069         {\cf19 if} (tp.m_currentColumn == {\cf17 static_cast<}{\cf18 int}{\cf17 >}(tp.m_columnInfos.size() - 1)) \{\par
9070             tp.m_currentColumn = -1;\par
9071             tp.m_os << {\cf23 '\\n'};\par
9072         \}\par
9073         tp.m_currentColumn++;\par
9074 \par
9075         {\cf17 auto} colInfo = tp.m_columnInfos[tp.m_currentColumn];\par
9076         {\cf17 auto} padding = (strSize + 1 < colInfo.width)\par
9077             ? std::string(colInfo.width - (strSize + 1), {\cf23 ' '})\par
9078             : std::string();\par
9079         {\cf19 if} (colInfo.justification == Justification::Left)\par
9080             tp.m_os << colStr << padding << {\cf23 ' '};\par
9081         {\cf19 else}\par
9082             tp.m_os << padding << colStr << {\cf23 ' '};\par
9083         {\cf19 return} tp;\par
9084     \}\par
}
}
{\xe \v operator<<\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TablePrinter} & operator<< ({\b TablePrinter} & tp, OutputFlush ){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9094                                                                    \{\par
9095         tp.m_os << std::flush;\par
9096         {\cf19 return} tp;\par
9097     \}\par
}
}
{\xe \v operator<<\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TablePrinter} & operator<< ({\b TablePrinter} & tp, RowBreak ){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9086                                                                  \{\par
9087         {\cf19 if} (tp.m_currentColumn > 0) \{\par
9088             tp.m_os << {\cf23 '\\n'};\par
9089             tp.m_currentColumn = -1;\par
9090         \}\par
9091         {\cf19 return} tp;\par
9092     \}\par
}
}
{\xe \v operator<<\:Catch::TablePrinter}
{\xe \v Catch::TablePrinter\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b TablePrinter} & operator<< ({\b TablePrinter} & tp, T const & value){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 9059                                                                        \{\par
9060         tp.m_oss << value;\par
9061         {\cf19 return} tp;\par
9062     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Tag\par \pard\plain 
{\tc\tcl2 \v Catch::Tag}
{\xe \v Catch::Tag}
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b Tag} ({\b StringRef} original_)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b original}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A {\b view}  of a tag string that provides case insensitive comparisons\par
Note that in Catch2 internals, the square brackets around tags are not a part of tag's representation, so e.g. "[cool-tag]" is represented as "cool-tag" internally. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Tag\:Catch::Tag}
{\xe \v Catch::Tag\:Tag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Tag::Tag ({\b StringRef} original_){\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7028                                           :\par
7029             original(original_)\par
7030         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<\:Catch::Tag}
{\xe \v Catch::Tag\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator< ({\b Tag} const & lhs, {\b Tag} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1607                                                       \{\par
1608         Detail::CaseInsensitiveLess cmp;\par
1609         {\cf19 return} cmp( lhs.original, rhs.original );\par
1610     \}\par
}
}
{\xe \v operator==\:Catch::Tag}
{\xe \v Catch::Tag\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== ({\b Tag} const & lhs, {\b Tag} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1611                                                       \{\par
1612         Detail::CaseInsensitiveEqualTo cmp;\par
1613         {\cf19 return} cmp( lhs.original, rhs.original );\par
1614     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v original\:Catch::Tag}
{\xe \v Catch::Tag\:original}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Tag::original}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::TagAlias\par \pard\plain 
{\tc\tcl2 \v Catch::TagAlias}
{\xe \v Catch::TagAlias}
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TagAlias} (std::string const &_tag, {\b SourceLineInfo} _lineInfo)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b tag}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TagAlias\:Catch::TagAlias}
{\xe \v Catch::TagAlias\:TagAlias}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::TagAlias::TagAlias (std::string const & _tag, {\b SourceLineInfo} _lineInfo){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4974                                                                  :\par
4975             tag(_tag),\par
4976             lineInfo(_lineInfo)\par
4977         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v lineInfo\:Catch::TagAlias}
{\xe \v Catch::TagAlias\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::TagAlias::lineInfo}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tag\:Catch::TagAlias}
{\xe \v Catch::TagAlias\:tag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TagAlias::tag}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Generators::TakeGenerator< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Generators::TakeGenerator< T >}
{\xe \v Catch::Generators::TakeGenerator< T >}
{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::Generators::TakeGenerator< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_generators_1_1_take_generator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TakeGenerator} (size_t target, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b get} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b next} () override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GeneratorUntypedBase} & {\b operator=} ({\b GeneratorUntypedBase} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GeneratorUntypedBase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b countedNext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b currentElementIndex} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b currentElementAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos P\'FAblicos herdados de {\b Catch::Generators::IGenerator< T >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TakeGenerator\:Catch::Generators::TakeGenerator< T >}
{\xe \v Catch::Generators::TakeGenerator< T >\:TakeGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Generators::TakeGenerator}< T >::TakeGenerator (size_t target, {\b GeneratorWrapper}< T > && generator){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7655                                                                      :\par
7656             m_generator(CATCH_MOVE(generator)),\par
7657             m_target(target)\par
7658         \{\par
7659             assert(target != 0 && {\cf22 "Empty generators are not allowed"});\par
7660         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Generators::TakeGenerator< T >}
{\xe \v Catch::Generators::TakeGenerator< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Generators::TakeGenerator}< T >::get () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::Generators::IGenerator< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7661                                       \{\par
7662             {\cf19 return} m_generator.get();\par
7663         \}\par
}
}
{\xe \v next\:Catch::Generators::TakeGenerator< T >}
{\xe \v Catch::Generators::TakeGenerator< T >\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b Catch::Generators::TakeGenerator}< T >::next (){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to move the generator to the next element\par
Returns true iff the move succeeded (and a valid element can be retrieved). \par
}{
Implementa {\b Catch::Generators::GeneratorUntypedBase} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACLI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7664                              \{\par
7665             ++m_returned;\par
7666             {\cf19 if} (m_returned >= m_target) \{\par
7667                 {\cf19 return} {\cf17 false};\par
7668             \}\par
7669 \par
7670             {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7671             {\cf20 // If the underlying generator does not contain enough values}\par
7672             {\cf20 // then we cut short as well}\par
7673             {\cf19 if} (!success) \{\par
7674                 m_returned = m_target;\par
7675             \}\par
7676             {\cf19 return} success;\par
7677         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::TestCaseHandle\par \pard\plain 
{\tc\tcl2 \v Catch::TestCaseHandle}
{\xe \v Catch::TestCaseHandle}
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseHandle} ({\b TestCaseInfo} *info, {\b ITestInvoker} *invoker)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invoke} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseInfo} const & {\b getTestCaseInfo} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper over the test case information and the test case invoker\par
Does not own either, and is specifically made to be cheap to copy around. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TestCaseHandle\:Catch::TestCaseHandle}
{\xe \v Catch::TestCaseHandle\:TestCaseHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::TestCaseHandle::TestCaseHandle ({\b TestCaseInfo} * info, {\b ITestInvoker} * invoker){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7103                                                                   :\par
7104             m_info(info), m_invoker(invoker) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getTestCaseInfo\:Catch::TestCaseHandle}
{\xe \v Catch::TestCaseHandle\:getTestCaseInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestCaseInfo} const  & Catch::TestCaseHandle::getTestCaseInfo () const}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1761                                                               \{\par
1762         {\cf19 return} *m_info;\par
1763     \}\par
}
}
{\xe \v invoke\:Catch::TestCaseHandle}
{\xe \v Catch::TestCaseHandle\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::TestCaseHandle::invoke () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7106                             \{\par
7107             m_invoker->invoke();\par
7108         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::TestCaseInfo\par \pard\plain 
{\tc\tcl2 \v Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo}
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::TestCaseInfo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1_test_case_info.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseInfo} ({\b StringRef} _className, {\b NameAndTags} const &_nameAndTags, {\b SourceLineInfo} const &_lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isHidden} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b throws} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b okToFail} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b expectedToFail} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addFilenameTag} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b tagsAsString} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b className}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b Tag} > {\b tags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SourceLineInfo} {\b lineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestCaseProperties} {\b properties} = {\b TestCaseProperties::None}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b TestCaseInfo} const &lhs, {\b TestCaseInfo} const &rhs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Orders by name, classname and tags. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::Detail::NonCopyable}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NonCopyable} () noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Various metadata about the test case.\par
A test case is uniquely identified by its (class)name and tags combination, with source location being ignored, and other properties being determined from tags.\par
Tags are kept sorted. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TestCaseInfo\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:TestCaseInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::TestCaseInfo::TestCaseInfo ({\b StringRef} _className, {\b NameAndTags} const & _nameAndTags, {\b SourceLineInfo} const & _lineInfo)}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1625                                                                :\par
1626         name( _nameAndTags.name.empty() ? makeDefaultName() : _nameAndTags.name ),\par
1627         className( _className ),\par
1628         lineInfo( _lineInfo )\par
1629     \{\par
1630         StringRef originalTags = _nameAndTags.tags;\par
1631         {\cf20 // We need to reserve enough space to store all of the tags}\par
1632         {\cf20 // (including optional hidden tag and filename tag)}\par
1633         {\cf17 auto} requiredSize = originalTags.size() + sizeOfExtraTags(_lineInfo.file);\par
1634         backingTags.reserve(requiredSize);\par
1635 \par
1636         {\cf20 // We cannot copy the tags directly, as we need to normalize}\par
1637         {\cf20 // some tags, so that [.foo] is copied as [.][foo].}\par
1638         {\cf18 size_t} tagStart = 0;\par
1639         {\cf18 size_t} tagEnd = 0;\par
1640         {\cf18 bool} inTag = {\cf17 false};\par
1641         {\cf19 for} ({\cf18 size_t} idx = 0; idx < originalTags.size(); ++idx) \{\par
1642             {\cf17 auto} c = originalTags[idx];\par
1643             {\cf19 if} (c == {\cf23 '['}) \{\par
1644                 CATCH_ENFORCE(\par
1645                     !inTag,\par
1646                     {\cf22 "Found '[' inside a tag while registering test case '"}\par
1647                         << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1648 \par
1649                 inTag = {\cf17 true};\par
1650                 tagStart = idx;\par
1651             \}\par
1652             {\cf19 if} (c == {\cf23 ']'}) \{\par
1653                 CATCH_ENFORCE(\par
1654                     inTag,\par
1655                     {\cf22 "Found unmatched ']' while registering test case '"}\par
1656                         << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1657 \par
1658                 inTag = {\cf17 false};\par
1659                 tagEnd = idx;\par
1660                 assert(tagStart < tagEnd);\par
1661 \par
1662                 {\cf20 // We need to check the tag for special meanings, copy}\par
1663                 {\cf20 // it over to backing storage and actually reference the}\par
1664                 {\cf20 // backing storage in the saved tags}\par
1665                 StringRef tagStr = originalTags.substr(tagStart+1, tagEnd - tagStart - 1);\par
1666                 CATCH_ENFORCE( !tagStr.empty(),\par
1667                                {\cf22 "Found an empty tag while registering test case '"}\par
1668                                    << _nameAndTags.name << {\cf22 "' at "}\par
1669                                    << _lineInfo );\par
1670 \par
1671                 enforceNotReservedTag(tagStr, lineInfo);\par
1672                 properties |= parseSpecialTag(tagStr);\par
1673                 {\cf20 // When copying a tag to the backing storage, we need to}\par
1674                 {\cf20 // check if it is a merged hide tag, such as [.foo], and}\par
1675                 {\cf20 // if it is, we need to handle it as if it was [foo].}\par
1676                 {\cf19 if} (tagStr.size() > 1 && tagStr[0] == {\cf23 '.'}) \{\par
1677                     tagStr = tagStr.substr(1, tagStr.size() - 1);\par
1678                 \}\par
1679                 {\cf20 // We skip over dealing with the [.] tag, as we will add}\par
1680                 {\cf20 // it later unconditionally and then sort and unique all}\par
1681                 {\cf20 // the tags.}\par
1682                 internalAppendTag(tagStr);\par
1683             \}\par
1684         \}\par
1685         CATCH_ENFORCE( !inTag,\par
1686                        {\cf22 "Found an unclosed tag while registering test case '"}\par
1687                            << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1688 \par
1689 \par
1690         {\cf20 // Add [.] if relevant}\par
1691         {\cf19 if} (isHidden()) \{\par
1692             internalAppendTag({\cf22 "."}_sr);\par
1693         \}\par
1694 \par
1695         {\cf20 // Sort and prepare tags}\par
1696         std::sort(begin(tags), end(tags));\par
1697         tags.erase(std::unique(begin(tags), end(tags)),\par
1698                    end(tags));\par
1699     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v addFilenameTag\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:addFilenameTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::TestCaseInfo::addFilenameTag ()}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1714                                       \{\par
1715         std::string combined({\cf22 "#"});\par
1716         combined += extractFilenamePart(lineInfo.file);\par
1717         internalAppendTag(combined);\par
1718     \}\par
}
}
{\xe \v expectedToFail\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:expectedToFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::expectedToFail () const}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1710                                             \{\par
1711         {\cf19 return} applies( properties & (TestCaseProperties::ShouldFail) );\par
1712     \}\par
}
}
{\xe \v isHidden\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:isHidden}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::isHidden () const}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1701                                       \{\par
1702         {\cf19 return} applies( properties & TestCaseProperties::IsHidden );\par
1703     \}\par
}
}
{\xe \v okToFail\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:okToFail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::okToFail () const}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1707                                       \{\par
1708         {\cf19 return} applies( properties & (TestCaseProperties::ShouldFail | TestCaseProperties::MayFail ) );\par
1709     \}\par
}
}
{\xe \v tagsAsString\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:tagsAsString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TestCaseInfo::tagsAsString () const}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1720                                                \{\par
1721         std::string ret;\par
1722         {\cf20 // '[' and ']' per tag}\par
1723         std::size_t full_size = 2 * tags.size();\par
1724         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
1725             full_size += tag.original.size();\par
1726         \}\par
1727         ret.reserve(full_size);\par
1728         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
1729             ret.push_back({\cf23 '['});\par
1730             ret += tag.original;\par
1731             ret.push_back({\cf23 ']'});\par
1732         \}\par
1733 \par
1734         {\cf19 return} ret;\par
1735     \}\par
}
}
{\xe \v throws\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:throws}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestCaseInfo::throws () const}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1704                                     \{\par
1705         {\cf19 return} applies( properties & TestCaseProperties::Throws );\par
1706     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator< ({\b TestCaseInfo} const & lhs, {\b TestCaseInfo} const & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Orders by name, classname and tags. }}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1746                                                                        \{\par
1747         {\cf20 // We want to avoid redoing the string comparisons multiple times,}\par
1748         {\cf20 // so we store the result of a three-way comparison before using}\par
1749         {\cf20 // it in the actual comparison logic.}\par
1750         {\cf17 const} {\cf17 auto} cmpName = lhs.name.compare( rhs.name );\par
1751         {\cf19 if} ( cmpName != 0 ) \{\par
1752             {\cf19 return} cmpName < 0;\par
1753         \}\par
1754         {\cf17 const} {\cf17 auto} cmpClassName = lhs.className.compare( rhs.className );\par
1755         {\cf19 if} ( cmpClassName != 0 ) \{\par
1756             {\cf19 return} cmpClassName < 0;\par
1757         \}\par
1758         {\cf19 return} lhs.tags < rhs.tags;\par
1759     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v className\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:className}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::TestCaseInfo::className}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lineInfo\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:lineInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SourceLineInfo} Catch::TestCaseInfo::lineInfo}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v name\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Catch::TestCaseInfo::name}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v properties\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:properties}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestCaseProperties} Catch::TestCaseInfo::properties = {\b TestCaseProperties::None}}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tags\:Catch::TestCaseInfo}
{\xe \v Catch::TestCaseInfo\:tags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b Tag}> Catch::TestCaseInfo::tags}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::TestFailureException\par \pard\plain 
{\tc\tcl2 \v Catch::TestFailureException}
{\xe \v Catch::TestFailureException}
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that an assertion macro failed. }}\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that an assertion macro failed. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::TestInvokerAsMethod< C >\par \pard\plain 
{\tc\tcl2 \v Catch::TestInvokerAsMethod< C >}
{\xe \v Catch::TestInvokerAsMethod< C >}
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::TestInvokerAsMethod< C >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_test_invoker_as_method.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TestInvokerAsMethod} (void(C::*testAsMethod)()) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invoke} () const override\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::ITestInvoker}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~ITestInvoker} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TestInvokerAsMethod\:Catch::TestInvokerAsMethod< C >}
{\xe \v Catch::TestInvokerAsMethod< C >\:TestInvokerAsMethod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > {\b Catch::TestInvokerAsMethod}< C >::TestInvokerAsMethod (void(C::* testAsMethod\~ )()){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5993 : m_testAsMethod( testAsMethod ) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v invoke\:Catch::TestInvokerAsMethod< C >}
{\xe \v Catch::TestInvokerAsMethod< C >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C > void {\b Catch::TestInvokerAsMethod}< C >::invoke () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implementa {\b Catch::ITestInvoker} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABGS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5995                                  \{\par
5996         C obj;\par
5997         (obj.*m_testAsMethod)();\par
5998     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::TestSkipException\par \pard\plain 
{\tc\tcl2 \v Catch::TestSkipException}
{\xe \v Catch::TestSkipException}
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that the remainder of a test should be skipped. }}\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that the remainder of a test should be skipped. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::TestSpec\par \pard\plain 
{\tc\tcl2 \v Catch::TestSpec}
{\xe \v Catch::TestSpec}
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b FilterMatch}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Matches} = std::vector<{\b FilterMatch}>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b vectorStrings} = std::vector<std::string>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasFilters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matches} ({\b TestCaseInfo} const &testCase) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Matches} {\b matchesByFilter} (std::vector< {\b TestCaseHandle} > const &testCases, {\b IConfig} const &config) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b vectorStrings} & {\b getInvalidSpecs} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TestSpecParser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &out, {\b TestSpec} const &spec)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v Matches\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:Matches}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::TestSpec::Matches} = std::vector<{\b FilterMatch}>}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v vectorStrings\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:vectorStrings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b Catch::TestSpec::vectorStrings} = std::vector<std::string>}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getInvalidSpecs\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:getInvalidSpecs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b TestSpec::vectorStrings} & Catch::TestSpec::getInvalidSpecs () const}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1880                                                                  \{\par
1881         {\cf19 return} m_invalidSpecs;\par
1882     \}\par
}
}
{\xe \v hasFilters\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:hasFilters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestSpec::hasFilters () const}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1857                                     \{\par
1858         {\cf19 return} !m_filters.empty();\par
1859     \}\par
}
}
{\xe \v matches\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:matches}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::TestSpec::matches ({\b TestCaseInfo} const & testCase) const}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1861                                                                \{\par
1862         {\cf19 return} std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter {\cf17 const}& f )\{ return f.matches( testCase ); \} );\par
1863     \}\par
}
}
{\xe \v matchesByFilter\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:matchesByFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TestSpec::Matches} Catch::TestSpec::matchesByFilter (std::vector< {\b TestCaseHandle} > const & testCases, {\b IConfig} const & config) const}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1865                                                                                                                        \{\par
1866         Matches matches;\par
1867         matches.reserve( m_filters.size() );\par
1868         {\cf19 for} ( {\cf17 auto} {\cf17 const}& filter : m_filters ) \{\par
1869             std::vector<TestCaseHandle const*> currentMatches;\par
1870             {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : testCases )\par
1871                 {\cf19 if} ( isThrowSafe( test, config ) &&\par
1872                      filter.matches( test.getTestCaseInfo() ) )\par
1873                     currentMatches.emplace_back( &test );\par
1874             matches.push_back(\par
1875                 FilterMatch\{ extractFilterName( filter ), currentMatches \} );\par
1876         \}\par
1877         {\cf19 return} matches;\par
1878     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<<\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream & out, {\b TestSpec} const & spec){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3497                                                               \{\par
3498             spec.serializeTo( out );\par
3499             {\cf19 return} out;\par
3500         \}\par
}
}
{\xe \v TestSpecParser\:Catch::TestSpec}
{\xe \v Catch::TestSpec\:TestSpecParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class TestSpecParser{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Timer\par \pard\plain 
{\tc\tcl2 \v Catch::Timer}
{\xe \v Catch::Timer}
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b start} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedNanoseconds} () const -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedMicroseconds} () const -> uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedMilliseconds} () const -> unsigned int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b getElapsedSeconds} () const -> double\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getElapsedMicroseconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedMicroseconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedMicroseconds () const -> uint64_t}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1915                                                          \{\par
1916         {\cf19 return} getElapsedNanoseconds()/1000;\par
1917     \}\par
}
}
{\xe \v getElapsedMilliseconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedMilliseconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedMilliseconds () const -> unsigned int}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1918                                                              \{\par
1919         {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(getElapsedMicroseconds()/1000);\par
1920     \}\par
}
}
{\xe \v getElapsedNanoseconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedNanoseconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedNanoseconds () const -> uint64_t}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1912                                                         \{\par
1913         {\cf19 return} getCurrentNanosecondsSinceEpoch() - m_nanoseconds;\par
1914     \}\par
}
}
{\xe \v getElapsedSeconds\:Catch::Timer}
{\xe \v Catch::Timer\:getElapsedSeconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto Catch::Timer::getElapsedSeconds () const -> double}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1921                                                   \{\par
1922         {\cf19 return} getElapsedMicroseconds()/1000000.0;\par
1923     \}\par
}
}
{\xe \v start\:Catch::Timer}
{\xe \v Catch::Timer\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Catch::Timer::start ()}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1909                       \{\par
1910        m_nanoseconds = getCurrentNanosecondsSinceEpoch();\par
1911     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Benchmark::Timing< Result >\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Timing< Result >}
{\xe \v Catch::Benchmark::Timing< Result >}
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDuration} {\b elapsed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Result {\b result}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b iterations}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v elapsed\:Catch::Benchmark::Timing< Result >}
{\xe \v Catch::Benchmark::Timing< Result >\:elapsed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Result > {\b IDuration} {\b Catch::Benchmark::Timing}< Result >::elapsed}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterations\:Catch::Benchmark::Timing< Result >}
{\xe \v Catch::Benchmark::Timing< Result >\:iterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Result > int {\b Catch::Benchmark::Timing}< Result >::iterations}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:Catch::Benchmark::Timing< Result >}
{\xe \v Catch::Benchmark::Timing< Result >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Result > Result {\b Catch::Benchmark::Timing}< Result >::result}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Clara::Detail::Token\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::Token}
{\xe \v Catch::Clara::Detail::Token}
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TokenType} {\b type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b token}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v token\:Catch::Clara::Detail::Token}
{\xe \v Catch::Clara::Detail::Token\:token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringRef} Catch::Clara::Detail::Token::token}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:Catch::Clara::Detail::Token}
{\xe \v Catch::Clara::Detail::Token\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TokenType} Catch::Clara::Detail::Token::type}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::Clara::Detail::TokenStream\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream}
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TokenStream} ({\b Args} const &args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TokenStream} (Iterator it, Iterator itEnd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b count} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Token} {\b operator*} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Token} const * {\b operator->} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TokenStream} & {\b operator++} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v TokenStream\:Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream\:TokenStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::TokenStream::TokenStream ({\b Args} const & args){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2698                                                       :\par
2699                 TokenStream( args.m_args.begin(), args.m_args.end() ) \{\}\par
}
}
{\xe \v TokenStream\:Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream\:TokenStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::TokenStream::TokenStream (Iterator it, Iterator itEnd)}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2701                                                                    :\par
2702                 it( it_ ), itEnd( itEnd_ ) \{\par
2703                 loadBuffer();\par
2704             \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v count\:Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Catch::Clara::Detail::TokenStream::count () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4280                                      \{\par
4281                     {\cf19 return} m_tokenBuffer.size() + ( itEnd - it );\par
4282                 \}\par
}
}
{\xe \v operator bool\:Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Clara::Detail::TokenStream::operator bool () const{\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4276                                                \{\par
4277                     {\cf19 return} !m_tokenBuffer.empty() || it != itEnd;\par
4278                 \}\par
}
}
{\xe \v operator*\:Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Token} Catch::Clara::Detail::TokenStream::operator* () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4284                                         \{\par
4285                     assert( !m_tokenBuffer.empty() );\par
4286                     {\cf19 return} m_tokenBuffer.front();\par
4287                 \}\par
}
}
{\xe \v operator++\:Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TokenStream} & Catch::Clara::Detail::TokenStream::operator++ ()}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2706                                                  \{\par
2707                 {\cf19 if} ( m_tokenBuffer.size() >= 2 ) \{\par
2708                     m_tokenBuffer.erase( m_tokenBuffer.begin() );\par
2709                 \} {\cf19 else} \{\par
2710                     {\cf19 if} ( it != itEnd )\par
2711                         ++it;\par
2712                     loadBuffer();\par
2713                 \}\par
2714                 {\cf19 return} *{\cf17 this};\par
2715             \}\par
}
}
{\xe \v operator->\:Catch::Clara::Detail::TokenStream}
{\xe \v Catch::Clara::Detail::TokenStream\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Token} const  * Catch::Clara::Detail::TokenStream::operator-> () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4289                                                 \{\par
4290                     assert( !m_tokenBuffer.empty() );\par
4291                     {\cf19 return} &m_tokenBuffer.front();\par
4292                 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Totals\par \pard\plain 
{\tc\tcl2 \v Catch::Totals}
{\xe \v Catch::Totals}
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Totals} {\b operator-} ({\b Totals} const &other) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Totals} & {\b operator+=} ({\b Totals} const &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Totals} {\b delta} ({\b Totals} const &prevTotals) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b assertions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Counts} {\b testCases}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v delta\:Catch::Totals}
{\xe \v Catch::Totals\:delta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Totals} Catch::Totals::delta ({\b Totals} const & prevTotals) const}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2217                                                          \{\par
2218         Totals diff = *{\cf17 this} - prevTotals;\par
2219         {\cf19 if}( diff.assertions.failed > 0 )\par
2220             ++diff.testCases.failed;\par
2221         {\cf19 else} {\cf19 if}( diff.assertions.failedButOk > 0 )\par
2222             ++diff.testCases.failedButOk;\par
2223         {\cf19 else} {\cf19 if} ( diff.assertions.skipped > 0 )\par
2224             ++ diff.testCases.skipped;\par
2225         {\cf19 else}\par
2226             ++diff.testCases.passed;\par
2227         {\cf19 return} diff;\par
2228     \}\par
}
}
{\xe \v operator+=\:Catch::Totals}
{\xe \v Catch::Totals\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Totals} & Catch::Totals::operator+= ({\b Totals} const & other)}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2211                                                       \{\par
2212         assertions += other.assertions;\par
2213         testCases += other.testCases;\par
2214         {\cf19 return} *{\cf17 this};\par
2215     \}\par
}
}
{\xe \v operator-\:Catch::Totals}
{\xe \v Catch::Totals\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Totals} Catch::Totals::operator- ({\b Totals} const & other) const}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2204                                                           \{\par
2205         Totals diff;\par
2206         diff.assertions = assertions - other.assertions;\par
2207         diff.testCases = testCases - other.testCases;\par
2208         {\cf19 return} diff;\par
2209     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v assertions\:Catch::Totals}
{\xe \v Catch::Totals\:assertions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::Totals::assertions}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v testCases\:Catch::Totals}
{\xe \v Catch::Totals\:testCases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Counts} Catch::Totals::testCases}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::true_given< typename >\par \pard\plain 
{\tc\tcl2 \v Catch::true_given< typename >}
{\xe \v Catch::true_given< typename >}
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::true_given< typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_catch_1_1true__given.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Benchmark::Detail::CompleteType< void >::type\par \pard\plain 
{\tc\tcl2 \v Catch::Benchmark::Detail::CompleteType< void >::type}
{\xe \v Catch::Benchmark::Detail::CompleteType< void >::type}
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::UnaryExpr< LhsT >\par \pard\plain 
{\tc\tcl2 \v Catch::UnaryExpr< LhsT >}
{\xe \v Catch::UnaryExpr< LhsT >}
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
Diagrama de hierarquia da classe Catch::UnaryExpr< LhsT >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_catch_1_1_unary_expr.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b UnaryExpr} (LhsT lhs)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros P\'FAblicos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b isBinaryExpression} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b getResult} () const -> bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b ITransientExpression} (bool {\b isBinaryExpression}, bool result)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} ({\b ITransientExpression} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ITransientExpression} & {\b operator=} ({\b ITransientExpression} const &)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Outros membros herdados\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Membros protegidos herdados de {\b Catch::ITransientExpression}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ITransientExpression} ()=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v UnaryExpr\:Catch::UnaryExpr< LhsT >}
{\xe \v Catch::UnaryExpr< LhsT >\:UnaryExpr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename LhsT > {\b Catch::UnaryExpr}< LhsT >::UnaryExpr (LhsT lhs){\f2 [inline]}, {\f2 [explicit]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5404         :   ITransientExpression\{ {\cf17 false}, {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(lhs) \},\par
5405             m_lhs( lhs )\par
5406         \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::UnaryLambdaTraits< L >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::UnaryLambdaTraits< L >}
{\xe \v Catch::Clara::Detail::UnaryLambdaTraits< L >}
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >}
{\xe \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >}
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b isValid} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v isValid\:Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >}
{\xe \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >\:isValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ClassT , typename ReturnT , typename... Args> const bool {\b Catch::Clara::Detail::UnaryLambdaTraits}< ReturnT(ClassT::*)(Args...) const >::isValid = false{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Estrutura Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >\par \pard\plain 
{\tc\tcl2 \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >}
{\xe \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >}
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ArgType} = std::remove_const_t<std::remove_reference_t<ArgT>>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ReturnType} = ReturnT\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos Est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const bool {\b isValid} = true\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das defini\'E7\'F5es de tipos\par
\pard\plain 
{\xe \v ArgType\:Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >}
{\xe \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >\:ArgType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ClassT , typename ReturnT , typename ArgT > using {\b Catch::Clara::Detail::UnaryLambdaTraits}< ReturnT(ClassT::*)(ArgT) const >::ArgType = std::remove_const_t<std::remove_reference_t<ArgT>>}}
\par
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ReturnType\:Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >}
{\xe \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >\:ReturnType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ClassT , typename ReturnT , typename ArgT > using {\b Catch::Clara::Detail::UnaryLambdaTraits}< ReturnT(ClassT::*)(ArgT) const >::ReturnType = ReturnT}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v isValid\:Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >}
{\xe \v Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >\:isValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ClassT , typename ReturnT , typename ArgT > const bool {\b Catch::Clara::Detail::UnaryLambdaTraits}< ReturnT(ClassT::*)(ArgT) const >::isValid = true{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Template da Classe Catch::Detail::unique_ptr< T >\par \pard\plain 
{\tc\tcl2 \v Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >}
{\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b unique_ptr} (std::nullptr_t=nullptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b unique_ptr} (T *ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U , typename  = std::enable_if_t<std::is_base_of<T, U>::value>> {\b unique_ptr} ({\b unique_ptr}< U > &&from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U , typename  = std::enable_if_t<std::is_base_of<T, U>::value>> {\b unique_ptr} & {\b operator=} ({\b unique_ptr}< U > &&from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b unique_ptr} ({\b unique_ptr} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b unique_ptr} & {\b operator=} ({\b unique_ptr} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b unique_ptr} ({\b unique_ptr} &&rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b unique_ptr} & {\b operator=} ({\b unique_ptr} &&rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~unique_ptr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator*} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const & {\b operator*} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b operator->} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const * {\b operator->} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b get} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T const * {\b get} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} (T *ptr=nullptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b release} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b unique_ptr} &lhs, {\b unique_ptr} &rhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class Catch::Detail::unique_ptr< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A reimplementation of {\f2 std::unique_ptr}  for improved compilation performance\par
Does not support arrays nor custom deleters. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v unique_ptr\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:unique_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Detail::unique_ptr}< T >::unique_ptr (std::nullptr_t  = {\f2 nullptr}){\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 864                                                     :\par
865             m_ptr\{\}\par
866         \{\}\par
}
}
{\xe \v unique_ptr\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:unique_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Detail::unique_ptr}< T >::unique_ptr (T * ptr){\f2 [inline]}, {\f2 [explicit]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 867                                              :\par
868             m_ptr(ptr)\par
869         \{\}\par
}
}
{\xe \v unique_ptr\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:unique_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U , typename  = std::enable_if_t<std::is_base_of<T, U>::value>> {\b Catch::Detail::unique_ptr}< T >::unique_ptr ({\b unique_ptr}< U > && from){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 872                                         :\par
873             m_ptr(from.release())\par
874         \{\}\par
}
}
{\xe \v unique_ptr\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:unique_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Detail::unique_ptr}< T >::unique_ptr ({\b unique_ptr}< T > const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unique_ptr\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:unique_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Detail::unique_ptr}< T >::unique_ptr ({\b unique_ptr}< T > && rhs){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 886                                              :\par
887             m_ptr(rhs.m_ptr) \{\par
888             rhs.m_ptr = {\cf17 nullptr};\par
889         \}\par
}
}
{\xe \v ~unique_ptr\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:~unique_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Detail::unique_ptr}< T >::~{\b unique_ptr} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 896                       \{\par
897             {\cf17 delete} m_ptr;\par
898         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v get\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b Catch::Detail::unique_ptr}< T >::get (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 917 \{ {\cf19 return} m_ptr; \}\par
}
}
{\xe \v get\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  * {\b Catch::Detail::unique_ptr}< T >::get () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 918 \{ {\cf19 return} m_ptr; \}\par
}
}
{\xe \v operator bool\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b Catch::Detail::unique_ptr}< T >::operator bool () const{\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 931                                        \{\par
932             {\cf19 return} m_ptr;\par
933         \}\par
}
}
{\xe \v operator*\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T & {\b Catch::Detail::unique_ptr}< T >::operator* (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 900                        \{\par
901             assert(m_ptr);\par
902             {\cf19 return} *m_ptr;\par
903         \}\par
}
}
{\xe \v operator*\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  & {\b Catch::Detail::unique_ptr}< T >::operator* () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 904                                    \{\par
905             assert(m_ptr);\par
906             {\cf19 return} *m_ptr;\par
907         \}\par
}
}
{\xe \v operator->\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T const  * {\b Catch::Detail::unique_ptr}< T >::operator-> () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 912                                              \{\par
913             assert(m_ptr);\par
914             {\cf19 return} m_ptr;\par
915         \}\par
}
}
{\xe \v operator->\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b Catch::Detail::unique_ptr}< T >::operator-> (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 908                                  \{\par
909             assert(m_ptr);\par
910             {\cf19 return} m_ptr;\par
911         \}\par
}
}
{\xe \v operator=\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b unique_ptr} & {\b Catch::Detail::unique_ptr}< T >::operator= ({\b unique_ptr}< T > && rhs){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 890                                                          \{\par
891             reset(rhs.release());\par
892 \par
893             {\cf19 return} *{\cf17 this};\par
894         \}\par
}
}
{\xe \v operator=\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b unique_ptr} & {\b Catch::Detail::unique_ptr}< T >::operator= ({\b unique_ptr}< T > const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U , typename  = std::enable_if_t<std::is_base_of<T, U>::value>> {\b unique_ptr} & {\b Catch::Detail::unique_ptr}< T >::operator= ({\b unique_ptr}< U > && from){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 877                                                     \{\par
878             reset(from.release());\par
879 \par
880             {\cf19 return} *{\cf17 this};\par
881         \}\par
}
}
{\xe \v release\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:release}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T * {\b Catch::Detail::unique_ptr}< T >::release (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 925                      \{\par
926             {\cf17 auto} temp = m_ptr;\par
927             m_ptr = {\cf17 nullptr};\par
928             {\cf19 return} temp;\par
929         \}\par
}
}
{\xe \v reset\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b Catch::Detail::unique_ptr}< T >::reset (T * ptr = {\f2 nullptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 920                                      \{\par
921             {\cf17 delete} m_ptr;\par
922             m_ptr = ptr;\par
923         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v swap\:Catch::Detail::unique_ptr< T >}
{\xe \v Catch::Detail::unique_ptr< T >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void swap ({\b unique_ptr}< T > & lhs, {\b unique_ptr}< T > & rhs){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 935                                                            \{\par
936             {\cf17 auto} temp = lhs.m_ptr;\par
937             lhs.m_ptr = rhs.m_ptr;\par
938             rhs.m_ptr = temp;\par
939         \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Usuario\par \pard\plain 
{\tc\tcl2 \v Usuario}
{\xe \v Usuario}
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
\par
{
{\f2 #include <Usuario.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Usuario} (int id, const string &nome, const string &telefone)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getId} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getNome} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getTelefone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNome} (const string &nome)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTelefone} (const string &telefone)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Usuario\:Usuario}
{\xe \v Usuario\:Usuario}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Usuario::Usuario (int id, const string & nome, const string & telefone)}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7     : id({\cf18 id}), nome(nome), telefone(telefone) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v getId\:Usuario}
{\xe \v Usuario\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Usuario::getId () const}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                          \{\par
11     {\cf19 return} id;\par
12 \}\par
}
}
{\xe \v getNome\:Usuario}
{\xe \v Usuario\:getNome}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Usuario::getNome () const}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13                               \{\par
14     {\cf19 return} nome;\par
15 \}\par
}
}
{\xe \v getTelefone\:Usuario}
{\xe \v Usuario\:getTelefone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string Usuario::getTelefone () const}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 16                                   \{\par
17     {\cf19 return} telefone;\par
18 \}\par
}
}
{\xe \v setNome\:Usuario}
{\xe \v Usuario\:setNome}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Usuario::setNome (const string & nome)}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21                                         \{\par
22     this->nome = nome;\par
23 \}\par
}
}
{\xe \v setTelefone\:Usuario}
{\xe \v Usuario\:setTelefone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Usuario::setTelefone (const string & telefone)}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                                                 \{\par
25     this->telefone = telefone;\par
26 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include/{\b Usuario.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Usuario.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::Version\par \pard\plain 
{\tc\tcl2 \v Catch::Version}
{\xe \v Catch::Version}
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Version} ({\b Version} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Version} & {\b operator=} ({\b Version} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Version} (unsigned int _majorVersion, unsigned int _minorVersion, unsigned int _patchNumber, char const *const _branchName, unsigned int _buildNumber)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int const {\b majorVersion}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int const {\b minorVersion}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int const {\b patchNumber}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char const  *const {\b branchName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int const {\b buildNumber}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, {\b Version} const &version)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v Version\:Catch::Version}
{\xe \v Catch::Version\:Version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Version::Version ({\b Version} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Version\:Catch::Version}
{\xe \v Catch::Version\:Version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::Version::Version (unsigned int _majorVersion, unsigned int _minorVersion, unsigned int _patchNumber, char const *const _branchName, unsigned int _buildNumber)}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2256     :   majorVersion( _majorVersion ),\par
2257         minorVersion( _minorVersion ),\par
2258         patchNumber( _patchNumber ),\par
2259         branchName( _branchName ),\par
2260         buildNumber( _buildNumber )\par
2261     \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator=\:Catch::Version}
{\xe \v Catch::Version\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Version} & Catch::Version::operator= ({\b Version} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos s\'EDmbolos amigos e relacionados\par
\pard\plain 
{\xe \v operator<<\:Catch::Version}
{\xe \v Catch::Version\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream & os, {\b Version} const & version){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2263                                                                        \{\par
2264         os  << version.majorVersion << {\cf23 '.'}\par
2265             << version.minorVersion << {\cf23 '.'}\par
2266             << version.patchNumber;\par
2267         {\cf20 // branchName is never null -> 0th char is \\0 if it is empty}\par
2268         {\cf19 if} (version.branchName[0]) \{\par
2269             os << {\cf23 '-'} << version.branchName\par
2270                << {\cf23 '.'} << version.buildNumber;\par
2271         \}\par
2272         {\cf19 return} os;\par
2273     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos\par
\pard\plain 
{\xe \v branchName\:Catch::Version}
{\xe \v Catch::Version\:branchName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char const* const Catch::Version::branchName}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v buildNumber\:Catch::Version}
{\xe \v Catch::Version\:buildNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int const Catch::Version::buildNumber}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v majorVersion\:Catch::Version}
{\xe \v Catch::Version\:majorVersion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int const Catch::Version::majorVersion}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v minorVersion\:Catch::Version}
{\xe \v Catch::Version\:minorVersion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int const Catch::Version::minorVersion}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v patchNumber\:Catch::Version}
{\xe \v Catch::Version\:patchNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int const Catch::Version::patchNumber}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::WaitForKeypress\par \pard\plain 
{\tc\tcl2 \v Catch::WaitForKeypress}
{\xe \v Catch::WaitForKeypress}
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b When} \{ {\b Never}
, {\b BeforeStart} = 1
, {\b BeforeExit} = 2
, {\b BeforeStartAndExit} = BeforeStart | BeforeExit
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v When\:Catch::WaitForKeypress}
{\xe \v Catch::WaitForKeypress\:When}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::WaitForKeypress::When}}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Never\:Catch::WaitForKeypress}
{\xe \v Catch::WaitForKeypress\:Never}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Never{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
\cell }{\cell }{\row }
{\xe \v BeforeStart\:Catch::WaitForKeypress}
{\xe \v Catch::WaitForKeypress\:BeforeStart}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BeforeStart{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
\cell }{\cell }{\row }
{\xe \v BeforeExit\:Catch::WaitForKeypress}
{\xe \v Catch::WaitForKeypress\:BeforeExit}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BeforeExit{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
\cell }{\cell }{\row }
{\xe \v BeforeStartAndExit\:Catch::WaitForKeypress}
{\xe \v Catch::WaitForKeypress\:BeforeStartAndExit}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BeforeStartAndExit{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
\cell }{\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1158                            \{ {\cf17 enum} When \{\par
1159         Never,\par
1160         BeforeStart = 1,\par
1161         BeforeExit = 2,\par
1162         BeforeStartAndExit = BeforeStart | BeforeExit\par
1163     \}; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Estrutura Catch::WarnAbout\par \pard\plain 
{\tc\tcl2 \v Catch::WarnAbout}
{\xe \v Catch::WarnAbout}
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b What} \{ {\b Nothing} = 0x00
, {\b NoAssertions} = 0x01
, {\b UnmatchedTestSpec} = 0x02
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das enumera\'E7\'F5es\par
\pard\plain 
{\xe \v What\:Catch::WarnAbout}
{\xe \v Catch::WarnAbout\:What}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Catch::WarnAbout::What}}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumeradores:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Nothing\:Catch::WarnAbout}
{\xe \v Catch::WarnAbout\:Nothing}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Nothing{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
\cell }{\cell }{\row }
{\xe \v NoAssertions\:Catch::WarnAbout}
{\xe \v Catch::WarnAbout\:NoAssertions}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NoAssertions{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A test case or leaf section did not run any assertions. \par
}\cell }{\row }
{\xe \v UnmatchedTestSpec\:Catch::WarnAbout}
{\xe \v Catch::WarnAbout\:UnmatchedTestSpec}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid UnmatchedTestSpec{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A command line test spec matched no test cases. \par
}\cell }{\row }
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1130                      \{ {\cf17 enum} What \{\par
1131         Nothing = 0x00,\par
1133         NoAssertions = 0x01,\par
1135         UnmatchedTestSpec = 0x02,\par
1136     \}; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa estrutura foi gerada a partir do seguinte arquivo:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia da Classe Catch::WildcardPattern\par \pard\plain 
{\tc\tcl2 \v Catch::WildcardPattern}
{\xe \v Catch::WildcardPattern}
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
\par
{
{\f2 #include <catch_amalgamated.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Membros P\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WildcardPattern} (std::string const &pattern, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b matches} (std::string const &str) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Construtores e Destrutores\par
\pard\plain 
{\xe \v WildcardPattern\:Catch::WildcardPattern}
{\xe \v Catch::WildcardPattern\:WildcardPattern}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Catch::WildcardPattern::WildcardPattern (std::string const & pattern, {\b CaseSensitive} caseSensitivity)}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7592     :   m_caseSensitivity( caseSensitivity ),\par
7593         m_pattern( normaliseString( pattern ) )\par
7594     \{\par
7595         {\cf19 if}( startsWith( m_pattern, {\cf23 '*'} ) ) \{\par
7596             m_pattern = m_pattern.substr( 1 );\par
7597             m_wildcard = WildcardAtStart;\par
7598         \}\par
7599         {\cf19 if}( endsWith( m_pattern, {\cf23 '*'} ) ) \{\par
7600             m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );\par
7601             m_wildcard = {\cf17 static_cast<}WildcardPosition{\cf17 >}( m_wildcard | WildcardAtEnd );\par
7602         \}\par
7603     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v matches\:Catch::WildcardPattern}
{\xe \v Catch::WildcardPattern\:matches}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Catch::WildcardPattern::matches (std::string const & str) const}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7605                                                               \{\par
7606         {\cf19 switch}( m_wildcard ) \{\par
7607             {\cf19 case} NoWildcard:\par
7608                 {\cf19 return} m_pattern == normaliseString( str );\par
7609             {\cf19 case} WildcardAtStart:\par
7610                 {\cf19 return} endsWith( normaliseString( str ), m_pattern );\par
7611             {\cf19 case} WildcardAtEnd:\par
7612                 {\cf19 return} startsWith( normaliseString( str ), m_pattern );\par
7613             {\cf19 case} WildcardAtBothEnds:\par
7614                 {\cf19 return} contains( normaliseString( str ), m_pattern );\par
7615             {\cf19 default}:\par
7616                 CATCH_INTERNAL_ERROR( {\cf22 "Unknown enum"} );\par
7617         \}\par
7618     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para essa classe foi gerada a partir dos seguintes arquivos:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
test/{\b catch_amalgamated.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Arquivos{\tc \v Arquivos}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo include/Emprestimo.h\par \pard\plain 
{\tc\tcl2 \v include/Emprestimo.h}
{\xe \v include/Emprestimo.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Usuario.h"}\par
{\f2 #include "Livro.h"}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Emprestimo}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EmprestimoLivros}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Emprestimo.h\par \pard\plain 
{\tc\tcl2 \v include/Emprestimo.h}
{\xe \v include/Emprestimo.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef EMPRESTIMO_H}\par
2 {\cf21 #define EMPRESTIMO_H}\par
3 \par
4 {\cf21 #include "Usuario.h"}\par
5 {\cf21 #include "Livro.h"}\par
6 {\cf21 #include <string>}\par
7 {\cf21 #include <vector>}\par
8 \par
9 {\cf17 using namespace }std;\par
10 \par
11 {\cf17 class }Emprestimo \{\par
12 {\cf17 private}:\par
13     {\cf18 int} id;\par
14     Usuario usuario;\par
15     Livro livro;\par
16     {\cf18 string} dataEmprestimo;\par
17     {\cf18 string} dataDevolucao;\par
18     {\cf18 double} multa;\par
19 \par
20 {\cf17 public}:\par
21     Emprestimo({\cf18 int} {\cf18 id}, {\cf17 const} Usuario &usuario, {\cf17 const} Livro &livro, {\cf17 const} {\cf18 string} &dataEmprestimo, {\cf17 const} {\cf18 string} &dataDevolucao);\par
22 \par
23     {\cf18 int} getId() {\cf17 const};\par
24     Usuario getUsuario() {\cf17 const};\par
25     Livro getLivro() {\cf17 const};\par
26     {\cf18 string} getDataEmprestimo() {\cf17 const};\par
27     {\cf18 string} getDataDevolucao() {\cf17 const};\par
28     {\cf18 double} getMulta() {\cf17 const};\par
29 \par
30     {\cf18 void} setDataDevolucao({\cf17 const} {\cf18 string} &dataDevolucao);\par
31     {\cf18 void} setMulta({\cf18 double} multa);\par
32 \};\par
33 \par
34 {\cf17 class }EmprestimoLivros \{\par
35 {\cf17 private}:\par
36     vector<Emprestimo> emprestimos;\par
37 \par
38 {\cf17 public}:\par
39     {\cf18 void} registrarEmprestimo({\cf17 const} Emprestimo &emprestimo);\par
40     {\cf18 bool} aplicarMulta({\cf18 int} {\cf18 id}, {\cf18 double} valor);\par
41     {\cf18 bool} controlarPrazoDevolucao({\cf18 int} {\cf18 id}, {\cf17 const} {\cf18 string} &novaData);\par
42      {\cf18 void} exibirRelatorioEmprestimos() {\cf17 const};\par
43 \};\par
44 \par
45 {\cf21 #endif }{\cf20 // EMPRESTIMO_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo include/Livro.h\par \pard\plain 
{\tc\tcl2 \v include/Livro.h}
{\xe \v include/Livro.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Livro}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GerenciamentoLivros}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Livro.h\par \pard\plain 
{\tc\tcl2 \v include/Livro.h}
{\xe \v include/Livro.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef LIVRO_H}\par
2 {\cf21 #define LIVRO_H}\par
3 \par
4 {\cf21 #include <string>}\par
5 {\cf21 #include <vector>}\par
6 {\cf17 using namespace }std;\par
7 \par
8 {\cf17 class }Livro \{\par
9 {\cf17 private}:\par
10     {\cf18 int} id;\par
11     {\cf18 string} titulo;\par
12     {\cf18 string} autor;\par
13     {\cf18 string} genero;\par
14     {\cf18 bool} disponivel;\par
15 \par
16 {\cf17 public}:\par
17     Livro({\cf18 int} {\cf18 id}, {\cf17 const} {\cf18 string} &titulo, {\cf17 const} {\cf18 string} &autor, {\cf17 const} {\cf18 string} &genero);\par
18 \par
19     {\cf18 int} getId() {\cf17 const};\par
20     {\cf18 string} getTitulo() {\cf17 const};\par
21     {\cf18 string} getAutor() {\cf17 const};\par
22     {\cf18 string} getGenero() {\cf17 const};\par
23     {\cf18 bool} isDisponivel() {\cf17 const};\par
24 \par
25     {\cf18 void} setDisponivel({\cf18 bool} disponivel);\par
26 \};\par
27 \par
28 {\cf17 class }GerenciamentoLivros \{\par
29 {\cf17 private}:\par
30     vector<Livro> livros;\par
31 \par
32 {\cf17 public}:\par
33     {\cf18 void} adicionarLivro({\cf17 const} Livro &livro);\par
34     {\cf18 void} removerLivro({\cf18 int} {\cf18 id});\par
35     Livro* consultarLivro({\cf18 int} {\cf18 id});\par
36     {\cf18 void} verificarDisponibilidade({\cf18 int} {\cf18 id});\par
37     {\cf18 void} exibirRelatorioLivros() {\cf17 const}; {\cf20 // Novo m\'E9todo}\par
38 \};\par
39 \par
40 {\cf21 #endif }{\cf20 // LIVRO_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo include/Usuario.h\par \pard\plain 
{\tc\tcl2 \v include/Usuario.h}
{\xe \v include/Usuario.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Usuario}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GerenciamentoUsuario}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Usuario.h\par \pard\plain 
{\tc\tcl2 \v include/Usuario.h}
{\xe \v include/Usuario.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef USUARIO_H}\par
2 {\cf21 #define USUARIO_H}\par
3 \par
4 {\cf21 #include <string>}\par
5 {\cf21 #include <vector>}\par
6 {\cf17 using namespace }std;\par
7 \par
8 {\cf17 class }Usuario \{\par
9 {\cf17 private}:\par
10     {\cf18 int} id;\par
11     {\cf18 string} nome;\par
12     {\cf18 string} telefone;\par
13 \par
14 {\cf17 public}:\par
15     Usuario({\cf18 int} {\cf18 id}, {\cf17 const} {\cf18 string} &nome, {\cf17 const} {\cf18 string} &telefone);\par
16 \par
17     {\cf18 int} getId() {\cf17 const};\par
18     {\cf18 string} getNome() {\cf17 const};\par
19     {\cf18 string} getTelefone() {\cf17 const};\par
20 \par
21     {\cf18 void} setNome({\cf17 const} {\cf18 string} &nome);\par
22     {\cf18 void} setTelefone({\cf17 const} {\cf18 string} &telefone);\par
23 \};\par
24 \par
25 {\cf17 class }GerenciamentoUsuario \{\par
26 {\cf17 private}:\par
27     vector<Usuario> usuarios;\par
28 \par
29 {\cf17 public}:\par
30     {\cf18 void} adicionarUsuario({\cf17 const} Usuario &usuario);\par
31     {\cf18 void} removerUsuario({\cf18 int} {\cf18 id});\par
32     Usuario* consultarUsuario({\cf18 int} {\cf18 id});\par
33     {\cf18 void} exibirRelatorioUsuarios() {\cf17 const}; {\cf20 // Novo m\'E9todo}\par
34 \};\par
35 \par
36 {\cf21 #endif }{\cf20 // USUARIO_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo src/Emprestimo.cpp\par \pard\plain 
{\tc\tcl2 \v src/Emprestimo.cpp}
{\xe \v src/Emprestimo.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Emprestimo.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo src/Livro.cpp\par \pard\plain 
{\tc\tcl2 \v src/Livro.cpp}
{\xe \v src/Livro.cpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Livro.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo src/main.cpp\par \pard\plain 
{\tc\tcl2 \v src/main.cpp}
{\xe \v src/main.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Usuario.h"}\par
{\f2 #include "Livro.h"}\par
{\f2 #include "Emprestimo.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <limits>}\par
{\f2 #include <cctype>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exibirMenu} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isStringValid} (const string &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readInt} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b readDouble} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b readString} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pause} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v exibirMenu\:main.cpp}
{\xe \v main.cpp\:exibirMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void exibirMenu ()}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10                   \{\par
11     cout << {\cf22 "---------------------------------------"} << endl;\par
12     cout << {\cf22 "Sistema de Gerenciamento de Biblioteca"} << endl;\par
13     cout << {\cf22 "---------------------------------------"} << endl;\par
14     cout << {\cf22 "1. Adicionar Usuario"} << endl;\par
15     cout << {\cf22 "2. Remover Usuario"} << endl;\par
16     cout << {\cf22 "3. Consultar Usuario"} << endl;\par
17     cout << {\cf22 "4. Adicionar Livro"} << endl;\par
18     cout << {\cf22 "5. Remover Livro"} << endl;\par
19     cout << {\cf22 "6. Consultar Livro"} << endl;\par
20     cout << {\cf22 "7. Registrar Emprestimo"} << endl;\par
21     cout << {\cf22 "8. Verificar Disponibilidade de Livro"} << endl;\par
22     cout << {\cf22 "9. Aplicar Multa"} << endl;\par
23     cout << {\cf22 "10.Controlar Prazo de Devolucao"} << endl;\par
24     cout << {\cf22 "11. Relatorio de Usuarios"} << endl; \par
25     cout << {\cf22 "12. Relatorio de Livros"} << endl;   \par
26      cout << {\cf22 "13. Relatorio de Emprestimos"} << endl; \par
27     cout << {\cf22 "0. Sair\\n"} << endl;\par
28 \}\par
}
}
{\xe \v isStringValid\:main.cpp}
{\xe \v main.cpp\:isStringValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isStringValid (const string & str)}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 30                                       \{\par
31     {\cf19 for} ({\cf18 char} ch : str) \{\par
32         {\cf19 if} (isdigit(ch) || ispunct(ch)) \{\par
33             {\cf19 return} {\cf17 false};\par
34         \}\par
35     \}\par
36     {\cf19 return} {\cf17 true};\par
37 \}\par
}
}
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 72            \{\par
73     GerenciamentoUsuario gerenciaUsuario;\par
74     GerenciamentoLivros gerenciaLivros;\par
75     EmprestimoLivros gerenciaEmprestimos;\par
76 \par
77     {\cf18 int} opcao;\par
78     {\cf19 do} \{\par
79         exibirMenu();\par
80         cout << {\cf22 "Escolha uma opcao: "};\par
81         opcao = readInt();\par
82 \par
83         {\cf19 switch}(opcao) \{\par
84             {\cf19 case} 1: \{\par
85                 {\cf18 int} id;\par
86                 {\cf18 string} nome, telefone;\par
87                 cout << {\cf22 "ID do Usuario: "};\par
88                 {\cf18 id} = readInt();\par
89                 cout << {\cf22 "Nome do Usuario: "};\par
90                 nome = readString();\par
91                 {\cf19 while} (!isStringValid(nome)) \{\par
92                     cout << {\cf22 "Nome invalido. Digite novamente: "};\par
93                     nome = readString();\par
94                 \}\par
95                 cout << {\cf22 "Telefone do Usuario: "};\par
96                 telefone = readString();\par
97                 Usuario novoUsuario({\cf18 id}, nome, telefone);\par
98                 gerenciaUsuario.adicionarUsuario(novoUsuario);\par
99                 cout << {\cf22 "Usuario adicionado com sucesso!"} << endl;\par
100                 pause();\par
101                 {\cf19 break};\par
102             \}\par
103             {\cf19 case} 2: \{\par
104                 {\cf18 int} id;\par
105                 cout << {\cf22 "ID do Usuario a ser removido: "};\par
106                 {\cf18 id} = readInt();\par
107                 gerenciaUsuario.removerUsuario({\cf18 id});\par
108                 cout << {\cf22 "Usuario removido com sucesso!"} << endl;\par
109                 pause();\par
110                 {\cf19 break};\par
111             \}\par
112             {\cf19 case} 3: \{\par
113                 {\cf18 int} id;\par
114                 cout << {\cf22 "ID do Usuario a ser consultado: "};\par
115                 {\cf18 id} = readInt();\par
116                 Usuario* usuario = gerenciaUsuario.consultarUsuario({\cf18 id});\par
117                 {\cf19 if} (usuario) \{\par
118                     cout << {\cf22 "Usuario encontrado: "} << usuario->getNome() << {\cf22 ", Telefone: "} << usuario->getTelefone() << endl;\par
119                 \} {\cf19 else} \{\par
120                     cout << {\cf22 "Usuario nao encontrado."} << endl;\par
121                 \}\par
122                 pause();\par
123                 {\cf19 break};\par
124             \}\par
125             {\cf19 case} 4: \{\par
126                 {\cf18 int} id;\par
127                 {\cf18 string} titulo, autor, genero;\par
128                 cout << {\cf22 "ID do Livro: "};\par
129                 {\cf18 id} = readInt();\par
130                 cout << {\cf22 "Titulo do Livro: "};\par
131                 titulo = readString();\par
132                 {\cf19 while} (!isStringValid(titulo)) \{\par
133                     cout << {\cf22 "Titulo invalido. Digite novamente: "};\par
134                     titulo = readString();\par
135                 \}\par
136                 cout << {\cf22 "Autor do Livro: "};\par
137                 autor = readString();\par
138                 {\cf19 while} (!isStringValid(autor)) \{\par
139                     cout << {\cf22 "Autor invalido. Digite novamente: "};\par
140                     autor = readString();\par
141                 \}\par
142                 cout << {\cf22 "Genero do Livro: "};\par
143                 genero = readString();\par
144                 {\cf19 while} (!isStringValid(genero)) \{\par
145                     cout << {\cf22 "Genero invalido. Digite novamente: "};\par
146                     genero = readString();\par
147                 \}\par
148                 Livro novoLivro({\cf18 id}, titulo, autor, genero);\par
149                 gerenciaLivros.adicionarLivro(novoLivro);\par
150                 cout << {\cf22 "Livro adicionado com sucesso!"} << endl;\par
151                 pause();\par
152                 {\cf19 break};\par
153             \}\par
154             {\cf19 case} 5: \{\par
155                 {\cf18 int} id;\par
156                 cout << {\cf22 "ID do Livro a ser removido: "};\par
157                 {\cf18 id} = readInt();\par
158                 gerenciaLivros.removerLivro({\cf18 id});\par
159                 cout << {\cf22 "Livro removido com sucesso!"} << endl;\par
160                 pause();\par
161                 {\cf19 break};\par
162             \}\par
163             {\cf19 case} 6: \{\par
164                 {\cf18 int} id;\par
165                 cout << {\cf22 "ID do Livro a ser consultado: "};\par
166                 {\cf18 id} = readInt();\par
167                 Livro* livro = gerenciaLivros.consultarLivro({\cf18 id});\par
168                 {\cf19 if} (livro) \{\par
169                     cout << {\cf22 "Livro encontrado: "} << livro->getTitulo() << {\cf22 ", Autor: "} << livro->getAutor() << {\cf22 ", G\'EAnero: "} << livro->getGenero() << endl;\par
170                 \} {\cf19 else} \{\par
171                     cout << {\cf22 "Livro nao encontrado."} << endl;\par
172                 \}\par
173                 pause();\par
174                 {\cf19 break};\par
175             \}\par
176             {\cf19 case} 7: \{\par
177                 {\cf18 int} idEmprestimo, idUsuario, idLivro;\par
178                 {\cf18 string} dataEmprestimo, dataDevolucao;\par
179                 cout << {\cf22 "ID do Emprestimo: "};\par
180                 idEmprestimo = readInt();\par
181                 cout << {\cf22 "ID do Usuario: "};\par
182                 idUsuario = readInt();\par
183                 cout << {\cf22 "ID do Livro: "};\par
184                 idLivro = readInt();\par
185                 cout << {\cf22 "Pressione enter para continuar ... \\n"};\par
186                 cin.ignore();\par
187                 cout << {\cf22 "Data do Emprestimo (formato dd-mm-aaaa): "};\par
188                 dataEmprestimo = readString();\par
189                 cout << {\cf22 "Data de Devolucao (formato dd-mm-aaaa): "};\par
190                 dataDevolucao = readString();\par
191                 Usuario* usuario = gerenciaUsuario.consultarUsuario(idUsuario);\par
192                 Livro* livro = gerenciaLivros.consultarLivro(idLivro);\par
193                 {\cf19 if} (usuario && livro && livro->isDisponivel()) \{\par
194                     Emprestimo novoEmprestimo(idEmprestimo, *usuario, *livro, dataEmprestimo, dataDevolucao);\par
195                     gerenciaEmprestimos.registrarEmprestimo(novoEmprestimo);\par
196                     livro->setDisponivel({\cf17 false});\par
197                     cout << {\cf22 "Emprestimo registrado com sucesso!"} << endl;\par
198                 \} {\cf19 else} \{\par
199                     cout << {\cf22 "Usuario ou Livro invalido, ou Livro nao disponivel."} << endl;\par
200                 \}\par
201                 pause();\par
202                 {\cf19 break};\par
203             \}\par
204             {\cf19 case} 8: \{\par
205                 {\cf18 int} id;\par
206                 cout << {\cf22 "ID do Livro para verificar disponibilidade: "};\par
207                 {\cf18 id} = readInt();\par
208                 gerenciaLivros.verificarDisponibilidade({\cf18 id});\par
209                 pause();\par
210                 {\cf19 break};\par
211             \}\par
212             {\cf19 case} 9: \{\par
213                 {\cf18 int} id;\par
214                 {\cf18 double} multa;\par
215                 cout << {\cf22 "ID do Emprestimo para aplicar multa: "};\par
216                 {\cf18 id} = readInt();\par
217                 cout << {\cf22 "Valor da multa: "};\par
218                 multa = readDouble();\par
219                 {\cf19 if} (multa < 0) \{\par
220                     cout << {\cf22 "Valor da multa nao pode ser negativo."} << endl;\par
221                     pause();\par
222                     {\cf19 break};\par
223                 \}\par
224                 {\cf19 if} (gerenciaEmprestimos.aplicarMulta({\cf18 id}, multa)) \{\par
225                     cout << {\cf22 "Multa aplicada com sucesso!"} << endl;\par
226                 \}\par
227                 pause();\par
228                 {\cf19 break};\par
229             \}\par
230             {\cf19 case} 10: \{\par
231                 {\cf18 int} id;\par
232                 {\cf18 string} novaData;\par
233                 cout << {\cf22 "ID do Emprestimo para controlar prazo: "};\par
234                 {\cf18 id} = readInt();\par
235                 cin.ignore();\par
236                 cout << {\cf22 "Nova Data de Devolucao (formato dd-mm-aaaa): "};\par
237                 novaData = readString();\par
238                 gerenciaEmprestimos.controlarPrazoDevolucao({\cf18 id}, novaData);\par
239                 cout << {\cf22 "Prazo de devolucao atualizado com sucesso!"} << endl;\par
240                 pause();\par
241                 {\cf19 break};\par
242             \}\par
243             {\cf19 case} 11: \{\par
244                 gerenciaUsuario.exibirRelatorioUsuarios();\par
245                 pause();\par
246                 {\cf19 break};\par
247             \}\par
248             {\cf19 case} 12: \{\par
249                 gerenciaLivros.exibirRelatorioLivros();\par
250                 pause();\par
251                 {\cf19 break};\par
252             \}\par
253             {\cf19 case} 13: \{\par
254                 gerenciaEmprestimos.exibirRelatorioEmprestimos();\par
255                 pause();\par
256                 {\cf19 break};\par
257              \}\par
258             {\cf19 case} 0:\par
259                 cout << {\cf22 "Saindo do sistema..."} << endl;\par
260                 {\cf19 break};\par
261             {\cf19 default}:\par
262                 cout << {\cf22 "Opcao invalida. Tente novamente."} << endl;\par
263                 pause();\par
264         \}\par
265 \par
266     \} {\cf19 while} (opcao != 0);\par
267 \par
268     {\cf19 return} 0;\par
269 \}\par
}
}
{\xe \v pause\:main.cpp}
{\xe \v main.cpp\:pause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pause ()}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67              \{\par
68     cout << {\cf22 "Pressione Enter para continuar..."};\par
69     cin.ignore(numeric_limits<streamsize>::max(), {\cf23 '\\n'});\par
70 \}\par
}
}
{\xe \v readDouble\:main.cpp}
{\xe \v main.cpp\:readDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double readDouble ()}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 50                     \{\par
51     {\cf18 double} value;\par
52     {\cf19 while} (!(cin >> value)) \{\par
53         cin.clear();  {\cf20 // Limpa o estado de erro}\par
54         cin.ignore(numeric_limits<streamsize>::max(), {\cf23 '\\n'});  {\cf20 // Ignora a linha}\par
55         cout << {\cf22 "Entrada invalida. Digite um numero decimal: "};\par
56     \}\par
57     cin.ignore(numeric_limits<streamsize>::max(), {\cf23 '\\n'});  {\cf20 // Ignora o '\\n' deixado pelo cin}\par
58     {\cf19 return} value;\par
59 \}\par
}
}
{\xe \v readInt\:main.cpp}
{\xe \v main.cpp\:readInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int readInt ()}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 39               \{\par
40     {\cf18 int} value;\par
41     {\cf19 while} (!(cin >> value)) \{\par
42         cin.clear();  {\cf20 // Limpa caso o erro}\par
43         cin.ignore(numeric_limits<streamsize>::max(), {\cf23 '\\n'});  {\cf20 // Ignora a linha}\par
44         cout << {\cf22 "Entrada invalida. Digite um numero inteiro: "};\par
45     \}\par
46     cin.ignore(numeric_limits<streamsize>::max(), {\cf23 '\\n'});  {\cf20 // Ignora o '\\n' deixado pelo cin}\par
47     {\cf19 return} value;\par
48 \}\par
}
}
{\xe \v readString\:main.cpp}
{\xe \v main.cpp\:readString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string readString ()}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 61                     \{\par
62     {\cf18 string} str;\par
63     getline(cin, str);\par
64     {\cf19 return} str;\par
65 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo src/Usuario.cpp\par \pard\plain 
{\tc\tcl2 \v src/Usuario.cpp}
{\xe \v src/Usuario.cpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Usuario.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo test/catch_amalgamated.cpp\par \pard\plain 
{\tc\tcl2 \v test/catch_amalgamated.cpp}
{\xe \v test/catch_amalgamated.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "catch_amalgamated.hpp"}\par
{\f2 #include <cmath>}\par
{\f2 #include <limits>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cassert>}\par
{\f2 #include <stack>}\par
{\f2 #include <exception>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <set>}\par
{\f2 #include <cctype>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <ostream>}\par
{\f2 #include <chrono>}\par
{\f2 #include <random>}\par
{\f2 #include <utility>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <cerrno>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <cstring>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <sstream>}\par
{\f2 #include <ctime>}\par
{\f2 #include <iostream>}\par
{\f2 #include <cstdint>}\par
{\f2 #include <iterator>}\par
{\f2 #include <type_traits>}\par
{\f2 #include <regex>}\par
{\f2 #include <cfloat>}\par
{\f2 #include <map>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Generators::RandomFloatingGenerator::PImpl}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SignalDefs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ReporterRegistry::ReporterRegistryImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringStreams}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ColumnInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::TablePrinter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Benchmark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Benchmark::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::literals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Generators}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Generators::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Clara}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Clara::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::TestCaseTracking}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::TextFlow}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers::Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Digits}({\b x})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::RegistryHubSingleton} = Singleton<RegistryHub, {\b IRegistryHub}, {\b IMutableRegistryHub}>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Matchers::Detail::FloatingPointKind} : uint8_t \{ {\b Catch::Matchers::Detail::Float}
, {\b Catch::Matchers::Detail::Double}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Justification} \{ {\b Catch::Left}
, {\b Catch::Right}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b if} ({\b w}< 6.250000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::weighted_average_quantile} (int k, int q, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OutlierClassification} {\b Catch::Benchmark::Detail::classify_outliers} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::mean} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::normal_cdf} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::erfc_inv} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::normal_quantile} (double {\b p})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< double > {\b Catch::Benchmark::Detail::bootstrap} (double confidence_level, double *first, double *last, {\b sample} const &resample, double(*estimator)(double const *, double const *))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bootstrap_analysis} {\b Catch::Benchmark::Detail::analyse_samples} (double confidence_level, unsigned int n_resamples, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b Catch::literals::operator""_a} (long double val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b Catch::literals::operator""_a} (unsigned long long val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b ProcessedReporterSpec} const &lhs, {\b ProcessedReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::getSeed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns Catch2's current RNG seed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRegistryHub} const & {\b Catch::getRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IMutableRegistryHub} & {\b Catch::getMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::translateActiveException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator<} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b TestCaseInfo} > {\b Catch::makeTestCaseInfo} ({\b StringRef} _className, {\b NameAndTags} const &nameAndTags, {\b SourceLineInfo} const &_lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator<} ({\b TestCaseInfo} const &lhs, {\b TestCaseInfo} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::convertIntoString} ({\b StringRef} string, bool escapeInvisibles)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases `string in quotes, and optionally escapes invisibles. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::convertIntoString} ({\b StringRef} string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases {\f2 string}  in quotes, and escapes invisibles if user requested it via CLI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::rawMemoryToString} (const void *object, std::size_t size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Detail::registerTranslatorImpl} ({\b Detail::unique_ptr}< {\b IExceptionTranslator} > &&translator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, {\b Version} const &version)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Version} const & {\b Catch::libraryVersion} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Generators::Detail::throw_generator_exception} (char const *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws {\b GeneratorException} with the provided message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b Catch::Generators::acquireGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} const &lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b Catch::Generators::createGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} lineInfo, {\b GeneratorBasePtr} &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::Generators::Detail::getSeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExceptionMatchExpr} ({\b AssertionHandler} &handler, std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b Catch::Clara::Detail::convertInto} (std::string const &source, std::string &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b Catch::Clara::Detail::convertInto} (std::string const &source, bool &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clara::Parser} {\b Catch::makeCommandLineParser} ({\b ConfigData} &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< ColourImpl > {\b Catch::makeColourImpl} ({\b ColourMode} colourSelection, IStream *stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isColourImplAvailable} ({\b ColourMode} colourSelection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanUpContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} & {\b Catch::getCurrentMutableContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SimplePcg32} & {\b Catch::sharedRng} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::writeToDebugConsole} (std::string const &text)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isDebuggerActive} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::formatReconstructedExpression} (std::ostream &os, std::string const &lhs, {\b StringRef} op, std::string const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_exception} (std::exception const &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_logic_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_domain_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_runtime_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b Catch::Detail::parseEnums} ({\b StringRef} enums)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Catch::Detail::unique_ptr}< {\b EnumInfo} > {\b Catch::Detail::makeEnumInfo} ({\b StringRef} enumName, {\b StringRef} allValueNames, std::vector< int > const &values)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Catch::Detail::convertToBits} (float f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Catch::Detail::convertToBits} (double d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::Detail::directCompare} (float lhs, float rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::Detail::directCompare} (double lhs, double rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char const * {\b Catch::Detail::getEnv} (char const *varName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::makeStream} (std::string const &filename) -> {\b Detail::unique_ptr}< IStream >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator<<} (std::ostream &os, {\b LazyExpression} const &lazyExpr) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::list} (IEventListener &reporter, {\b Config} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< unsigned int > {\b Catch::parseUInt} (std::string const &input, int base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isnan} (float f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isnan} (double d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Catch::nextafter} (float {\b x}, float y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::nextafter} (double {\b x}, double y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator!=} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::generateRandomSeed} ({\b GenerateFrom} from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b Catch::Detail::splitReporterSpec} ({\b StringRef} reporterSpec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits the reporter spec into reporter name and kv-pair options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ColourMode} > {\b Catch::Detail::stringToColourMode} ({\b StringRef} colourMode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b ReporterSpec} const &lhs, {\b ReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ReporterSpec} > {\b Catch::parseReporterSpec} ({\b StringRef} reporterSpec)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isOk} ({\b ResultWas::OfType} resultType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isJustInfo} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b Catch::operator|} ({\b ResultDisposition::Flags} lhs, {\b ResultDisposition::Flags} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldContinueOnFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldSuppressFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IResultCapture} & {\b Catch::getResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::seedRng} ({\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b Catch::rngSeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::addSingleton} (ISingleton *singleton)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanupSingletons} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, {\b SourceLineInfo} const &info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::cout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::cerr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::clog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::startsWith} (std::string const &s, std::string const &prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::startsWith} ({\b StringRef} s, char prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::endsWith} (std::string const &s, std::string const &suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::endsWith} (std::string const &s, char suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::contains} (std::string const &s, std::string const &infix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::toLowerInPlace} (std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::toLower} (std::string const &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Catch::toLower} (char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::trim} (std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b Catch::trim} ({\b StringRef} ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::replaceInPlace} (std::string &str, std::string const &replaceThis, std::string const &withThis)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b Catch::splitStringRef} ({\b StringRef} str, char delimiter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, pluralise const &pluraliser)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator<<} (std::ostream &os, {\b StringRef} str) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::operator+} ({\b StringRef} lhs, {\b StringRef} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator+=} (std::string &lhs, {\b StringRef} rhs) -> std::string &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > {\b Catch::sortTests} ({\b IConfig} const &config, std::vector< {\b TestCaseHandle} > const &unsortedTestCases)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isThrowSafe} ({\b TestCaseHandle} const &testCase, {\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > {\b Catch::filterTests} (std::vector< {\b TestCaseHandle} > const &testCases, {\b TestSpec} const &testSpec, {\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > const & {\b Catch::getAllTestCasesSorted} ({\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_test_failure_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_test_skip_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b ITestInvoker} > {\b Catch::makeTestInvoker} (void(*testAsFunction)())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::TextFlow::operator<<} (std::ostream &os, Column const &col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Column {\b Catch::TextFlow::Spacer} (size_t spaceWidth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::TextFlow::operator<<} (std::ostream &os, Columns const &cols)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Column const &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Column &&lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns & {\b Catch::TextFlow::operator+=} (Columns &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns & {\b Catch::TextFlow::operator+=} (Columns &lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Columns const &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Columns &&lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::uncaught_exceptions} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmlFormatting {\b Catch::operator|} (XmlFormatting lhs, XmlFormatting rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmlFormatting {\b Catch::operator&} (XmlFormatting lhs, XmlFormatting rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, XmlEncode const &xmlEncode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IsEmptyMatcher {\b Catch::Matchers::IsEmpty} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HasSizeMatcher {\b Catch::Matchers::SizeIs} (std::size_t sz)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ExceptionMessageMatcher {\b Catch::Matchers::Message} (std::string const &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinUlpsMatcher {\b Catch::Matchers::WithinULP} (double target, uint64_t maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinUlpsMatcher {\b Catch::Matchers::WithinULP} (float target, uint64_t maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinAbsMatcher {\b Catch::Matchers::WithinAbs} (double target, double margin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (double target, double eps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (double target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (float target, float eps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (float target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IsNaNMatcher {\b Catch::Matchers::IsNaN} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AllTrueMatcher {\b Catch::Matchers::AllTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NoneTrueMatcher {\b Catch::Matchers::NoneTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AnyTrueMatcher {\b Catch::Matchers::AnyTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StringEqualsMatcher {\b Catch::Matchers::Equals} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StringContainsMatcher {\b Catch::Matchers::ContainsSubstring} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EndsWithMatcher {\b Catch::Matchers::EndsWith} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StartsWithMatcher {\b Catch::Matchers::StartsWith} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RegexMatcher {\b Catch::Matchers::Matches} (std::string const &regex, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Matchers::Detail::describe_multi_matcher} ({\b StringRef} combine, std::string const *descriptions_begin, std::string const *descriptions_end)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExceptionMatchExpr} ({\b AssertionHandler} &handler, StringMatcher const &matcher)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::getFormattedDuration} (double duration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldShowDuration} ({\b IConfig} const &config, double duration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::serializeFilters} (std::vector< std::string > const &filters)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &out, lineOfChars {\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListReporters} (std::ostream &out, std::vector< ReporterDescription > const &descriptions, {\b Verbosity} verbosity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListListeners} (std::ostream &out, std::vector< ListenerDescription > const &descriptions)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListTags} (std::ostream &out, std::vector< TagInfo > const &tags, bool isFiltered)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListTests} (std::ostream &out, ColourImpl *streamColour, std::vector< {\b TestCaseHandle} > const &tests, bool isFiltered, {\b Verbosity} verbosity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::printTestRunTotals} (std::ostream &stream, ColourImpl &streamColour, {\b Totals} const &totals)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Detail::registerReporterImpl} (std::string const &name, {\b IReporterFactoryPtr} reporterPtr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Detail::registerListenerImpl} ({\b Detail::unique_ptr}< EventListenerFactory > listenerFactory)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b w} = -log( ( 1.0 - {\b x} ) * ( 1.0 + {\b x} ) )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b p} = -2.7109920616438573243e-11\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b else}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
return {\b p} * {\b x}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file provides platform specific implementations of FatalConditionHandler\par
This means that there is a lot of conditional compilation, and platform specific code. Currently, Catch2 supports a dummy handler (if no handler is desired), and 2 platform specific handlers:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Windows' SEH\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
POSIX signals\par}
\par
Consequently, various pieces of code below are compiled if either of the platform specific handlers is enabled, or if none of them are enabled. It is assumed that both cannot be enabled at the same time, and doing so should cause a compilation error.\par
If another platform specific handler is added, the compile guards below will need to be updated taking these assumptions into account. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v Digits\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:Digits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Digits( {\b x})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( x & 0xFF'FF'FF'FF )            std::uint64_t lhs_low = Digits( lhs );            std::uint64_t rhs_low = Digits( rhs );            std::uint64_t low_low = ( lhs_low * rhs_low );            std::uint64_t high_high = CarryBits( lhs ) * CarryBits( rhs );                        std::uint64_t high_low =                ( CarryBits( lhs ) * rhs_low ) + CarryBits( low_low );                                    std::uint64_t low_high =                ( lhs_low * CarryBits( rhs ) ) + Digits( high_low );            {\cf19 return} \{ high_high + CarryBits( high_low ) + CarryBits( low_high ),                     ( low_high << 32 ) | Digits( low_low ) \};#undef CarryBits#undef Digits        \}                {\cf17 inline} ExtendedMultResult<std::uint64_t>        extendedMult( std::uint64_t lhs, std::uint64_t rhs ) \{#{\cf19 if} defined( CATCH_CONFIG_UINT128 )            {\cf17 auto} result = __uint128_t( lhs ) * __uint128_t( rhs );            {\cf19 return} \{ {\cf17 static_cast<}std::uint64_t{\cf17 >}( result >> 64 ),                     {\cf17 static_cast<}std::uint64_t{\cf17 >}( result ) \};#elif defined( CATCH_CONFIG_MSVC_UMUL128 )            std::uint64_t high;            std::uint64_t low = _umul128( lhs, rhs, &high );            {\cf19 return} \{ high, low \};#{\cf19 else}            {\cf19 return} extendedMultPortable( lhs, rhs );#endif        \}        {\cf17 template} <{\cf17 typename} UInt>        {\cf17 constexpr} ExtendedMultResult<UInt> extendedMult( UInt lhs, UInt rhs ) \{            {\cf17 static_assert}( std::is_unsigned<UInt>::value,                           {\cf22 "extendedMult can only handle unsigned integers"} );            {\cf17 static_assert}( {\cf17 sizeof}( UInt ) < {\cf17 sizeof}( std::uint64_t ),                           {\cf22 "Generic extendedMult can only handle types smaller "}                           {\cf22 "than uint64_t"} );            {\cf17 using }WideType = DoubleWidthUnsignedType_t<UInt>;            {\cf17 auto} result = WideType( lhs ) * WideType( rhs );            {\cf19 return} \{                {\cf17 static_cast<}UInt{\cf17 >}( result >> ( CHAR_BIT * {\cf17 sizeof}( UInt ) ) ),                {\cf17 static_cast<}UInt{\cf17 >}( result & UInt( -1 ) ) \};        \}        {\cf17 template} <{\cf17 typename} TargetType,                  {\cf17 typename} Generator>            std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) >= {\cf17 sizeof}(TargetType),            TargetType> fillBitsFrom(Generator& gen) \{            {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;            {\cf17 static_assert}( std::is_unsigned<TargetType>::value, {\cf22 "Only unsigned integers are supported"} );            {\cf17 static_assert}( Generator::min() == 0 &&                           Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),                           {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );                                    {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;            {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;            {\cf19 return} {\cf17 static_cast<}TargetType{\cf17 >}( gen() >>                                            ( generated_bits - return_bits) );        \}        {\cf17 template} <{\cf17 typename} TargetType,                  {\cf17 typename} Generator>            std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) < {\cf17 sizeof}(TargetType),            TargetType> fillBitsFrom(Generator& gen) \{            {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;            {\cf17 static_assert}( std::is_unsigned<TargetType>::value,                           {\cf22 "Only unsigned integers are supported"} );            {\cf17 static_assert}( Generator::min() == 0 &&                           Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),                           {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );            {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;            {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;            std::size_t filled_bits = 0;            TargetType ret = 0;            {\cf19 do} \{                ret <<= generated_bits;                ret |= gen();                filled_bits += generated_bits;            \} {\cf19 while} ( filled_bits < return_bits );            {\cf19 return} ret;        \}                {\cf17 template} <{\cf17 typename} OriginalType, {\cf17 typename} Un{\cf18 signed}Type>        std::enable_if_t<std::is_signed<OriginalType>::value, UnsignedType>        transposeToNaturalOrder( UnsignedType in ) \{            {\cf17 static_assert}(                {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),                {\cf22 "reordering requires the same sized types on both sides"} );            {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value,                           {\cf22 "Input type must be unsigned"} );                                                            {\cf17 constexpr} {\cf17 auto} highest_bit =                UnsignedType( 1 ) << ( {\cf17 sizeof}( UnsignedType ) * CHAR_BIT - 1 );            {\cf19 return} {\cf17 static_cast<}UnsignedType{\cf17 >}( in ^ highest_bit );        \}        {\cf17 template} <{\cf17 typename} OriginalType,                  {\cf17 typename} Un{\cf18 signed}Type>        std::enable_if_t<std::is_unsigned<OriginalType>::value, UnsignedType>            transposeToNaturalOrder(UnsignedType in) \{            {\cf17 static_assert}(                {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),                {\cf22 "reordering requires the same sized types on both sides"} );            {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value, {\cf22 "Input type must be unsigned"} );                        {\cf19 return} in;        \}    \} \} #endif {\cf17 namespace }Catch \{{\cf17 template} <{\cf17 typename} IntegerType>{\cf17 class }uniform_integer_distribution \{    {\cf17 static_assert}(std::is_integral<IntegerType>::value, {\cf22 "..."});    {\cf17 using }UnsignedIntegerType = Detail::SizedUnsignedType_t<{\cf17 sizeof}(IntegerType)>;                        UnsignedIntegerType m_a;        UnsignedIntegerType m_ab_distance;                            UnsignedIntegerType m_rejection_threshold = 0;    UnsignedIntegerType computeDistance(IntegerType a, IntegerType b){\cf17  const }\{                        {\cf19 return} transposeTo(b) - transposeTo(a) + 1;    \}    {\cf17 static} UnsignedIntegerType computeRejectionThreshold(UnsignedIntegerType ab_distance) \{                        {\cf19 if} ( ab_distance == 0 ) \{ {\cf19 return} 0; \}        {\cf19 return} ( ~ab_distance + 1 ) % ab_distance;    \}    {\cf17 static} UnsignedIntegerType transposeTo(IntegerType in) \{        {\cf19 return} Detail::transposeToNaturalOrder<IntegerType>(            {\cf17 static_cast<}UnsignedIntegerType{\cf17 >}( in ) );    \}    {\cf17 static} IntegerType transposeBack(UnsignedIntegerType in) \{        {\cf19 return} {\cf17 static_cast<}IntegerType{\cf17 >}(            Detail::transposeToNaturalOrder<IntegerType>(in) );    \}{\cf17 public}:    {\cf17 using }result_type = IntegerType;    uniform_integer_distribution( IntegerType a, IntegerType b ):        m_a( transposeTo(a) ),        m_ab_distance( computeDistance(a, b) ),        m_rejection_threshold( computeRejectionThreshold(m_ab_distance) ) \{        assert( a <= b );    \}    {\cf17 template} <{\cf17 typename} Generator>    result_type operator()( Generator& g ) \{                {\cf19 if} ( m_ab_distance == 0 ) \{            {\cf19 return} transposeBack( Detail::fillBitsFrom<UnsignedIntegerType>( g ) );        \}        {\cf17 auto} random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );        {\cf17 auto} emul = Detail::extendedMult( random_number, m_ab_distance );                        {\cf19 while} (emul.lower < m_rejection_threshold) \{            random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );            emul = Detail::extendedMult( random_number, m_ab_distance );        \}        {\cf19 return} transposeBack(m_a + emul.upper);    \}    result_type a(){\cf17  const }\{ {\cf19 return} transposeBack(m_a); \}    result_type b(){\cf17  const }\{ {\cf19 return} transposeBack(m_ab_distance + m_a - 1); \}\};\} #endif #ifndef CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED#define CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED#ifndef CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED#define CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED#ifndef CATCH_POLYFILLS_HPP_INCLUDED#define CATCH_POLYFILLS_HPP_INCLUDEDnamespace Catch \{    {\cf18 bool} isnan({\cf18 float} f);    {\cf18 bool} isnan({\cf18 double} d);    {\cf18 float} nextafter({\cf18 float} x, {\cf18 float} y);    {\cf18 double} nextafter({\cf18 double} x, {\cf18 double} y);\}#endif #include <cassert>#include <cmath>#include <cstdint>#include <limits>#include <type_traits>{\cf17 namespace }Catch \{    {\cf17 namespace }Detail \{                {\cf17 template} <{\cf17 typename} FloatType>        FloatType gamma(FloatType a, FloatType b) \{            {\cf17 static_assert}( std::is_floating_point<FloatType>::value,                           {\cf22 "gamma returns the largest ULP magnitude within "}                           {\cf22 "floating point range [a, b]. This only makes sense "}                           {\cf22 "for floating point types"} );            assert( a <= b );            {\cf17 const} {\cf17 auto} gamma_up = Catch::nextafter( a, std::numeric_limits<FloatType>::infinity() ) - a;            {\cf17 const} {\cf17 auto} gamma_down = b - Catch::nextafter( b, -std::numeric_limits<FloatType>::infinity() );            {\cf19 return} gamma_up < gamma_down ? gamma_down : gamma_up;        \}        template <typename FloatingPoint>        {\cf17 struct }DistanceTypePicker;        {\cf17 template} <>        {\cf17 struct }DistanceTypePicker<float> \{            {\cf17 using }type = std::uint32_t;        \};        {\cf17 template} <>        {\cf17 struct }DistanceTypePicker<double> \{            {\cf17 using }type = std::uint64_t;        \};        {\cf17 template} <{\cf17 typename} T>        {\cf17 using }DistanceType = {\cf17 typename} DistanceTypePicker<T>::type;#{\cf19 if} defined( __GNUC__ ) || defined( __clang__ ){\cf21 #    pragma GCC diagnostic push#    pragma GCC diagnostic ignored "-Wfloat-equal"#endif                template <typename FloatType>        DistanceType<FloatType>        count_equidistant_floats( FloatType a, FloatType b, FloatType distance ) \{            assert( a <= b );                                    const auto ag = a / distance;            const auto bg = b / distance;            const auto s = bg - ag;            const auto err = ( std::fabs( a ) <= std::fabs( b ) )                                 ? -ag - ( s - bg )                                 : bg - ( s + ag );            const auto ceil_s = static_cast<DistanceType<FloatType>>( std::ceil( s ) );            return ( ceil_s != s ) ? ceil_s : ceil_s + ( err > 0 );        \}#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif    \}\} #endif #include <cmath>#include <type_traits>namespace Catch \{    namespace Detail \{#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic push#    pragma GCC diagnostic ignored "-Wfloat-equal"#endif                                        constexpr std::uint64_t calculate_max_steps_in_one_go(double gamma) \{            if ( gamma == 1.99584030953472e+292 ) \{ return 9007199254740991; \}            return static_cast<std::uint64_t>( -1 );        \}        constexpr std::uint32_t calculate_max_steps_in_one_go(float gamma) \{            if ( gamma == 2.028241e+31f ) \{ return 16777215; \}            return static_cast<std::uint32_t>( -1 );        \}#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif    \}template <typename FloatType>class uniform_floating_point_distribution \{    static_assert(std::is_floating_point<FloatType>::value, "...");    static_assert(!std::is_same<FloatType, long double>::value,                  "We do not support long double due to inconsistent behaviour between platforms");    using WidthType = Detail::DistanceType<FloatType>;    FloatType m_a, m_b;    FloatType m_ulp_magnitude;    WidthType m_floats_in_range;    uniform_integer_distribution<WidthType> m_int_dist;                WidthType m_max_steps_in_one_go;        bool m_a_has_leq_magnitude;public:    using result_type = FloatType;    uniform_floating_point_distribution( FloatType a, FloatType b ):        m_a( a ),        m_b( b ),        m_ulp_magnitude( Detail::gamma( m_a, m_b ) ),        m_floats_in_range( Detail::count_equidistant_floats( m_a, m_b, m_ulp_magnitude ) ),        m_int_dist(0, m_floats_in_range),        m_max_steps_in_one_go( Detail::calculate_max_steps_in_one_go(m_ulp_magnitude)),        m_a_has_leq_magnitude(std::fabs(m_a) <= std::fabs(m_b))    \{        assert( a <= b );    \}    template <typename Generator>    result_type operator()( Generator& g ) \{        WidthType steps = m_int_dist( g );        if ( m_a_has_leq_magnitude ) \{            if ( steps == m_floats_in_range ) \{ return m_a; \}            auto b = m_b;            while (steps > m_max_steps_in_one_go) \{                b -= m_max_steps_in_one_go * m_ulp_magnitude;                steps -= m_max_steps_in_one_go;            \}            return b - steps * m_ulp_magnitude;        \} else \{            if ( steps == m_floats_in_range ) \{ return m_b; \}            auto a = m_a;            while (steps > m_max_steps_in_one_go) \{                a += m_max_steps_in_one_go * m_ulp_magnitude;                steps -= m_max_steps_in_one_go;            \}            return a + steps * m_ulp_magnitude;        \}    \}    result_type a() const \{ return m_a; \}    result_type b() const \{ return m_b; \}\};\} #endif namespace Catch \{namespace Generators \{namespace Detail \{                std::uint32_t getSeed();\}template <typename Float>class RandomFloatingGenerator final : public IGenerator<Float> \{    Catch::SimplePcg32 m_rng;    Catch::uniform_floating_point_distribution<Float> m_dist;    Float m_current_number;public:    RandomFloatingGenerator( Float a, Float b, std::uint32_t seed ):        m_rng(seed),        m_dist(a, b) \{        static_cast<void>(next());    \}    Float const& get() const override \{        return m_current_number;    \}    bool next() override \{        m_current_number = m_dist(m_rng);        return true;    \}\};template <>class RandomFloatingGenerator<long double> final : public IGenerator<long double> \{            struct PImpl;    Catch::Detail::unique_ptr<PImpl> m_pimpl;    long double m_current_number;public:    RandomFloatingGenerator( long double a, long double b, std::uint32_t seed );    long double const& get() const override \{ return m_current_number; \}    bool next() override;    ~RandomFloatingGenerator() override; \};template <typename Integer>class RandomIntegerGenerator final : public IGenerator<Integer> \{    Catch::SimplePcg32 m_rng;    Catch::uniform_integer_distribution<Integer> m_dist;    Integer m_current_number;public:    RandomIntegerGenerator( Integer a, Integer b, std::uint32_t seed ):        m_rng(seed),        m_dist(a, b) \{        static_cast<void>(next());    \}    Integer const& get() const override \{        return m_current_number;    \}    bool next() override \{        m_current_number = m_dist(m_rng);        return true;    \}\};template <typename T>std::enable_if_t<std::is_integral<T>::value, GeneratorWrapper<T>>random(T a, T b) \{    return GeneratorWrapper<T>(        Catch::Detail::make_unique<RandomIntegerGenerator<T>>(a, b, Detail::getSeed())    );\}template <typename T>std::enable_if_t<std::is_floating_point<T>::value,GeneratorWrapper<T>>random(T a, T b) \{    return GeneratorWrapper<T>(        Catch::Detail::make_unique<RandomFloatingGenerator<T>>(a, b, Detail::getSeed())    );\}\} \} #endif #ifndef CATCH_GENERATORS_RANGE_HPP_INCLUDED#define CATCH_GENERATORS_RANGE_HPP_INCLUDED#include <iterator>#include <type_traits>namespace Catch \{namespace Generators \{template <typename T>class RangeGenerator final : public IGenerator<T> \{    T m_current;    T m_end;    T m_step;    bool m_positive;public:    RangeGenerator(T const& start, T const& end, T const& step):        m_current(start),        m_end(end),        m_step(step),        m_positive(m_step > T(0))    \{        assert(m_current != m_end && "Range start and end cannot be equal");        assert(m_step != T(0) && "Step size cannot be zero");        assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");    \}    RangeGenerator(T const& start, T const& end):        RangeGenerator(start, end, (start < end) ? T(1) : T(-1))    \{\}    T const& get() const override \{        return m_current;    \}    bool next() override \{        m_current += m_step;        return (m_positive) ? (m_current < m_end) : (m_current > m_end);    \}\};template <typename T>GeneratorWrapper<T> range(T const& start, T const& end, T const& step) \{    static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end, step));\}template <typename T>GeneratorWrapper<T> range(T const& start, T const& end) \{    static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end));\}template <typename T>class IteratorGenerator final : public IGenerator<T> \{    static_assert(!std::is_same<T, bool>::value,        "IteratorGenerator currently does not support bools"        "because of std::vector<bool> specialization");    std::vector<T> m_elems;    size_t m_current = 0;public:    template <typename InputIterator, typename InputSentinel>    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) \{        if (m_elems.empty()) \{            Detail::throw_generator_exception("IteratorGenerator received no valid values");        \}    \}    T const& get() const override \{        return m_elems[m_current];    \}    bool next() override \{        ++m_current;        return m_current != m_elems.size();    \}\};template <typename InputIterator,          typename InputSentinel,          typename ResultType = typename std::iterator_traits<InputIterator>::value_type>GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) \{    return GeneratorWrapper<ResultType>(Catch::Detail::make_unique<IteratorGenerator<ResultType>>(from, to));\}template <typename Container>auto from_range(Container const& cnt) \{    using std::begin;    using std::end;    return from_range( begin( cnt ), end( cnt ) );\}\} \} #endif #endif #ifndef CATCH_INTERFACES_ALL_HPP_INCLUDED#define CATCH_INTERFACES_ALL_HPP_INCLUDED#ifndef CATCH_INTERFACES_REPORTER_HPP_INCLUDED#define CATCH_INTERFACES_REPORTER_HPP_INCLUDED#ifndef CATCH_TEST_RUN_INFO_HPP_INCLUDED#define CATCH_TEST_RUN_INFO_HPP_INCLUDEDnamespace Catch \{    struct TestRunInfo \{        constexpr TestRunInfo(StringRef _name) : name(_name) \{\}        StringRef name;    \};\} #endif #include <map>#include <string>#include <vector>#include <iosfwd>namespace Catch \{    struct ReporterDescription;    struct ListenerDescription;    struct TagInfo;    struct TestCaseInfo;    class TestCaseHandle;    class IConfig;    class IStream;    enum class ColourMode : std::uint8_t;    struct ReporterConfig \{        ReporterConfig( IConfig const* _fullConfig,                        Detail::unique_ptr<IStream> _stream,                        ColourMode colourMode,                        std::map<std::string, std::string> customOptions );        ReporterConfig( ReporterConfig&& ) = default;        ReporterConfig& operator=( ReporterConfig&& ) = default;        ~ReporterConfig();         Detail::unique_ptr<IStream> takeStream() &&;        IConfig const* fullConfig() const;        ColourMode colourMode() const;        std::map<std::string, std::string> const& customOptions() const;    private:        Detail::unique_ptr<IStream> m_stream;        IConfig const* m_fullConfig;        ColourMode m_colourMode;        std::map<std::string, std::string> m_customOptions;    \};    struct AssertionStats \{        AssertionStats( AssertionResult const& _assertionResult,                        std::vector<MessageInfo> const& _infoMessages,                        Totals const& _totals );        AssertionStats( AssertionStats const& )              = default;        AssertionStats( AssertionStats && )                  = default;        AssertionStats& operator = ( AssertionStats const& ) = delete;        AssertionStats& operator = ( AssertionStats && )     = delete;        AssertionResult assertionResult;        std::vector<MessageInfo> infoMessages;        Totals totals;    \};    struct SectionStats \{        SectionStats(   SectionInfo&& _sectionInfo,                        Counts const& _assertions,                        double _durationInSeconds,                        bool _missingAssertions );        SectionInfo sectionInfo;        Counts assertions;        double durationInSeconds;        bool missingAssertions;    \};    struct TestCaseStats \{        TestCaseStats(  TestCaseInfo const& _testInfo,                        Totals const& _totals,                        std::string&& _stdOut,                        std::string&& _stdErr,                        bool _aborting );        TestCaseInfo const * testInfo;        Totals totals;        std::string stdOut;        std::string stdErr;        bool aborting;    \};    struct TestRunStats \{        TestRunStats(   TestRunInfo const& _runInfo,                        Totals const& _totals,                        bool _aborting );        TestRunInfo runInfo;        Totals totals;        bool aborting;    \};                struct ReporterPreferences \{                        bool shouldRedirectStdOut = false;                        bool shouldReportAllAssertions = false;    \};        class IEventListener \{    protected:                ReporterPreferences m_preferences;                IConfig const* m_config;    public:        IEventListener( IConfig const* config ): m_config( config ) \{\}        virtual ~IEventListener();                         ReporterPreferences const& getPreferences() const \{            return m_preferences;        \}                virtual void noMatchingTestCases( StringRef unmatchedSpec ) = 0;                virtual void reportInvalidTestSpec( StringRef invalidArgument ) = 0;                virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;                virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;                virtual void testCasePartialStarting( TestCaseInfo const& testInfo, uint64_t partNumber ) = 0;                virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;                virtual void benchmarkPreparing( StringRef benchmarkName ) = 0;                virtual void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) = 0;                virtual void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) = 0;                virtual void benchmarkFailed( StringRef benchmarkName ) = 0;                virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;                virtual void assertionEnded( AssertionStats const& assertionStats ) = 0;                virtual void sectionEnded( SectionStats const& sectionStats ) = 0;                virtual void testCasePartialEnded(TestCaseStats const& testCaseStats, uint64_t partNumber ) = 0;                virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;                virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;                virtual void skipTest( TestCaseInfo const& testInfo ) = 0;                virtual void fatalErrorEncountered( StringRef error ) = 0;                virtual void listReporters(std::vector<ReporterDescription> const& descriptions) = 0;                virtual void listListeners(std::vector<ListenerDescription> const& descriptions) = 0;                virtual void listTests(std::vector<TestCaseHandle> const& tests) = 0;                virtual void listTags(std::vector<TagInfo> const& tags) = 0;    \};    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;\} #endif #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED#define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED#include <string>namespace Catch \{    struct ReporterConfig;    class IConfig;    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;    class IReporterFactory \{    public:        virtual ~IReporterFactory();         virtual IEventListenerPtr        create( ReporterConfig&& config ) const = 0;        virtual std::string getDescription() const = 0;    \};    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;    class EventListenerFactory \{    public:        virtual ~EventListenerFactory();         virtual IEventListenerPtr create( IConfig const* config ) const = 0;                virtual StringRef getName() const = 0;                virtual std::string getDescription() const = 0;    \};\} #endif #ifndef CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED#define CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED#include <string>namespace Catch \{    struct TagAlias;    class ITagAliasRegistry \{    public:        virtual ~ITagAliasRegistry();                 virtual TagAlias const* find( std::string const& alias ) const = 0;        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;        static ITagAliasRegistry const& get();    \};\} #endif #ifndef CATCH_INTERFACES_TESTCASE_HPP_INCLUDED#define CATCH_INTERFACES_TESTCASE_HPP_INCLUDED#include <vector>namespace Catch \{    struct TestCaseInfo;    class TestCaseHandle;    class IConfig;    class ITestCaseRegistry \{    public:        virtual ~ITestCaseRegistry();                 virtual std::vector<TestCaseInfo* > const& getAllInfos() const = 0;        virtual std::vector<TestCaseHandle> const& getAllTests() const = 0;        virtual std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const = 0;    \};\}#endif #endif #ifndef CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED#define CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDEDnamespace Catch \{    namespace Detail \{                struct CaseInsensitiveLess \{            bool operator()( StringRef lhs,                             StringRef rhs ) const;        \};                struct CaseInsensitiveEqualTo \{            bool operator()( StringRef lhs,                             StringRef rhs ) const;        \};    \} \} #endif #ifndef CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED#define CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED#if defined(__ANDROID__)#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE#endif#if defined( CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE ) && \\    !defined( CATCH_CONFIG_NO_ANDROID_LOGWRITE ) &&      \\    !defined( CATCH_CONFIG_ANDROID_LOGWRITE )#    define CATCH_CONFIG_ANDROID_LOGWRITE#endif#endif #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#if defined(_MSC_VER)#  if _MSC_VER >= 1900 #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#  endif#endif#include <exception>#if defined(__cpp_lib_uncaught_exceptions) \\    && !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#endif #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \\    && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \\    && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#endif#endif #ifndef CATCH_CONSOLE_COLOUR_HPP_INCLUDED#define CATCH_CONSOLE_COLOUR_HPP_INCLUDED#include <iosfwd>#include <cstdint>namespace Catch \{    enum class ColourMode : std::uint8_t;    class IStream;    struct Colour \{        enum Code \{            None = 0,            White,            Red,            Green,            Blue,            Cyan,            Yellow,            Grey,            Bright = 0x10,            BrightRed = Bright | Red,            BrightGreen = Bright | Green,            LightGrey = Bright | Grey,            BrightWhite = Bright | White,            BrightYellow = Bright | Yellow,                        FileName = LightGrey,            Warning = BrightYellow,            ResultError = BrightRed,            ResultSuccess = BrightGreen,            ResultExpectedFailure = Warning,            Error = BrightRed,            Success = Green,            Skip = LightGrey,            OriginalExpression = Cyan,            ReconstructedExpression = BrightYellow,            SecondaryText = LightGrey,            Headers = White        \};    \};    class ColourImpl \{    protected:                IStream* m_stream;    public:        ColourImpl( IStream* stream ): m_stream( stream ) \{\}                        class ColourGuard \{            ColourImpl const* m_colourImpl;            Colour::Code m_code;            bool m_engaged = false;        public:                        ColourGuard( Colour::Code code,                         ColourImpl const* colour );            ColourGuard( ColourGuard const& rhs ) = delete;            ColourGuard& operator=( ColourGuard const& rhs ) = delete;            ColourGuard( ColourGuard&& rhs ) noexcept;            ColourGuard& operator=( ColourGuard&& rhs ) noexcept;                        ~ColourGuard();                        ColourGuard& engage( std::ostream& stream ) &;                        ColourGuard&& engage( std::ostream& stream ) &&;        private:                        friend std::ostream& operator<<( std::ostream& lhs,                                             ColourGuard& guard ) \{                guard.engageImpl( lhs );                return lhs;            \}                        friend std::ostream& operator<<( std::ostream& lhs,                                            ColourGuard&& guard) \{                guard.engageImpl( lhs );                return lhs;            \}            void engageImpl( std::ostream& stream );        \};        virtual ~ColourImpl();                 ColourGuard guardColour( Colour::Code colourCode );    private:        virtual void use( Colour::Code colourCode ) const = 0;    \};        Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,                                                   IStream* stream );        bool isColourImplAvailable( ColourMode colourSelection );\} #endif #ifndef CATCH_CONSOLE_WIDTH_HPP_INCLUDED#define CATCH_CONSOLE_WIDTH_HPP_INCLUDED#ifndef CATCH_CONFIG_CONSOLE_WIDTH#define CATCH_CONFIG_CONSOLE_WIDTH 80#endif#endif #ifndef CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED#define CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED#include <cstddef>#include <initializer_list>#if defined(CATCH_CPP17_OR_GREATER) || defined(_MSC_VER)#include <string>#  if !defined(__cpp_lib_nonmember_container_access)#      define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS#  endif#else#define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS#endifnamespace Catch \{namespace Detail \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)    template <typename Container>    constexpr auto empty(Container const& cont) -> decltype(cont.empty()) \{        return cont.empty();    \}    template <typename T, std::size_t N>    constexpr bool empty(const T (&)[N]) noexcept \{                        (void)N;        return false;    \}    template <typename T>    constexpr bool empty(std::initializer_list<T> list) noexcept \{        return list.size() > 0;    \}    template <typename Container>    constexpr auto size(Container const& cont) -> decltype(cont.size()) \{        return cont.size();    \}    template <typename T, std::size_t N>    constexpr std::size_t size(const T(&)[N]) noexcept \{        return N;    \}#endif \} \} #endif #ifndef CATCH_DEBUG_CONSOLE_HPP_INCLUDED#define CATCH_DEBUG_CONSOLE_HPP_INCLUDED#include <string>namespace Catch \{    void writeToDebugConsole( std::string const& text );\}#endif #ifndef CATCH_DEBUGGER_HPP_INCLUDED#define CATCH_DEBUGGER_HPP_INCLUDEDnamespace Catch \{    bool isDebuggerActive();\}#ifdef CATCH_PLATFORM_MAC    #if defined(__i386__) || defined(__x86_64__)        #define CATCH_TRAP() __asm__("int $3\\n" : : )     #elif defined(__aarch64__)        #define CATCH_TRAP() __asm__(".inst 0xd43e0000")    #elif defined(__POWERPC__)        #define CATCH_TRAP() __asm__("li r0, 20\\nsc\\nnop\\nli r0, 37\\nli r4, 2\\nsc\\nnop\\n" \\        : : : "memory","r0","r3","r4" )     #endif#elif defined(CATCH_PLATFORM_IPHONE)        #if defined(__i386__) || defined(__x86_64__)        #define CATCH_TRAP()  __asm__("int $3")    #elif defined(__aarch64__)        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")    #elif defined(__arm__) && !defined(__thumb__)        #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")    #elif defined(__arm__) &&  defined(__thumb__)        #define CATCH_TRAP()  __asm__(".inst 0xde01")    #endif#elif defined(CATCH_PLATFORM_LINUX)                #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))        #define CATCH_TRAP() asm volatile ("int $3")     #else         #include <signal.h>        #define CATCH_TRAP() raise(SIGTRAP)    #endif#elif defined(_MSC_VER)    #define CATCH_TRAP() __debugbreak()#elif defined(__MINGW32__)    extern "C" __declspec(dllimport) void __stdcall DebugBreak();    #define CATCH_TRAP() DebugBreak()#endif#ifndef CATCH_BREAK_INTO_DEBUGGER    #ifdef CATCH_TRAP        #define CATCH_BREAK_INTO_DEBUGGER() []\{ if( Catch::isDebuggerActive() ) \{ CATCH_TRAP(); \} \}()    #else        #define CATCH_BREAK_INTO_DEBUGGER() []\{\}()    #endif#endif#endif #ifndef CATCH_ENFORCE_HPP_INCLUDED#define CATCH_ENFORCE_HPP_INCLUDED#include <exception>namespace Catch \{#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)    template <typename Ex>    [[noreturn]]    void throw_exception(Ex const& e) \{        throw e;    \}#else     [[noreturn]]    void throw_exception(std::exception const& e);#endif    [[noreturn]]    void throw_logic_error(std::string const& msg);    [[noreturn]]    void throw_domain_error(std::string const& msg);    [[noreturn]]    void throw_runtime_error(std::string const& msg);\} #define CATCH_MAKE_MSG(...) \\    (Catch::ReusableStringStream() << __VA_ARGS__).str()#define CATCH_INTERNAL_ERROR(...) \\    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))#define CATCH_ERROR(...) \\    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))#define CATCH_RUNTIME_ERROR(...) \\    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))#define CATCH_ENFORCE( condition, ... ) \\    do\{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); \} while(false)#endif #ifndef CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED#define CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED#include <vector>namespace Catch \{    namespace Detail \{        Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values );        class EnumValuesRegistry : public IMutableEnumValuesRegistry \{            std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;            EnumInfo const& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values) override;        \};        std::vector<StringRef> parseEnums( StringRef enums );    \} \} #endif #ifndef CATCH_ERRNO_GUARD_HPP_INCLUDED#define CATCH_ERRNO_GUARD_HPP_INCLUDEDnamespace Catch \{            class ErrnoGuard \{    public:                ErrnoGuard();        ~ErrnoGuard();    private:        int m_oldErrno;    \};\}#endif #ifndef CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED#define CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED#include <vector>#include <string>namespace Catch \{    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry \{    public:        ~ExceptionTranslatorRegistry() override;        void registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator );        std::string translateActiveException() const override;    private:        ExceptionTranslators m_translators;    \};\}#endif #ifndef CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED#define CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED#include <cassert>namespace Catch \{        class FatalConditionHandler \{        bool m_started = false;                                void engage_platform();        void disengage_platform() noexcept;    public:                FatalConditionHandler();        ~FatalConditionHandler();        void engage() \{            assert(!m_started && "Handler cannot be installed twice.");            m_started = true;            engage_platform();        \}        void disengage() noexcept \{            assert(m_started && "Handler cannot be uninstalled without being installed first");            m_started = false;            disengage_platform();        \}    \};        class FatalConditionHandlerGuard \{        FatalConditionHandler* m_handler;    public:        FatalConditionHandlerGuard(FatalConditionHandler* handler):            m_handler(handler) \{            m_handler->engage();        \}        ~FatalConditionHandlerGuard() \{            m_handler->disengage();        \}    \};\} #endif #ifndef CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED#define CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED#include <cassert>#include <cmath>#include <cstdint>#include <utility>#include <limits>namespace Catch \{    namespace Detail \{        uint32_t convertToBits(float f);        uint64_t convertToBits(double d);                        bool directCompare( float lhs, float rhs );        bool directCompare( double lhs, double rhs );    \} #if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic push            #    pragma GCC diagnostic ignored "-Wfloat-equal"#endif        template <typename FP>    uint64_t ulpDistance( FP lhs, FP rhs ) \{        assert( std::numeric_limits<FP>::is_iec559 &&            "ulpDistance assumes IEEE-754 format for floating point types" );        assert( !Catch::isnan( lhs ) &&                "Distance between NaN and number is not meaningful" );        assert( !Catch::isnan( rhs ) &&                "Distance between NaN and number is not meaningful" );                        if ( lhs == rhs ) \{ return 0; \}                static constexpr FP positive_zero\{\};                if ( lhs == positive_zero ) \{ lhs = positive_zero; \}        if ( rhs == positive_zero ) \{ rhs = positive_zero; \}                        if ( std::signbit( lhs ) != std::signbit( rhs ) ) \{            return ulpDistance( std::abs( lhs ), positive_zero ) +                   ulpDistance( std::abs( rhs ), positive_zero );        \}                                uint64_t lc = Detail::convertToBits( lhs );        uint64_t rc = Detail::convertToBits( rhs );                        if ( lc < rc ) \{            std::swap( lc, rc );        \}        return lc - rc;    \}#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif\} #endif #ifndef CATCH_GETENV_HPP_INCLUDED#define CATCH_GETENV_HPP_INCLUDEDnamespace Catch \{namespace Detail \{        char const* getEnv(char const* varName);\}\}#endif #ifndef CATCH_IS_PERMUTATION_HPP_INCLUDED#define CATCH_IS_PERMUTATION_HPP_INCLUDED#include <algorithm>#include <iterator>namespace Catch \{    namespace Detail \{        template <typename ForwardIter,                  typename Sentinel,                  typename T,                  typename Comparator>        ForwardIter find_sentinel( ForwardIter start,                                   Sentinel sentinel,                                   T const& value,                                   Comparator cmp ) \{            while ( start != sentinel ) \{                if ( cmp( *start, value ) ) \{ break; \}                ++start;            \}            return start;        \}        template <typename ForwardIter,                  typename Sentinel,                  typename T,                  typename Comparator>        std::ptrdiff_t count_sentinel( ForwardIter start,                                       Sentinel sentinel,                                       T const& value,                                       Comparator cmp ) \{            std::ptrdiff_t count = 0;            while ( start != sentinel ) \{                if ( cmp( *start, value ) ) \{ ++count; \}                ++start;            \}            return count;        \}        template <typename ForwardIter, typename Sentinel>        std::enable_if_t<!std::is_same<ForwardIter, Sentinel>::value,                         std::ptrdiff_t>        sentinel_distance( ForwardIter iter, const Sentinel sentinel ) \{            std::ptrdiff_t dist = 0;            while ( iter != sentinel ) \{                ++iter;                ++dist;            \}            return dist;        \}        template <typename ForwardIter>        std::ptrdiff_t sentinel_distance( ForwardIter first,                                          ForwardIter last ) \{            return std::distance( first, last );        \}        template <typename ForwardIter1,                  typename Sentinel1,                  typename ForwardIter2,                  typename Sentinel2,                  typename Comparator>        bool check_element_counts( ForwardIter1 first_1,                                   const Sentinel1 end_1,                                   ForwardIter2 first_2,                                   const Sentinel2 end_2,                                   Comparator cmp ) \{            auto cursor = first_1;            while ( cursor != end_1 ) \{                if ( find_sentinel( first_1, cursor, *cursor, cmp ) ==                     cursor ) \{                                        const auto count_in_range_2 =                        count_sentinel( first_2, end_2, *cursor, cmp );                                                            if ( count_in_range_2 == 0 ) \{ return false; \}                    const auto count_in_range_1 =                        count_sentinel( cursor, end_1, *cursor, cmp );                    if ( count_in_range_1 != count_in_range_2 ) \{                        return false;                    \}                \}                ++cursor;            \}            return true;        \}        template <typename ForwardIter1,                  typename Sentinel1,                  typename ForwardIter2,                  typename Sentinel2,                  typename Comparator>        bool is_permutation( ForwardIter1 first_1,                             const Sentinel1 end_1,                             ForwardIter2 first_2,                             const Sentinel2 end_2,                             Comparator cmp ) \{                                                while (first_1 != end_1 && first_2 != end_2 && cmp(*first_1, *first_2)) \{                ++first_1;                ++first_2;            \}                        if (first_1 == end_1 || first_2 == end_2) \{                return first_1 == end_1 && first_2 == end_2;            \}                        auto dist_1 = sentinel_distance( first_1, end_1 );            auto dist_2 = sentinel_distance( first_2, end_2 );            if (dist_1 != dist_2) \{ return false; \}                                                return check_element_counts( first_1, end_1, first_2, end_2, cmp );        \}    \} \} #endif #ifndef CATCH_ISTREAM_HPP_INCLUDED#define CATCH_ISTREAM_HPP_INCLUDED#include <iosfwd>#include <cstddef>#include <ostream>#include <string>namespace Catch \{    class IStream \{    public:        virtual ~IStream();         virtual std::ostream& stream() = 0;                virtual bool isConsole() const \{ return false; \}    \};        auto makeStream( std::string const& filename ) -> Detail::unique_ptr<IStream>;\}#endif #ifndef CATCH_JSONWRITER_HPP_INCLUDED#define CATCH_JSONWRITER_HPP_INCLUDED#include <cstdint>#include <sstream>namespace Catch \{    class JsonObjectWriter;    class JsonArrayWriter;    struct JsonUtils \{        static void indent( std::ostream& os, std::uint64_t level );        static void appendCommaNewline( std::ostream& os,                                        bool& should_comma,                                        std::uint64_t level );    \};    class JsonValueWriter \{    public:        JsonValueWriter( std::ostream& os );        JsonValueWriter( std::ostream& os, std::uint64_t indent_level );        JsonObjectWriter writeObject() &&;        JsonArrayWriter writeArray() &&;        template <typename T>        void write( T const& value ) && \{            writeImpl( value, !std::is_arithmetic<T>::value );        \}        void write( StringRef value ) &&;        void write( bool value ) &&;    private:        void writeImpl( StringRef value, bool quote );                                        template <typename T,                  typename = typename std::enable_if_t<                      !std::is_convertible<T, StringRef>::value>>        void writeImpl( T const& value, bool quote_value ) \{            m_sstream << value;            writeImpl( m_sstream.str(), quote_value );        \}        std::ostream& m_os;        std::stringstream m_sstream;        std::uint64_t m_indent_level;    \};    class JsonObjectWriter \{    public:        JsonObjectWriter( std::ostream& os );        JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );        JsonObjectWriter( JsonObjectWriter&& source ) noexcept;        JsonObjectWriter& operator=( JsonObjectWriter&& source ) = delete;        ~JsonObjectWriter();        JsonValueWriter write( StringRef key );    private:        std::ostream& m_os;        std::uint64_t m_indent_level;        bool m_should_comma = false;        bool m_active = true;    \};    class JsonArrayWriter \{    public:        JsonArrayWriter( std::ostream& os );        JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );        JsonArrayWriter( JsonArrayWriter&& source ) noexcept;        JsonArrayWriter& operator=( JsonArrayWriter&& source ) = delete;        ~JsonArrayWriter();        JsonObjectWriter writeObject();        JsonArrayWriter writeArray();        template <typename T>        JsonArrayWriter& write( T const& value ) \{            return writeImpl( value );        \}        JsonArrayWriter& write( bool value );    private:        template <typename T>        JsonArrayWriter& writeImpl( T const& value ) \{            JsonUtils::appendCommaNewline(                m_os, m_should_comma, m_indent_level + 1 );            JsonValueWriter\{ m_os \}.write( value );            return *this;        \}        std::ostream& m_os;        std::uint64_t m_indent_level;        bool m_should_comma = false;        bool m_active = true;    \};\} #endif #ifndef CATCH_LEAK_DETECTOR_HPP_INCLUDED#define CATCH_LEAK_DETECTOR_HPP_INCLUDEDnamespace Catch \{    struct LeakDetector \{        LeakDetector();        ~LeakDetector();    \};\}#endif #ifndef CATCH_LIST_HPP_INCLUDED#define CATCH_LIST_HPP_INCLUDED#include <set>#include <string>namespace Catch \{    class IEventListener;    class Config;    struct ReporterDescription \{        std::string name, description;    \};    struct ListenerDescription \{        StringRef name;        std::string description;    \};    struct TagInfo \{        void add(StringRef spelling);        std::string all() const;        std::set<StringRef> spellings;        std::size_t count = 0;    \};    bool list( IEventListener& reporter, Config const& config );\} #endif #ifndef CATCH_OUTPUT_REDIRECT_HPP_INCLUDED#define CATCH_OUTPUT_REDIRECT_HPP_INCLUDED#include <cstdio>#include <iosfwd>#include <string>namespace Catch \{    class RedirectedStream \{        std::ostream& m_originalStream;        std::ostream& m_redirectionStream;        std::streambuf* m_prevBuf;    public:        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );        ~RedirectedStream();    \};    class RedirectedStdOut \{        ReusableStringStream m_rss;        RedirectedStream m_cout;    public:        RedirectedStdOut();        auto str() const -> std::string;    \};                class RedirectedStdErr \{        ReusableStringStream m_rss;        RedirectedStream m_cerr;        RedirectedStream m_clog;    public:        RedirectedStdErr();        auto str() const -> std::string;    \};    class RedirectedStreams \{    public:        RedirectedStreams(RedirectedStreams const&) = delete;        RedirectedStreams& operator=(RedirectedStreams const&) = delete;        RedirectedStreams(RedirectedStreams&&) = delete;        RedirectedStreams& operator=(RedirectedStreams&&) = delete;        RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);        ~RedirectedStreams();    private:        std::string& m_redirectedCout;        std::string& m_redirectedCerr;        RedirectedStdOut m_redirectedStdOut;        RedirectedStdErr m_redirectedStdErr;    \};#if defined(CATCH_CONFIG_NEW_CAPTURE)                    class TempFile \{    public:        TempFile(TempFile const&) = delete;        TempFile& operator=(TempFile const&) = delete;        TempFile(TempFile&&) = delete;        TempFile& operator=(TempFile&&) = delete;        TempFile();        ~TempFile();        std::FILE* getFile();        std::string getContents();    private:        std::FILE* m_file = nullptr;    #if defined(_MSC_VER)        char m_buffer[L_tmpnam] = \{ 0 \};    #endif    \};    class OutputRedirect \{    public:        OutputRedirect(OutputRedirect const&) = delete;        OutputRedirect& operator=(OutputRedirect const&) = delete;        OutputRedirect(OutputRedirect&&) = delete;        OutputRedirect& operator=(OutputRedirect&&) = delete;        OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);        ~OutputRedirect();    private:        int m_originalStdout = -1;        int m_originalStderr = -1;        TempFile m_stdoutFile;        TempFile m_stderrFile;        std::string& m_stdoutDest;        std::string& m_stderrDest;    \};#endif\} #endif #ifndef CATCH_PARSE_NUMBERS_HPP_INCLUDED#define CATCH_PARSE_NUMBERS_HPP_INCLUDED#include <string>namespace Catch \{        Optional<unsigned int> parseUInt(std::string const& input, int base = 10);\}#endif #ifndef CATCH_REPORTER_REGISTRY_HPP_INCLUDED#define CATCH_REPORTER_REGISTRY_HPP_INCLUDED#include <map>#include <string>#include <vector>namespace Catch \{    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;    class IReporterFactory;    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;    struct ReporterConfig;    class EventListenerFactory;    class ReporterRegistry \{        struct ReporterRegistryImpl;        Detail::unique_ptr<ReporterRegistryImpl> m_impl;    public:        ReporterRegistry();        ~ReporterRegistry();         IEventListenerPtr create( std::string const& name,                                  ReporterConfig&& config ) const;        void registerReporter( std::string const& name,                               IReporterFactoryPtr factory );        void        registerListener( Detail::unique_ptr<EventListenerFactory> factory );        std::map<std::string,                 IReporterFactoryPtr,                 Detail::CaseInsensitiveLess> const&        getFactories() const;        std::vector<Detail::unique_ptr<EventListenerFactory>> const&        getListeners() const;    \};\} #endif #ifndef CATCH_RUN_CONTEXT_HPP_INCLUDED#define CATCH_RUN_CONTEXT_HPP_INCLUDED#ifndef CATCH_TEST_CASE_TRACKER_HPP_INCLUDED#define CATCH_TEST_CASE_TRACKER_HPP_INCLUDED#include <string>#include <vector>namespace Catch \{namespace TestCaseTracking \{    struct NameAndLocation \{        std::string name;        SourceLineInfo location;        NameAndLocation( std::string&& _name, SourceLineInfo const& _location );        friend bool operator==(NameAndLocation const& lhs, NameAndLocation const& rhs) \{                                                            if ( lhs.location.line != rhs.location.line ) \{ return false; \}            return lhs.name == rhs.name && lhs.location == rhs.location;        \}        friend bool operator!=(NameAndLocation const& lhs,                               NameAndLocation const& rhs) \{            return !( lhs == rhs );        \}    \};        struct NameAndLocationRef \{        StringRef name;        SourceLineInfo location;        constexpr NameAndLocationRef( StringRef name_,                                      SourceLineInfo location_ ):            name( name_ ), location( location_ ) \{\}        friend bool operator==( NameAndLocation const& lhs,                                NameAndLocationRef const& rhs ) \{                                                            if ( lhs.location.line != rhs.location.line ) \{ return false; \}            return StringRef( lhs.name ) == rhs.name &&                   lhs.location == rhs.location;        \}        friend bool operator==( NameAndLocationRef const& lhs,                                NameAndLocation const& rhs ) \{            return rhs == lhs;        \}    \};    class ITracker;    using ITrackerPtr = Catch::Detail::unique_ptr<ITracker>;    class ITracker \{        NameAndLocation m_nameAndLocation;        using Children = std::vector<ITrackerPtr>;    protected:        enum CycleState \{            NotStarted,            Executing,            ExecutingChildren,            NeedsAnotherRun,            CompletedSuccessfully,            Failed        \};        ITracker* m_parent = nullptr;        Children m_children;        CycleState m_runState = NotStarted;    public:        ITracker( NameAndLocation&& nameAndLoc, ITracker* parent ):            m_nameAndLocation( CATCH_MOVE(nameAndLoc) ),            m_parent( parent )        \{\}                NameAndLocation const& nameAndLocation() const \{            return m_nameAndLocation;        \}        ITracker* parent() const \{            return m_parent;        \}        virtual ~ITracker();                         virtual bool isComplete() const = 0;                bool isSuccessfullyCompleted() const \{            return m_runState == CompletedSuccessfully;        \}                bool isOpen() const;                bool hasStarted() const;                virtual void close() = 0;         virtual void fail() = 0;        void markAsNeedingAnotherRun();                void addChild( ITrackerPtr&& child );                ITracker* findChild( NameAndLocationRef const& nameAndLocation );                bool hasChildren() const \{            return !m_children.empty();        \}                void openChild();                virtual bool isSectionTracker() const;                virtual bool isGeneratorTracker() const;    \};    class TrackerContext \{        enum RunState \{            NotStarted,            Executing,            CompletedCycle        \};        ITrackerPtr m_rootTracker;        ITracker* m_currentTracker = nullptr;        RunState m_runState = NotStarted;    public:        ITracker& startRun();        void startCycle() \{            m_currentTracker = m_rootTracker.get();            m_runState = Executing;        \}        void completeCycle();        bool completedCycle() const;        ITracker& currentTracker() \{ return *m_currentTracker; \}        void setCurrentTracker( ITracker* tracker );    \};    class TrackerBase : public ITracker \{    protected:        TrackerContext& m_ctx;    public:        TrackerBase( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );        bool isComplete() const override;        void open();        void close() override;        void fail() override;    private:        void moveToParent();        void moveToThis();    \};    class SectionTracker : public TrackerBase \{        std::vector<StringRef> m_filters;                                        StringRef m_trimmed_name;    public:        SectionTracker( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );        bool isSectionTracker() const override;        bool isComplete() const override;        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocationRef const& nameAndLocation );        void tryOpen();        void addInitialFilters( std::vector<std::string> const& filters );        void addNextFilters( std::vector<StringRef> const& filters );                std::vector<StringRef> const& getFilters() const \{ return m_filters; \}                StringRef trimmedName() const;    \};\} using TestCaseTracking::ITracker;using TestCaseTracking::TrackerContext;using TestCaseTracking::SectionTracker;\} #endif #include <string>namespace Catch \{    class IGeneratorTracker;    class IConfig;    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;        class RunContext final : public IResultCapture \{    public:        RunContext( RunContext const& ) = delete;        RunContext& operator =( RunContext const& ) = delete;        explicit RunContext( IConfig const* _config, IEventListenerPtr&& reporter );        ~RunContext() override;        Totals runTest(TestCaseHandle const& testCase);    public:                 void handleExpr                (   AssertionInfo const& info,                    ITransientExpression const& expr,                    AssertionReaction& reaction ) override;        void handleMessage                (   AssertionInfo const& info,                    ResultWas::OfType resultType,                    StringRef message,                    AssertionReaction& reaction ) override;        void handleUnexpectedExceptionNotThrown                (   AssertionInfo const& info,                    AssertionReaction& reaction ) override;        void handleUnexpectedInflightException                (   AssertionInfo const& info,                    std::string&& message,                    AssertionReaction& reaction ) override;        void handleIncomplete                (   AssertionInfo const& info ) override;        void handleNonExpr                (   AssertionInfo const &info,                    ResultWas::OfType resultType,                    AssertionReaction &reaction ) override;        void notifyAssertionStarted( AssertionInfo const& info ) override;        bool sectionStarted( StringRef sectionName,                             SourceLineInfo const& sectionLineInfo,                             Counts& assertions ) override;        void sectionEnded( SectionEndInfo&& endInfo ) override;        void sectionEndedEarly( SectionEndInfo&& endInfo ) override;        IGeneratorTracker*        acquireGeneratorTracker( StringRef generatorName,                                 SourceLineInfo const& lineInfo ) override;        IGeneratorTracker* createGeneratorTracker(            StringRef generatorName,            SourceLineInfo lineInfo,            Generators::GeneratorBasePtr&& generator ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& info ) override;        void benchmarkEnded( BenchmarkStats<> const& stats ) override;        void benchmarkFailed( StringRef error ) override;        void pushScopedMessage( MessageInfo const& message ) override;        void popScopedMessage( MessageInfo const& message ) override;        void emplaceUnscopedMessage( MessageBuilder&& builder ) override;        std::string getCurrentTestName() const override;        const AssertionResult* getLastResult() const override;        void exceptionEarlyReported() override;        void handleFatalErrorCondition( StringRef message ) override;        bool lastAssertionPassed() override;        void assertionPassed() override;    public:                bool aborting() const;    private:        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );        void invokeActiveTestCase();        void resetAssertionInfo();        bool testForMissingAssertions( Counts& assertions );        void assertionEnded( AssertionResult&& result );        void reportExpr                (   AssertionInfo const &info,                    ResultWas::OfType resultType,                    ITransientExpression const *expr,                    bool negated );        void populateReaction( AssertionReaction& reaction );    private:        void handleUnfinishedSections();        TestRunInfo m_runInfo;        TestCaseHandle const* m_activeTestCase = nullptr;        ITracker* m_testCaseTracker = nullptr;        Optional<AssertionResult> m_lastResult;        IConfig const* m_config;        Totals m_totals;        IEventListenerPtr m_reporter;        std::vector<MessageInfo> m_messages;        std::vector<ScopedMessage> m_messageScopes;         AssertionInfo m_lastAssertionInfo;        std::vector<SectionEndInfo> m_unfinishedSections;        std::vector<ITracker*> m_activeSections;        TrackerContext m_trackerContext;        FatalConditionHandler m_fatalConditionhandler;        bool m_lastAssertionPassed = false;        bool m_shouldReportUnexpected = true;        bool m_includeSuccessfulResults;    \};    void seedRng(IConfig const& config);    unsigned int rngSeed();\} #endif #ifndef CATCH_SHARDING_HPP_INCLUDED#define CATCH_SHARDING_HPP_INCLUDED#include <cassert>#include <cmath>#include <algorithm>namespace Catch \{    template<typename Container>    Container createShard(Container const& container, std::size_t const shardCount, std::size_t const shardIndex) \{        assert(shardCount > shardIndex);        if (shardCount == 1) \{            return container;        \}        const std::size_t totalTestCount = container.size();        const std::size_t shardSize = totalTestCount / shardCount;        const std::size_t leftoverTests = totalTestCount % shardCount;        const std::size_t startIndex = shardIndex * shardSize + (std::min)(shardIndex, leftoverTests);        const std::size_t endIndex = (shardIndex + 1) * shardSize + (std::min)(shardIndex + 1, leftoverTests);        auto startIterator = std::next(container.begin(), static_cast<std::ptrdiff_t>(startIndex));        auto endIterator = std::next(container.begin(), static_cast<std::ptrdiff_t>(endIndex));        return Container(startIterator, endIterator);    \}\}#endif #ifndef CATCH_SINGLETONS_HPP_INCLUDED#define CATCH_SINGLETONS_HPP_INCLUDEDnamespace Catch \{    struct ISingleton \{        virtual ~ISingleton();     \};    void addSingleton( ISingleton* singleton );    void cleanupSingletons();    template<typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT>    class Singleton : SingletonImplT, public ISingleton \{        static auto getInternal() -> Singleton* \{            static Singleton* s_instance = nullptr;            if( !s_instance ) \{                s_instance = new Singleton;                addSingleton( s_instance );            \}            return s_instance;        \}    public:        static auto get() -> InterfaceT const& \{            return *getInternal();        \}        static auto getMutable() -> MutableInterfaceT& \{            return *getInternal();        \}    \};\} #endif #ifndef CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED#define CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED#include <vector>#include <exception>namespace Catch \{    class StartupExceptionRegistry \{#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)    public:        void add(std::exception_ptr const& exception) noexcept;        std::vector<std::exception_ptr> const& getExceptions() const noexcept;    private:        std::vector<std::exception_ptr> m_exceptions;#endif    \};\} #endif #ifndef CATCH_STDSTREAMS_HPP_INCLUDED#define CATCH_STDSTREAMS_HPP_INCLUDED#include <iosfwd>namespace Catch \{    std::ostream& cout();    std::ostream& cerr();    std::ostream& clog();\} #endif#ifndef CATCH_STRING_MANIP_HPP_INCLUDED#define CATCH_STRING_MANIP_HPP_INCLUDED#include <cstdint>#include <string>#include <iosfwd>#include <vector>namespace Catch \{    bool startsWith( std::string const& s, std::string const& prefix );    bool startsWith( StringRef s, char prefix );    bool endsWith( std::string const& s, std::string const& suffix );    bool endsWith( std::string const& s, char suffix );    bool contains( std::string const& s, std::string const& infix );    void toLowerInPlace( std::string& s );    std::string toLower( std::string const& s );    char toLower( char c );        std::string trim( std::string const& str );        StringRef trim(StringRef ref);        std::vector<StringRef> splitStringRef( StringRef str, char delimiter );    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );        class pluralise \{        std::uint64_t m_count;        StringRef m_label;    public:        constexpr pluralise(std::uint64_t count, StringRef label):            m_count(count),            m_label(label)        \{\}        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );    \};\}#endif #ifndef CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED#define CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED#include <map>#include <string>namespace Catch \{    struct SourceLineInfo;    class TagAliasRegistry : public ITagAliasRegistry \{    public:        ~TagAliasRegistry() override;        TagAlias const* find( std::string const& alias ) const override;        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );    private:        std::map<std::string, TagAlias> m_registry;    \};\} #endif #ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED#include <cstdint>namespace Catch \{    struct TestCaseInfo;    class TestCaseInfoHasher \{    public:        using hash_t = std::uint64_t;        TestCaseInfoHasher( hash_t seed );        uint32_t operator()( TestCaseInfo const& t ) const;    private:        hash_t m_seed;    \};\} #endif #ifndef CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED#define CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED#include <vector>namespace Catch \{    class IConfig;    class ITestInvoker;    class TestCaseHandle;    class TestSpec;    std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases );    bool isThrowSafe( TestCaseHandle const& testCase, IConfig const& config );    std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> const& testCases, TestSpec const& testSpec, IConfig const& config );    std::vector<TestCaseHandle> const& getAllTestCasesSorted( IConfig const& config );    class TestRegistry : public ITestCaseRegistry \{    public:        void registerTest( Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker );        std::vector<TestCaseInfo*> const& getAllInfos() const override;        std::vector<TestCaseHandle> const& getAllTests() const override;        std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const override;        ~TestRegistry() override;     private:        std::vector<Detail::unique_ptr<TestCaseInfo>> m_owned_test_infos;                        std::vector<TestCaseInfo*> m_viewed_test_infos;        std::vector<Detail::unique_ptr<ITestInvoker>> m_invokers;        std::vector<TestCaseHandle> m_handles;        mutable TestRunOrder m_currentSortOrder = TestRunOrder::Declared;        mutable std::vector<TestCaseHandle> m_sortedFunctions;    \};    \} #endif #ifndef CATCH_TEST_SPEC_PARSER_HPP_INCLUDED#define CATCH_TEST_SPEC_PARSER_HPP_INCLUDED#ifdef __clang__#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wpadded"#endif#include <vector>#include <string>namespace Catch \{    class ITagAliasRegistry;    class TestSpecParser \{        enum Mode\{ None, Name, QuotedName, Tag, EscapedName \};        Mode m_mode = None;        Mode lastMode = None;        bool m_exclusion = false;        std::size_t m_pos = 0;        std::size_t m_realPatternPos = 0;        std::string m_arg;        std::string m_substring;        std::string m_patternName;        std::vector<std::size_t> m_escapeChars;        TestSpec::Filter m_currentFilter;        TestSpec m_testSpec;        ITagAliasRegistry const* m_tagAliases = nullptr;    public:        TestSpecParser( ITagAliasRegistry const& tagAliases );        TestSpecParser& parse( std::string const& arg );        TestSpec testSpec();    private:        bool visitChar( char c );        void startNewMode( Mode mode );        bool processNoneChar( char c );        void processNameChar( char c );        bool processOtherChar( char c );        void endMode();        void escape();        bool isControlChar( char c ) const;        void saveLastMode();        void revertBackToLastMode();        void addFilter();        bool separate();                std::string preprocessPattern();                void addNamePattern();                void addTagPattern();        inline void addCharToPattern(char c) \{            m_substring += c;            m_patternName += c;            m_realPatternPos++;        \}    \};\} #ifdef __clang__#pragma clang diagnostic pop#endif#endif #ifndef CATCH_TEXTFLOW_HPP_INCLUDED#define CATCH_TEXTFLOW_HPP_INCLUDED#include <cassert>#include <string>#include <vector>namespace Catch \{    namespace TextFlow \{        class Columns;                class AnsiSkippingString \{            std::string m_string;            std::size_t m_size = 0;                        void preprocessString();        public:            class const_iterator;            using iterator = const_iterator;                                    static constexpr char sentinel = static_cast<char>( 0xffu );            explicit AnsiSkippingString( std::string const& text );            explicit AnsiSkippingString( std::string&& text );            const_iterator begin() const;            const_iterator end() const;            size_t size() const \{ return m_size; \}            std::string substring( const_iterator begin,                                   const_iterator end ) const;        \};        class AnsiSkippingString::const_iterator \{            friend AnsiSkippingString;            struct EndTag \{\};            const std::string* m_string;            std::string::const_iterator m_it;            explicit const_iterator( const std::string& string, EndTag ):                m_string( &string ), m_it( string.end() ) \{\}            void tryParseAnsiEscapes();            void advance();            void unadvance();        public:            using difference_type = std::ptrdiff_t;            using value_type = char;            using pointer = value_type*;            using reference = value_type&;            using iterator_category = std::bidirectional_iterator_tag;            explicit const_iterator( const std::string& string ):                m_string( &string ), m_it( string.begin() ) \{                tryParseAnsiEscapes();            \}            char operator*() const \{ return *m_it; \}            const_iterator& operator++() \{                advance();                return *this;            \}            const_iterator operator++( int ) \{                iterator prev( *this );                operator++();                return prev;            \}            const_iterator& operator--() \{                unadvance();                return *this;            \}            const_iterator operator--( int ) \{                iterator prev( *this );                operator--();                return prev;            \}            bool operator==( const_iterator const& other ) const \{                return m_it == other.m_it;            \}            bool operator!=( const_iterator const& other ) const \{                return !operator==( other );            \}            bool operator<=( const_iterator const& other ) const \{                return m_it <= other.m_it;            \}            const_iterator oneBefore() const \{                auto it = *this;                return --it;            \}        \};                class Column \{                        AnsiSkippingString m_string;                        size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;                                    size_t m_indent = 0;                        size_t m_initialIndent = std::string::npos;        public:                        class const_iterator \{                friend Column;                struct EndTag \{\};                Column const& m_column;                                AnsiSkippingString::const_iterator m_lineStart;                                AnsiSkippingString::const_iterator m_lineEnd;                                AnsiSkippingString::const_iterator m_parsedTo;                                bool m_addHyphen = false;                const_iterator( Column const& column, EndTag ):                    m_column( column ),                    m_lineStart( m_column.m_string.end() ),                    m_lineEnd( column.m_string.end() ),                    m_parsedTo( column.m_string.end() ) \{\}                                void calcLength();                                size_t indentSize() const;                                                std::string addIndentAndSuffix(                    AnsiSkippingString::const_iterator start,                    AnsiSkippingString::const_iterator end ) const;            public:                using difference_type = std::ptrdiff_t;                using value_type = std::string;                using pointer = value_type*;                using reference = value_type&;                using iterator_category = std::forward_iterator_tag;                explicit const_iterator( Column const& column );                std::string operator*() const;                const_iterator& operator++();                const_iterator operator++( int );                bool operator==( const_iterator const& other ) const \{                    return m_lineStart == other.m_lineStart &&                           &m_column == &other.m_column;                \}                bool operator!=( const_iterator const& other ) const \{                    return !operator==( other );                \}            \};            using iterator = const_iterator;            explicit Column( std::string const& text ): m_string( text ) \{\}            explicit Column( std::string&& text ):                m_string( CATCH_MOVE( text ) ) \{\}            Column& width( size_t newWidth ) & \{                assert( newWidth > 0 );                m_width = newWidth;                return *this;            \}            Column&& width( size_t newWidth ) && \{                assert( newWidth > 0 );                m_width = newWidth;                return CATCH_MOVE( *this );            \}            Column& indent( size_t newIndent ) & \{                m_indent = newIndent;                return *this;            \}            Column&& indent( size_t newIndent ) && \{                m_indent = newIndent;                return CATCH_MOVE( *this );            \}            Column& initialIndent( size_t newIndent ) & \{                m_initialIndent = newIndent;                return *this;            \}            Column&& initialIndent( size_t newIndent ) && \{                m_initialIndent = newIndent;                return CATCH_MOVE( *this );            \}            size_t width() const \{ return m_width; \}            const_iterator begin() const \{ return const_iterator( *this ); \}            const_iterator end() const \{                return \{ *this, const_iterator::EndTag\{\} \};            \}            friend std::ostream& operator<<( std::ostream& os,                                             Column const& col );            friend Columns operator+( Column const& lhs, Column const& rhs );            friend Columns operator+( Column&& lhs, Column&& rhs );        \};                Column Spacer( size_t spaceWidth );        class Columns \{            std::vector<Column> m_columns;        public:            class iterator \{                friend Columns;                struct EndTag \{\};                std::vector<Column> const& m_columns;                std::vector<Column::const_iterator> m_iterators;                size_t m_activeIterators;                iterator( Columns const& columns, EndTag );            public:                using difference_type = std::ptrdiff_t;                using value_type = std::string;                using pointer = value_type*;                using reference = value_type&;                using iterator_category = std::forward_iterator_tag;                explicit iterator( Columns const& columns );                auto operator==( iterator const& other ) const -> bool \{                    return m_iterators == other.m_iterators;                \}                auto operator!=( iterator const& other ) const -> bool \{                    return m_iterators != other.m_iterators;                \}                std::string operator*() const;                iterator& operator++();                iterator operator++( int );            \};            using const_iterator = iterator;            iterator begin() const \{ return iterator( *this ); \}            iterator end() const \{ return \{ *this, iterator::EndTag() \}; \}            friend Columns& operator+=( Columns& lhs, Column const& rhs );            friend Columns& operator+=( Columns& lhs, Column&& rhs );            friend Columns operator+( Columns const& lhs, Column const& rhs );            friend Columns operator+( Columns&& lhs, Column&& rhs );            friend std::ostream& operator<<( std::ostream& os,                                             Columns const& cols );        \};    \} \} #endif #ifndef CATCH_TO_STRING_HPP_INCLUDED#define CATCH_TO_STRING_HPP_INCLUDED#include <string>namespace Catch \{    template <typename T>    std::string to_string(T const& t) \{#if defined(CATCH_CONFIG_CPP11_TO_STRING)        return std::to_string(t);#else        ReusableStringStream rss;        rss << t;        return rss.str();#endif    \}\} #endif #ifndef CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#define CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDEDnamespace Catch \{    bool uncaught_exceptions();\} #endif #ifndef CATCH_XMLWRITER_HPP_INCLUDED#define CATCH_XMLWRITER_HPP_INCLUDED#include <iosfwd>#include <vector>namespace Catch \{    enum class XmlFormatting \{        None = 0x00,        Indent = 0x01,        Newline = 0x02,    \};    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);        class XmlEncode \{    public:        enum ForWhat \{ ForTextNodes, ForAttributes \};        XmlEncode( StringRef str, ForWhat forWhat = ForTextNodes );        void encodeTo( std::ostream& os ) const;        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );    private:        StringRef m_str;        ForWhat m_forWhat;    \};    class XmlWriter \{    public:        class ScopedElement \{        public:            ScopedElement( XmlWriter* writer, XmlFormatting fmt );            ScopedElement( ScopedElement&& other ) noexcept;            ScopedElement& operator=( ScopedElement&& other ) noexcept;            ~ScopedElement();            ScopedElement&            writeText( StringRef text,                       XmlFormatting fmt = XmlFormatting::Newline |                                           XmlFormatting::Indent );            ScopedElement& writeAttribute( StringRef name,                                           StringRef attribute );            template <typename T,                                                                                                              typename = typename std::enable_if_t<                          !std::is_convertible<T, StringRef>::value>>            ScopedElement& writeAttribute( StringRef name,                                           T const& attribute ) \{                m_writer->writeAttribute( name, attribute );                return *this;            \}        private:            XmlWriter* m_writer = nullptr;            XmlFormatting m_fmt;        \};        XmlWriter( std::ostream& os );        ~XmlWriter();        XmlWriter( XmlWriter const& ) = delete;        XmlWriter& operator=( XmlWriter const& ) = delete;        XmlWriter& startElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);        ScopedElement scopedElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);        XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);                XmlWriter& writeAttribute( StringRef name, StringRef attribute );                XmlWriter& writeAttribute( StringRef name, bool attribute );                XmlWriter& writeAttribute( StringRef name, char const* attribute );                        template <typename T,                                                                                          typename = typename std::enable_if_t<                      !std::is_convertible<T, StringRef>::value>>        XmlWriter& writeAttribute( StringRef name, T const& attribute ) \{            ReusableStringStream rss;            rss << attribute;            return writeAttribute( name, rss.str() );        \}                XmlWriter& writeText( StringRef text,                              XmlFormatting fmt = XmlFormatting::Newline |                                                  XmlFormatting::Indent );                XmlWriter& writeComment( StringRef text,                                 XmlFormatting fmt = XmlFormatting::Newline |                                                     XmlFormatting::Indent );        void writeStylesheetRef( StringRef url );        void ensureTagClosed();    private:        void applyFormatting(XmlFormatting fmt);        void writeDeclaration();        void newlineIfNecessary();        bool m_tagIsOpen = false;        bool m_needsNewline = false;        std::vector<std::string> m_tags;        std::string m_indent;        std::ostream& m_os;    \};\}#endif #ifndef CATCH_MATCHERS_ALL_HPP_INCLUDED#define CATCH_MATCHERS_ALL_HPP_INCLUDED#ifndef CATCH_MATCHERS_HPP_INCLUDED#define CATCH_MATCHERS_HPP_INCLUDED#ifndef CATCH_MATCHERS_IMPL_HPP_INCLUDED#define CATCH_MATCHERS_IMPL_HPP_INCLUDED#include <string>namespace Catch \{#ifdef __clang__#    pragma clang diagnostic push#    pragma clang diagnostic ignored "-Wsign-compare"#    pragma clang diagnostic ignored "-Wnon-virtual-dtor"#elif defined __GNUC__#    pragma GCC diagnostic push#    pragma GCC diagnostic ignored "-Wsign-compare"#    pragma GCC diagnostic ignored "-Wnon-virtual-dtor"#endif    template<typename ArgT, typename MatcherT>    class MatchExpr : public ITransientExpression \{        ArgT && m_arg;        MatcherT const& m_matcher;    public:        MatchExpr( ArgT && arg, MatcherT const& matcher )        :   ITransientExpression\{ true, matcher.match( arg ) \},             m_arg( CATCH_FORWARD(arg) ),            m_matcher( matcher )        \{\}        void streamReconstructedExpression( std::ostream& os ) const override \{            os << Catch::Detail::stringify( m_arg )               << ' '               << m_matcher.toString();        \}    \};#ifdef __clang__#    pragma clang diagnostic pop#elif defined __GNUC__#    pragma GCC diagnostic pop#endif    namespace Matchers \{        template <typename ArgT>        class MatcherBase;    \}    using StringMatcher = Matchers::MatcherBase<std::string>;    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher );    template<typename ArgT, typename MatcherT>    auto makeMatchExpr( ArgT && arg, MatcherT const& matcher ) -> MatchExpr<ArgT, MatcherT> \{        return MatchExpr<ArgT, MatcherT>( CATCH_FORWARD(arg), matcher );    \}\} #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \\    do \{ \\        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\        INTERNAL_CATCH_TRY \{ \\            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher ) ); \\        \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\    \} while( false )#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \\    do \{ \\        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\        if( catchAssertionHandler.allowThrows() ) \\            try \{ \\                static_cast<void>(__VA_ARGS__ ); \\                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\            \} \\            catch( exceptionType const& ex ) \{ \\                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher ) ); \\            \} \\            catch( ... ) \{ \\                catchAssertionHandler.handleUnexpectedInflightException(); \\            \} \\        else \\            catchAssertionHandler.handleThrowingCallSkipped(); \\        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\    \} while( false )#endif #include <string>#include <vector>namespace Catch \{namespace Matchers \{    class MatcherUntypedBase \{    public:        MatcherUntypedBase() = default;        MatcherUntypedBase(MatcherUntypedBase const&) = default;        MatcherUntypedBase(MatcherUntypedBase&&) = default;        MatcherUntypedBase& operator = (MatcherUntypedBase const&) = delete;        MatcherUntypedBase& operator = (MatcherUntypedBase&&) = delete;        std::string toString() const;    protected:        virtual ~MatcherUntypedBase();         virtual std::string describe() const = 0;        mutable std::string m_cachedToString;    \};    template<typename T>    class MatcherBase : public MatcherUntypedBase \{    public:        virtual bool match( T const& arg ) const = 0;    \};    namespace Detail \{        template<typename ArgT>        class MatchAllOf final : public MatcherBase<ArgT> \{            std::vector<MatcherBase<ArgT> const*> m_matchers;        public:            MatchAllOf() = default;            MatchAllOf(MatchAllOf const&) = delete;            MatchAllOf& operator=(MatchAllOf const&) = delete;            MatchAllOf(MatchAllOf&&) = default;            MatchAllOf& operator=(MatchAllOf&&) = default;            bool match( ArgT const& arg ) const override \{                for( auto matcher : m_matchers ) \{                    if (!matcher->match(arg))                        return false;                \}                return true;            \}            std::string describe() const override \{                std::string description;                description.reserve( 4 + m_matchers.size()*32 );                description += "( ";                bool first = true;                for( auto matcher : m_matchers ) \{                    if( first )                        first = false;                    else                        description += " and ";                    description += matcher->toString();                \}                description += " )";                return description;            \}            friend MatchAllOf operator&& (MatchAllOf&& lhs, MatcherBase<ArgT> const& rhs) \{                lhs.m_matchers.push_back(&rhs);                return CATCH_MOVE(lhs);            \}            friend MatchAllOf operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf&& rhs) \{                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);                return CATCH_MOVE(rhs);            \}        \};                        template<typename ArgT>        MatchAllOf<ArgT> operator&& (MatchAllOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;                        template<typename ArgT>        MatchAllOf<ArgT> operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf<ArgT> const& rhs) = delete;        template<typename ArgT>        class MatchAnyOf final : public MatcherBase<ArgT> \{            std::vector<MatcherBase<ArgT> const*> m_matchers;        public:            MatchAnyOf() = default;            MatchAnyOf(MatchAnyOf const&) = delete;            MatchAnyOf& operator=(MatchAnyOf const&) = delete;            MatchAnyOf(MatchAnyOf&&) = default;            MatchAnyOf& operator=(MatchAnyOf&&) = default;            bool match( ArgT const& arg ) const override \{                for( auto matcher : m_matchers ) \{                    if (matcher->match(arg))                        return true;                \}                return false;            \}            std::string describe() const override \{                std::string description;                description.reserve( 4 + m_matchers.size()*32 );                description += "( ";                bool first = true;                for( auto matcher : m_matchers ) \{                    if( first )                        first = false;                    else                        description += " or ";                    description += matcher->toString();                \}                description += " )";                return description;            \}            friend MatchAnyOf operator|| (MatchAnyOf&& lhs, MatcherBase<ArgT> const& rhs) \{                lhs.m_matchers.push_back(&rhs);                return CATCH_MOVE(lhs);            \}            friend MatchAnyOf operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf&& rhs) \{                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);                return CATCH_MOVE(rhs);            \}        \};                        template<typename ArgT>        MatchAnyOf<ArgT> operator|| (MatchAnyOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;                        template<typename ArgT>        MatchAnyOf<ArgT> operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf<ArgT> const& rhs) = delete;        template<typename ArgT>        class MatchNotOf final : public MatcherBase<ArgT> \{            MatcherBase<ArgT> const& m_underlyingMatcher;        public:            explicit MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ):                m_underlyingMatcher( underlyingMatcher )            \{\}            bool match( ArgT const& arg ) const override \{                return !m_underlyingMatcher.match( arg );            \}            std::string describe() const override \{                return "not " + m_underlyingMatcher.toString();            \}        \};    \}     template <typename T>    Detail::MatchAllOf<T> operator&& (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) \{        return Detail::MatchAllOf<T>\{\} && lhs && rhs;    \}    template <typename T>    Detail::MatchAnyOf<T> operator|| (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) \{        return Detail::MatchAnyOf<T>\{\} || lhs || rhs;    \}    template <typename T>    Detail::MatchNotOf<T> operator! (MatcherBase<T> const& matcher) \{        return Detail::MatchNotOf<T>\{ matcher \};    \}\} \} #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)  #define CATCH_CHECK_THROWS_WITH( expr, matcher )                     (void)(0)  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)  #define CATCH_CHECK_THAT( arg, matcher )                             (void)(0)  #define CATCH_REQUIRE_THAT( arg, matcher )                           (void)(0)#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)  #define REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)  #define CHECK_THROWS_WITH( expr, matcher )                     (void)(0)  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)  #define CHECK_THAT( arg, matcher )                             (void)(0)  #define REQUIRE_THAT( arg, matcher )                           (void)(0)#endif #endif #ifndef CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED#define CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED#ifndef CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED#define CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED#include <array>#include <algorithm>#include <string>#include <type_traits>namespace Catch \{namespace Matchers \{    class MatcherGenericBase : public MatcherUntypedBase \{    public:        MatcherGenericBase() = default;        ~MatcherGenericBase() override;         MatcherGenericBase(MatcherGenericBase const&) = default;        MatcherGenericBase(MatcherGenericBase&&) = default;        MatcherGenericBase& operator=(MatcherGenericBase const&) = delete;        MatcherGenericBase& operator=(MatcherGenericBase&&) = delete;    \};    namespace Detail \{        template<std::size_t N, std::size_t M>        std::array<void const*, N + M> array_cat(std::array<void const*, N> && lhs, std::array<void const*, M> && rhs) \{            std::array<void const*, N + M> arr\{\};            std::copy_n(lhs.begin(), N, arr.begin());            std::copy_n(rhs.begin(), M, arr.begin() + N);            return arr;        \}        template<std::size_t N>        std::array<void const*, N+1> array_cat(std::array<void const*, N> && lhs, void const* rhs) \{            std::array<void const*, N+1> arr\{\};            std::copy_n(lhs.begin(), N, arr.begin());            arr[N] = rhs;            return arr;        \}        template<std::size_t N>        std::array<void const*, N+1> array_cat(void const* lhs, std::array<void const*, N> && rhs) \{            std::array<void const*, N + 1> arr\{ \{lhs\} \};            std::copy_n(rhs.begin(), N, arr.begin() + 1);            return arr;        \}        template<typename T>        using is_generic_matcher = std::is_base_of<            Catch::Matchers::MatcherGenericBase,            std::remove_cv_t<std::remove_reference_t<T>>        >;        template<typename... Ts>        using are_generic_matchers = Catch::Detail::conjunction<is_generic_matcher<Ts>...>;        template<typename T>        using is_matcher = std::is_base_of<            Catch::Matchers::MatcherUntypedBase,            std::remove_cv_t<std::remove_reference_t<T>>        >;        template<std::size_t N, typename Arg>        bool match_all_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) \{            return true;        \}        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>        bool match_all_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) \{            return static_cast<T const*>(matchers[Idx])->match(arg) && match_all_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});        \}        template<std::size_t N, typename Arg>        bool match_any_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) \{            return false;        \}        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>        bool match_any_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) \{            return static_cast<T const*>(matchers[Idx])->match(arg) || match_any_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});        \}        std::string describe_multi_matcher(StringRef combine, std::string const* descriptions_begin, std::string const* descriptions_end);        template<typename... MatcherTs, std::size_t... Idx>        std::string describe_multi_matcher(StringRef combine, std::array<void const*, sizeof...(MatcherTs)> const& matchers, std::index_sequence<Idx...>) \{            std::array<std::string, sizeof...(MatcherTs)> descriptions \{\{                static_cast<MatcherTs const*>(matchers[Idx])->toString()...            \}\};            return describe_multi_matcher(combine, descriptions.data(), descriptions.data() + descriptions.size());        \}        template<typename... MatcherTs>        class MatchAllOfGeneric final : public MatcherGenericBase \{        public:            MatchAllOfGeneric(MatchAllOfGeneric const&) = delete;            MatchAllOfGeneric& operator=(MatchAllOfGeneric const&) = delete;            MatchAllOfGeneric(MatchAllOfGeneric&&) = default;            MatchAllOfGeneric& operator=(MatchAllOfGeneric&&) = default;            MatchAllOfGeneric(MatcherTs const&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}            explicit MatchAllOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}            template<typename Arg>            bool match(Arg&& arg) const \{                return match_all_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}            std::string describe() const override \{                return describe_multi_matcher<MatcherTs...>(" and "_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}                                                std::array<void const*, sizeof...( MatcherTs )> m_matchers;                        template<typename... MatchersRHS>            friend            MatchAllOfGeneric<MatcherTs..., MatchersRHS...> operator && (                    MatchAllOfGeneric<MatcherTs...>&& lhs,                    MatchAllOfGeneric<MatchersRHS...>&& rhs) \{                return MatchAllOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};            \}                        template<typename MatcherRHS>            friend std::enable_if_t<is_matcher<MatcherRHS>::value,            MatchAllOfGeneric<MatcherTs..., MatcherRHS>> operator && (                    MatchAllOfGeneric<MatcherTs...>&& lhs,                    MatcherRHS const& rhs) \{                return MatchAllOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), static_cast<void const*>(&rhs))\};            \}                        template<typename MatcherLHS>            friend std::enable_if_t<is_matcher<MatcherLHS>::value,            MatchAllOfGeneric<MatcherLHS, MatcherTs...>> operator && (                    MatcherLHS const& lhs,                    MatchAllOfGeneric<MatcherTs...>&& rhs) \{                return MatchAllOfGeneric<MatcherLHS, MatcherTs...>\{array_cat(static_cast<void const*>(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};            \}        \};        template<typename... MatcherTs>        class MatchAnyOfGeneric final : public MatcherGenericBase \{        public:            MatchAnyOfGeneric(MatchAnyOfGeneric const&) = delete;            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric const&) = delete;            MatchAnyOfGeneric(MatchAnyOfGeneric&&) = default;            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric&&) = default;            MatchAnyOfGeneric(MatcherTs const&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}            explicit MatchAnyOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}            template<typename Arg>            bool match(Arg&& arg) const \{                return match_any_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}            std::string describe() const override \{                return describe_multi_matcher<MatcherTs...>(" or "_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}                                                std::array<void const*, sizeof...( MatcherTs )> m_matchers;                        template<typename... MatchersRHS>            friend MatchAnyOfGeneric<MatcherTs..., MatchersRHS...> operator || (                    MatchAnyOfGeneric<MatcherTs...>&& lhs,                    MatchAnyOfGeneric<MatchersRHS...>&& rhs) \{                return MatchAnyOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};            \}                        template<typename MatcherRHS>            friend std::enable_if_t<is_matcher<MatcherRHS>::value,            MatchAnyOfGeneric<MatcherTs..., MatcherRHS>> operator || (                    MatchAnyOfGeneric<MatcherTs...>&& lhs,                    MatcherRHS const& rhs) \{                return MatchAnyOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), static_cast<void const*>(std::addressof(rhs)))\};            \}                        template<typename MatcherLHS>            friend std::enable_if_t<is_matcher<MatcherLHS>::value,            MatchAnyOfGeneric<MatcherLHS, MatcherTs...>> operator || (                MatcherLHS const& lhs,                MatchAnyOfGeneric<MatcherTs...>&& rhs) \{                return MatchAnyOfGeneric<MatcherLHS, MatcherTs...>\{array_cat(static_cast<void const*>(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};            \}        \};        template<typename MatcherT>        class MatchNotOfGeneric final : public MatcherGenericBase \{            MatcherT const& m_matcher;        public:            MatchNotOfGeneric(MatchNotOfGeneric const&) = delete;            MatchNotOfGeneric& operator=(MatchNotOfGeneric const&) = delete;            MatchNotOfGeneric(MatchNotOfGeneric&&) = default;            MatchNotOfGeneric& operator=(MatchNotOfGeneric&&) = default;            explicit MatchNotOfGeneric(MatcherT const& matcher) : m_matcher\{matcher\} \{\}            template<typename Arg>            bool match(Arg&& arg) const \{                return !m_matcher.match(arg);            \}            std::string describe() const override \{                return "not " + m_matcher.toString();            \}                        friend MatcherT const& operator ! (MatchNotOfGeneric<MatcherT> const& matcher) \{                return matcher.m_matcher;            \}        \};    \}         template<typename MatcherLHS, typename MatcherRHS>    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherRHS>>        operator && (MatcherLHS const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename MatcherLHS, typename MatcherRHS>    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherRHS>>        operator || (MatcherLHS const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}        template<typename MatcherT>    std::enable_if_t<Detail::is_generic_matcher<MatcherT>::value, Detail::MatchNotOfGeneric<MatcherT>>        operator ! (MatcherT const& matcher) \{        return Detail::MatchNotOfGeneric<MatcherT>\{matcher\};    \}        template<typename MatcherLHS, typename ArgRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>        operator && (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename ArgLHS, typename MatcherRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>        operator && (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename MatcherLHS, typename ArgRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>        operator || (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename ArgLHS, typename MatcherRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>        operator || (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}\} \} #endif namespace Catch \{    namespace Matchers \{        class IsEmptyMatcher final : public MatcherGenericBase \{        public:            template <typename RangeLike>            bool match(RangeLike&& rng) const \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::empty;#else                using std::empty;#endif                return empty(rng);            \}            std::string describe() const override;        \};        class HasSizeMatcher final : public MatcherGenericBase \{            std::size_t m_target_size;        public:            explicit HasSizeMatcher(std::size_t target_size):                m_target_size(target_size)            \{\}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::size;#else                using std::size;#endif                return size(rng) == m_target_size;            \}            std::string describe() const override;        \};        template <typename Matcher>        class SizeMatchesMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            explicit SizeMatchesMatcher(Matcher m):                m_matcher(CATCH_MOVE(m))            \{\}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::size;#else                using std::size;#endif                return m_matcher.match(size(rng));            \}            std::string describe() const override \{                return "size matches " + m_matcher.describe();            \}        \};                IsEmptyMatcher IsEmpty();                HasSizeMatcher SizeIs(std::size_t sz);        template <typename Matcher>        std::enable_if_t<Detail::is_matcher<Matcher>::value,        SizeMatchesMatcher<Matcher>> SizeIs(Matcher&& m) \{            return SizeMatchesMatcher<Matcher>\{CATCH_FORWARD(m)\};        \}    \} \} #endif #ifndef CATCH_MATCHERS_CONTAINS_HPP_INCLUDED#define CATCH_MATCHERS_CONTAINS_HPP_INCLUDED#include <algorithm>#include <functional>namespace Catch \{    namespace Matchers \{                template <typename T, typename Equality>        class ContainsElementMatcher final : public MatcherGenericBase \{            T m_desired;            Equality m_eq;        public:            template <typename T2, typename Equality2>            ContainsElementMatcher(T2&& target, Equality2&& predicate):                m_desired(CATCH_FORWARD(target)),                m_eq(CATCH_FORWARD(predicate))            \{\}            std::string describe() const override \{                return "contains element " + Catch::Detail::stringify(m_desired);            \}            template <typename RangeLike>            bool match( RangeLike&& rng ) const \{                for ( auto&& elem : rng ) \{                    if ( m_eq( elem, m_desired ) ) \{ return true; \}                \}                return false;            \}        \};                template <typename Matcher>        class ContainsMatcherMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:                                                ContainsMatcherMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (m_matcher.match(elem)) \{                        return true;                    \}                \}                return false;            \}            std::string describe() const override \{                return "contains element matching " + m_matcher.describe();            \}        \};                template <typename T>        std::enable_if_t<!Detail::is_matcher<T>::value,        ContainsElementMatcher<T, std::equal_to<>>> Contains(T&& elem) \{            return \{ CATCH_FORWARD(elem), std::equal_to<>\{\} \};        \}                template <typename Matcher>        std::enable_if_t<Detail::is_matcher<Matcher>::value,        ContainsMatcherMatcher<Matcher>> Contains(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}                template <typename T, typename Equality>        ContainsElementMatcher<T, Equality> Contains(T&& elem, Equality&& eq) \{            return \{ CATCH_FORWARD(elem), CATCH_FORWARD(eq) \};        \}    \}\}#endif #ifndef CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED#define CATCH_MATCHERS_EXCEPTION_HPP_INCLUDEDnamespace Catch \{namespace Matchers \{class ExceptionMessageMatcher final : public MatcherBase<std::exception> \{    std::string m_message;public:    ExceptionMessageMatcher(std::string const& message):        m_message(message)    \{\}    bool match(std::exception const& ex) const override;    std::string describe() const override;\};ExceptionMessageMatcher Message(std::string const& message);template <typename StringMatcherType>class ExceptionMessageMatchesMatcher final    : public MatcherBase<std::exception> \{    StringMatcherType m_matcher;public:    ExceptionMessageMatchesMatcher( StringMatcherType matcher ):        m_matcher( CATCH_MOVE( matcher ) ) \{\}    bool match( std::exception const& ex ) const override \{        return m_matcher.match( ex.what() );    \}    std::string describe() const override \{        return " matches \\"" + m_matcher.describe() + '"';    \}\};template <typename StringMatcherType>ExceptionMessageMatchesMatcher<StringMatcherType>MessageMatches( StringMatcherType&& matcher ) \{    return \{ CATCH_FORWARD( matcher ) \};\}\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED#ifndef CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED#define CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDEDnamespace Catch \{namespace Matchers \{    namespace Detail \{        enum class FloatingPointKind : uint8_t;    \}    class  WithinAbsMatcher final : public MatcherBase<double> \{    public:        WithinAbsMatcher(double target, double margin);        bool match(double const& matchee) const override;        std::string describe() const override;    private:        double m_target;        double m_margin;    \};        WithinAbsMatcher WithinAbs( double target, double margin );    class WithinUlpsMatcher final : public MatcherBase<double> \{    public:        WithinUlpsMatcher( double target,                           uint64_t ulps,                           Detail::FloatingPointKind baseType );        bool match(double const& matchee) const override;        std::string describe() const override;    private:        double m_target;        uint64_t m_ulps;        Detail::FloatingPointKind m_type;    \};        WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);        WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);    // Given IEEE-754 format for floats and doubles, we can assume    // that float -> double promotion is lossless. Given this, we can    // assume that if we do the standard relative comparison of    // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get    // the same result if we do this for floats, as if we do this for    // doubles that were promoted from floats.    class WithinRelMatcher final : public MatcherBase<double> \{    public:        WithinRelMatcher( double target, double epsilon );        bool match(double const& matchee) const override;        std::string describe() const override;    private:        double m_target;        double m_epsilon;    \};        WithinRelMatcher WithinRel(double target, double eps);        WithinRelMatcher WithinRel(double target);        WithinRelMatcher WithinRel(float target, float eps);        WithinRelMatcher WithinRel(float target);    class IsNaNMatcher final : public MatcherBase<double> \{    public:        IsNaNMatcher() = default;        bool match( double const& matchee ) const override;        std::string describe() const override;    \};    IsNaNMatcher IsNaN();\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED#ifndef CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#define CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#include <string>namespace Catch \{namespace Matchers \{namespace Detail \{    std::string finalizeDescription(const std::string& desc);\} // namespace Detailtemplate <typename T, typename Predicate>class PredicateMatcher final : public MatcherBase<T> \{    Predicate m_predicate;    std::string m_description;public:    PredicateMatcher(Predicate&& elem, std::string const& descr)        :m_predicate(CATCH_FORWARD(elem)),        m_description(Detail::finalizeDescription(descr))    \{\}    bool match( T const& item ) const override \{        return m_predicate(item);    \}    std::string describe() const override \{        return m_description;    \}\};    /**     * Creates a matcher that calls delegates `match` to the provided predicate.     *     * The user has to explicitly specify the argument type to the matcher     */    template<typename T, typename Pred>    PredicateMatcher<T, Pred> Predicate(Pred&& predicate, std::string const& description = "") \{        static_assert(is_callable<Pred(T)>::value, "Predicate not callable with argument T");        static_assert(std::is_same<bool, FunctionReturnType<Pred, T>>::value, "Predicate does not return bool");        return PredicateMatcher<T, Pred>(CATCH_FORWARD(predicate), description);    \}\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#ifndef CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED#define CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDEDnamespace Catch \{    namespace Matchers \{        // Matcher for checking that all elements in range matches a given matcher.        template <typename Matcher>        class AllMatchMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            AllMatchMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            std::string describe() const override \{                return "all match " + m_matcher.describe();            \}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (!m_matcher.match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range matches a given matcher.        template <typename Matcher>        class NoneMatchMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            NoneMatchMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            std::string describe() const override \{                return "none match " + m_matcher.describe();            \}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (m_matcher.match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that at least one element in range matches a given matcher.        template <typename Matcher>        class AnyMatchMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            AnyMatchMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            std::string describe() const override \{                return "any match " + m_matcher.describe();            \}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (m_matcher.match(elem)) \{                        return true;                    \}                \}                return false;            \}        \};        // Matcher for checking that all elements in range are true.        class AllTrueMatcher final : public MatcherGenericBase \{        public:            std::string describe() const override;            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (!elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range is true.        class NoneTrueMatcher final : public MatcherGenericBase \{        public:            std::string describe() const override;            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that any element in range is true.        class AnyTrueMatcher final : public MatcherGenericBase \{        public:            std::string describe() const override;            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (elem) \{                        return true;                    \}                \}                return false;            \}        \};        // Creates a matcher that checks whether all elements in a range match a matcher        template <typename Matcher>        AllMatchMatcher<Matcher> AllMatch(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}        // Creates a matcher that checks whether no element in a range matches a matcher.        template <typename Matcher>        NoneMatchMatcher<Matcher> NoneMatch(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}        // Creates a matcher that checks whether any element in a range matches a matcher.        template <typename Matcher>        AnyMatchMatcher<Matcher> AnyMatch(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}        // Creates a matcher that checks whether all elements in a range are true        AllTrueMatcher AllTrue();        // Creates a matcher that checks whether no element in a range is true        NoneTrueMatcher NoneTrue();        // Creates a matcher that checks whether any element in a range is true        AnyTrueMatcher AnyTrue();    \}\}#endif // CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED#ifndef CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#define CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#include <algorithm>#include <utility>namespace Catch \{    namespace Matchers \{        /**         * Matcher for checking that an element contains the same         * elements in the same order         */        template <typename TargetRangeLike, typename Equality>        class RangeEqualsMatcher final : public MatcherGenericBase \{            TargetRangeLike m_desired;            Equality m_predicate;        public:            template <typename TargetRangeLike2, typename Equality2>            RangeEqualsMatcher( TargetRangeLike2&& range,                                Equality2&& predicate ):                m_desired( CATCH_FORWARD( range ) ),                m_predicate( CATCH_FORWARD( predicate ) ) \{\}            template <typename RangeLike>            bool match( RangeLike&& rng ) const \{                auto rng_start = begin( rng );                const auto rng_end = end( rng );                auto target_start = begin( m_desired );                const auto target_end = end( m_desired );                while (rng_start != rng_end && target_start != target_end) \{                    if (!m_predicate(*rng_start, *target_start)) \{                        return false;                    \}                    ++rng_start;                    ++target_start;                \}                return rng_start == rng_end && target_start == target_end;            \}            std::string describe() const override \{                return "elements are " + Catch::Detail::stringify( m_desired );            \}        \};        /**         * Matcher for checking that an element contains the same         * elements (but not necessarily in the same order)         */        template <typename TargetRangeLike, typename Equality>        class UnorderedRangeEqualsMatcher final : public MatcherGenericBase \{            TargetRangeLike m_desired;            Equality m_predicate;        public:            template <typename TargetRangeLike2, typename Equality2>            UnorderedRangeEqualsMatcher( TargetRangeLike2&& range,                                         Equality2&& predicate ):                m_desired( CATCH_FORWARD( range ) ),                m_predicate( CATCH_FORWARD( predicate ) ) \{\}            template <typename RangeLike>            bool match( RangeLike&& rng ) const \{                using std::begin;                using std::end;                return Catch::Detail::is_permutation( begin( m_desired ),                                                      end( m_desired ),                                                      begin( rng ),                                                      end( rng ),                                                      m_predicate );            \}            std::string describe() const override \{                return "unordered elements are " +                       ::Catch::Detail::stringify( m_desired );            \}        \};        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range.         *         * Uses `std::equal_to` to do the comparison         */        template <typename RangeLike>        std::enable_if_t<!Detail::is_matcher<RangeLike>::value,                         RangeEqualsMatcher<RangeLike, std::equal_to<>>>        RangeEquals( RangeLike&& range ) \{            return \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};        \}        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range.         *         * Uses to provided predicate `predicate` to do the comparisons         */        template <typename RangeLike, typename Equality>        RangeEqualsMatcher<RangeLike, Equality>        RangeEquals( RangeLike&& range, Equality&& predicate ) \{            return \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};        \}        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range, in some permutation         *         * Uses `std::equal_to` to do the comparison         */        template <typename RangeLike>        std::enable_if_t<            !Detail::is_matcher<RangeLike>::value,            UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>        UnorderedRangeEquals( RangeLike&& range ) \{            return \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};        \}        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range, in some permutation.         *         * Uses to provided predicate `predicate` to do the comparisons         */        template <typename RangeLike, typename Equality>        UnorderedRangeEqualsMatcher<RangeLike, Equality>        UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) \{            return \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};        \}    \} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#ifndef CATCH_MATCHERS_STRING_HPP_INCLUDED#define CATCH_MATCHERS_STRING_HPP_INCLUDED#include <string>namespace Catch \{namespace Matchers \{    struct CasedString \{        CasedString( std::string const& str, CaseSensitive caseSensitivity );        std::string adjustString( std::string const& str ) const;        StringRef caseSensitivitySuffix() const;        CaseSensitive m_caseSensitivity;        std::string m_str;    \};    class StringMatcherBase : public MatcherBase<std::string> \{    protected:        CasedString m_comparator;        StringRef m_operation;    public:        StringMatcherBase( StringRef operation,                           CasedString const& comparator );        std::string describe() const override;    \};    class StringEqualsMatcher final : public StringMatcherBase \{    public:        StringEqualsMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class StringContainsMatcher final : public StringMatcherBase \{    public:        StringContainsMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class StartsWithMatcher final : public StringMatcherBase \{    public:        StartsWithMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class EndsWithMatcher final : public StringMatcherBase \{    public:        EndsWithMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class RegexMatcher final : public MatcherBase<std::string> \{        std::string m_regex;        CaseSensitive m_caseSensitivity;    public:        RegexMatcher( std::string regex, CaseSensitive caseSensitivity );        bool match( std::string const& matchee ) const override;        std::string describe() const override;    \};        StringEqualsMatcher Equals( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        StringContainsMatcher ContainsSubstring( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        EndsWithMatcher EndsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        StartsWithMatcher StartsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        RegexMatcher Matches( std::string const& regex, CaseSensitive caseSensitivity = CaseSensitive::Yes );\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_STRING_HPP_INCLUDED#ifndef CATCH_MATCHERS_VECTOR_HPP_INCLUDED#define CATCH_MATCHERS_VECTOR_HPP_INCLUDED#include <algorithm>namespace Catch \{namespace Matchers \{    template<typename T, typename Alloc>    class VectorContainsElementMatcher final : public MatcherBase<std::vector<T, Alloc>> \{        T const& m_comparator;    public:        VectorContainsElementMatcher(T const& comparator):            m_comparator(comparator)        \{\}        bool match(std::vector<T, Alloc> const& v) const override \{            for (auto const& el : v) \{                if (el == m_comparator) \{                    return true;                \}            \}            return false;        \}        std::string describe() const override \{            return "Contains: " + ::Catch::Detail::stringify( m_comparator );        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class ContainsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_comparator;    public:        ContainsMatcher(std::vector<T, AllocComp> const& comparator):            m_comparator( comparator )        \{\}        bool match(std::vector<T, AllocMatch> const& v) const override \{            // !TBD: see note in EqualsMatcher            if (m_comparator.size() > v.size())                return false;            for (auto const& comparator : m_comparator) \{                auto present = false;                for (const auto& el : v) \{                    if (el == comparator) \{                        present = true;                        break;                    \}                \}                if (!present) \{                    return false;                \}            \}            return true;        \}        std::string describe() const override \{            return "Contains: " + ::Catch::Detail::stringify( m_comparator );        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class EqualsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_comparator;    public:        EqualsMatcher(std::vector<T, AllocComp> const& comparator):            m_comparator( comparator )        \{\}        bool match(std::vector<T, AllocMatch> const& v) const override \{            // !TBD: This currently works if all elements can be compared using !=            // - a more general approach would be via a compare template that defaults            // to using !=. but could be specialised for, e.g. std::vector<T> etc            // - then just call that directly            if ( m_comparator.size() != v.size() ) \{ return false; \}            for ( std::size_t i = 0; i < v.size(); ++i ) \{                if ( !( m_comparator[i] == v[i] ) ) \{ return false; \}            \}            return true;        \}        std::string describe() const override \{            return "Equals: " + ::Catch::Detail::stringify( m_comparator );        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class ApproxMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_comparator;        mutable Catch::Approx approx = Catch::Approx::custom();    public:        ApproxMatcher(std::vector<T, AllocComp> const& comparator):            m_comparator( comparator )        \{\}        bool match(std::vector<T, AllocMatch> const& v) const override \{            if (m_comparator.size() != v.size())                return false;            for (std::size_t i = 0; i < v.size(); ++i)                if (m_comparator[i] != approx(v[i]))                    return false;            return true;        \}        std::string describe() const override \{            return "is approx: " + ::Catch::Detail::stringify( m_comparator );        \}        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>        ApproxMatcher& epsilon( T const& newEpsilon ) \{            approx.epsilon(static_cast<double>(newEpsilon));            return *this;        \}        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>        ApproxMatcher& margin( T const& newMargin ) \{            approx.margin(static_cast<double>(newMargin));            return *this;        \}        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>        ApproxMatcher& scale( T const& newScale ) \{            approx.scale(static_cast<double>(newScale));            return *this;        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class UnorderedEqualsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_target;    public:        UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target):            m_target(target)        \{\}        bool match(std::vector<T, AllocMatch> const& vec) const override \{            if (m_target.size() != vec.size()) \{                return false;            \}            return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());        \}        std::string describe() const override \{            return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);        \}    \};    // The following functions create the actual matcher objects.    // This allows the types to be inferred        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) \{        return ContainsMatcher<T, AllocComp, AllocMatch>(comparator);    \}        template<typename T, typename Alloc = std::allocator<T>>    VectorContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) \{        return VectorContainsElementMatcher<T, Alloc>(comparator);    \}        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) \{        return EqualsMatcher<T, AllocComp, AllocMatch>(comparator);    \}        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) \{        return ApproxMatcher<T, AllocComp, AllocMatch>(comparator);    \}        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) \{        return UnorderedEqualsMatcher<T, AllocComp, AllocMatch>(target);    \}\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_VECTOR_HPP_INCLUDED#endif // CATCH_MATCHERS_ALL_HPP_INCLUDED/** \\file * This is a convenience header for Catch2's Reporter support. It includes * **all** of Catch2 headers related to reporters, including all reporters. * * Generally the Catch2 users should use specific includes they need, * but this header can be used instead for ease-of-experimentation, or * just plain convenience, at the cost of (significantly) increased * compilation times. * * When a new header (reporter) is added to either the `reporter` folder, * or to the corresponding internal subfolder, it should be added here. */#ifndef CATCH_REPORTERS_ALL_HPP_INCLUDED#define CATCH_REPORTERS_ALL_HPP_INCLUDED#ifndef CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#define CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#ifndef CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#define CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#ifndef CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#define CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#include <map>#include <string>namespace Catch \{    class ColourImpl;    /**     * This is the base class for all reporters.     *     * If are writing a reporter, you must derive from this type, or one     * of the helper reporter bases that are derived from this type.     *     * ReporterBase centralizes handling of various common tasks in reporters,     * like storing the right stream for the reporters to write to, and     * providing the default implementation of the different listing events.     */    class ReporterBase : public IEventListener \{    protected:                Detail::unique_ptr<IStream> m_wrapped_stream;                        std::ostream& m_stream;                Detail::unique_ptr<ColourImpl> m_colour;                std::map<std::string, std::string> m_customOptions;    public:        ReporterBase( ReporterConfig&& config );        ~ReporterBase() override; // = default;        /**         * Provides a simple default listing of reporters.         *         * Should look roughly like the reporter listing in v2 and earlier         * versions of Catch2.         */        void listReporters(            std::vector<ReporterDescription> const& descriptions ) override;        /**         * Provides a simple default listing of listeners         *         * Looks similarly to listing of reporters, but with listener type         * instead of reporter name.         */        void listListeners(            std::vector<ListenerDescription> const& descriptions ) override;        /**         * Provides a simple default listing of tests.         *         * Should look roughly like the test listing in v2 and earlier versions         * of Catch2. Especially supports low-verbosity listing that mimics the         * old `--list-test-names-only` output.         */        void listTests( std::vector<TestCaseHandle> const& tests ) override;        /**         * Provides a simple default listing of tags.         *         * Should look roughly like the tag listing in v2 and earlier versions         * of Catch2.         */        void listTags( std::vector<TagInfo> const& tags ) override;    \};\} // namespace Catch#endif // CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#include <vector>namespace Catch \{    class StreamingReporterBase : public ReporterBase \{    public:        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        StreamingReporterBase(ReporterConfig&& _config):            ReporterBase(CATCH_MOVE(_config))        \{\}        ~StreamingReporterBase() override;        void benchmarkPreparing( StringRef ) override \{\}        void benchmarkStarting( BenchmarkInfo const& ) override \{\}        void benchmarkEnded( BenchmarkStats<> const& ) override \{\}        void benchmarkFailed( StringRef ) override \{\}        void fatalErrorEncountered( StringRef /*error*/ ) override \{\}        void noMatchingTestCases( StringRef /*unmatchedSpec*/ ) override \{\}        void reportInvalidTestSpec( StringRef /*invalidArgument*/ ) override \{\}        void testRunStarting( TestRunInfo const& _testRunInfo ) override;        void testCaseStarting(TestCaseInfo const& _testInfo) override  \{            currentTestCaseInfo = &_testInfo;        \}        void testCasePartialStarting( TestCaseInfo const&, uint64_t ) override \{\}        void sectionStarting(SectionInfo const& _sectionInfo) override \{            m_sectionStack.push_back(_sectionInfo);        \}        void assertionStarting( AssertionInfo const& ) override \{\}        void assertionEnded( AssertionStats const& ) override \{\}        void sectionEnded(SectionStats const& /* _sectionStats */) override \{            m_sectionStack.pop_back();        \}        void testCasePartialEnded( TestCaseStats const&, uint64_t ) override \{\}        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override \{            currentTestCaseInfo = nullptr;        \}        void testRunEnded( TestRunStats const& /* _testRunStats */ ) override;        void skipTest(TestCaseInfo const&) override \{            // Don't do anything with this by default.            // It can optionally be overridden in the derived class.        \}    protected:        TestRunInfo currentTestRunInfo\{ "test run has not started yet"_sr \};        TestCaseInfo const* currentTestCaseInfo = nullptr;                std::vector<SectionInfo> m_sectionStack;    \};\} // end namespace Catch#endif // CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#include <string>namespace Catch \{    class AutomakeReporter final : public StreamingReporterBase \{    public:        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        AutomakeReporter(ReporterConfig&& _config):            StreamingReporterBase(CATCH_MOVE(_config))        \{\}        ~AutomakeReporter() override;        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results in the format of Automake .trs files"s;        \}        void testCaseEnded(TestCaseStats const& _testCaseStats) override;        void skipTest(TestCaseInfo const& testInfo) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#ifndef CATCH_REPORTER_COMPACT_HPP_INCLUDED#define CATCH_REPORTER_COMPACT_HPP_INCLUDEDnamespace Catch \{    class CompactReporter final : public StreamingReporterBase \{    public:        using StreamingReporterBase::StreamingReporterBase;        ~CompactReporter() override;        static std::string getDescription();        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void testRunStarting( TestRunInfo const& _testInfo ) override;        void assertionEnded(AssertionStats const& _assertionStats) override;        void sectionEnded(SectionStats const& _sectionStats) override;        void testRunEnded(TestRunStats const& _testRunStats) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_COMPACT_HPP_INCLUDED#ifndef CATCH_REPORTER_CONSOLE_HPP_INCLUDED#define CATCH_REPORTER_CONSOLE_HPP_INCLUDEDnamespace Catch \{    // Fwd decls    class TablePrinter;    class ConsoleReporter final : public StreamingReporterBase \{        Detail::unique_ptr<TablePrinter> m_tablePrinter;    public:        ConsoleReporter(ReporterConfig&& config);        ~ConsoleReporter() override;        static std::string getDescription();        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void reportInvalidTestSpec( StringRef arg ) override;        void assertionStarting(AssertionInfo const&) override;        void assertionEnded(AssertionStats const& _assertionStats) override;        void sectionStarting(SectionInfo const& _sectionInfo) override;        void sectionEnded(SectionStats const& _sectionStats) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting(BenchmarkInfo const& info) override;        void benchmarkEnded(BenchmarkStats<> const& stats) override;        void benchmarkFailed( StringRef error ) override;        void testCaseEnded(TestCaseStats const& _testCaseStats) override;        void testRunEnded(TestRunStats const& _testRunStats) override;        void testRunStarting(TestRunInfo const& _testRunInfo) override;    private:        void lazyPrint();        void lazyPrintWithoutClosingBenchmarkTable();        void lazyPrintRunInfo();        void printTestCaseAndSectionHeader();        void printClosedHeader(std::string const& _name);        void printOpenHeader(std::string const& _name);        // if string has a : in first line will set indent to follow it on        // subsequent lines        void printHeaderString(std::string const& _string, std::size_t indent = 0);        void printTotalsDivider(Totals const& totals);        bool m_headerPrinted = false;        bool m_testRunInfoPrinted = false;    \};\} // end namespace Catch#endif // CATCH_REPORTER_CONSOLE_HPP_INCLUDED#ifndef CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#define CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#include <string>#include <vector>namespace Catch \{    namespace Detail \{                class AssertionOrBenchmarkResult \{            // This should really be a variant, but this is much faster            // to write and the data layout here is already terrible            // enough that we do not have to care about the object size.            Optional<AssertionStats> m_assertion;            Optional<BenchmarkStats<>> m_benchmark;        public:            AssertionOrBenchmarkResult(AssertionStats const& assertion);            AssertionOrBenchmarkResult(BenchmarkStats<> const& benchmark);            bool isAssertion() const;            bool isBenchmark() const;            AssertionStats const& asAssertion() const;            BenchmarkStats<> const& asBenchmark() const;        \};    \}    /**     * Utility base for reporters that need to handle all results at once     *     * It stores tree of all test cases, sections and assertions, and after the     * test run is finished, calls into `testRunEndedCumulative` to pass the     * control to the deriving class.     *     * If you are deriving from this class and override any testing related     * member functions, you should first call into the base's implementation to     * avoid breaking the tree construction.     *     * Due to the way this base functions, it has to expand assertions up-front,     * even if they are later unused (e.g. because the deriving reporter does     * not report successful assertions, or because the deriving reporter does     * not use assertion expansion at all). Derived classes can use two     * customization points, `m_shouldStoreSuccesfulAssertions` and     * `m_shouldStoreFailedAssertions`, to disable the expansion and gain extra     * performance. **Accessing the assertion expansions if it wasn't stored is     * UB.**     */    class CumulativeReporterBase : public ReporterBase \{    public:        template<typename T, typename ChildNodeT>        struct Node \{            explicit Node( T const& _value ) : value( _value ) \{\}            using ChildNodes = std::vector<Detail::unique_ptr<ChildNodeT>>;            T value;            ChildNodes children;        \};        struct SectionNode \{            explicit SectionNode(SectionStats const& _stats) : stats(_stats) \{\}            bool operator == (SectionNode const& other) const \{                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;            \}            bool hasAnyAssertions() const;            SectionStats stats;            std::vector<Detail::unique_ptr<SectionNode>> childSections;            std::vector<Detail::AssertionOrBenchmarkResult> assertionsAndBenchmarks;            std::string stdOut;            std::string stdErr;        \};        using TestCaseNode = Node<TestCaseStats, SectionNode>;        using TestRunNode = Node<TestRunStats, TestCaseNode>;        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        CumulativeReporterBase(ReporterConfig&& _config):            ReporterBase(CATCH_MOVE(_config))        \{\}        ~CumulativeReporterBase() override;        void benchmarkPreparing( StringRef ) override \{\}        void benchmarkStarting( BenchmarkInfo const& ) override \{\}        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;        void benchmarkFailed( StringRef ) override \{\}        void noMatchingTestCases( StringRef ) override \{\}        void reportInvalidTestSpec( StringRef ) override \{\}        void fatalErrorEncountered( StringRef /*error*/ ) override \{\}        void testRunStarting( TestRunInfo const& ) override \{\}        void testCaseStarting( TestCaseInfo const& ) override \{\}        void testCasePartialStarting( TestCaseInfo const&, uint64_t ) override \{\}        void sectionStarting( SectionInfo const& sectionInfo ) override;        void assertionStarting( AssertionInfo const& ) override \{\}        void assertionEnded( AssertionStats const& assertionStats ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void testCasePartialEnded( TestCaseStats const&, uint64_t ) override \{\}        void testCaseEnded( TestCaseStats const& testCaseStats ) override;        void testRunEnded( TestRunStats const& testRunStats ) override;                virtual void testRunEndedCumulative() = 0;        void skipTest(TestCaseInfo const&) override \{\}    protected:                bool m_shouldStoreSuccesfulAssertions = true;                bool m_shouldStoreFailedAssertions = true;        // We need lazy construction here. We should probably refactor it        // later, after the events are redone.                Detail::unique_ptr<TestRunNode> m_testRun;    private:        // Note: We rely on pointer identity being stable, which is why        //       we store pointers to the nodes rather than the values.        std::vector<Detail::unique_ptr<TestCaseNode>> m_testCases;        // Root section of the _current_ test case        Detail::unique_ptr<SectionNode> m_rootSection;        // Deepest section of the _current_ test case        SectionNode* m_deepestSection = nullptr;        // Stack of _active_ sections in the _current_ test case        std::vector<SectionNode*> m_sectionStack;    \};\} // end namespace Catch#endif // CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#ifndef CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED#define CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDEDnamespace Catch \{    /**     * Base class to simplify implementing listeners.     *     * Provides empty default implementation for all IEventListener member     * functions, so that a listener implementation can pick which     * member functions it actually cares about.     */    class EventListenerBase : public IEventListener \{    public:        using IEventListener::IEventListener;        void reportInvalidTestSpec( StringRef unmatchedSpec ) override;        void fatalErrorEncountered( StringRef error ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;        void benchmarkFailed( StringRef error ) override;        void assertionStarting( AssertionInfo const& assertionInfo ) override;        void assertionEnded( AssertionStats const& assertionStats ) override;        void listReporters(            std::vector<ReporterDescription> const& descriptions ) override;        void listListeners(            std::vector<ListenerDescription> const& descriptions ) override;        void listTests( std::vector<TestCaseHandle> const& tests ) override;        void listTags( std::vector<TagInfo> const& tagInfos ) override;        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void testRunStarting( TestRunInfo const& testRunInfo ) override;        void testCaseStarting( TestCaseInfo const& testInfo ) override;        void testCasePartialStarting( TestCaseInfo const& testInfo,                                      uint64_t partNumber ) override;        void sectionStarting( SectionInfo const& sectionInfo ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void testCasePartialEnded( TestCaseStats const& testCaseStats,                                   uint64_t partNumber ) override;        void testCaseEnded( TestCaseStats const& testCaseStats ) override;        void testRunEnded( TestRunStats const& testRunStats ) override;        void skipTest( TestCaseInfo const& testInfo ) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED#ifndef CATCH_REPORTER_HELPERS_HPP_INCLUDED#define CATCH_REPORTER_HELPERS_HPP_INCLUDED#include <iosfwd>#include <string>#include <vector>namespace Catch \{    class IConfig;    class TestCaseHandle;    class ColourImpl;    // Returns double formatted as %.3f (format expected on output)    std::string getFormattedDuration( double duration );        bool shouldShowDuration( IConfig const& config, double duration );    std::string serializeFilters( std::vector<std::string> const& filters );    struct lineOfChars \{        char c;        constexpr lineOfChars( char c_ ): c( c_ ) \{\}        friend std::ostream& operator<<( std::ostream& out, lineOfChars value );    \};    /**     * Lists reporter descriptions to the provided stream in user-friendly     * format     *     * Used as the default listing implementation by the first party reporter     * bases. The output should be backwards compatible with the output of     * Catch2 v2 binaries.     */    void    defaultListReporters( std::ostream& out,                          std::vector<ReporterDescription> const& descriptions,                          Verbosity verbosity );    /**     * Lists listeners descriptions to the provided stream in user-friendly     * format     */    void defaultListListeners( std::ostream& out,                               std::vector<ListenerDescription> const& descriptions );    /**     * Lists tag information to the provided stream in user-friendly format     *     * Used as the default listing implementation by the first party reporter     * bases. The output should be backwards compatible with the output of     * Catch2 v2 binaries.     */    void defaultListTags( std::ostream& out, std::vector<TagInfo> const& tags, bool isFiltered );    /**     * Lists test case information to the provided stream in user-friendly     * format     *     * Used as the default listing implementation by the first party reporter     * bases. The output is backwards compatible with the output of Catch2     * v2 binaries, and also supports the format specific to the old     * `--list-test-names-only` option, for people who used it in integrations.     */    void defaultListTests( std::ostream& out,                           ColourImpl* streamColour,                           std::vector<TestCaseHandle> const& tests,                           bool isFiltered,                           Verbosity verbosity );    /**     * Prints test run totals to the provided stream in user-friendly format     *     * Used by the console and compact reporters.     */    void printTestRunTotals( std::ostream& stream,                      ColourImpl& streamColour,                      Totals const& totals );\} // end namespace Catch#endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED#ifndef CATCH_REPORTER_JSON_HPP_INCLUDED#define CATCH_REPORTER_JSON_HPP_INCLUDED#include <stack>namespace Catch \{    class JsonReporter : public StreamingReporterBase \{    public:        JsonReporter( ReporterConfig&& config );        ~JsonReporter() override;        static std::string getDescription();    public: // StreamingReporterBase        void testRunStarting( TestRunInfo const& runInfo ) override;        void testRunEnded( TestRunStats const& runStats ) override;        void testCaseStarting( TestCaseInfo const& tcInfo ) override;        void testCaseEnded( TestCaseStats const& tcStats ) override;        void testCasePartialStarting( TestCaseInfo const& tcInfo,                                      uint64_t index ) override;        void testCasePartialEnded( TestCaseStats const& tcStats,                                   uint64_t index ) override;        void sectionStarting( SectionInfo const& sectionInfo ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void assertionStarting( AssertionInfo const& assertionInfo ) override;        void assertionEnded( AssertionStats const& assertionStats ) override;        //void testRunEndedCumulative() override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& ) override;        void benchmarkEnded( BenchmarkStats<> const& ) override;        void benchmarkFailed( StringRef error ) override;        void listReporters(            std::vector<ReporterDescription> const& descriptions ) override;        void listListeners(            std::vector<ListenerDescription> const& descriptions ) override;        void listTests( std::vector<TestCaseHandle> const& tests ) override;        void listTags( std::vector<TagInfo> const& tags ) override;    private:        Timer m_testCaseTimer;        enum class Writer \{            Object,            Array        \};        JsonArrayWriter& startArray();        JsonArrayWriter& startArray( StringRef key );        JsonObjectWriter& startObject();        JsonObjectWriter& startObject( StringRef key );        void endObject();        void endArray();        bool isInside( Writer writer );        void startListing();        void endListing();        // Invariant:        // When m_writers is not empty and its top element is        // - Writer::Object, then m_objectWriters is not be empty        // - Writer::Array,  then m_arrayWriters shall not be empty        std::stack<JsonObjectWriter> m_objectWriters\{\};        std::stack<JsonArrayWriter> m_arrayWriters\{\};        std::stack<Writer> m_writers\{\};        bool m_startedListing = false;        // std::size_t m_sectionDepth = 0;        // std::size_t m_sectionStarted = 0;    \};\} // namespace Catch#endif // CATCH_REPORTER_JSON_HPP_INCLUDED#ifndef CATCH_REPORTER_JUNIT_HPP_INCLUDED#define CATCH_REPORTER_JUNIT_HPP_INCLUDEDnamespace Catch \{    class JunitReporter final : public CumulativeReporterBase \{    public:        JunitReporter(ReporterConfig&& _config);        static std::string getDescription();        void testRunStarting(TestRunInfo const& runInfo) override;        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;        void assertionEnded(AssertionStats const& assertionStats) override;        void testCaseEnded(TestCaseStats const& testCaseStats) override;        void testRunEndedCumulative() override;    private:        void writeRun(TestRunNode const& testRunNode, double suiteTime);        void writeTestCase(TestCaseNode const& testCaseNode);        void writeSection( std::string const& className,                           std::string const& rootName,                           SectionNode const& sectionNode,                           bool testOkToFail );        void writeAssertions(SectionNode const& sectionNode);        void writeAssertion(AssertionStats const& stats);        XmlWriter xml;        Timer suiteTimer;        std::string stdOutForSuite;        std::string stdErrForSuite;        unsigned int unexpectedExceptions = 0;        bool m_okToFail = false;    \};\} // end namespace Catch#endif // CATCH_REPORTER_JUNIT_HPP_INCLUDED#ifndef CATCH_REPORTER_MULTI_HPP_INCLUDED#define CATCH_REPORTER_MULTI_HPP_INCLUDEDnamespace Catch \{    class MultiReporter final : public IEventListener \{        /*         * Stores all added reporters and listeners         *         * All Listeners are stored before all reporters, and individual         * listeners/reporters are stored in order of insertion.         */        std::vector<IEventListenerPtr> m_reporterLikes;        bool m_haveNoncapturingReporters = false;        // Keep track of how many listeners we have already inserted,        // so that we can insert them into the main vector at the right place        size_t m_insertedListeners = 0;        void updatePreferences(IEventListener const& reporterish);    public:        using IEventListener::IEventListener;        void addListener( IEventListenerPtr&& listener );        void addReporter( IEventListenerPtr&& reporter );    public: // IEventListener        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void fatalErrorEncountered( StringRef error ) override;        void reportInvalidTestSpec( StringRef arg ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;        void benchmarkFailed( StringRef error ) override;        void testRunStarting( TestRunInfo const& testRunInfo ) override;        void testCaseStarting( TestCaseInfo const& testInfo ) override;        void testCasePartialStarting(TestCaseInfo const& testInfo, uint64_t partNumber) override;        void sectionStarting( SectionInfo const& sectionInfo ) override;        void assertionStarting( AssertionInfo const& assertionInfo ) override;        void assertionEnded( AssertionStats const& assertionStats ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void testCasePartialEnded(TestCaseStats const& testStats, uint64_t partNumber) override;        void testCaseEnded( TestCaseStats const& testCaseStats ) override;        void testRunEnded( TestRunStats const& testRunStats ) override;        void skipTest( TestCaseInfo const& testInfo ) override;        void listReporters(std::vector<ReporterDescription> const& descriptions) override;        void listListeners(std::vector<ListenerDescription> const& descriptions) override;        void listTests(std::vector<TestCaseHandle> const& tests) override;        void listTags(std::vector<TagInfo> const& tags) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_MULTI_HPP_INCLUDED#ifndef CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#include <type_traits>namespace Catch \{    namespace Detail \{        template <typename T, typename = void>        struct has_description : std::false_type \{\};        template <typename T>        struct has_description<            T,            void_t<decltype( T::getDescription() )>>            : std::true_type \{\};                        void registerReporterImpl( std::string const& name,                                   IReporterFactoryPtr reporterPtr );                void registerListenerImpl( Detail::unique_ptr<EventListenerFactory> listenerFactory );    \} // namespace Detail    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;    template <typename T>    class ReporterFactory : public IReporterFactory \{        IEventListenerPtr create( ReporterConfig&& config ) const override \{            return Detail::make_unique<T>( CATCH_MOVE(config) );        \}        std::string getDescription() const override \{            return T::getDescription();        \}    \};    template<typename T>    class ReporterRegistrar \{    public:        explicit ReporterRegistrar( std::string const& name ) \{            registerReporterImpl( name,                                  Detail::make_unique<ReporterFactory<T>>() );        \}    \};    template<typename T>    class ListenerRegistrar \{        class TypedListenerFactory : public EventListenerFactory \{            StringRef m_listenerName;            std::string getDescriptionImpl( std::true_type ) const \{                return T::getDescription();            \}            std::string getDescriptionImpl( std::false_type ) const \{                return "(No description provided)";            \}        public:            TypedListenerFactory( StringRef listenerName ):                m_listenerName( listenerName ) \{\}            IEventListenerPtr create( IConfig const* config ) const override \{                return Detail::make_unique<T>( config );            \}            StringRef getName() const override \{                return m_listenerName;            \}            std::string getDescription() const override \{                return getDescriptionImpl( Detail::has_description<T>\{\} );            \}        \};    public:        ListenerRegistrar(StringRef listenerName) \{            registerListenerImpl( Detail::make_unique<TypedListenerFactory>(listenerName) );        \}    \};\}#if !defined(CATCH_CONFIG_DISABLE)#    define CATCH_REGISTER_REPORTER( name, reporterType )                      \\        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\        namespace \{                                                            \\            Catch::ReporterRegistrar<reporterType> INTERNAL_CATCH_UNIQUE_NAME( \\                catch_internal_RegistrarFor )( name );                         \\        \}                                                                      \\        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION#    define CATCH_REGISTER_LISTENER( listenerType )                            \\        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\        namespace \{                                                            \\            Catch::ListenerRegistrar<listenerType> INTERNAL_CATCH_UNIQUE_NAME( \\                catch_internal_RegistrarFor )( #listenerType##_catch_sr );     \\        \}                                                                      \\        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION#else // CATCH_CONFIG_DISABLE#define CATCH_REGISTER_REPORTER(name, reporterType)#define CATCH_REGISTER_LISTENER(listenerType)#endif // CATCH_CONFIG_DISABLE#endif // CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#ifndef CATCH_REPORTER_SONARQUBE_HPP_INCLUDED#define CATCH_REPORTER_SONARQUBE_HPP_INCLUDEDnamespace Catch \{    class SonarQubeReporter final : public CumulativeReporterBase \{    public:        SonarQubeReporter(ReporterConfig&& config)        : CumulativeReporterBase(CATCH_MOVE(config))        , xml(m_stream) \{            m_preferences.shouldRedirectStdOut = true;            m_preferences.shouldReportAllAssertions = true;            m_shouldStoreSuccesfulAssertions = false;        \}        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results in the Generic Test Data SonarQube XML format"s;        \}        void testRunStarting( TestRunInfo const& testRunInfo ) override;        void testRunEndedCumulative() override \{            writeRun( *m_testRun );            xml.endElement();        \}        void writeRun( TestRunNode const& runNode );        void writeTestFile(StringRef filename, std::vector<TestCaseNode const*> const& testCaseNodes);        void writeTestCase(TestCaseNode const& testCaseNode);        void writeSection(std::string const& rootName, SectionNode const& sectionNode, bool okToFail);        void writeAssertions(SectionNode const& sectionNode, bool okToFail);        void writeAssertion(AssertionStats const& stats, bool okToFail);    private:        XmlWriter xml;    \};\} // end namespace Catch#endif // CATCH_REPORTER_SONARQUBE_HPP_INCLUDED#ifndef CATCH_REPORTER_TAP_HPP_INCLUDED#define CATCH_REPORTER_TAP_HPP_INCLUDEDnamespace Catch \{    class TAPReporter final : public StreamingReporterBase \{    public:        TAPReporter( ReporterConfig&& config ):            StreamingReporterBase( CATCH_MOVE(config) ) \{            m_preferences.shouldReportAllAssertions = true;        \}        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results in TAP format, suitable for test harnesses"s;        \}        void testRunStarting( TestRunInfo const& testInfo ) override;        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void assertionEnded(AssertionStats const& _assertionStats) override;        void testRunEnded(TestRunStats const& _testRunStats) override;    private:        std::size_t counter = 0;    \};\} // end namespace Catch#endif // CATCH_REPORTER_TAP_HPP_INCLUDED#ifndef CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#define CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#include <cstring>#ifdef __clang__#   pragma clang diagnostic push#   pragma clang diagnostic ignored "-Wpadded"#endifnamespace Catch \{    class TeamCityReporter final : public StreamingReporterBase \{    public:        TeamCityReporter( ReporterConfig&& _config )        :   StreamingReporterBase( CATCH_MOVE(_config) )        \{            m_preferences.shouldRedirectStdOut = true;        \}        ~TeamCityReporter() override;        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results as TeamCity service messages"s;        \}        void testRunStarting( TestRunInfo const& runInfo ) override;        void testRunEnded( TestRunStats const& runStats ) override;        void assertionEnded(AssertionStats const& assertionStats) override;        void sectionStarting(SectionInfo const& sectionInfo) override \{            m_headerPrintedForThisSection = false;            StreamingReporterBase::sectionStarting( sectionInfo );        \}        void testCaseStarting(TestCaseInfo const& testInfo) override;        void testCaseEnded(TestCaseStats const& testCaseStats) override;    private:        void printSectionHeader(std::ostream& os);        bool m_headerPrintedForThisSection = false;        Timer m_testTimer;    \};\} // end namespace Catch#ifdef __clang__#   pragma clang diagnostic pop#endif#endif // CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#ifndef CATCH_REPORTER_XML_HPP_INCLUDED#define CATCH_REPORTER_XML_HPP_INCLUDEDnamespace Catch \{    class XmlReporter : public StreamingReporterBase \{    public:        XmlReporter(ReporterConfig&& _config);        ~XmlReporter() override;        static std::string getDescription();        virtual std::string getStylesheetRef() const;        void writeSourceInfo(SourceLineInfo const& sourceInfo);    public: // StreamingReporterBase        void testRunStarting(TestRunInfo const& testInfo) override;        void testCaseStarting(TestCaseInfo const& testInfo) override;        void sectionStarting(SectionInfo const& sectionInfo) override;        void assertionStarting(AssertionInfo const&) override;        void assertionEnded(AssertionStats const& assertionStats) override;        void sectionEnded(SectionStats const& sectionStats) override;        void testCaseEnded(TestCaseStats const& testCaseStats) override;        void testRunEnded(TestRunStats const& testRunStats) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting(BenchmarkInfo const&) override;        void benchmarkEnded(BenchmarkStats<> const&) override;        void benchmarkFailed( StringRef error ) override;        void listReporters(std::vector<ReporterDescription> const& descriptions) override;        void listListeners(std::vector<ListenerDescription> const& descriptions) override;        void listTests(std::vector<TestCaseHandle> const& tests) override;        void listTags(std::vector<TagInfo> const& tags) override;    private:        Timer m_testCaseTimer;        XmlWriter m_xml;        int m_sectionDepth = 0;    \};\} // end namespace Catch#endif // CATCH_REPORTER_XML_HPP_INCLUDED#endif // CATCH_REPORTERS_ALL_HPP_INCLUDED#endif // CATCH_ALL_HPP_INCLUDED#endif // CATCH_AMALGAMATED_HPP_INCLUDED#ifndef CATCH_WINDOWS_H_PROXY_HPP_INCLUDED#define CATCH_WINDOWS_H_PROXY_HPP_INCLUDED#if defined(CATCH_PLATFORM_WINDOWS)// We might end up with the define made globally through the compiler,// and we don't want to trigger warnings for this#if !defined(NOMINMAX)#  define NOMINMAX#endif#if !defined(WIN32_LEAN_AND_MEAN)#  define WIN32_LEAN_AND_MEAN#endif#include <windows.h>#endif // defined(CATCH_PLATFORM_WINDOWS)#endif // CATCH_WINDOWS_H_PROXY_HPP_INCLUDEDnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            ChronometerConcept::~ChronometerConcept() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.#include <vector>namespace Catch \{    namespace Benchmark \{        namespace Detail \{            SampleAnalysis analyse(const IConfig &cfg, FDuration* first, FDuration* last) \{                if (!cfg.benchmarkNoAnalysis()) \{                    std::vector<double> samples;                    samples.reserve(static_cast<size_t>(last - first));                    for (auto current = first; current != last; ++current) \{                        samples.push_back( current->count() );                    \}                    auto analysis = Catch::Benchmark::Detail::analyse_samples(                        cfg.benchmarkConfidenceInterval(),                        cfg.benchmarkResamples(),                        samples.data(),                        samples.data() + samples.size() );                    auto outliers = Catch::Benchmark::Detail::classify_outliers(                        samples.data(), samples.data() + samples.size() );                    auto wrap_estimate = [](Estimate<double> e) \{                        return Estimate<FDuration> \{                            FDuration(e.point),                                FDuration(e.lower_bound),                                FDuration(e.upper_bound),                                e.confidence_interval,                        \};                    \};                    std::vector<FDuration> samples2;                    samples2.reserve(samples.size());                    for (auto s : samples) \{                        samples2.push_back( FDuration( s ) );                    \}                    return \{                        CATCH_MOVE(samples2),                        wrap_estimate(analysis.mean),                        wrap_estimate(analysis.standard_deviation),                        outliers,                        analysis.outlier_variance,                    \};                \} else \{                    std::vector<FDuration> samples;                    samples.reserve(static_cast<size_t>(last - first));                    FDuration mean = FDuration(0);                    int i = 0;                    for (auto it = first; it < last; ++it, ++i) \{                        samples.push_back(*it);                        mean += *it;                    \}                    mean /= i;                    return SampleAnalysis\{                        CATCH_MOVE(samples),                        Estimate<FDuration>\{ mean, mean, mean, 0.0 \},                        Estimate<FDuration>\{ FDuration( 0 ),                                             FDuration( 0 ),                                             FDuration( 0 ),                                             0.0 \},                        OutlierClassification\{\},                        0.0                    \};                \}            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catchnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            BenchmarkFunction::callable::~callable() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch#include <exception>namespace Catch \{    namespace Benchmark \{        namespace Detail \{            struct optimized_away_error : std::exception \{                const char* what() const noexcept override;            \};            const char* optimized_away_error::what() const noexcept \{                return "could not measure benchmark, maybe it was optimized away";            \}            void throw_optimized_away_error() \{                Catch::throw_exception(optimized_away_error\{\});            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.#include <algorithm>#include <cassert>#include <cmath>#include <cstddef>#include <numeric>#include <random>#if defined(CATCH_CONFIG_USE_ASYNC)#include <future>#endifnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            namespace \{                template <typename URng, typename Estimator>                static sample                resample( URng& rng,                          unsigned int resamples,                          double const* first,                          double const* last,                          Estimator& estimator ) \{                    auto n = static_cast<size_t>( last - first );                    Catch::uniform_integer_distribution<size_t> dist( 0, n - 1 );                    sample out;                    out.reserve( resamples );                    std::vector<double> resampled;                    resampled.reserve( n );                    for ( size_t i = 0; i < resamples; ++i ) \{                        resampled.clear();                        for ( size_t s = 0; s < n; ++s ) \{                            resampled.push_back( first[dist( rng )] );                        \}                        const auto estimate =                            estimator( resampled.data(), resampled.data() + resampled.size() );                        out.push_back( estimate );                    \}                    std::sort( out.begin(), out.end() );                    return out;                \}                static double outlier_variance( Estimate<double> mean,                                                Estimate<double> stddev,                                                int n ) \{                    double sb = stddev.point;                    double mn = mean.point / n;                    double mg_min = mn / 2.;                    double sg = (std::min)( mg_min / 4., sb / std::sqrt( n ) );                    double sg2 = sg * sg;                    double sb2 = sb * sb;                    auto c_max = [n, mn, sb2, sg2]( double x ) -> double \{                        double k = mn - x;                        double d = k * k;                        double nd = n * d;                        double k0 = -n * nd;                        double k1 = sb2 - n * sg2 + nd;                        double det = k1 * k1 - 4 * sg2 * k0;                        return static_cast<int>( -2. * k0 /                                                 ( k1 + std::sqrt( det ) ) );                    \};                    auto var_out = [n, sb2, sg2]( double c ) \{                        double nc = n - c;                        return ( nc / n ) * ( sb2 - nc * sg2 );                    \};                    return (std::min)( var_out( 1 ),                                       var_out(                                           (std::min)( c_max( 0. ),                                                       c_max( mg_min ) ) ) ) /                           sb2;                \}                static double erf_inv( double x ) \{                    // Code accompanying the article "Approximating the erfinv}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v if\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:if}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b else} if ()}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 249                                         \{\par
250                         w = w - 3.125000;\par
251                         p = -3.6444120640178196996e-21;\par
252                         p = -1.685059138182016589e-19 + p * w;\par
253                         p = 1.2858480715256400167e-18 + p * w;\par
254                         p = 1.115787767802518096e-17 + p * w;\par
255                         p = -1.333171662854620906e-16 + p * w;\par
256                         p = 2.0972767875968561637e-17 + p * w;\par
257                         p = 6.6376381343583238325e-15 + p * w;\par
258                         p = -4.0545662729752068639e-14 + p * w;\par
259                         p = -8.1519341976054721522e-14 + p * w;\par
260                         p = 2.6335093153082322977e-12 + p * w;\par
261                         p = -1.2975133253453532498e-11 + p * w;\par
262                         p = -5.4154120542946279317e-11 + p * w;\par
263                         p = 1.051212273321532285e-09 + p * w;\par
264                         p = -4.1126339803469836976e-09 + p * w;\par
265                         p = -2.9070369957882005086e-08 + p * w;\par
266                         p = 4.2347877827932403518e-07 + p * w;\par
267                         p = -1.3654692000834678645e-06 + p * w;\par
268                         p = -1.3882523362786468719e-05 + p * w;\par
269                         p = 0.0001867342080340571352 + p * w;\par
270                         p = -0.00074070253416626697512 + p * w;\par
271                         p = -0.0060336708714301490533 + p * w;\par
272                         p = 0.24015818242558961693 + p * w;\par
273                         p = 1.6536545626831027356 + p * w;\par
274                     \} {\cf19 else} {\cf19 if} ( w < 16.000000 ) \{\par
}
}
{\xe \v main\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char * argv[])}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4776                                    \{\par
4777 {\cf21 #endif}\par
4778 \par
4779     {\cf20 // We want to force the linker not to discard the global variable}\par
4780     {\cf20 // and its constructor, as it (optionally) registers leak detector}\par
4781     (void)&Catch::leakDetector;\par
4782 \par
4783     {\cf19 return} Catch::Session().run( argc, argv );\par
4784 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 
{\xe \v else\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
else}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor inicial:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
                        w = sqrt( w ) - 5.000000\par
}
}
{\xe \v key\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringRef key}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_generator\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:m_generator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GeneratorBasePtr m_generator}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v p\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
p = -2.7109920616438573243e-11}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardCount\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:shardCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int shardCount}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardFilePath\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:shardFilePath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string shardFilePath}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardIndex\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:shardIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int shardIndex}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringRef value}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v w\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:w}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
w = -log( ( 1.0 - {\b x} ) * ( 1.0 + {\b x} ) )}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v x\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
return {\b p}* x}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
catch_amalgamated.cpp\par \pard\plain 
{\tc\tcl2 \v test/catch_amalgamated.cpp}
{\xe \v test/catch_amalgamated.cpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //              Copyright Catch2 Authors}\par
3 {\cf20 // Distributed under the Boost Software License, Version 1.0.}\par
4 {\cf20 //   (See accompanying file LICENSE.txt or copy at}\par
5 {\cf20 //        https://www.boost.org/LICENSE_1_0.txt)}\par
6 \par
7 {\cf20 // SPDX-License-Identifier: BSL-1.0}\par
8 \par
9 {\cf20 //  Catch v3.6.0}\par
10 {\cf20 //  Generated: 2024-05-05 20:53:27.562886}\par
11 {\cf20 //  ----------------------------------------------------------}\par
12 {\cf20 //  This file is an amalgamation of multiple different files.}\par
13 {\cf20 //  You probably shouldn't edit it directly.}\par
14 {\cf20 //  ----------------------------------------------------------}\par
15 \par
16 {\cf21 #include "catch_amalgamated.hpp"}\par
17 \par
18 \par
19 {\cf21 #ifndef CATCH_WINDOWS_H_PROXY_HPP_INCLUDED}\par
20 {\cf21 #define CATCH_WINDOWS_H_PROXY_HPP_INCLUDED}\par
21 \par
22 \par
23 {\cf21 #if defined(CATCH_PLATFORM_WINDOWS)}\par
24 \par
25 {\cf20 // We might end up with the define made globally through the compiler,}\par
26 {\cf20 // and we don't want to trigger warnings for this}\par
27 {\cf21 #if !defined(NOMINMAX)}\par
28 {\cf21 #  define NOMINMAX}\par
29 {\cf21 #endif}\par
30 {\cf21 #if !defined(WIN32_LEAN_AND_MEAN)}\par
31 {\cf21 #  define WIN32_LEAN_AND_MEAN}\par
32 {\cf21 #endif}\par
33 \par
34 {\cf21 #include <windows.h>}\par
35 \par
36 {\cf21 #endif }{\cf20 // defined(CATCH_PLATFORM_WINDOWS)}\par
37 \par
38 {\cf21 #endif }{\cf20 // CATCH_WINDOWS_H_PROXY_HPP_INCLUDED}\par
39 \par
40 \par
41 \par
42 \par
43 {\cf17 namespace }Catch \{\par
44     {\cf17 namespace }Benchmark \{\par
45         {\cf17 namespace }Detail \{\par
46             ChronometerConcept::~ChronometerConcept() = {\cf19 default};\par
47         \} {\cf20 // namespace Detail}\par
48     \} {\cf20 // namespace Benchmark}\par
49 \} {\cf20 // namespace Catch}\par
50 \par
51 \par
52 {\cf20 // Adapted from donated nonius code.}\par
53 \par
54 \par
55 {\cf21 #include <vector>}\par
56 \par
57 {\cf17 namespace }Catch \{\par
58     {\cf17 namespace }Benchmark \{\par
59         {\cf17 namespace }Detail \{\par
60             SampleAnalysis analyse({\cf17 const} IConfig &cfg, FDuration* first, FDuration* last) \{\par
61                 {\cf19 if} (!cfg.benchmarkNoAnalysis()) \{\par
62                     std::vector<double> samples;\par
63                     samples.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(last - first));\par
64                     {\cf19 for} ({\cf17 auto} current = first; current != last; ++current) \{\par
65                         samples.push_back( current->count() );\par
66                     \}\par
67 \par
68                     {\cf17 auto} analysis = Catch::Benchmark::Detail::analyse_samples(\par
69                         cfg.benchmarkConfidenceInterval(),\par
70                         cfg.benchmarkResamples(),\par
71                         samples.data(),\par
72                         samples.data() + samples.size() );\par
73                     {\cf17 auto} outliers = Catch::Benchmark::Detail::classify_outliers(\par
74                         samples.data(), samples.data() + samples.size() );\par
75 \par
76                     {\cf17 auto} wrap_estimate = [](Estimate<double> e) \{\par
77                         {\cf19 return} Estimate<FDuration> \{\par
78                             FDuration(e.point),\par
79                                 FDuration(e.lower_bound),\par
80                                 FDuration(e.upper_bound),\par
81                                 e.confidence_interval,\par
82                         \};\par
83                     \};\par
84                     std::vector<FDuration> samples2;\par
85                     samples2.reserve(samples.size());\par
86                     {\cf19 for} ({\cf17 auto} s : samples) \{\par
87                         samples2.push_back( FDuration( s ) );\par
88                     \}\par
89 \par
90                     {\cf19 return} \{\par
91                         CATCH_MOVE(samples2),\par
92                         wrap_estimate(analysis.mean),\par
93                         wrap_estimate(analysis.standard_deviation),\par
94                         outliers,\par
95                         analysis.outlier_variance,\par
96                     \};\par
97                 \} {\cf19 else} \{\par
98                     std::vector<FDuration> samples;\par
99                     samples.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(last - first));\par
100 \par
101                     FDuration mean = FDuration(0);\par
102                     {\cf18 int} i = 0;\par
103                     {\cf19 for} ({\cf17 auto} it = first; it < last; ++it, ++i) \{\par
104                         samples.push_back(*it);\par
105                         mean += *it;\par
106                     \}\par
107                     mean /= i;\par
108 \par
109                     {\cf19 return} SampleAnalysis\{\par
110                         CATCH_MOVE(samples),\par
111                         Estimate<FDuration>\{ mean, mean, mean, 0.0 \},\par
112                         Estimate<FDuration>\{ FDuration( 0 ),\par
113                                              FDuration( 0 ),\par
114                                              FDuration( 0 ),\par
115                                              0.0 \},\par
116                         OutlierClassification\{\},\par
117                         0.0\par
118                     \};\par
119                 \}\par
120             \}\par
121         \} {\cf20 // namespace Detail}\par
122     \} {\cf20 // namespace Benchmark}\par
123 \} {\cf20 // namespace Catch}\par
124 \par
125 \par
126 \par
127 \par
128 {\cf17 namespace }Catch \{\par
129     {\cf17 namespace }Benchmark \{\par
130         {\cf17 namespace }Detail \{\par
131             BenchmarkFunction::callable::~callable() = {\cf19 default};\par
132         \} {\cf20 // namespace Detail}\par
133     \} {\cf20 // namespace Benchmark}\par
134 \} {\cf20 // namespace Catch}\par
135 \par
136 \par
137 \par
138 \par
139 {\cf21 #include <exception>}\par
140 \par
141 {\cf17 namespace }Catch \{\par
142     {\cf17 namespace }Benchmark \{\par
143         {\cf17 namespace }Detail \{\par
144             {\cf17 struct }optimized_away_error : std::exception \{\par
145                 {\cf17 const} {\cf18 char}* what() const noexcept override;\par
146             \};\par
147 \par
148             const {\cf18 char}* optimized_away_error::what() const noexcept \{\par
149                 {\cf19 return} {\cf22 "could not measure benchmark, maybe it was optimized away"};\par
150             \}\par
151 \par
152             {\cf18 void} throw_optimized_away_error() \{\par
153                 Catch::throw_exception(optimized_away_error\{\});\par
154             \}\par
155 \par
156         \} {\cf20 // namespace Detail}\par
157     \} {\cf20 // namespace Benchmark}\par
158 \} {\cf20 // namespace Catch}\par
159 \par
160 \par
161 {\cf20 // Adapted from donated nonius code.}\par
162 \par
163 \par
164 \par
165 {\cf21 #include <algorithm>}\par
166 {\cf21 #include <cassert>}\par
167 {\cf21 #include <cmath>}\par
168 {\cf21 #include <cstddef>}\par
169 {\cf21 #include <numeric>}\par
170 {\cf21 #include <random>}\par
171 \par
172 \par
173 {\cf21 #if defined(CATCH_CONFIG_USE_ASYNC)}\par
174 {\cf21 #include <future>}\par
175 {\cf21 #endif}\par
176 \par
177 {\cf17 namespace }Catch \{\par
178     {\cf17 namespace }Benchmark \{\par
179         {\cf17 namespace }Detail \{\par
180             {\cf17 namespace }\{\par
181 \par
182                 {\cf17 template} <{\cf17 typename} URng, {\cf17 typename} Estimator>\par
183                 {\cf17 static} sample\par
184                 resample( URng& rng,\par
185                           {\cf18 unsigned} {\cf18 int} resamples,\par
186                           {\cf18 double} {\cf17 const}* first,\par
187                           {\cf18 double} {\cf17 const}* last,\par
188                           Estimator& estimator ) \{\par
189                     {\cf17 auto} n = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( last - first );\par
190                     Catch::uniform_integer_distribution<size_t> dist( 0, n - 1 );\par
191 \par
192                     sample out;\par
193                     out.reserve( resamples );\par
194                     std::vector<double> resampled;\par
195                     resampled.reserve( n );\par
196                     {\cf19 for} ( {\cf18 size_t} i = 0; i < resamples; ++i ) \{\par
197                         resampled.clear();\par
198                         {\cf19 for} ( {\cf18 size_t} s = 0; s < n; ++s ) \{\par
199                             resampled.push_back( first[dist( rng )] );\par
200                         \}\par
201                         {\cf17 const} {\cf17 auto} estimate =\par
202                             estimator( resampled.data(), resampled.data() + resampled.size() );\par
203                         out.push_back( estimate );\par
204                     \}\par
205                     std::sort( out.begin(), out.end() );\par
206                     {\cf19 return} out;\par
207                 \}\par
208 \par
209                 {\cf17 static} {\cf18 double} outlier_variance( Estimate<double> mean,\par
210                                                 Estimate<double> stddev,\par
211                                                 {\cf18 int} n ) \{\par
212                     {\cf18 double} sb = stddev.point;\par
213                     {\cf18 double} mn = mean.point / n;\par
214                     {\cf18 double} mg_min = mn / 2.;\par
215                     {\cf18 double} sg = (std::min)( mg_min / 4., sb / std::sqrt( n ) );\par
216                     {\cf18 double} sg2 = sg * sg;\par
217                     {\cf18 double} sb2 = sb * sb;\par
218 \par
219                     {\cf17 auto} c_max = [n, mn, sb2, sg2]( {\cf18 double} x ) -> {\cf18 double} \{\par
220                         {\cf18 double} k = mn - x;\par
221                         {\cf18 double} d = k * k;\par
222                         {\cf18 double} nd = n * d;\par
223                         {\cf18 double} k0 = -n * nd;\par
224                         {\cf18 double} k1 = sb2 - n * sg2 + nd;\par
225                         {\cf18 double} det = k1 * k1 - 4 * sg2 * k0;\par
226                         {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}( -2. * k0 /\par
227                                                  ( k1 + std::sqrt( det ) ) );\par
228                     \};\par
229 \par
230                     {\cf17 auto} var_out = [n, sb2, sg2]( {\cf18 double} c ) \{\par
231                         {\cf18 double} nc = n - c;\par
232                         {\cf19 return} ( nc / n ) * ( sb2 - nc * sg2 );\par
233                     \};\par
234 \par
235                     {\cf19 return} (std::min)( var_out( 1 ),\par
236                                        var_out(\par
237                                            (std::min)( c_max( 0. ),\par
238                                                        c_max( mg_min ) ) ) ) /\par
239                            sb2;\par
240                 \}\par
241 \par
242                 {\cf17 static} {\cf18 double} erf_inv( {\cf18 double} x ) \{\par
243                     {\cf20 // Code accompanying the article "Approximating the erfinv}\par
244                     {\cf20 // function" in GPU Computing Gems, Volume 2}\par
245                     {\cf18 double} w, p;\par
246 \par
247                     w = -log( ( 1.0 - x ) * ( 1.0 + x ) );\par
248 \par
249                     {\cf19 if} ( w < 6.250000 ) \{\par
250                         w = w - 3.125000;\par
251                         p = -3.6444120640178196996e-21;\par
252                         p = -1.685059138182016589e-19 + p * w;\par
253                         p = 1.2858480715256400167e-18 + p * w;\par
254                         p = 1.115787767802518096e-17 + p * w;\par
255                         p = -1.333171662854620906e-16 + p * w;\par
256                         p = 2.0972767875968561637e-17 + p * w;\par
257                         p = 6.6376381343583238325e-15 + p * w;\par
258                         p = -4.0545662729752068639e-14 + p * w;\par
259                         p = -8.1519341976054721522e-14 + p * w;\par
260                         p = 2.6335093153082322977e-12 + p * w;\par
261                         p = -1.2975133253453532498e-11 + p * w;\par
262                         p = -5.4154120542946279317e-11 + p * w;\par
263                         p = 1.051212273321532285e-09 + p * w;\par
264                         p = -4.1126339803469836976e-09 + p * w;\par
265                         p = -2.9070369957882005086e-08 + p * w;\par
266                         p = 4.2347877827932403518e-07 + p * w;\par
267                         p = -1.3654692000834678645e-06 + p * w;\par
268                         p = -1.3882523362786468719e-05 + p * w;\par
269                         p = 0.0001867342080340571352 + p * w;\par
270                         p = -0.00074070253416626697512 + p * w;\par
271                         p = -0.0060336708714301490533 + p * w;\par
272                         p = 0.24015818242558961693 + p * w;\par
273                         p = 1.6536545626831027356 + p * w;\par
274                     \} {\cf19 else} {\cf19 if} ( w < 16.000000 ) \{\par
275                         w = sqrt( w ) - 3.250000;\par
276                         p = 2.2137376921775787049e-09;\par
277                         p = 9.0756561938885390979e-08 + p * w;\par
278                         p = -2.7517406297064545428e-07 + p * w;\par
279                         p = 1.8239629214389227755e-08 + p * w;\par
280                         p = 1.5027403968909827627e-06 + p * w;\par
281                         p = -4.013867526981545969e-06 + p * w;\par
282                         p = 2.9234449089955446044e-06 + p * w;\par
283                         p = 1.2475304481671778723e-05 + p * w;\par
284                         p = -4.7318229009055733981e-05 + p * w;\par
285                         p = 6.8284851459573175448e-05 + p * w;\par
286                         p = 2.4031110387097893999e-05 + p * w;\par
287                         p = -0.0003550375203628474796 + p * w;\par
288                         p = 0.00095328937973738049703 + p * w;\par
289                         p = -0.0016882755560235047313 + p * w;\par
290                         p = 0.0024914420961078508066 + p * w;\par
291                         p = -0.0037512085075692412107 + p * w;\par
292                         p = 0.005370914553590063617 + p * w;\par
293                         p = 1.0052589676941592334 + p * w;\par
294                         p = 3.0838856104922207635 + p * w;\par
295                     \} {\cf19 else} \{\par
296                         w = sqrt( w ) - 5.000000;\par
297                         p = -2.7109920616438573243e-11;\par
298                         p = -2.5556418169965252055e-10 + p * w;\par
299                         p = 1.5076572693500548083e-09 + p * w;\par
300                         p = -3.7894654401267369937e-09 + p * w;\par
301                         p = 7.6157012080783393804e-09 + p * w;\par
302                         p = -1.4960026627149240478e-08 + p * w;\par
303                         p = 2.9147953450901080826e-08 + p * w;\par
304                         p = -6.7711997758452339498e-08 + p * w;\par
305                         p = 2.2900482228026654717e-07 + p * w;\par
306                         p = -9.9298272942317002539e-07 + p * w;\par
307                         p = 4.5260625972231537039e-06 + p * w;\par
308                         p = -1.9681778105531670567e-05 + p * w;\par
309                         p = 7.5995277030017761139e-05 + p * w;\par
310                         p = -0.00021503011930044477347 + p * w;\par
311                         p = -0.00013871931833623122026 + p * w;\par
312                         p = 1.0103004648645343977 + p * w;\par
313                         p = 4.8499064014085844221 + p * w;\par
314                     \}\par
315                     {\cf19 return} p * x;\par
316                 \}\par
317 \par
318                 {\cf17 static} {\cf18 double}\par
319                 standard_deviation( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last ) \{\par
320                     {\cf17 auto} m = Catch::Benchmark::Detail::mean( first, last );\par
321                     {\cf18 double} variance =\par
322                         std::accumulate( first,\par
323                                          last,\par
324                                          0.,\par
325                                          [m]( {\cf18 double} a, {\cf18 double} b ) \{\par
326                                              {\cf18 double} diff = b - m;\par
327                                              {\cf19 return} a + diff * diff;\par
328                                          \} ) /\par
329                         ( last - first );\par
330                     {\cf19 return} std::sqrt( variance );\par
331                 \}\par
332 \par
333                 {\cf17 static} sample jackknife( {\cf18 double} ( *estimator )( {\cf18 double} {\cf17 const}*,\par
334                                                                 {\cf18 double} {\cf17 const}* ),\par
335                                          {\cf18 double}* first,\par
336                                          {\cf18 double}* last ) \{\par
337                     {\cf17 const} {\cf17 auto} second = first + 1;\par
338                     sample results;\par
339                     results.reserve( {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( last - first ) );\par
340 \par
341                     {\cf19 for} ( {\cf17 auto} it = first; it != last; ++it ) \{\par
342                         std::iter_swap( it, first );\par
343                         results.push_back( estimator( second, last ) );\par
344                     \}\par
345 \par
346                     {\cf19 return} results;\par
347                 \}\par
348 \par
349 \par
350             \} {\cf20 // namespace}\par
351         \}     {\cf20 // namespace Detail}\par
352     \}         {\cf20 // namespace Benchmark}\par
353 \} {\cf20 // namespace Catch}\par
354 \par
355 {\cf17 namespace }Catch \{\par
356     {\cf17 namespace }Benchmark \{\par
357         {\cf17 namespace }Detail \{\par
358 \par
359             {\cf18 double} weighted_average_quantile( {\cf18 int} k,\par
360                                               {\cf18 int} q,\par
361                                               {\cf18 double}* first,\par
362                                               {\cf18 double}* last ) \{\par
363                 {\cf17 auto} count = last - first;\par
364                 {\cf18 double} idx = (count - 1) * k / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(q);\par
365                 {\cf18 int} j = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(idx);\par
366                 {\cf18 double} g = idx - j;\par
367                 std::nth_element(first, first + j, last);\par
368                 {\cf17 auto} xj = first[j];\par
369                 {\cf19 if} ( Catch::Detail::directCompare( g, 0 ) ) \{\par
370                     {\cf19 return} xj;\par
371                 \}\par
372 \par
373                 {\cf17 auto} xj1 = *std::min_element(first + (j + 1), last);\par
374                 {\cf19 return} xj + g * (xj1 - xj);\par
375             \}\par
376 \par
377             OutlierClassification\par
378             classify_outliers( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last ) \{\par
379                 std::vector<double> copy( first, last );\par
380 \par
381                 {\cf17 auto} q1 = weighted_average_quantile( 1, 4, copy.data(), copy.data() + copy.size() );\par
382                 {\cf17 auto} q3 = weighted_average_quantile( 3, 4, copy.data(), copy.data() + copy.size() );\par
383                 {\cf17 auto} iqr = q3 - q1;\par
384                 {\cf17 auto} los = q1 - ( iqr * 3. );\par
385                 {\cf17 auto} lom = q1 - ( iqr * 1.5 );\par
386                 {\cf17 auto} him = q3 + ( iqr * 1.5 );\par
387                 {\cf17 auto} his = q3 + ( iqr * 3. );\par
388 \par
389                 OutlierClassification o;\par
390                 {\cf19 for} ( ; first != last; ++first ) \{\par
391                     {\cf17 const} {\cf18 double} t = *first;\par
392                     {\cf19 if} ( t < los ) \{\par
393                         ++o.low_severe;\par
394                     \} {\cf19 else} {\cf19 if} ( t < lom ) \{\par
395                         ++o.low_mild;\par
396                     \} {\cf19 else} {\cf19 if} ( t > his ) \{\par
397                         ++o.high_severe;\par
398                     \} {\cf19 else} {\cf19 if} ( t > him ) \{\par
399                         ++o.high_mild;\par
400                     \}\par
401                     ++o.samples_seen;\par
402                 \}\par
403                 {\cf19 return} o;\par
404             \}\par
405 \par
406             {\cf18 double} mean( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last ) \{\par
407                 {\cf17 auto} count = last - first;\par
408                 {\cf18 double} sum = 0.;\par
409                 {\cf19 while} (first != last) \{\par
410                     sum += *first;\par
411                     ++first;\par
412                 \}\par
413                 {\cf19 return} sum / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(count);\par
414             \}\par
415 \par
416             {\cf18 double} normal_cdf( {\cf18 double} x ) \{\par
417                 {\cf19 return} std::erfc( -x / std::sqrt( 2.0 ) ) / 2.0;\par
418             \}\par
419 \par
420             {\cf18 double} erfc_inv({\cf18 double} x) \{\par
421                 {\cf19 return} erf_inv(1.0 - x);\par
422             \}\par
423 \par
424             {\cf18 double} normal_quantile({\cf18 double} p) \{\par
425                 {\cf17 static} {\cf17 const} {\cf18 double} ROOT_TWO = std::sqrt(2.0);\par
426 \par
427                 {\cf18 double} result = 0.0;\par
428                 assert(p >= 0 && p <= 1);\par
429                 {\cf19 if} (p < 0 || p > 1) \{\par
430                     {\cf19 return} result;\par
431                 \}\par
432 \par
433                 result = -erfc_inv(2.0 * p);\par
434                 {\cf20 // result *= normal distribution standard deviation (1.0) * sqrt(2)}\par
435                 result *= {\cf20 /*sd * */} ROOT_TWO;\par
436                 {\cf20 // result += normal disttribution mean (0)}\par
437                 {\cf19 return} result;\par
438             \}\par
439 \par
440             Estimate<double>\par
441             bootstrap( {\cf18 double} confidence_level,\par
442                        {\cf18 double}* first,\par
443                        {\cf18 double}* last,\par
444                        sample {\cf17 const}& resample,\par
445                        {\cf18 double} ( *estimator )( {\cf18 double} {\cf17 const}*, {\cf18 double} {\cf17 const}* ) ) \{\par
446                 {\cf17 auto} n_samples = last - first;\par
447 \par
448                 {\cf18 double} point = estimator( first, last );\par
449                 {\cf20 // Degenerate case with a single sample}\par
450                 {\cf19 if} ( n_samples == 1 )\par
451                     {\cf19 return} \{ point, point, point, confidence_level \};\par
452 \par
453                 sample jack = jackknife( estimator, first, last );\par
454                 {\cf18 double} jack_mean =\par
455                     mean( jack.data(), jack.data() + jack.size() );\par
456                 {\cf18 double} sum_squares = 0, sum_cubes = 0;\par
457                 {\cf19 for} ( {\cf18 double} x : jack ) \{\par
458                     {\cf17 auto} difference = jack_mean - x;\par
459                     {\cf17 auto} square = difference * difference;\par
460                     {\cf17 auto} cube = square * difference;\par
461                     sum_squares += square;\par
462                     sum_cubes += cube;\par
463                 \}\par
464 \par
465                 {\cf18 double} accel = sum_cubes / ( 6 * std::pow( sum_squares, 1.5 ) );\par
466                 {\cf18 long} n = {\cf17 static_cast<}{\cf18 long}{\cf17 >}( resample.size() );\par
467                 {\cf18 double} prob_n =\par
468                     std::count_if( resample.begin(),\par
469                                    resample.end(),\par
470                                    [point]( {\cf18 double} x ) \{ return x < point; \} ) /\par
471                     {\cf17 static_cast<}{\cf18 double}{\cf17 >}( n );\par
472                 {\cf20 // degenerate case with uniform samples}\par
473                 {\cf19 if} ( Catch::Detail::directCompare( prob_n, 0. ) ) \{\par
474                     {\cf19 return} \{ point, point, point, confidence_level \};\par
475                 \}\par
476 \par
477                 {\cf18 double} bias = normal_quantile( prob_n );\par
478                 {\cf18 double} z1 = normal_quantile( ( 1. - confidence_level ) / 2. );\par
479 \par
480                 {\cf17 auto} cumn = [n]( {\cf18 double} x ) -> {\cf18 long} \{\par
481                     {\cf19 return} std::lround( normal_cdf( x ) *\par
482                                         {\cf17 static_cast<}{\cf18 double}{\cf17 >}( n ) );\par
483                 \};\par
484                 {\cf17 auto} a = [bias, accel]( {\cf18 double} b ) \{\par
485                     {\cf19 return} bias + b / ( 1. - accel * b );\par
486                 \};\par
487                 {\cf18 double} b1 = bias + z1;\par
488                 {\cf18 double} b2 = bias - z1;\par
489                 {\cf18 double} a1 = a( b1 );\par
490                 {\cf18 double} a2 = a( b2 );\par
491                 {\cf17 auto} lo = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( (std::max)( cumn( a1 ), 0l ) );\par
492                 {\cf17 auto} hi =\par
493                     {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( (std::min)( cumn( a2 ), n - 1 ) );\par
494 \par
495                 {\cf19 return} \{ point, resample[lo], resample[hi], confidence_level \};\par
496             \}\par
497 \par
498             bootstrap_analysis analyse_samples({\cf18 double} confidence_level,\par
499                                                {\cf18 unsigned} {\cf18 int} n_resamples,\par
500                                                {\cf18 double}* first,\par
501                                                {\cf18 double}* last) \{\par
502                 {\cf17 auto} mean = &Detail::mean;\par
503                 {\cf17 auto} stddev = &standard_deviation;\par
504 \par
505 {\cf21 #if defined(CATCH_CONFIG_USE_ASYNC)}\par
506                 {\cf17 auto} Estimate = [=](double(*f)({\cf18 double} {\cf17 const}*, {\cf18 double} {\cf17 const}*)) \{\par
507                     std::random_device rd;\par
508                     {\cf17 auto} seed = rd();\par
509                     {\cf19 return} std::async(std::launch::async, [=] \{\par
510                         SimplePcg32 rng( seed );\par
511                         {\cf17 auto} resampled = resample(rng, n_resamples, first, last, f);\par
512                         {\cf19 return} bootstrap(confidence_level, first, last, resampled, f);\par
513                     \});\par
514                 \};\par
515 \par
516                 {\cf17 auto} mean_future = Estimate(mean);\par
517                 {\cf17 auto} stddev_future = Estimate(stddev);\par
518 \par
519                 {\cf17 auto} mean_estimate = mean_future.get();\par
520                 {\cf17 auto} stddev_estimate = stddev_future.get();\par
521 {\cf21 #else}\par
522                 {\cf17 auto} Estimate = [=](double(*f)({\cf18 double} {\cf17 const}* , {\cf18 double} {\cf17 const}*)) \{\par
523                     std::random_device rd;\par
524                     {\cf17 auto} seed = rd();\par
525                     SimplePcg32 rng( seed );\par
526                     {\cf17 auto} resampled = resample(rng, n_resamples, first, last, f);\par
527                     {\cf19 return} bootstrap(confidence_level, first, last, resampled, f);\par
528                 \};\par
529 \par
530                 {\cf17 auto} mean_estimate = Estimate(mean);\par
531                 {\cf17 auto} stddev_estimate = Estimate(stddev);\par
532 {\cf21 #endif }{\cf20 // CATCH_USE_ASYNC}\par
533 \par
534                 {\cf17 auto} n = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(last - first); {\cf20 // seriously, one can't use integral types without hell in C++}\par
535                 {\cf18 double} outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);\par
536 \par
537                 {\cf19 return} \{ mean_estimate, stddev_estimate, outlier_variance \};\par
538             \}\par
539         \} {\cf20 // namespace Detail}\par
540     \} {\cf20 // namespace Benchmark}\par
541 \} {\cf20 // namespace Catch}\par
542 \par
543 \par
544 \par
545 {\cf21 #include <cmath>}\par
546 {\cf21 #include <limits>}\par
547 \par
548 {\cf17 namespace }\{\par
549 \par
550 {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
551 {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
552 {\cf18 bool} marginComparison({\cf18 double} lhs, {\cf18 double} rhs, {\cf18 double} margin) \{\par
553     {\cf19 return} (lhs + margin >= rhs) && (rhs + margin >= lhs);\par
554 \}\par
555 \par
556 \}\par
557 \par
558 {\cf17 namespace }Catch \{\par
559 \par
560     Approx::Approx ( {\cf18 double} value )\par
561     :   m_epsilon( static_cast<double>(std::numeric_limits<float>::epsilon())*100. ),\par
562         m_margin( 0.0 ),\par
563         m_scale( 0.0 ),\par
564         m_value( value )\par
565     \{\}\par
566 \par
567     Approx Approx::custom() \{\par
568         {\cf19 return} Approx( 0 );\par
569     \}\par
570 \par
571     Approx Approx::operator-(){\cf17  const }\{\par
572         {\cf17 auto} temp(*{\cf17 this});\par
573         temp.m_value = -temp.m_value;\par
574         {\cf19 return} temp;\par
575     \}\par
576 \par
577 \par
578     std::string Approx::toString(){\cf17  const }\{\par
579         ReusableStringStream rss;\par
580         rss << {\cf22 "Approx( "} << ::Catch::Detail::stringify( m_value ) << {\cf22 " )"};\par
581         {\cf19 return} rss.str();\par
582     \}\par
583 \par
584     {\cf18 bool} Approx::equalityComparisonImpl({\cf17 const} {\cf18 double} other){\cf17  const }\{\par
585         {\cf20 // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value}\par
586         {\cf20 // Thanks to Richard Harris for his help refining the scaled margin value}\par
587         {\cf19 return} marginComparison(m_value, other, m_margin)\par
588             || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(std::isinf(m_value)? 0 : m_value)));\par
589     \}\par
590 \par
591     {\cf18 void} Approx::setMargin({\cf18 double} newMargin) \{\par
592         CATCH_ENFORCE(newMargin >= 0,\par
593             {\cf22 "Invalid Approx::margin: "} << newMargin << {\cf23 '.'}\par
594             << {\cf22 " Approx::Margin has to be non-negative."});\par
595         m_margin = newMargin;\par
596     \}\par
597 \par
598     {\cf18 void} Approx::setEpsilon({\cf18 double} newEpsilon) \{\par
599         CATCH_ENFORCE(newEpsilon >= 0 && newEpsilon <= 1.0,\par
600             {\cf22 "Invalid Approx::epsilon: "} << newEpsilon << {\cf23 '.'}\par
601             << {\cf22 " Approx::epsilon has to be in [0, 1]"});\par
602         m_epsilon = newEpsilon;\par
603     \}\par
604 \par
605 {\cf17 namespace }literals \{\par
606     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 long} {\cf18 double} val) \{\par
607         {\cf19 return} Approx(val);\par
608     \}\par
609     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 unsigned} {\cf18 long} {\cf18 long} val) \{\par
610         {\cf19 return} Approx(val);\par
611     \}\par
612 \} {\cf20 // end namespace literals}\par
613 \par
614 std::string StringMaker<Catch::Approx>::convert(Catch::Approx {\cf17 const}& value) \{\par
615     {\cf19 return} value.toString();\par
616 \}\par
617 \par
618 \} {\cf20 // end namespace Catch}\par
619 \par
620 \par
621 \par
622 {\cf17 namespace }Catch \{\par
623 \par
624     AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression {\cf17 const} & _lazyExpression):\par
625         lazyExpression(_lazyExpression),\par
626         resultType(_resultType) \{\}\par
627 \par
628     std::string AssertionResultData::reconstructExpression(){\cf17  const }\{\par
629 \par
630         {\cf19 if}( reconstructedExpression.empty() ) \{\par
631             {\cf19 if}( lazyExpression ) \{\par
632                 ReusableStringStream rss;\par
633                 rss << lazyExpression;\par
634                 reconstructedExpression = rss.str();\par
635             \}\par
636         \}\par
637         {\cf19 return} reconstructedExpression;\par
638     \}\par
639 \par
640     AssertionResult::AssertionResult( AssertionInfo {\cf17 const}& info, AssertionResultData&& data )\par
641     :   m_info( info ),\par
642         m_resultData( CATCH_MOVE(data) )\par
643     \{\}\par
644 \par
645     {\cf20 // Result was a success}\par
646     {\cf18 bool} AssertionResult::succeeded(){\cf17  const }\{\par
647         {\cf19 return} Catch::isOk( m_resultData.resultType );\par
648     \}\par
649 \par
650     {\cf20 // Result was a success, or failure is suppressed}\par
651     {\cf18 bool} AssertionResult::isOk(){\cf17  const }\{\par
652         {\cf19 return} Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );\par
653     \}\par
654 \par
655     ResultWas::OfType AssertionResult::getResultType(){\cf17  const }\{\par
656         {\cf19 return} m_resultData.resultType;\par
657     \}\par
658 \par
659     {\cf18 bool} AssertionResult::hasExpression(){\cf17  const }\{\par
660         {\cf19 return} !m_info.capturedExpression.empty();\par
661     \}\par
662 \par
663     {\cf18 bool} AssertionResult::hasMessage(){\cf17  const }\{\par
664         {\cf19 return} !m_resultData.message.empty();\par
665     \}\par
666 \par
667     std::string AssertionResult::getExpression(){\cf17  const }\{\par
668         {\cf20 // Possibly overallocating by 3 characters should be basically free}\par
669         std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);\par
670         {\cf19 if} (isFalseTest(m_info.resultDisposition)) \{\par
671             expr += {\cf22 "!("};\par
672         \}\par
673         expr += m_info.capturedExpression;\par
674         {\cf19 if} (isFalseTest(m_info.resultDisposition)) \{\par
675             expr += {\cf23 ')'};\par
676         \}\par
677         {\cf19 return} expr;\par
678     \}\par
679 \par
680     std::string AssertionResult::getExpressionInMacro(){\cf17  const }\{\par
681         {\cf19 if} ( m_info.macroName.empty() ) \{\par
682             {\cf19 return} {\cf17 static_cast<}std::string{\cf17 >}( m_info.capturedExpression );\par
683         \}\par
684         std::string expr;\par
685         expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );\par
686         expr += m_info.macroName;\par
687         expr += {\cf22 "( "};\par
688         expr += m_info.capturedExpression;\par
689         expr += {\cf22 " )"};\par
690         {\cf19 return} expr;\par
691     \}\par
692 \par
693     {\cf18 bool} AssertionResult::hasExpandedExpression(){\cf17  const }\{\par
694         {\cf19 return} hasExpression() && getExpandedExpression() != getExpression();\par
695     \}\par
696 \par
697     std::string AssertionResult::getExpandedExpression(){\cf17  const }\{\par
698         std::string expr = m_resultData.reconstructExpression();\par
699         {\cf19 return} expr.empty()\par
700                 ? getExpression()\par
701                 : expr;\par
702     \}\par
703 \par
704     StringRef AssertionResult::getMessage(){\cf17  const }\{\par
705         {\cf19 return} m_resultData.message;\par
706     \}\par
707     SourceLineInfo AssertionResult::getSourceInfo(){\cf17  const }\{\par
708         {\cf19 return} m_info.lineInfo;\par
709     \}\par
710 \par
711     StringRef AssertionResult::getTestMacroName(){\cf17  const }\{\par
712         {\cf19 return} m_info.macroName;\par
713     \}\par
714 \par
715 \} {\cf20 // end namespace Catch}\par
716 \par
717 \par
718 \par
719 {\cf21 #include <fstream>}\par
720 \par
721 {\cf17 namespace }Catch \{\par
722 \par
723     {\cf17 namespace }\{\par
724         {\cf17 static} {\cf18 bool} enableBazelEnvSupport() \{\par
725 {\cf21 #if defined( CATCH_CONFIG_BAZEL_SUPPORT )}\par
726             {\cf19 return} {\cf17 true};\par
727 {\cf21 #else}\par
728             {\cf19 return} Detail::getEnv( {\cf22 "BAZEL_TEST"} ) != {\cf17 nullptr};\par
729 {\cf21 #endif}\par
730         \}\par
731 \par
732         {\cf17 struct }bazelShardingOptions \{\par
733             {\cf18 unsigned} {\cf18 int} shardIndex, shardCount;\par
734             std::string shardFilePath;\par
735         \};\par
736 \par
737         {\cf17 static} Optional<bazelShardingOptions> readBazelShardingOptions() \{\par
738             {\cf17 const} {\cf17 auto} bazelShardIndex = Detail::getEnv( {\cf22 "TEST_SHARD_INDEX"} );\par
739             {\cf17 const} {\cf17 auto} bazelShardTotal = Detail::getEnv( {\cf22 "TEST_TOTAL_SHARDS"} );\par
740             {\cf17 const} {\cf17 auto} bazelShardInfoFile = Detail::getEnv( {\cf22 "TEST_SHARD_STATUS_FILE"} );\par
741 \par
742 \par
743             {\cf17 const} {\cf18 bool} has_all =\par
744                 bazelShardIndex && bazelShardTotal && bazelShardInfoFile;\par
745             {\cf19 if} ( !has_all ) \{\par
746                 {\cf20 // We provide nice warning message if the input is}\par
747                 {\cf20 // misconfigured.}\par
748                 {\cf17 auto} warn = []( {\cf17 const} {\cf18 char}* env_var ) \{\par
749                     Catch::cerr()\par
750                         << {\cf22 "Warning: Bazel shard configuration is missing '"}\par
751                         << env_var << {\cf22 "'. Shard configuration is skipped.\\n"};\par
752                 \};\par
753                 {\cf19 if} ( !bazelShardIndex ) \{\par
754                     warn( {\cf22 "TEST_SHARD_INDEX"} );\par
755                 \}\par
756                 {\cf19 if} ( !bazelShardTotal ) \{\par
757                     warn( {\cf22 "TEST_TOTAL_SHARDS"} );\par
758                 \}\par
759                 {\cf19 if} ( !bazelShardInfoFile ) \{\par
760                     warn( {\cf22 "TEST_SHARD_STATUS_FILE"} );\par
761                 \}\par
762                 {\cf19 return} \{\};\par
763             \}\par
764 \par
765             {\cf17 auto} shardIndex = parseUInt( bazelShardIndex );\par
766             {\cf19 if} ( !shardIndex ) \{\par
767                 Catch::cerr()\par
768                     << {\cf22 "Warning: could not parse 'TEST_SHARD_INDEX' ('"} << bazelShardIndex\par
769                     << {\cf22 "') as unsigned int.\\n"};\par
770                 {\cf19 return} \{\};\par
771             \}\par
772             {\cf17 auto} shardTotal = parseUInt( bazelShardTotal );\par
773             {\cf19 if} ( !shardTotal ) \{\par
774                 Catch::cerr()\par
775                     << {\cf22 "Warning: could not parse 'TEST_TOTAL_SHARD' ('"}\par
776                     << bazelShardTotal << {\cf22 "') as unsigned int.\\n"};\par
777                 {\cf19 return} \{\};\par
778             \}\par
779 \par
780             {\cf19 return} bazelShardingOptions\{\par
781                 *shardIndex, *shardTotal, bazelShardInfoFile \};\par
782 \par
783         \}\par
784     \} {\cf20 // end namespace}\par
785 \par
786 \par
787     {\cf18 bool} operator==( ProcessedReporterSpec {\cf17 const}& lhs,\par
788                      ProcessedReporterSpec {\cf17 const}& rhs ) \{\par
789         {\cf19 return} lhs.name == rhs.name &&\par
790                lhs.outputFilename == rhs.outputFilename &&\par
791                lhs.colourMode == rhs.colourMode &&\par
792                lhs.customOptions == rhs.customOptions;\par
793     \}\par
794 \par
795     Config::Config( ConfigData {\cf17 const}& data ):\par
796         m_data( data ) \{\par
797         {\cf20 // We need to trim filter specs to avoid trouble with superfluous}\par
798         {\cf20 // whitespace (esp. important for bdd macros, as those are manually}\par
799         {\cf20 // aligned with whitespace).}\par
800 \par
801         {\cf19 for} ({\cf17 auto}& elem : m_data.testsOrTags) \{\par
802             elem = trim(elem);\par
803         \}\par
804         for ({\cf17 auto}& elem : m_data.sectionsToRun) \{\par
805             elem = trim(elem);\par
806         \}\par
807 \par
808         {\cf20 // Insert the default reporter if user hasn't asked for a specific one}\par
809         if ( m_data.reporterSpecifications.empty() ) \{\par
810 #if defined( CATCH_CONFIG_DEFAULT_REPORTER )\par
811             const auto default_spec = CATCH_CONFIG_DEFAULT_REPORTER;\par
812 #else\par
813             const auto default_spec = {\cf22 "console"};\par
814 #endif\par
815             auto parsed = parseReporterSpec(default_spec);\par
816             CATCH_ENFORCE( parsed,\par
817                            {\cf22 "Cannot parse the provided default reporter spec: '"}\par
818                                << default_spec << {\cf22 '\\''} );\par
819             m_data.reporterSpecifications.push_back( std::move( *parsed ) );\par
820         \}\par
821 \par
822         if ( enableBazelEnvSupport() ) \{\par
823             readBazelEnvVars();\par
824         \}\par
825 \par
826         {\cf20 // Bazel support can modify the test specs, so parsing has to happen}\par
827         {\cf20 // after reading Bazel env vars.}\par
828         TestSpecParser parser( ITagAliasRegistry::get() );\par
829         {\cf19 if} ( !m_data.testsOrTags.empty() ) \{\par
830             m_hasTestFilters = {\cf17 true};\par
831             {\cf19 for} ( {\cf17 auto} {\cf17 const}& testOrTags : m_data.testsOrTags ) \{\par
832                 parser.parse( testOrTags );\par
833             \}\par
834         \}\par
835         m_testSpec = parser.testSpec();\par
836 \par
837 \par
838         {\cf20 // We now fixup the reporter specs to handle default output spec,}\par
839         {\cf20 // default colour spec, etc}\par
840         {\cf18 bool} defaultOutputUsed = {\cf17 false};\par
841         {\cf19 for} ( {\cf17 auto} {\cf17 const}& reporterSpec : m_data.reporterSpecifications ) \{\par
842             {\cf20 // We do the default-output check separately, while always}\par
843             {\cf20 // using the default output below to make the code simpler}\par
844             {\cf20 // and avoid superfluous copies.}\par
845             {\cf19 if} ( reporterSpec.outputFile().none() ) \{\par
846                 CATCH_ENFORCE( !defaultOutputUsed,\par
847                                {\cf22 "Internal error: cannot use default output for "}\par
848                                {\cf22 "multiple reporters"} );\par
849                 defaultOutputUsed = {\cf17 true};\par
850             \}\par
851 \par
852             m_processedReporterSpecs.push_back( ProcessedReporterSpec\{\par
853                 reporterSpec.name(),\par
854                 reporterSpec.outputFile() ? *reporterSpec.outputFile()\par
855                                           : data.defaultOutputFilename,\par
856                 reporterSpec.colourMode().valueOr( data.defaultColourMode ),\par
857                 reporterSpec.customOptions() \} );\par
858         \}\par
859     \}\par
860 \par
861     Config::~Config() = {\cf19 default};\par
862 \par
863 \par
864     {\cf18 bool} Config::listTests(){\cf17  const          }\{ {\cf19 return} m_data.listTests; \}\par
865     {\cf18 bool} Config::listTags(){\cf17  const           }\{ {\cf19 return} m_data.listTags; \}\par
866     {\cf18 bool} Config::listReporters(){\cf17  const      }\{ {\cf19 return} m_data.listReporters; \}\par
867     {\cf18 bool} Config::listListeners(){\cf17  const      }\{ {\cf19 return} m_data.listListeners; \}\par
868 \par
869     std::vector<std::string> {\cf17 const}& Config::getTestsOrTags(){\cf17  const }\{ {\cf19 return} m_data.testsOrTags; \}\par
870     std::vector<std::string> {\cf17 const}& Config::getSectionsToRun(){\cf17  const }\{ {\cf19 return} m_data.sectionsToRun; \}\par
871 \par
872     std::vector<ReporterSpec> {\cf17 const}& Config::getReporterSpecs(){\cf17  const }\{\par
873         {\cf19 return} m_data.reporterSpecifications;\par
874     \}\par
875 \par
876     std::vector<ProcessedReporterSpec> {\cf17 const}&\par
877     Config::getProcessedReporterSpecs(){\cf17  const }\{\par
878         {\cf19 return} m_processedReporterSpecs;\par
879     \}\par
880 \par
881     TestSpec {\cf17 const}& Config::testSpec(){\cf17  const }\{ {\cf19 return} m_testSpec; \}\par
882     {\cf18 bool} Config::hasTestFilters(){\cf17  const }\{ {\cf19 return} m_hasTestFilters; \}\par
883 \par
884     {\cf18 bool} Config::showHelp(){\cf17  const }\{ {\cf19 return} m_data.showHelp; \}\par
885 \par
886     {\cf20 // IConfig interface}\par
887     {\cf18 bool} Config::allowThrows(){\cf17  const                   }\{ {\cf19 return} !m_data.noThrow; \}\par
888     StringRef Config::name(){\cf17  const }\{ {\cf19 return} m_data.name.empty() ? m_data.processName : m_data.name; \}\par
889     {\cf18 bool} Config::includeSuccessfulResults(){\cf17  const      }\{ {\cf19 return} m_data.showSuccessfulTests; \}\par
890     {\cf18 bool} Config::warnAboutMissingAssertions(){\cf17  const }\{\par
891         {\cf19 return} !!( m_data.warnings & WarnAbout::NoAssertions );\par
892     \}\par
893     {\cf18 bool} Config::warnAboutUnmatchedTestSpecs(){\cf17  const }\{\par
894         {\cf19 return} !!( m_data.warnings & WarnAbout::UnmatchedTestSpec );\par
895     \}\par
896     {\cf18 bool} Config::zeroTestsCountAsSuccess(){\cf17  const       }\{ {\cf19 return} m_data.allowZeroTests; \}\par
897     ShowDurations Config::showDurations(){\cf17  const        }\{ {\cf19 return} m_data.showDurations; \}\par
898     {\cf18 double} Config::minDuration(){\cf17  const                 }\{ {\cf19 return} m_data.minDuration; \}\par
899     TestRunOrder Config::runOrder(){\cf17  const              }\{ {\cf19 return} m_data.runOrder; \}\par
900     uint32_t Config::rngSeed(){\cf17  const                   }\{ {\cf19 return} m_data.rngSeed; \}\par
901     {\cf18 unsigned} {\cf18 int} Config::shardCount(){\cf17  const            }\{ {\cf19 return} m_data.shardCount; \}\par
902     {\cf18 unsigned} {\cf18 int} Config::shardIndex(){\cf17  const            }\{ {\cf19 return} m_data.shardIndex; \}\par
903     ColourMode Config::defaultColourMode(){\cf17  const       }\{ {\cf19 return} m_data.defaultColourMode; \}\par
904     {\cf18 bool} Config::shouldDebugBreak(){\cf17  const              }\{ {\cf19 return} m_data.shouldDebugBreak; \}\par
905     {\cf18 int} Config::abortAfter(){\cf17  const                     }\{ {\cf19 return} m_data.abortAfter; \}\par
906     {\cf18 bool} Config::showInvisibles(){\cf17  const                }\{ {\cf19 return} m_data.showInvisibles; \}\par
907     Verbosity Config::verbosity(){\cf17  const                }\{ {\cf19 return} m_data.verbosity; \}\par
908 \par
909     {\cf18 bool} Config::skipBenchmarks(){\cf17  const                           }\{ {\cf19 return} m_data.skipBenchmarks; \}\par
910     {\cf18 bool} Config::benchmarkNoAnalysis(){\cf17  const                      }\{ {\cf19 return} m_data.benchmarkNoAnalysis; \}\par
911     {\cf18 unsigned} {\cf18 int} Config::benchmarkSamples(){\cf17  const                 }\{ {\cf19 return} m_data.benchmarkSamples; \}\par
912     {\cf18 double} Config::benchmarkConfidenceInterval(){\cf17  const            }\{ {\cf19 return} m_data.benchmarkConfidenceInterval; \}\par
913     {\cf18 unsigned} {\cf18 int} Config::benchmarkResamples(){\cf17  const               }\{ {\cf19 return} m_data.benchmarkResamples; \}\par
914     std::chrono::milliseconds Config::benchmarkWarmupTime(){\cf17  const }\{ {\cf19 return} std::chrono::milliseconds(m_data.benchmarkWarmupTime); \}\par
915 \par
916     {\cf18 void} Config::readBazelEnvVars() \{\par
917         {\cf20 // Register a JUnit reporter for Bazel. Bazel sets an environment}\par
918         {\cf20 // variable with the path to XML output. If this file is written to}\par
919         {\cf20 // during test, Bazel will not generate a default XML output.}\par
920         {\cf20 // This allows the XML output file to contain higher level of detail}\par
921         {\cf20 // than what is possible otherwise.}\par
922         {\cf17 const} {\cf17 auto} bazelOutputFile = Detail::getEnv( {\cf22 "XML_OUTPUT_FILE"} );\par
923 \par
924         {\cf19 if} ( bazelOutputFile ) \{\par
925             m_data.reporterSpecifications.push_back(\par
926                 \{ {\cf22 "junit"}, std::string( bazelOutputFile ), \{\}, \{\} \} );\par
927         \}\par
928 \par
929         {\cf17 const} {\cf17 auto} bazelTestSpec = Detail::getEnv( {\cf22 "TESTBRIDGE_TEST_ONLY"} );\par
930         {\cf19 if} ( bazelTestSpec ) \{\par
931             {\cf20 // Presumably the test spec from environment should overwrite}\par
932             {\cf20 // the one we got from CLI (if we got any)}\par
933             m_data.testsOrTags.clear();\par
934             m_data.testsOrTags.push_back( bazelTestSpec );\par
935         \}\par
936 \par
937         {\cf17 const} {\cf17 auto} bazelShardOptions = readBazelShardingOptions();\par
938         {\cf19 if} ( bazelShardOptions ) \{\par
939             std::ofstream f( bazelShardOptions->shardFilePath,\par
940                              std::ios_base::out | std::ios_base::trunc );\par
941             {\cf19 if} ( f.is_open() ) \{\par
942                 f << {\cf22 ""};\par
943                 m_data.shardIndex = bazelShardOptions->shardIndex;\par
944                 m_data.shardCount = bazelShardOptions->shardCount;\par
945             \}\par
946         \}\par
947     \}\par
948 \par
949 \} {\cf20 // end namespace Catch}\par
950 \par
951 \par
952 \par
953 \par
954 \par
955 {\cf17 namespace }Catch \{\par
956     std::uint32_t getSeed() \{\par
957         {\cf19 return} getCurrentContext().getConfig()->rngSeed();\par
958     \}\par
959 \}\par
960 \par
961 \par
962 \par
963 {\cf21 #include <cassert>}\par
964 {\cf21 #include <stack>}\par
965 \par
966 {\cf17 namespace }Catch \{\par
967 \par
969 \par
970 \par
971     ScopedMessage::ScopedMessage( MessageBuilder&& builder ):\par
972         m_info( CATCH_MOVE(builder.m_info) ) \{\par
973         m_info.message = builder.m_stream.str();\par
974         getResultCapture().pushScopedMessage( m_info );\par
975     \}\par
976 \par
977     ScopedMessage::ScopedMessage( ScopedMessage&& old ) {\cf17 noexcept}:\par
978         m_info( CATCH_MOVE( old.m_info ) ) \{\par
979         old.m_moved = {\cf17 true};\par
980     \}\par
981 \par
982     ScopedMessage::~ScopedMessage() \{\par
983         {\cf19 if} ( !uncaught_exceptions() && !m_moved )\{\par
984             getResultCapture().popScopedMessage(m_info);\par
985         \}\par
986     \}\par
987 \par
988 \par
989     Capturer::Capturer( StringRef macroName,\par
990                         SourceLineInfo {\cf17 const}& lineInfo,\par
991                         ResultWas::OfType resultType,\par
992                         StringRef names ):\par
993         m_resultCapture( getResultCapture() ) \{\par
994         {\cf17 auto} trimmed = [&] ({\cf18 size_t} start, {\cf18 size_t} end) \{\par
995             {\cf19 while} (names[start] == {\cf23 ','} || isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(names[start]))) \{\par
996                 ++start;\par
997             \}\par
998             {\cf19 while} (names[end] == {\cf23 ','} || isspace({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(names[end]))) \{\par
999                 --end;\par
1000             \}\par
1001             {\cf19 return} names.substr(start, end - start + 1);\par
1002         \};\par
1003         {\cf17 auto} skipq = [&] ({\cf18 size_t} start, {\cf18 char} quote) \{\par
1004             {\cf19 for} ({\cf17 auto} i = start + 1; i < names.size() ; ++i) \{\par
1005                 {\cf19 if} (names[i] == quote)\par
1006                     {\cf19 return} i;\par
1007                 {\cf19 if} (names[i] == {\cf23 '\\\\'})\par
1008                     ++i;\par
1009             \}\par
1010             CATCH_INTERNAL_ERROR({\cf22 "CAPTURE parsing encountered unmatched quote"});\par
1011         \};\par
1012 \par
1013         {\cf18 size_t} start = 0;\par
1014         std::stack<char> openings;\par
1015         {\cf19 for} ({\cf18 size_t} pos = 0; pos < names.size(); ++pos) \{\par
1016             {\cf18 char} c = names[pos];\par
1017             {\cf19 switch} (c) \{\par
1018             {\cf19 case} {\cf23 '['}:\par
1019             {\cf19 case} {\cf23 '\{'}:\par
1020             {\cf19 case} {\cf23 '('}:\par
1021             {\cf20 // It is basically impossible to disambiguate between}\par
1022             {\cf20 // comparison and start of template args in this context}\par
1023 {\cf20 //            case '<':}\par
1024                 openings.push(c);\par
1025                 {\cf19 break};\par
1026             {\cf19 case} {\cf23 ']'}:\par
1027             {\cf19 case} {\cf23 '\}'}:\par
1028             {\cf19 case} {\cf23 ')'}:\par
1029 {\cf20 //           case '>':}\par
1030                 openings.pop();\par
1031                 {\cf19 break};\par
1032             {\cf19 case} {\cf23 '"'}:\par
1033             {\cf19 case} {\cf23 '\\''}:\par
1034                 pos = skipq(pos, c);\par
1035                 {\cf19 break};\par
1036             {\cf19 case} {\cf23 ','}:\par
1037                 {\cf19 if} (start != pos && openings.empty()) \{\par
1038                     m_messages.emplace_back(macroName, lineInfo, resultType);\par
1039                     m_messages.back().message = {\cf17 static_cast<}std::string{\cf17 >}(trimmed(start, pos));\par
1040                     m_messages.back().message += {\cf22 " := "};\par
1041                     start = pos;\par
1042                 \}\par
1043             {\cf19 default}:; {\cf20 // noop}\par
1044             \}\par
1045         \}\par
1046         assert(openings.empty() && {\cf22 "Mismatched openings"});\par
1047         m_messages.emplace_back(macroName, lineInfo, resultType);\par
1048         m_messages.back().message = {\cf17 static_cast<}std::string{\cf17 >}(trimmed(start, names.size() - 1));\par
1049         m_messages.back().message += {\cf22 " := "};\par
1050     \}\par
1051     Capturer::~Capturer() \{\par
1052         {\cf19 if} ( !uncaught_exceptions() )\{\par
1053             assert( m_captured == m_messages.size() );\par
1054             {\cf19 for}( {\cf18 size_t} i = 0; i < m_captured; ++i  )\par
1055                 m_resultCapture.popScopedMessage( m_messages[i] );\par
1056         \}\par
1057     \}\par
1058 \par
1059     {\cf18 void} Capturer::captureValue( {\cf18 size_t} index, std::string {\cf17 const}& value ) \{\par
1060         assert( index < m_messages.size() );\par
1061         m_messages[index].message += value;\par
1062         m_resultCapture.pushScopedMessage( m_messages[index] );\par
1063         m_captured++;\par
1064     \}\par
1065 \par
1066 \} {\cf20 // end namespace Catch}\par
1067 \par
1068 \par
1069 \par
1070 \par
1071 {\cf21 #include <exception>}\par
1072 \par
1073 {\cf17 namespace }Catch \{\par
1074 \par
1075     {\cf17 namespace }\{\par
1076 \par
1077         {\cf17 class }RegistryHub : {\cf17 public} IRegistryHub,\par
1078                             {\cf17 public} IMutableRegistryHub,\par
1079                             {\cf17 private} Detail::NonCopyable \{\par
1080 \par
1081         {\cf17 public}: {\cf20 // IRegistryHub}\par
1082             RegistryHub() = {\cf19 default};\par
1083             ReporterRegistry {\cf17 const}& getReporterRegistry(){\cf17  const override }\{\par
1084                 {\cf19 return} m_reporterRegistry;\par
1085             \}\par
1086             ITestCaseRegistry {\cf17 const}& getTestCaseRegistry(){\cf17  const override }\{\par
1087                 {\cf19 return} m_testCaseRegistry;\par
1088             \}\par
1089             IExceptionTranslatorRegistry {\cf17 const}& getExceptionTranslatorRegistry(){\cf17  const override }\{\par
1090                 {\cf19 return} m_exceptionTranslatorRegistry;\par
1091             \}\par
1092             ITagAliasRegistry {\cf17 const}& getTagAliasRegistry(){\cf17  const override }\{\par
1093                 {\cf19 return} m_tagAliasRegistry;\par
1094             \}\par
1095             StartupExceptionRegistry {\cf17 const}& getStartupExceptionRegistry(){\cf17  const override }\{\par
1096                 {\cf19 return} m_exceptionRegistry;\par
1097             \}\par
1098 \par
1099         {\cf17 public}: {\cf20 // IMutableRegistryHub}\par
1100             {\cf18 void} registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr factory ){\cf17  override }\{\par
1101                 m_reporterRegistry.registerReporter( name, CATCH_MOVE(factory) );\par
1102             \}\par
1103             {\cf18 void} registerListener( Detail::unique_ptr<EventListenerFactory> factory ){\cf17  override }\{\par
1104                 m_reporterRegistry.registerListener( CATCH_MOVE(factory) );\par
1105             \}\par
1106             {\cf18 void} registerTest( Detail::unique_ptr<TestCaseInfo>&& testInfo, Detail::unique_ptr<ITestInvoker>&& invoker ){\cf17  override }\{\par
1107                 m_testCaseRegistry.registerTest( CATCH_MOVE(testInfo), CATCH_MOVE(invoker) );\par
1108             \}\par
1109             {\cf18 void} registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator ){\cf17  override }\{\par
1110                 m_exceptionTranslatorRegistry.registerTranslator( CATCH_MOVE(translator) );\par
1111             \}\par
1112             {\cf18 void} registerTagAlias( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ){\cf17  override }\{\par
1113                 m_tagAliasRegistry.add( alias, tag, lineInfo );\par
1114             \}\par
1115             {\cf18 void} registerStartupException() noexcept{\cf17  override }\{\par
1116 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
1117                 m_exceptionRegistry.add(std::current_exception());\par
1118 {\cf21 #else}\par
1119                 CATCH_INTERNAL_ERROR({\cf22 "Attempted to register active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!"});\par
1120 {\cf21 #endif}\par
1121             \}\par
1122             IMutableEnumValuesRegistry& getMutableEnumValuesRegistry(){\cf17  override }\{\par
1123                 {\cf19 return} m_enumValuesRegistry;\par
1124             \}\par
1125 \par
1126         {\cf17 private}:\par
1127             TestRegistry m_testCaseRegistry;\par
1128             ReporterRegistry m_reporterRegistry;\par
1129             ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;\par
1130             TagAliasRegistry m_tagAliasRegistry;\par
1131             StartupExceptionRegistry m_exceptionRegistry;\par
1132             Detail::EnumValuesRegistry m_enumValuesRegistry;\par
1133         \};\par
1134     \}\par
1135 \par
1136     {\cf17 using }RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;\par
1137 \par
1138     IRegistryHub {\cf17 const}& getRegistryHub() \{\par
1139         {\cf19 return} RegistryHubSingleton::get();\par
1140     \}\par
1141     IMutableRegistryHub& getMutableRegistryHub() \{\par
1142         {\cf19 return} RegistryHubSingleton::getMutable();\par
1143     \}\par
1144     {\cf18 void} cleanUp() \{\par
1145         cleanupSingletons();\par
1146         cleanUpContext();\par
1147     \}\par
1148     std::string translateActiveException() \{\par
1149         {\cf19 return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();\par
1150     \}\par
1151 \par
1152 \par
1153 \} {\cf20 // end namespace Catch}\par
1154 \par
1155 \par
1156 \par
1157 {\cf21 #include <algorithm>}\par
1158 {\cf21 #include <cassert>}\par
1159 {\cf21 #include <exception>}\par
1160 {\cf21 #include <iomanip>}\par
1161 {\cf21 #include <set>}\par
1162 \par
1163 {\cf17 namespace }Catch \{\par
1164 \par
1165     {\cf17 namespace }\{\par
1166         {\cf17 const} {\cf18 int} MaxExitCode = 255;\par
1167 \par
1168         IEventListenerPtr createReporter(std::string {\cf17 const}& reporterName, ReporterConfig&& config) \{\par
1169             {\cf17 auto} reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, CATCH_MOVE(config));\par
1170             CATCH_ENFORCE(reporter, {\cf22 "No reporter registered with name: '"} << reporterName << {\cf23 '\\''});\par
1171 \par
1172             {\cf19 return} reporter;\par
1173         \}\par
1174 \par
1175         IEventListenerPtr prepareReporters(Config {\cf17 const}* config) \{\par
1176             {\cf19 if} (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()\par
1177                     && config->getProcessedReporterSpecs().size() == 1) \{\par
1178                 {\cf17 auto} {\cf17 const}& spec = config->getProcessedReporterSpecs()[0];\par
1179                 {\cf19 return} createReporter(\par
1180                     spec.name,\par
1181                     ReporterConfig( config,\par
1182                                     makeStream( spec.outputFilename ),\par
1183                                     spec.colourMode,\par
1184                                     spec.customOptions ) );\par
1185             \}\par
1186 \par
1187             {\cf17 auto} multi = Detail::make_unique<MultiReporter>(config);\par
1188 \par
1189             {\cf17 auto} {\cf17 const}& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();\par
1190             {\cf19 for} ({\cf17 auto} {\cf17 const}& listener : listeners) \{\par
1191                 multi->addListener(listener->create(config));\par
1192             \}\par
1193 \par
1194             {\cf19 for} ( {\cf17 auto} {\cf17 const}& reporterSpec : config->getProcessedReporterSpecs() ) \{\par
1195                 multi->addReporter( createReporter(\par
1196                     reporterSpec.name,\par
1197                     ReporterConfig( config,\par
1198                                     makeStream( reporterSpec.outputFilename ),\par
1199                                     reporterSpec.colourMode,\par
1200                                     reporterSpec.customOptions ) ) );\par
1201             \}\par
1202 \par
1203             {\cf19 return} multi;\par
1204         \}\par
1205 \par
1206         {\cf17 class }TestGroup \{\par
1207         {\cf17 public}:\par
1208             {\cf17 explicit} TestGroup(IEventListenerPtr&& reporter, Config {\cf17 const}* config):\par
1209                 m_reporter(reporter.get()),\par
1210                 m_config\{config\},\par
1211                 m_context\{config, CATCH_MOVE(reporter)\} \{\par
1212 \par
1213                 assert( m_config->testSpec().getInvalidSpecs().empty() &&\par
1214                         {\cf22 "Invalid test specs should be handled before running tests"} );\par
1215 \par
1216                 {\cf17 auto} {\cf17 const}& allTestCases = getAllTestCasesSorted(*m_config);\par
1217                 {\cf17 auto} {\cf17 const}& testSpec = m_config->testSpec();\par
1218                 {\cf19 if} ( !testSpec.hasFilters() ) \{\par
1219                     {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : allTestCases ) \{\par
1220                         {\cf19 if} ( !test.getTestCaseInfo().isHidden() ) \{\par
1221                             m_tests.emplace( &test );\par
1222                         \}\par
1223                     \}\par
1224                 \} {\cf19 else} \{\par
1225                     m_matches =\par
1226                         testSpec.matchesByFilter( allTestCases, *m_config );\par
1227                     {\cf19 for} ( {\cf17 auto} {\cf17 const}& match : m_matches ) \{\par
1228                         m_tests.insert( match.tests.begin(),\par
1229                                         match.tests.end() );\par
1230                     \}\par
1231                 \}\par
1232 \par
1233                 m_tests = createShard(m_tests, m_config->shardCount(), m_config->shardIndex());\par
1234             \}\par
1235 \par
1236             Totals execute() \{\par
1237                 Totals totals;\par
1238                 {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : m_tests) \{\par
1239                     {\cf19 if} (!m_context.aborting())\par
1240                         totals += m_context.runTest(*testCase);\par
1241                     {\cf19 else}\par
1242                         m_reporter->skipTest(testCase->getTestCaseInfo());\par
1243                 \}\par
1244 \par
1245                 {\cf19 for} ({\cf17 auto} {\cf17 const}& match : m_matches) \{\par
1246                     {\cf19 if} (match.tests.empty()) \{\par
1247                         m_unmatchedTestSpecs = {\cf17 true};\par
1248                         m_reporter->noMatchingTestCases( match.name );\par
1249                     \}\par
1250                 \}\par
1251 \par
1252                 {\cf19 return} totals;\par
1253             \}\par
1254 \par
1255             {\cf18 bool} hadUnmatchedTestSpecs(){\cf17  const }\{\par
1256                 {\cf19 return} m_unmatchedTestSpecs;\par
1257             \}\par
1258 \par
1259 \par
1260         {\cf17 private}:\par
1261             IEventListener* m_reporter;\par
1262             Config {\cf17 const}* m_config;\par
1263             RunContext m_context;\par
1264             std::set<TestCaseHandle const*> m_tests;\par
1265             TestSpec::Matches m_matches;\par
1266             {\cf18 bool} m_unmatchedTestSpecs = {\cf17 false};\par
1267         \};\par
1268 \par
1269         {\cf18 void} applyFilenamesAsTags() \{\par
1270             {\cf19 for} ({\cf17 auto} {\cf17 const}& testInfo : getRegistryHub().getTestCaseRegistry().getAllInfos()) \{\par
1271                 testInfo->addFilenameTag();\par
1272             \}\par
1273         \}\par
1274 \par
1275     \} {\cf20 // anon namespace}\par
1276 \par
1277     Session::Session() \{\par
1278         {\cf17 static} {\cf18 bool} alreadyInstantiated = {\cf17 false};\par
1279         {\cf19 if}( alreadyInstantiated ) \{\par
1280             CATCH_TRY \{ CATCH_INTERNAL_ERROR( {\cf22 "Only one instance of Catch::Session can ever be used"} ); \}\par
1281             CATCH_CATCH_ALL \{ getMutableRegistryHub().registerStartupException(); \}\par
1282         \}\par
1283 \par
1284         {\cf20 // There cannot be exceptions at startup in no-exception mode.}\par
1285 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
1286         {\cf17 const} {\cf17 auto}& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();\par
1287         {\cf19 if} ( !exceptions.empty() ) \{\par
1288             config();\par
1289             getCurrentMutableContext().setConfig(m_config.get());\par
1290 \par
1291             m_startupExceptions = {\cf17 true};\par
1292             {\cf17 auto} errStream = makeStream( {\cf22 "%stderr"} );\par
1293             {\cf17 auto} colourImpl = makeColourImpl(\par
1294                 ColourMode::PlatformDefault, errStream.get() );\par
1295             {\cf17 auto} guard = colourImpl->guardColour( Colour::Red );\par
1296             errStream->stream() << {\cf22 "Errors occurred during startup!"} << {\cf23 '\\n'};\par
1297             {\cf20 // iterate over all exceptions and notify user}\par
1298             {\cf19 for} ( {\cf17 const} {\cf17 auto}& ex_ptr : exceptions ) \{\par
1299                 {\cf19 try} \{\par
1300                     std::rethrow_exception(ex_ptr);\par
1301                 \} {\cf19 catch} ( std::exception {\cf17 const}& ex ) \{\par
1302                     errStream->stream() << TextFlow::Column( ex.what() ).indent(2) << {\cf23 '\\n'};\par
1303                 \}\par
1304             \}\par
1305         \}\par
1306 {\cf21 #endif}\par
1307 \par
1308         alreadyInstantiated = {\cf17 true};\par
1309         m_cli = makeCommandLineParser( m_configData );\par
1310     \}\par
1311     Session::~Session() \{\par
1312         Catch::cleanUp();\par
1313     \}\par
1314 \par
1315     {\cf18 void} Session::showHelp(){\cf17  const }\{\par
1316         Catch::cout()\par
1317                 << {\cf22 "\\nCatch2 v"} << libraryVersion() << {\cf23 '\\n'}\par
1318                 << m_cli << {\cf23 '\\n'}\par
1319                 << {\cf22 "For more detailed usage please see the project docs\\n\\n"} << std::flush;\par
1320     \}\par
1321     {\cf18 void} Session::libIdentify() \{\par
1322         Catch::cout()\par
1323                 << std::left << std::setw(16) << {\cf22 "description: "} << {\cf22 "A Catch2 test executable\\n"}\par
1324                 << std::left << std::setw(16) << {\cf22 "category: "} << {\cf22 "testframework\\n"}\par
1325                 << std::left << std::setw(16) << {\cf22 "framework: "} << {\cf22 "Catch2\\n"}\par
1326                 << std::left << std::setw(16) << {\cf22 "version: "} << libraryVersion() << {\cf23 '\\n'} << std::flush;\par
1327     \}\par
1328 \par
1329     {\cf18 int} Session::applyCommandLine( {\cf18 int} argc, {\cf18 char} {\cf17 const} * {\cf17 const} * argv ) \{\par
1330         {\cf19 if}( m_startupExceptions )\par
1331             {\cf19 return} 1;\par
1332 \par
1333         {\cf17 auto} result = m_cli.parse( Clara::Args( argc, argv ) );\par
1334 \par
1335         {\cf19 if}( !result ) \{\par
1336             config();\par
1337             getCurrentMutableContext().setConfig(m_config.get());\par
1338             {\cf17 auto} errStream = makeStream( {\cf22 "%stderr"} );\par
1339             {\cf17 auto} colour = makeColourImpl( ColourMode::PlatformDefault, errStream.get() );\par
1340 \par
1341             errStream->stream()\par
1342                 << colour->guardColour( Colour::Red )\par
1343                 << {\cf22 "\\nError(s) in input:\\n"}\par
1344                 << TextFlow::Column( result.errorMessage() ).indent( 2 )\par
1345                 << {\cf22 "\\n\\n"};\par
1346             errStream->stream() << {\cf22 "Run with -? for usage\\n\\n"} << std::flush;\par
1347             {\cf19 return} MaxExitCode;\par
1348         \}\par
1349 \par
1350         {\cf19 if}( m_configData.showHelp )\par
1351             showHelp();\par
1352         {\cf19 if}( m_configData.libIdentify )\par
1353             libIdentify();\par
1354 \par
1355         m_config.reset();\par
1356         {\cf19 return} 0;\par
1357     \}\par
1358 \par
1359 {\cf21 #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)}\par
1360     {\cf18 int} Session::applyCommandLine( {\cf18 int} argc, {\cf18 wchar_t} {\cf17 const} * {\cf17 const} * argv ) \{\par
1361 \par
1362         {\cf18 char} **utf8Argv = {\cf17 new} {\cf18 char} *[ argc ];\par
1363 \par
1364         {\cf19 for} ( {\cf18 int} i = 0; i < argc; ++i ) \{\par
1365             {\cf18 int} bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, {\cf17 nullptr}, 0, {\cf17 nullptr}, {\cf17 nullptr} );\par
1366 \par
1367             utf8Argv[ i ] = {\cf17 new} {\cf18 char}[ bufSize ];\par
1368 \par
1369             WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, {\cf17 nullptr}, {\cf17 nullptr} );\par
1370         \}\par
1371 \par
1372         {\cf18 int} returnCode = applyCommandLine( argc, utf8Argv );\par
1373 \par
1374         {\cf19 for} ( {\cf18 int} i = 0; i < argc; ++i )\par
1375             {\cf17 delete} [] utf8Argv[ i ];\par
1376 \par
1377         {\cf17 delete} [] utf8Argv;\par
1378 \par
1379         {\cf19 return} returnCode;\par
1380     \}\par
1381 {\cf21 #endif}\par
1382 \par
1383     {\cf18 void} Session::useConfigData( ConfigData {\cf17 const}& configData ) \{\par
1384         m_configData = configData;\par
1385         m_config.reset();\par
1386     \}\par
1387 \par
1388     {\cf18 int} Session::run() \{\par
1389         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) \{\par
1390             Catch::cout() << {\cf22 "...waiting for enter/ return before starting\\n"} << std::flush;\par
1391             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
1392         \}\par
1393         {\cf18 int} exitCode = runInternal();\par
1394         {\cf19 if}( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) \{\par
1395             Catch::cout() << {\cf22 "...waiting for enter/ return before exiting, with code: "} << exitCode << {\cf23 '\\n'} << std::flush;\par
1396             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(std::getchar());\par
1397         \}\par
1398         {\cf19 return} exitCode;\par
1399     \}\par
1400 \par
1401     Clara::Parser {\cf17 const}& Session::cli(){\cf17  const }\{\par
1402         {\cf19 return} m_cli;\par
1403     \}\par
1404     {\cf18 void} Session::cli( Clara::Parser {\cf17 const}& newParser ) \{\par
1405         m_cli = newParser;\par
1406     \}\par
1407     ConfigData& Session::configData() \{\par
1408         {\cf19 return} m_configData;\par
1409     \}\par
1410     Config& Session::config() \{\par
1411         {\cf19 if}( !m_config )\par
1412             m_config = Detail::make_unique<Config>( m_configData );\par
1413         {\cf19 return} *m_config;\par
1414     \}\par
1415 \par
1416     {\cf18 int} Session::runInternal() \{\par
1417         {\cf19 if}( m_startupExceptions )\par
1418             {\cf19 return} 1;\par
1419 \par
1420         {\cf19 if} (m_configData.showHelp || m_configData.libIdentify) \{\par
1421             {\cf19 return} 0;\par
1422         \}\par
1423 \par
1424         {\cf19 if} ( m_configData.shardIndex >= m_configData.shardCount ) \{\par
1425             Catch::cerr() << {\cf22 "The shard count ("} << m_configData.shardCount\par
1426                           << {\cf22 ") must be greater than the shard index ("}\par
1427                           << m_configData.shardIndex << {\cf22 ")\\n"}\par
1428                           << std::flush;\par
1429             {\cf19 return} 1;\par
1430         \}\par
1431 \par
1432         CATCH_TRY \{\par
1433             config(); {\cf20 // Force config to be constructed}\par
1434 \par
1435             seedRng( *m_config );\par
1436 \par
1437             {\cf19 if} (m_configData.filenamesAsTags) \{\par
1438                 applyFilenamesAsTags();\par
1439             \}\par
1440 \par
1441             {\cf20 // Set up global config instance before we start calling into other functions}\par
1442             getCurrentMutableContext().setConfig(m_config.get());\par
1443 \par
1444             {\cf20 // Create reporter(s) so we can route listings through them}\par
1445             {\cf17 auto} reporter = prepareReporters(m_config.get());\par
1446 \par
1447             {\cf17 auto} {\cf17 const}& invalidSpecs = m_config->testSpec().getInvalidSpecs();\par
1448             {\cf19 if} ( !invalidSpecs.empty() ) \{\par
1449                 {\cf19 for} ( {\cf17 auto} {\cf17 const}& spec : invalidSpecs ) \{\par
1450                     reporter->reportInvalidTestSpec( spec );\par
1451                 \}\par
1452                 {\cf19 return} 1;\par
1453             \}\par
1454 \par
1455 \par
1456             {\cf20 // Handle list request}\par
1457             {\cf19 if} (list(*reporter, *m_config)) \{\par
1458                 {\cf19 return} 0;\par
1459             \}\par
1460 \par
1461             TestGroup tests \{ CATCH_MOVE(reporter), m_config.get() \};\par
1462             {\cf17 auto} {\cf17 const} totals = tests.execute();\par
1463 \par
1464             {\cf19 if} ( tests.hadUnmatchedTestSpecs()\par
1465                 && m_config->warnAboutUnmatchedTestSpecs() ) \{\par
1466                 {\cf19 return} 3;\par
1467             \}\par
1468 \par
1469             {\cf19 if} ( totals.testCases.total() == 0\par
1470                 && !m_config->zeroTestsCountAsSuccess() ) \{\par
1471                 {\cf19 return} 2;\par
1472             \}\par
1473 \par
1474             {\cf19 if} ( totals.testCases.total() > 0 &&\par
1475                  totals.testCases.total() == totals.testCases.skipped\par
1476                 && !m_config->zeroTestsCountAsSuccess() ) \{\par
1477                 {\cf19 return} 4;\par
1478             \}\par
1479 \par
1480             {\cf20 // Note that on unices only the lower 8 bits are usually used, clamping}\par
1481             {\cf20 // the return value to 255 prevents false negative when some multiple}\par
1482             {\cf20 // of 256 tests has failed}\par
1483             {\cf19 return} (std::min) (MaxExitCode, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(totals.assertions.failed));\par
1484         \}\par
1485 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
1486         {\cf19 catch}( std::exception& ex ) \{\par
1487             Catch::cerr() << ex.what() << {\cf23 '\\n'} << std::flush;\par
1488             {\cf19 return} MaxExitCode;\par
1489         \}\par
1490 {\cf21 #endif}\par
1491     \}\par
1492 \par
1493 \} {\cf20 // end namespace Catch}\par
1494 \par
1495 \par
1496 \par
1497 \par
1498 {\cf17 namespace }Catch \{\par
1499 \par
1500     RegistrarForTagAliases::RegistrarForTagAliases({\cf18 char} {\cf17 const}* alias, {\cf18 char} {\cf17 const}* tag, SourceLineInfo {\cf17 const}& lineInfo) \{\par
1501         CATCH_TRY \{\par
1502             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);\par
1503         \} CATCH_CATCH_ALL \{\par
1504             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
1505             getMutableRegistryHub().registerStartupException();\par
1506         \}\par
1507     \}\par
1508 \par
1509 \}\par
1510 \par
1511 \par
1512 \par
1513 {\cf21 #include <cassert>}\par
1514 {\cf21 #include <cctype>}\par
1515 {\cf21 #include <algorithm>}\par
1516 \par
1517 {\cf17 namespace }Catch \{\par
1518 \par
1519     {\cf17 namespace }\{\par
1520         {\cf17 using }TCP_underlying_type = uint8_t;\par
1521         {\cf17 static_assert}({\cf17 sizeof}(TestCaseProperties) == {\cf17 sizeof}(TCP_underlying_type),\par
1522                       {\cf22 "The size of the TestCaseProperties is different from the assumed size"});\par
1523 \par
1524         TestCaseProperties operator|(TestCaseProperties lhs, TestCaseProperties rhs) \{\par
1525             {\cf19 return} {\cf17 static_cast<}TestCaseProperties{\cf17 >}(\par
1526                 {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(lhs) | {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(rhs)\par
1527             );\par
1528         \}\par
1529 \par
1530         TestCaseProperties& operator|=(TestCaseProperties& lhs, TestCaseProperties rhs) \{\par
1531             lhs = {\cf17 static_cast<}TestCaseProperties{\cf17 >}(\par
1532                 {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(lhs) | {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(rhs)\par
1533             );\par
1534             {\cf19 return} lhs;\par
1535         \}\par
1536 \par
1537         TestCaseProperties operator&(TestCaseProperties lhs, TestCaseProperties rhs) \{\par
1538             {\cf19 return} {\cf17 static_cast<}TestCaseProperties{\cf17 >}(\par
1539                 {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(lhs) & {\cf17 static_cast<}TCP_underlying_type{\cf17 >}(rhs)\par
1540             );\par
1541         \}\par
1542 \par
1543         {\cf18 bool} applies(TestCaseProperties tcp) \{\par
1544             {\cf17 static_assert}({\cf17 static_cast<}TCP_underlying_type{\cf17 >}(TestCaseProperties::None) == 0,\par
1545                           {\cf22 "TestCaseProperties::None must be equal to 0"});\par
1546             {\cf19 return} tcp != TestCaseProperties::None;\par
1547         \}\par
1548 \par
1549         TestCaseProperties parseSpecialTag( StringRef tag ) \{\par
1550             {\cf19 if}( !tag.empty() && tag[0] == {\cf23 '.'} )\par
1551                 {\cf19 return} TestCaseProperties::IsHidden;\par
1552             {\cf19 else} {\cf19 if}( tag == {\cf22 "!throws"}_sr )\par
1553                 {\cf19 return} TestCaseProperties::Throws;\par
1554             {\cf19 else} {\cf19 if}( tag == {\cf22 "!shouldfail"}_sr )\par
1555                 {\cf19 return} TestCaseProperties::ShouldFail;\par
1556             {\cf19 else} {\cf19 if}( tag == {\cf22 "!mayfail"}_sr )\par
1557                 {\cf19 return} TestCaseProperties::MayFail;\par
1558             {\cf19 else} {\cf19 if}( tag == {\cf22 "!nonportable"}_sr )\par
1559                 {\cf19 return} TestCaseProperties::NonPortable;\par
1560             {\cf19 else} {\cf19 if}( tag == {\cf22 "!benchmark"}_sr )\par
1561                 {\cf19 return} TestCaseProperties::Benchmark | TestCaseProperties::IsHidden;\par
1562             {\cf19 else}\par
1563                 {\cf19 return} TestCaseProperties::None;\par
1564         \}\par
1565         {\cf18 bool} isReservedTag( StringRef tag ) \{\par
1566             {\cf19 return} parseSpecialTag( tag ) == TestCaseProperties::None\par
1567                 && tag.size() > 0\par
1568                 && !std::isalnum( {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(tag[0]) );\par
1569         \}\par
1570         {\cf18 void} enforceNotReservedTag( StringRef tag, SourceLineInfo {\cf17 const}& _lineInfo ) \{\par
1571             CATCH_ENFORCE( !isReservedTag(tag),\par
1572                           {\cf22 "Tag name: ["} << tag << {\cf22 "] is not allowed.\\n"}\par
1573                           << {\cf22 "Tag names starting with non alphanumeric characters are reserved\\n"}\par
1574                           << _lineInfo );\par
1575         \}\par
1576 \par
1577         std::string makeDefaultName() \{\par
1578             {\cf17 static} {\cf18 size_t} counter = 0;\par
1579             {\cf19 return} {\cf22 "Anonymous test case "} + std::to_string(++counter);\par
1580         \}\par
1581 \par
1582         StringRef extractFilenamePart(StringRef filename) \{\par
1583             {\cf18 size_t} lastDot = filename.size();\par
1584             {\cf19 while} (lastDot > 0 && filename[lastDot - 1] != {\cf23 '.'}) \{\par
1585                 --lastDot;\par
1586             \}\par
1587             {\cf20 // In theory we could have filename without any extension in it}\par
1588             {\cf19 if} ( lastDot == 0 ) \{ {\cf19 return} StringRef(); \}\par
1589 \par
1590             --lastDot;\par
1591             {\cf18 size_t} nameStart = lastDot;\par
1592             {\cf19 while} (nameStart > 0 && filename[nameStart - 1] != {\cf23 '/'} && filename[nameStart - 1] != {\cf23 '\\\\'}) \{\par
1593                 --nameStart;\par
1594             \}\par
1595 \par
1596             {\cf19 return} filename.substr(nameStart, lastDot - nameStart);\par
1597         \}\par
1598 \par
1599         {\cf20 // Returns the upper bound on size of extra tags ([#file]+[.])}\par
1600         {\cf18 size_t} sizeOfExtraTags(StringRef filepath) \{\par
1601             {\cf20 // [.] is 3, [#] is another 3}\par
1602             {\cf17 const} {\cf18 size_t} extras = 3 + 3;\par
1603             {\cf19 return} extractFilenamePart(filepath).size() + extras;\par
1604         \}\par
1605     \} {\cf20 // end unnamed namespace}\par
1606 \par
1607     {\cf18 bool} operator<(  Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs ) \{\par
1608         Detail::CaseInsensitiveLess cmp;\par
1609         {\cf19 return} cmp( lhs.original, rhs.original );\par
1610     \}\par
1611     {\cf18 bool} operator==( Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs ) \{\par
1612         Detail::CaseInsensitiveEqualTo cmp;\par
1613         {\cf19 return} cmp( lhs.original, rhs.original );\par
1614     \}\par
1615 \par
1616     Detail::unique_ptr<TestCaseInfo>\par
1617         makeTestCaseInfo(StringRef _className,\par
1618                          NameAndTags {\cf17 const}& nameAndTags,\par
1619                          SourceLineInfo {\cf17 const}& _lineInfo ) \{\par
1620         {\cf19 return} Detail::make_unique<TestCaseInfo>(_className, nameAndTags, _lineInfo);\par
1621     \}\par
1622 \par
1623     TestCaseInfo::TestCaseInfo(StringRef _className,\par
1624                                NameAndTags {\cf17 const}& _nameAndTags,\par
1625                                SourceLineInfo {\cf17 const}& _lineInfo):\par
1626         name( _nameAndTags.name.empty() ? makeDefaultName() : _nameAndTags.name ),\par
1627         className( _className ),\par
1628         lineInfo( _lineInfo )\par
1629     \{\par
1630         StringRef originalTags = _nameAndTags.tags;\par
1631         {\cf20 // We need to reserve enough space to store all of the tags}\par
1632         {\cf20 // (including optional hidden tag and filename tag)}\par
1633         {\cf17 auto} requiredSize = originalTags.size() + sizeOfExtraTags(_lineInfo.file);\par
1634         backingTags.reserve(requiredSize);\par
1635 \par
1636         {\cf20 // We cannot copy the tags directly, as we need to normalize}\par
1637         {\cf20 // some tags, so that [.foo] is copied as [.][foo].}\par
1638         {\cf18 size_t} tagStart = 0;\par
1639         {\cf18 size_t} tagEnd = 0;\par
1640         {\cf18 bool} inTag = {\cf17 false};\par
1641         for ({\cf18 size_t} idx = 0; idx < originalTags.size(); ++idx) \{\par
1642             {\cf17 auto} c = originalTags[idx];\par
1643             {\cf19 if} (c == {\cf23 '['}) \{\par
1644                 CATCH_ENFORCE(\par
1645                     !inTag,\par
1646                     {\cf22 "Found '[' inside a tag while registering test case '"}\par
1647                         << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1648 \par
1649                 inTag = {\cf17 true};\par
1650                 tagStart = idx;\par
1651             \}\par
1652             {\cf19 if} (c == {\cf23 ']'}) \{\par
1653                 CATCH_ENFORCE(\par
1654                     inTag,\par
1655                     {\cf22 "Found unmatched ']' while registering test case '"}\par
1656                         << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1657 \par
1658                 inTag = {\cf17 false};\par
1659                 tagEnd = idx;\par
1660                 assert(tagStart < tagEnd);\par
1661 \par
1662                 {\cf20 // We need to check the tag for special meanings, copy}\par
1663                 {\cf20 // it over to backing storage and actually reference the}\par
1664                 {\cf20 // backing storage in the saved tags}\par
1665                 StringRef tagStr = originalTags.substr(tagStart+1, tagEnd - tagStart - 1);\par
1666                 CATCH_ENFORCE( !tagStr.empty(),\par
1667                                {\cf22 "Found an empty tag while registering test case '"}\par
1668                                    << _nameAndTags.name << {\cf22 "' at "}\par
1669                                    << _lineInfo );\par
1670 \par
1671                 enforceNotReservedTag(tagStr, lineInfo);\par
1672                 properties |= parseSpecialTag(tagStr);\par
1673                 {\cf20 // When copying a tag to the backing storage, we need to}\par
1674                 {\cf20 // check if it is a merged hide tag, such as [.foo], and}\par
1675                 {\cf20 // if it is, we need to handle it as if it was [foo].}\par
1676                 {\cf19 if} (tagStr.size() > 1 && tagStr[0] == {\cf23 '.'}) \{\par
1677                     tagStr = tagStr.substr(1, tagStr.size() - 1);\par
1678                 \}\par
1679                 {\cf20 // We skip over dealing with the [.] tag, as we will add}\par
1680                 {\cf20 // it later unconditionally and then sort and unique all}\par
1681                 {\cf20 // the tags.}\par
1682                 internalAppendTag(tagStr);\par
1683             \}\par
1684         \}\par
1685         CATCH_ENFORCE( !inTag,\par
1686                        {\cf22 "Found an unclosed tag while registering test case '"}\par
1687                            << _nameAndTags.name << {\cf22 "' at "} << _lineInfo );\par
1688 \par
1689 \par
1690         {\cf20 // Add [.] if relevant}\par
1691         {\cf19 if} (isHidden()) \{\par
1692             internalAppendTag({\cf22 "."}_sr);\par
1693         \}\par
1694 \par
1695         {\cf20 // Sort and prepare tags}\par
1696         std::sort(begin(tags), end(tags));\par
1697         tags.erase(std::unique(begin(tags), end(tags)),\par
1698                    end(tags));\par
1699     \}\par
1700 \par
1701     {\cf18 bool} TestCaseInfo::isHidden(){\cf17  const }\{\par
1702         {\cf19 return} applies( properties & TestCaseProperties::IsHidden );\par
1703     \}\par
1704     {\cf18 bool} TestCaseInfo::throws(){\cf17  const }\{\par
1705         {\cf19 return} applies( properties & TestCaseProperties::Throws );\par
1706     \}\par
1707     {\cf18 bool} TestCaseInfo::okToFail(){\cf17  const }\{\par
1708         {\cf19 return} applies( properties & (TestCaseProperties::ShouldFail | TestCaseProperties::MayFail ) );\par
1709     \}\par
1710     {\cf18 bool} TestCaseInfo::expectedToFail(){\cf17  const }\{\par
1711         {\cf19 return} applies( properties & (TestCaseProperties::ShouldFail) );\par
1712     \}\par
1713 \par
1714     {\cf18 void} TestCaseInfo::addFilenameTag() \{\par
1715         std::string combined({\cf22 "#"});\par
1716         combined += extractFilenamePart(lineInfo.file);\par
1717         internalAppendTag(combined);\par
1718     \}\par
1719 \par
1720     std::string TestCaseInfo::tagsAsString(){\cf17  const }\{\par
1721         std::string ret;\par
1722         {\cf20 // '[' and ']' per tag}\par
1723         std::size_t full_size = 2 * tags.size();\par
1724         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
1725             full_size += tag.original.size();\par
1726         \}\par
1727         ret.reserve(full_size);\par
1728         {\cf19 for} ({\cf17 const} {\cf17 auto}& tag : tags) \{\par
1729             ret.push_back({\cf23 '['});\par
1730             ret += tag.original;\par
1731             ret.push_back({\cf23 ']'});\par
1732         \}\par
1733 \par
1734         {\cf19 return} ret;\par
1735     \}\par
1736 \par
1737     {\cf18 void} TestCaseInfo::internalAppendTag(StringRef tagStr) \{\par
1738         backingTags += {\cf23 '['};\par
1739         {\cf17 const} {\cf17 auto} backingStart = backingTags.size();\par
1740         backingTags += tagStr;\par
1741         {\cf17 const} {\cf17 auto} backingEnd = backingTags.size();\par
1742         backingTags += {\cf23 ']'};\par
1743         tags.emplace_back(StringRef(backingTags.c_str() + backingStart, backingEnd - backingStart));\par
1744     \}\par
1745 \par
1746     {\cf18 bool} operator<( TestCaseInfo {\cf17 const}& lhs, TestCaseInfo {\cf17 const}& rhs ) \{\par
1747         {\cf20 // We want to avoid redoing the string comparisons multiple times,}\par
1748         {\cf20 // so we store the result of a three-way comparison before using}\par
1749         {\cf20 // it in the actual comparison logic.}\par
1750         {\cf17 const} {\cf17 auto} cmpName = lhs.name.compare( rhs.name );\par
1751         {\cf19 if} ( cmpName != 0 ) \{\par
1752             {\cf19 return} cmpName < 0;\par
1753         \}\par
1754         {\cf17 const} {\cf17 auto} cmpClassName = lhs.className.compare( rhs.className );\par
1755         {\cf19 if} ( cmpClassName != 0 ) \{\par
1756             {\cf19 return} cmpClassName < 0;\par
1757         \}\par
1758         {\cf19 return} lhs.tags < rhs.tags;\par
1759     \}\par
1760 \par
1761     TestCaseInfo {\cf17 const}& TestCaseHandle::getTestCaseInfo(){\cf17  const }\{\par
1762         {\cf19 return} *m_info;\par
1763     \}\par
1764 \par
1765 \} {\cf20 // end namespace Catch}\par
1766 \par
1767 \par
1768 \par
1769 {\cf21 #include <algorithm>}\par
1770 {\cf21 #include <string>}\par
1771 {\cf21 #include <vector>}\par
1772 {\cf21 #include <ostream>}\par
1773 \par
1774 {\cf17 namespace }Catch \{\par
1775 \par
1776     TestSpec::Pattern::Pattern( std::string {\cf17 const}& name )\par
1777     : m_name( name )\par
1778     \{\}\par
1779 \par
1780     TestSpec::Pattern::~Pattern() = {\cf19 default};\par
1781 \par
1782     std::string {\cf17 const}& TestSpec::Pattern::name(){\cf17  const }\{\par
1783         {\cf19 return} m_name;\par
1784     \}\par
1785 \par
1786 \par
1787     TestSpec::NamePattern::NamePattern( std::string {\cf17 const}& name, std::string {\cf17 const}& filterString )\par
1788     : Pattern( filterString )\par
1789     , m_wildcardPattern( toLower( name ), CaseSensitive::No )\par
1790     \{\}\par
1791 \par
1792     {\cf18 bool} TestSpec::NamePattern::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1793         {\cf19 return} m_wildcardPattern.matches( testCase.name );\par
1794     \}\par
1795 \par
1796     {\cf18 void} TestSpec::NamePattern::serializeTo( std::ostream& out ){\cf17  const }\{\par
1797         out << {\cf23 '"'} << name() << {\cf23 '"'};\par
1798     \}\par
1799 \par
1800 \par
1801     TestSpec::TagPattern::TagPattern( std::string {\cf17 const}& tag, std::string {\cf17 const}& filterString )\par
1802     : Pattern( filterString )\par
1803     , m_tag( tag )\par
1804     \{\}\par
1805 \par
1806     {\cf18 bool} TestSpec::TagPattern::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1807         {\cf19 return} std::find( begin( testCase.tags ),\par
1808                           end( testCase.tags ),\par
1809                           Tag( m_tag ) ) != end( testCase.tags );\par
1810     \}\par
1811 \par
1812     {\cf18 void} TestSpec::TagPattern::serializeTo( std::ostream& out ){\cf17  const }\{\par
1813         out << name();\par
1814     \}\par
1815 \par
1816     {\cf18 bool} TestSpec::Filter::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1817         {\cf18 bool} should_use = !testCase.isHidden();\par
1818         {\cf19 for} ({\cf17 auto} {\cf17 const}& pattern : m_required) \{\par
1819             should_use = {\cf17 true};\par
1820             {\cf19 if} (!pattern->matches(testCase)) \{\par
1821                 {\cf19 return} {\cf17 false};\par
1822             \}\par
1823         \}\par
1824         {\cf19 for} ({\cf17 auto} {\cf17 const}& pattern : m_forbidden) \{\par
1825             {\cf19 if} (pattern->matches(testCase)) \{\par
1826                 {\cf19 return} {\cf17 false};\par
1827             \}\par
1828         \}\par
1829         {\cf19 return} should_use;\par
1830     \}\par
1831 \par
1832     {\cf18 void} TestSpec::Filter::serializeTo( std::ostream& out ){\cf17  const }\{\par
1833         {\cf18 bool} first = {\cf17 true};\par
1834         {\cf19 for} ( {\cf17 auto} {\cf17 const}& pattern : m_required ) \{\par
1835             {\cf19 if} ( !first ) \{\par
1836                 out << {\cf23 ' '};\par
1837             \}\par
1838             out << *pattern;\par
1839             first = {\cf17 false};\par
1840         \}\par
1841         {\cf19 for} ( {\cf17 auto} {\cf17 const}& pattern : m_forbidden ) \{\par
1842             {\cf19 if} ( !first ) \{\par
1843                 out << {\cf23 ' '};\par
1844             \}\par
1845             out << *pattern;\par
1846             first = {\cf17 false};\par
1847         \}\par
1848     \}\par
1849 \par
1850 \par
1851     std::string TestSpec::extractFilterName( Filter {\cf17 const}& filter ) \{\par
1852         Catch::ReusableStringStream sstr;\par
1853         sstr << filter;\par
1854         {\cf19 return} sstr.str();\par
1855     \}\par
1856 \par
1857     {\cf18 bool} TestSpec::hasFilters(){\cf17  const }\{\par
1858         {\cf19 return} !m_filters.empty();\par
1859     \}\par
1860 \par
1861     {\cf18 bool} TestSpec::matches( TestCaseInfo {\cf17 const}& testCase ){\cf17  const }\{\par
1862         {\cf19 return} std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter {\cf17 const}& f )\{ return f.matches( testCase ); \} );\par
1863     \}\par
1864 \par
1865     TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCaseHandle> {\cf17 const}& testCases, IConfig {\cf17 const}& config ){\cf17  const }\{\par
1866         Matches matches;\par
1867         matches.reserve( m_filters.size() );\par
1868         {\cf19 for} ( {\cf17 auto} {\cf17 const}& filter : m_filters ) \{\par
1869             std::vector<TestCaseHandle const*> currentMatches;\par
1870             {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : testCases )\par
1871                 {\cf19 if} ( isThrowSafe( test, config ) &&\par
1872                      filter.matches( test.getTestCaseInfo() ) )\par
1873                     currentMatches.emplace_back( &test );\par
1874             matches.push_back(\par
1875                 FilterMatch\{ extractFilterName( filter ), currentMatches \} );\par
1876         \}\par
1877         {\cf19 return} matches;\par
1878     \}\par
1879 \par
1880     {\cf17 const} TestSpec::vectorStrings& TestSpec::getInvalidSpecs(){\cf17  const }\{\par
1881         {\cf19 return} m_invalidSpecs;\par
1882     \}\par
1883 \par
1884     {\cf18 void} TestSpec::serializeTo( std::ostream& out ){\cf17  const }\{\par
1885         {\cf18 bool} first = {\cf17 true};\par
1886         {\cf19 for} ( {\cf17 auto} {\cf17 const}& filter : m_filters ) \{\par
1887             {\cf19 if} ( !first ) \{\par
1888                 out << {\cf23 ','};\par
1889             \}\par
1890             out << filter;\par
1891             first = {\cf17 false};\par
1892         \}\par
1893     \}\par
1894 \par
1895 \}\par
1896 \par
1897 \par
1898 \par
1899 {\cf21 #include <chrono>}\par
1900 \par
1901 {\cf17 namespace }Catch \{\par
1902 \par
1903     {\cf17 namespace }\{\par
1904         {\cf17 static} {\cf17 auto} getCurrentNanosecondsSinceEpoch() -> uint64_t \{\par
1905             {\cf19 return} std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count();\par
1906         \}\par
1907     \} {\cf20 // end unnamed namespace}\par
1908 \par
1909     {\cf18 void} Timer::start() \{\par
1910        m_nanoseconds = getCurrentNanosecondsSinceEpoch();\par
1911     \}\par
1912     {\cf17 auto} Timer::getElapsedNanoseconds() const -> uint64_t \{\par
1913         {\cf19 return} getCurrentNanosecondsSinceEpoch() - m_nanoseconds;\par
1914     \}\par
1915     {\cf17 auto} Timer::getElapsedMicroseconds() const -> uint64_t \{\par
1916         {\cf19 return} getElapsedNanoseconds()/1000;\par
1917     \}\par
1918     {\cf17 auto} Timer::getElapsedMilliseconds() const -> {\cf18 unsigned} {\cf18 int} \{\par
1919         {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(getElapsedMicroseconds()/1000);\par
1920     \}\par
1921     {\cf17 auto} Timer::getElapsedSeconds() const -> {\cf18 double} \{\par
1922         {\cf19 return} getElapsedMicroseconds()/1000000.0;\par
1923     \}\par
1924 \par
1925 \par
1926 \} {\cf20 // namespace Catch}\par
1927 \par
1928 \par
1929 \par
1930 \par
1931 {\cf21 #include <cmath>}\par
1932 {\cf21 #include <iomanip>}\par
1933 \par
1934 {\cf17 namespace }Catch \{\par
1935 \par
1936 {\cf17 namespace }Detail \{\par
1937 \par
1938     {\cf17 namespace }\{\par
1939         {\cf17 const} {\cf18 int} hexThreshold = 255;\par
1940 \par
1941         {\cf17 struct }Endianness \{\par
1942             {\cf17 enum} Arch \{ Big, Little \};\par
1943 \par
1944             {\cf17 static} Arch which() \{\par
1945                 {\cf18 int} one = 1;\par
1946                 {\cf20 // If the lowest byte we read is non-zero, we can assume}\par
1947                 {\cf20 // that little endian format is used.}\par
1948                 {\cf17 auto} value = *{\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >}(&one);\par
1949                 {\cf19 return} value ? Little : Big;\par
1950             \}\par
1951         \};\par
1952 \par
1953         {\cf17 template}<{\cf17 typename} T>\par
1954         std::string fpToString(T value, {\cf18 int} precision) \{\par
1955             {\cf19 if} (Catch::isnan(value)) \{\par
1956                 {\cf19 return} {\cf22 "nan"};\par
1957             \}\par
1958 \par
1959             ReusableStringStream rss;\par
1960             rss << std::setprecision(precision)\par
1961                 << std::fixed\par
1962                 << value;\par
1963             std::string d = rss.str();\par
1964             std::size_t i = d.find_last_not_of({\cf23 '0'});\par
1965             {\cf19 if} (i != std::string::npos && i != d.size() - 1) \{\par
1966                 {\cf19 if} (d[i] == {\cf23 '.'})\par
1967                     i++;\par
1968                 d = d.substr(0, i + 1);\par
1969             \}\par
1970             {\cf19 return} d;\par
1971         \}\par
1972     \} {\cf20 // end unnamed namespace}\par
1973 \par
1974     std::string convertIntoString(StringRef {\cf18 string}, {\cf18 bool} escapeInvisibles) \{\par
1975         std::string ret;\par
1976         {\cf20 // This is enough for the "don't escape invisibles" case, and a good}\par
1977         {\cf20 // lower bound on the "escape invisibles" case.}\par
1978         ret.reserve({\cf18 string}.size() + 2);\par
1979 \par
1980         {\cf19 if} (!escapeInvisibles) \{\par
1981             ret += {\cf23 '"'};\par
1982             ret += string;\par
1983             ret += {\cf23 '"'};\par
1984             {\cf19 return} ret;\par
1985         \}\par
1986 \par
1987         ret += {\cf23 '"'};\par
1988         {\cf19 for} ({\cf18 char} c : {\cf18 string}) \{\par
1989             {\cf19 switch} (c) \{\par
1990             {\cf19 case} {\cf23 '\\r'}:\par
1991                 ret.append({\cf22 "\\\\r"});\par
1992                 {\cf19 break};\par
1993             {\cf19 case} {\cf23 '\\n'}:\par
1994                 ret.append({\cf22 "\\\\n"});\par
1995                 {\cf19 break};\par
1996             {\cf19 case} {\cf23 '\\t'}:\par
1997                 ret.append({\cf22 "\\\\t"});\par
1998                 {\cf19 break};\par
1999             {\cf19 case} {\cf23 '\\f'}:\par
2000                 ret.append({\cf22 "\\\\f"});\par
2001                 {\cf19 break};\par
2002             {\cf19 default}:\par
2003                 ret.push_back(c);\par
2004                 {\cf19 break};\par
2005             \}\par
2006         \}\par
2007         ret += {\cf23 '"'};\par
2008 \par
2009         {\cf19 return} ret;\par
2010     \}\par
2011 \par
2012     std::string convertIntoString(StringRef {\cf18 string}) \{\par
2013         {\cf19 return} convertIntoString({\cf18 string}, getCurrentContext().getConfig()->showInvisibles());\par
2014     \}\par
2015 \par
2016     std::string rawMemoryToString( {\cf17 const} {\cf18 void} *{\cf18 object}, std::size_t size ) \{\par
2017         {\cf20 // Reverse order for little endian architectures}\par
2018         {\cf18 int} i = 0, end = {\cf17 static_cast<}{\cf18 int}{\cf17 >}( size ), inc = 1;\par
2019         {\cf19 if}( Endianness::which() == Endianness::Little ) \{\par
2020             i = end-1;\par
2021             end = inc = -1;\par
2022         \}\par
2023 \par
2024         {\cf18 unsigned} {\cf18 char} {\cf17 const} *bytes = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char} {\cf17 const }*{\cf17 >}(object);\par
2025         ReusableStringStream rss;\par
2026         rss << {\cf22 "0x"} << std::setfill({\cf23 '0'}) << std::hex;\par
2027         {\cf19 for}( ; i != end; i += inc )\par
2028              rss << std::setw(2) << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(bytes[i]);\par
2029        {\cf19 return} rss.str();\par
2030     \}\par
2031 \} {\cf20 // end Detail namespace}\par
2032 \par
2033 \par
2034 \par
2036 {\cf20 //}\par
2037 {\cf20 //   Out-of-line defs for full specialization of StringMaker}\par
2038 {\cf20 //}\par
2040 \par
2041 std::string StringMaker<std::string>::convert({\cf17 const} std::string& str) \{\par
2042     {\cf19 return} Detail::convertIntoString( str );\par
2043 \}\par
2044 \par
2045 {\cf21 #ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2046 std::string StringMaker<std::string_view>::convert(std::string_view str) \{\par
2047     {\cf19 return} Detail::convertIntoString( StringRef( str.data(), str.size() ) );\par
2048 \}\par
2049 {\cf21 #endif}\par
2050 \par
2051 std::string StringMaker<char const*>::convert({\cf18 char} {\cf17 const}* str) \{\par
2052     {\cf19 if} (str) \{\par
2053         {\cf19 return} Detail::convertIntoString( str );\par
2054     \} {\cf19 else} \{\par
2055         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2056     \}\par
2057 \}\par
2058 std::string StringMaker<char*>::convert({\cf18 char}* str) \{ {\cf20 // NOLINT(readability-non-const-parameter)}\par
2059     {\cf19 if} (str) \{\par
2060         {\cf19 return} Detail::convertIntoString( str );\par
2061     \} {\cf19 else} \{\par
2062         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2063     \}\par
2064 \}\par
2065 \par
2066 {\cf21 #ifdef CATCH_CONFIG_WCHAR}\par
2067 std::string StringMaker<std::wstring>::convert({\cf17 const} std::wstring& wstr) \{\par
2068     std::string s;\par
2069     s.reserve(wstr.size());\par
2070     {\cf19 for} ({\cf17 auto} c : wstr) \{\par
2071         s += (c <= 0xff) ? static_cast<char>(c) : {\cf23 '?'};\par
2072     \}\par
2073     return ::Catch::Detail::stringify(s);\par
2074 \}\par
2075 \par
2076 {\cf21 # ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2077 std::string StringMaker<std::wstring_view>::convert(std::wstring_view str) \{\par
2078     {\cf19 return} StringMaker<std::wstring>::convert(std::wstring(str));\par
2079 \}\par
2080 {\cf21 # endif}\par
2081 \par
2082 std::string StringMaker<wchar_t const*>::convert({\cf18 wchar_t} {\cf17 const} * str) \{\par
2083     {\cf19 if} (str) \{\par
2084         return ::Catch::Detail::stringify(std::wstring\{ str \});\par
2085     \} {\cf19 else} \{\par
2086         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2087     \}\par
2088 \}\par
2089 std::string StringMaker<wchar_t *>::convert({\cf18 wchar_t} * str) \{\par
2090     {\cf19 if} (str) \{\par
2091         return ::Catch::Detail::stringify(std::wstring\{ str \});\par
2092     \} {\cf19 else} \{\par
2093         {\cf19 return}\{ {\cf22 "\{null string\}"} \};\par
2094     \}\par
2095 \}\par
2096 {\cf21 #endif}\par
2097 \par
2098 {\cf21 #if defined(CATCH_CONFIG_CPP17_BYTE)}\par
2099 {\cf21 #include <cstddef>}\par
2100 std::string StringMaker<std::byte>::convert(std::byte value) \{\par
2101     return ::Catch::Detail::stringify(std::to_integer<unsigned long long>(value));\par
2102 \}\par
2103 {\cf21 #endif }{\cf20 // defined(CATCH_CONFIG_CPP17_BYTE)}\par
2104 \par
2105 std::string StringMaker<int>::convert({\cf18 int} value) \{\par
2106     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2107 \}\par
2108 std::string StringMaker<long>::convert({\cf18 long} value) \{\par
2109     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2110 \}\par
2111 std::string StringMaker<long long>::convert({\cf18 long} {\cf18 long} value) \{\par
2112     ReusableStringStream rss;\par
2113     rss << value;\par
2114     {\cf19 if} (value > Detail::hexThreshold) \{\par
2115         rss << {\cf22 " (0x"} << std::hex << value << {\cf23 ')'};\par
2116     \}\par
2117     {\cf19 return} rss.str();\par
2118 \}\par
2119 \par
2120 std::string StringMaker<unsigned int>::convert({\cf18 unsigned} {\cf18 int} value) \{\par
2121     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2122 \}\par
2123 std::string StringMaker<unsigned long>::convert({\cf18 unsigned} {\cf18 long} value) \{\par
2124     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 long} {\cf18 long}{\cf17 >}(value));\par
2125 \}\par
2126 std::string StringMaker<unsigned long long>::convert({\cf18 unsigned} {\cf18 long} {\cf18 long} value) \{\par
2127     ReusableStringStream rss;\par
2128     rss << value;\par
2129     {\cf19 if} (value > Detail::hexThreshold) \{\par
2130         rss << {\cf22 " (0x"} << std::hex << value << {\cf23 ')'};\par
2131     \}\par
2132     {\cf19 return} rss.str();\par
2133 \}\par
2134 \par
2135 std::string StringMaker<signed char>::convert({\cf18 signed} {\cf18 char} value) \{\par
2136     {\cf19 if} (value == {\cf23 '\\r'}) \{\par
2137         {\cf19 return} {\cf22 "'\\\\r'"};\par
2138     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\f'}) \{\par
2139         {\cf19 return} {\cf22 "'\\\\f'"};\par
2140     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\n'}) \{\par
2141         {\cf19 return} {\cf22 "'\\\\n'"};\par
2142     \} {\cf19 else} {\cf19 if} (value == {\cf23 '\\t'}) \{\par
2143         {\cf19 return} {\cf22 "'\\\\t'"};\par
2144     \} {\cf19 else} {\cf19 if} ({\cf23 '\\0'} <= value && value < {\cf23 ' '}) \{\par
2145         return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(value));\par
2146     \} {\cf19 else} \{\par
2147         {\cf18 char} chstr[] = {\cf22 "' '"};\par
2148         chstr[1] = value;\par
2149         {\cf19 return} chstr;\par
2150     \}\par
2151 \}\par
2152 std::string StringMaker<char>::convert({\cf18 char} c) \{\par
2153     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 signed} {\cf18 char}{\cf17 >}(c));\par
2154 \}\par
2155 std::string StringMaker<unsigned char>::convert({\cf18 unsigned} {\cf18 char} value) \{\par
2156     return ::Catch::Detail::stringify({\cf17 static_cast<}{\cf18 char}{\cf17 >}(value));\par
2157 \}\par
2158 \par
2159 {\cf18 int} StringMaker<float>::precision = std::numeric_limits<float>::max_digits10;\par
2160 \par
2161 std::string StringMaker<float>::convert({\cf18 float} value) \{\par
2162     {\cf19 return} Detail::fpToString(value, precision) + {\cf23 'f'};\par
2163 \}\par
2164 \par
2165 {\cf18 int} StringMaker<double>::precision = std::numeric_limits<double>::max_digits10;\par
2166 \par
2167 std::string StringMaker<double>::convert({\cf18 double} value) \{\par
2168     {\cf19 return} Detail::fpToString(value, precision);\par
2169 \}\par
2170 \par
2171 \} {\cf20 // end namespace Catch}\par
2172 \par
2173 \par
2174 \par
2175 {\cf17 namespace }Catch \{\par
2176 \par
2177     Counts Counts::operator - ( Counts {\cf17 const}& other ){\cf17  const }\{\par
2178         Counts diff;\par
2179         diff.passed = passed - other.passed;\par
2180         diff.failed = failed - other.failed;\par
2181         diff.failedButOk = failedButOk - other.failedButOk;\par
2182         diff.skipped = skipped - other.skipped;\par
2183         {\cf19 return} diff;\par
2184     \}\par
2185 \par
2186     Counts& Counts::operator += ( Counts {\cf17 const}& other ) \{\par
2187         passed += other.passed;\par
2188         failed += other.failed;\par
2189         failedButOk += other.failedButOk;\par
2190         skipped += other.skipped;\par
2191         {\cf19 return} *{\cf17 this};\par
2192     \}\par
2193 \par
2194     std::uint64_t Counts::total(){\cf17  const }\{\par
2195         {\cf19 return} passed + failed + failedButOk + skipped;\par
2196     \}\par
2197     {\cf18 bool} Counts::allPassed(){\cf17  const }\{\par
2198         {\cf19 return} failed == 0 && failedButOk == 0 && skipped == 0;\par
2199     \}\par
2200     {\cf18 bool} Counts::allOk(){\cf17  const }\{\par
2201         {\cf19 return} failed == 0;\par
2202     \}\par
2203 \par
2204     Totals Totals::operator - ( Totals {\cf17 const}& other ){\cf17  const }\{\par
2205         Totals diff;\par
2206         diff.assertions = assertions - other.assertions;\par
2207         diff.testCases = testCases - other.testCases;\par
2208         {\cf19 return} diff;\par
2209     \}\par
2210 \par
2211     Totals& Totals::operator += ( Totals {\cf17 const}& other ) \{\par
2212         assertions += other.assertions;\par
2213         testCases += other.testCases;\par
2214         {\cf19 return} *{\cf17 this};\par
2215     \}\par
2216 \par
2217     Totals Totals::delta( Totals {\cf17 const}& prevTotals ){\cf17  const }\{\par
2218         Totals diff = *{\cf17 this} - prevTotals;\par
2219         {\cf19 if}( diff.assertions.failed > 0 )\par
2220             ++diff.testCases.failed;\par
2221         {\cf19 else} {\cf19 if}( diff.assertions.failedButOk > 0 )\par
2222             ++diff.testCases.failedButOk;\par
2223         {\cf19 else} {\cf19 if} ( diff.assertions.skipped > 0 )\par
2224             ++ diff.testCases.skipped;\par
2225         {\cf19 else}\par
2226             ++diff.testCases.passed;\par
2227         {\cf19 return} diff;\par
2228     \}\par
2229 \par
2230 \}\par
2231 \par
2232 \par
2233 \par
2234 \par
2235 {\cf17 namespace }Catch \{\par
2236     {\cf17 namespace }Detail \{\par
2237         {\cf18 void} registerTranslatorImpl(\par
2238             Detail::unique_ptr<IExceptionTranslator>&& translator ) \{\par
2239             getMutableRegistryHub().registerTranslator(\par
2240                 CATCH_MOVE( translator ) );\par
2241         \}\par
2242     \} {\cf20 // namespace Detail}\par
2243 \} {\cf20 // namespace Catch}\par
2244 \par
2245 \par
2246 {\cf21 #include <ostream>}\par
2247 \par
2248 {\cf17 namespace }Catch \{\par
2249 \par
2250     Version::Version\par
2251         (   {\cf18 unsigned} {\cf18 int} _majorVersion,\par
2252             {\cf18 unsigned} {\cf18 int} _minorVersion,\par
2253             {\cf18 unsigned} {\cf18 int} _patchNumber,\par
2254             {\cf18 char} {\cf17 const} * {\cf17 const} _branchName,\par
2255             {\cf18 unsigned} {\cf18 int} _buildNumber )\par
2256     :   majorVersion( _majorVersion ),\par
2257         minorVersion( _minorVersion ),\par
2258         patchNumber( _patchNumber ),\par
2259         branchName( _branchName ),\par
2260         buildNumber( _buildNumber )\par
2261     \{\}\par
2262 \par
2263     std::ostream& operator << ( std::ostream& os, Version {\cf17 const}& version ) \{\par
2264         os  << version.majorVersion << {\cf23 '.'}\par
2265             << version.minorVersion << {\cf23 '.'}\par
2266             << version.patchNumber;\par
2267         {\cf20 // branchName is never null -> 0th char is \\0 if it is empty}\par
2268         {\cf19 if} (version.branchName[0]) \{\par
2269             os << {\cf23 '-'} << version.branchName\par
2270                << {\cf23 '.'} << version.buildNumber;\par
2271         \}\par
2272         {\cf19 return} os;\par
2273     \}\par
2274 \par
2275     Version {\cf17 const}& libraryVersion() \{\par
2276         {\cf17 static} Version version( 3, 6, 0, {\cf22 ""}, 0 );\par
2277         {\cf19 return} version;\par
2278     \}\par
2279 \par
2280 \}\par
2281 \par
2282 \par
2283 \par
2284 \par
2285 {\cf17 namespace }Catch \{\par
2286 \par
2287     {\cf17 const} {\cf18 char}* GeneratorException::what() const noexcept \{\par
2288         {\cf19 return} m_msg;\par
2289     \}\par
2290 \par
2291 \} {\cf20 // end namespace Catch}\par
2292 \par
2293 \par
2294 \par
2295 \par
2296 {\cf17 namespace }Catch \{\par
2297 \par
2298     IGeneratorTracker::~IGeneratorTracker() = {\cf19 default};\par
2299 \par
2300 {\cf17 namespace }Generators \{\par
2301 \par
2302 {\cf17 namespace }Detail \{\par
2303 \par
2304     [[noreturn]]\par
2305     {\cf18 void} throw_generator_exception({\cf18 char} {\cf17 const}* msg) \{\par
2306         Catch::throw_exception(GeneratorException\{ msg \});\par
2307     \}\par
2308 \} {\cf20 // end namespace Detail}\par
2309 \par
2310     GeneratorUntypedBase::~GeneratorUntypedBase() = {\cf19 default};\par
2311 \par
2312     IGeneratorTracker* acquireGeneratorTracker(StringRef generatorName, SourceLineInfo {\cf17 const}& lineInfo ) \{\par
2313         {\cf19 return} getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );\par
2314     \}\par
2315 \par
2316     IGeneratorTracker* createGeneratorTracker( StringRef generatorName,\par
2317                                  SourceLineInfo lineInfo,\par
2318                                  GeneratorBasePtr&& generator ) \{\par
2319         {\cf19 return} getResultCapture().createGeneratorTracker(\par
2320             generatorName, lineInfo, CATCH_MOVE( generator ) );\par
2321     \}\par
2322 \par
2323 \} {\cf20 // namespace Generators}\par
2324 \} {\cf20 // namespace Catch}\par
2325 \par
2326 \par
2327 \par
2328 \par
2329 {\cf21 #include <random>}\par
2330 \par
2331 {\cf17 namespace }Catch \{\par
2332     {\cf17 namespace }Generators \{\par
2333         {\cf17 namespace }Detail \{\par
2334             std::uint32_t getSeed() \{ {\cf19 return} sharedRng()(); \}\par
2335         \} {\cf20 // namespace Detail}\par
2336 \par
2337         {\cf17 struct }RandomFloatingGenerator<long double>::PImpl \{\par
2338             PImpl( {\cf18 long} {\cf18 double} a, {\cf18 long} {\cf18 double} b, uint32_t seed ):\par
2339                 rng( seed ), dist( a, b ) \{\}\par
2340 \par
2341             Catch::SimplePcg32 rng;\par
2342             std::uniform_real_distribution<long double> dist;\par
2343         \};\par
2344 \par
2345         RandomFloatingGenerator<long double>::RandomFloatingGenerator(\par
2346             {\cf18 long} {\cf18 double} a, {\cf18 long} {\cf18 double} b, std::uint32_t seed) :\par
2347             m_pimpl(Catch::Detail::make_unique<PImpl>(a, b, seed)) \{\par
2348             {\cf17 static_cast<}{\cf18 void}{\cf17 >}( next() );\par
2349         \}\par
2350 \par
2351         RandomFloatingGenerator<long double>::~RandomFloatingGenerator() =\par
2352             {\cf19 default};\par
2353         {\cf18 bool} RandomFloatingGenerator<long double>::next() \{\par
2354             m_current_number = m_pimpl->dist( m_pimpl->rng );\par
2355             {\cf19 return} {\cf17 true};\par
2356         \}\par
2357     \} {\cf20 // namespace Generators}\par
2358 \} {\cf20 // namespace Catch}\par
2359 \par
2360 \par
2361 \par
2362 \par
2363 {\cf17 namespace }Catch \{\par
2364     IResultCapture::~IResultCapture() = {\cf19 default};\par
2365 \}\par
2366 \par
2367 \par
2368 \par
2369 \par
2370 {\cf17 namespace }Catch \{\par
2371     IConfig::~IConfig() = {\cf19 default};\par
2372 \}\par
2373 \par
2374 \par
2375 \par
2376 \par
2377 {\cf17 namespace }Catch \{\par
2378     IExceptionTranslator::~IExceptionTranslator() = {\cf19 default};\par
2379     IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = {\cf19 default};\par
2380 \}\par
2381 \par
2382 \par
2383 \par
2384 {\cf21 #include <string>}\par
2385 \par
2386 {\cf17 namespace }Catch \{\par
2387     {\cf17 namespace }Generators \{\par
2388 \par
2389         {\cf18 bool} GeneratorUntypedBase::countedNext() \{\par
2390             {\cf17 auto} ret = next();\par
2391             {\cf19 if} ( ret ) \{\par
2392                 m_stringReprCache.clear();\par
2393                 ++m_currentElementIndex;\par
2394             \}\par
2395             {\cf19 return} ret;\par
2396         \}\par
2397 \par
2398         StringRef GeneratorUntypedBase::currentElementAsString(){\cf17  const }\{\par
2399             {\cf19 if} ( m_stringReprCache.empty() ) \{\par
2400                 m_stringReprCache = stringifyImpl();\par
2401             \}\par
2402             {\cf19 return} m_stringReprCache;\par
2403         \}\par
2404 \par
2405     \} {\cf20 // namespace Generators}\par
2406 \} {\cf20 // namespace Catch}\par
2407 \par
2408 \par
2409 \par
2410 \par
2411 {\cf17 namespace }Catch \{\par
2412     IRegistryHub::~IRegistryHub() = {\cf19 default};\par
2413     IMutableRegistryHub::~IMutableRegistryHub() = {\cf19 default};\par
2414 \}\par
2415 \par
2416 \par
2417 \par
2418 {\cf21 #include <cassert>}\par
2419 \par
2420 {\cf17 namespace }Catch \{\par
2421 \par
2422     ReporterConfig::ReporterConfig(\par
2423         IConfig {\cf17 const}* _fullConfig,\par
2424         Detail::unique_ptr<IStream> _stream,\par
2425         ColourMode colourMode,\par
2426         std::map<std::string, std::string> customOptions ):\par
2427         m_stream( CATCH_MOVE(_stream) ),\par
2428         m_fullConfig( _fullConfig ),\par
2429         m_colourMode( colourMode ),\par
2430         m_customOptions( CATCH_MOVE( customOptions ) ) \{\}\par
2431 \par
2432     Detail::unique_ptr<IStream> ReporterConfig::takeStream() && \{\par
2433         assert( m_stream );\par
2434         {\cf19 return} CATCH_MOVE( m_stream );\par
2435     \}\par
2436     IConfig {\cf17 const} * ReporterConfig::fullConfig(){\cf17  const }\{ {\cf19 return} m_fullConfig; \}\par
2437     ColourMode ReporterConfig::colourMode(){\cf17  const }\{ {\cf19 return} m_colourMode; \}\par
2438 \par
2439     std::map<std::string, std::string> {\cf17 const}&\par
2440     ReporterConfig::customOptions(){\cf17  const }\{\par
2441         {\cf19 return} m_customOptions;\par
2442     \}\par
2443 \par
2444     ReporterConfig::~ReporterConfig() = {\cf19 default};\par
2445 \par
2446     AssertionStats::AssertionStats( AssertionResult {\cf17 const}& _assertionResult,\par
2447                                     std::vector<MessageInfo> {\cf17 const}& _infoMessages,\par
2448                                     Totals {\cf17 const}& _totals )\par
2449     :   assertionResult( _assertionResult ),\par
2450         infoMessages( _infoMessages ),\par
2451         totals( _totals )\par
2452     \{\par
2453         {\cf19 if}( assertionResult.hasMessage() ) \{\par
2454             {\cf20 // Copy message into messages list.}\par
2455             {\cf20 // !TBD This should have been done earlier, somewhere}\par
2456             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );\par
2457             builder.m_info.message = static_cast<std::string>(assertionResult.getMessage());\par
2458 \par
2459             infoMessages.push_back( CATCH_MOVE(builder.m_info) );\par
2460         \}\par
2461     \}\par
2462 \par
2463     SectionStats::SectionStats(  SectionInfo&& _sectionInfo,\par
2464                                  Counts {\cf17 const}& _assertions,\par
2465                                  {\cf18 double} _durationInSeconds,\par
2466                                  {\cf18 bool} _missingAssertions )\par
2467     :   sectionInfo( CATCH_MOVE(_sectionInfo) ),\par
2468         assertions( _assertions ),\par
2469         durationInSeconds( _durationInSeconds ),\par
2470         missingAssertions( _missingAssertions )\par
2471     \{\}\par
2472 \par
2473 \par
2474     TestCaseStats::TestCaseStats(  TestCaseInfo {\cf17 const}& _testInfo,\par
2475                                    Totals {\cf17 const}& _totals,\par
2476                                    std::string&& _stdOut,\par
2477                                    std::string&& _stdErr,\par
2478                                    {\cf18 bool} _aborting )\par
2479     : testInfo( &_testInfo ),\par
2480         totals( _totals ),\par
2481         stdOut( CATCH_MOVE(_stdOut) ),\par
2482         stdErr( CATCH_MOVE(_stdErr) ),\par
2483         aborting( _aborting )\par
2484     \{\}\par
2485 \par
2486 \par
2487     TestRunStats::TestRunStats(   TestRunInfo {\cf17 const}& _runInfo,\par
2488                     Totals {\cf17 const}& _totals,\par
2489                     {\cf18 bool} _aborting )\par
2490     :   runInfo( _runInfo ),\par
2491         totals( _totals ),\par
2492         aborting( _aborting )\par
2493     \{\}\par
2494 \par
2495     IEventListener::~IEventListener() = {\cf19 default};\par
2496 \par
2497 \} {\cf20 // end namespace Catch}\par
2498 \par
2499 \par
2500 \par
2501 \par
2502 {\cf17 namespace }Catch \{\par
2503     IReporterFactory::~IReporterFactory() = {\cf19 default};\par
2504     EventListenerFactory::~EventListenerFactory() = {\cf19 default};\par
2505 \}\par
2506 \par
2507 \par
2508 \par
2509 \par
2510 {\cf17 namespace }Catch \{\par
2511     ITestCaseRegistry::~ITestCaseRegistry() = {\cf19 default};\par
2512 \}\par
2513 \par
2514 \par
2515 \par
2516 {\cf17 namespace }Catch \{\par
2517 \par
2518     AssertionHandler::AssertionHandler\par
2519         (   StringRef macroName,\par
2520             SourceLineInfo {\cf17 const}& lineInfo,\par
2521             StringRef capturedExpression,\par
2522             ResultDisposition::Flags resultDisposition )\par
2523     :   m_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},\par
2524         m_resultCapture( getResultCapture() )\par
2525     \{\par
2526         m_resultCapture.notifyAssertionStarted( m_assertionInfo );\par
2527     \}\par
2528 \par
2529     {\cf18 void} AssertionHandler::handleExpr( ITransientExpression {\cf17 const}& expr ) \{\par
2530         m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );\par
2531     \}\par
2532     {\cf18 void} AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef message) \{\par
2533         m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );\par
2534     \}\par
2535 \par
2536     {\cf17 auto} AssertionHandler::allowThrows() const -> {\cf18 bool} \{\par
2537         {\cf19 return} getCurrentContext().getConfig()->allowThrows();\par
2538     \}\par
2539 \par
2540     {\cf18 void} AssertionHandler::complete() \{\par
2541         m_completed = {\cf17 true};\par
2542         {\cf19 if}( m_reaction.shouldDebugBreak ) \{\par
2543 \par
2544             {\cf20 // If you find your debugger stopping you here then go one level up on the}\par
2545             {\cf20 // call-stack for the code that caused it (typically a failed assertion)}\par
2546 \par
2547             {\cf20 // (To go back to the test and change execution, jump over the throw, next)}\par
2548             CATCH_BREAK_INTO_DEBUGGER();\par
2549         \}\par
2550         {\cf19 if} (m_reaction.shouldThrow) \{\par
2551             throw_test_failure_exception();\par
2552         \}\par
2553         {\cf19 if} ( m_reaction.shouldSkip ) \{\par
2554             throw_test_skip_exception();\par
2555         \}\par
2556     \}\par
2557 \par
2558     {\cf18 void} AssertionHandler::handleUnexpectedInflightException() \{\par
2559         m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );\par
2560     \}\par
2561 \par
2562     {\cf18 void} AssertionHandler::handleExceptionThrownAsExpected() \{\par
2563         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2564     \}\par
2565     {\cf18 void} AssertionHandler::handleExceptionNotThrownAsExpected() \{\par
2566         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2567     \}\par
2568 \par
2569     {\cf18 void} AssertionHandler::handleUnexpectedExceptionNotThrown() \{\par
2570         m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );\par
2571     \}\par
2572 \par
2573     {\cf18 void} AssertionHandler::handleThrowingCallSkipped() \{\par
2574         m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);\par
2575     \}\par
2576 \par
2577     {\cf20 // This is the overload that takes a string and infers the Equals matcher from it}\par
2578     {\cf20 // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp}\par
2579     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, std::string {\cf17 const}& str ) \{\par
2580         handleExceptionMatchExpr( handler, Matchers::Equals( str ) );\par
2581     \}\par
2582 \par
2583 \} {\cf20 // namespace Catch}\par
2584 \par
2585 \par
2586 \par
2587 \par
2588 {\cf21 #include <algorithm>}\par
2589 \par
2590 {\cf17 namespace }Catch \{\par
2591     {\cf17 namespace }Detail \{\par
2592 \par
2593         {\cf18 bool} CaseInsensitiveLess::operator()( StringRef lhs,\par
2594                                               StringRef rhs ){\cf17  const }\{\par
2595             {\cf19 return} std::lexicographical_compare(\par
2596                 lhs.begin(), lhs.end(),\par
2597                 rhs.begin(), rhs.end(),\par
2598                 []( {\cf18 char} l, {\cf18 char} r ) \{ return toLower( l ) < toLower( r ); \} );\par
2599         \}\par
2600 \par
2601         {\cf18 bool}\par
2602         CaseInsensitiveEqualTo::operator()( StringRef lhs,\par
2603                                             StringRef rhs ){\cf17  const }\{\par
2604             {\cf19 return} std::equal(\par
2605                 lhs.begin(), lhs.end(),\par
2606                 rhs.begin(), rhs.end(),\par
2607                 []( {\cf18 char} l, {\cf18 char} r ) \{ return toLower( l ) == toLower( r ); \} );\par
2608         \}\par
2609 \par
2610     \} {\cf20 // namespace Detail}\par
2611 \} {\cf20 // namespace Catch}\par
2612 \par
2613 \par
2614 \par
2615 \par
2616 {\cf21 #include <algorithm>}\par
2617 {\cf21 #include <ostream>}\par
2618 \par
2619 {\cf17 namespace }\{\par
2620     {\cf18 bool} isOptPrefix( {\cf18 char} c ) \{\par
2621         {\cf19 return} c == {\cf23 '-'}\par
2622 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
2623                || c == {\cf23 '/'}\par
2624 {\cf21 #endif}\par
2625             ;\par
2626     \}\par
2627 \par
2628     Catch::StringRef normaliseOpt( Catch::StringRef optName ) \{\par
2629         {\cf19 if} ( optName[0] == {\cf23 '-'}\par
2630 #{\cf19 if} defined(CATCH_PLATFORM_WINDOWS)\par
2631              || optName[0] == {\cf23 '/'}\par
2632 #endif\par
2633         ) \{\par
2634             {\cf19 return} optName.substr( 1, optName.size() );\par
2635         \}\par
2636 \par
2637         {\cf19 return} optName;\par
2638     \}\par
2639 \par
2640     {\cf17 static} {\cf18 size_t} find_first_separator(Catch::StringRef sr) \{\par
2641         {\cf17 auto} is_separator = []( {\cf18 char} c ) \{\par
2642             {\cf19 return} c == {\cf23 ' '} || c == {\cf23 ':'} || c == {\cf23 '='};\par
2643         \};\par
2644         {\cf18 size_t} pos = 0;\par
2645         {\cf19 while} (pos < sr.size()) \{\par
2646             {\cf19 if} (is_separator(sr[pos])) \{ {\cf19 return} pos; \}\par
2647             ++pos;\par
2648         \}\par
2649 \par
2650         {\cf19 return} Catch::StringRef::npos;\par
2651     \}\par
2652 \par
2653 \} {\cf20 // namespace}\par
2654 \par
2655 {\cf17 namespace }Catch \{\par
2656     {\cf17 namespace }Clara \{\par
2657         {\cf17 namespace }Detail \{\par
2658 \par
2659             {\cf18 void} TokenStream::loadBuffer() \{\par
2660                 m_tokenBuffer.clear();\par
2661 \par
2662                 {\cf20 // Skip any empty strings}\par
2663                 {\cf19 while} ( it != itEnd && it->empty() ) \{\par
2664                     ++it;\par
2665                 \}\par
2666 \par
2667                 {\cf19 if} ( it != itEnd ) \{\par
2668                     StringRef next = *it;\par
2669                     {\cf19 if} ( isOptPrefix( next[0] ) ) \{\par
2670                         {\cf17 auto} delimiterPos = find_first_separator(next);\par
2671                         {\cf19 if} ( delimiterPos != StringRef::npos ) \{\par
2672                             m_tokenBuffer.push_back(\par
2673                                 \{ TokenType::Option,\par
2674                                   next.substr( 0, delimiterPos ) \} );\par
2675                             m_tokenBuffer.push_back(\par
2676                                 \{ TokenType::Argument,\par
2677                                   next.substr( delimiterPos + 1, next.size() ) \} );\par
2678                         \} {\cf19 else} \{\par
2679                             {\cf19 if} ( next[1] != {\cf23 '-'} && next.size() > 2 ) \{\par
2680                                 {\cf20 // Combined short args, e.g. "-ab" for "-a -b"}\par
2681                                 {\cf19 for} ( {\cf18 size_t} i = 1; i < next.size(); ++i ) \{\par
2682                                     m_tokenBuffer.push_back(\par
2683                                         \{ TokenType::Option,\par
2684                                           next.substr( i, 1 ) \} );\par
2685                                 \}\par
2686                             \} {\cf19 else} \{\par
2687                                 m_tokenBuffer.push_back(\par
2688                                     \{ TokenType::Option, next \} );\par
2689                             \}\par
2690                         \}\par
2691                     \} {\cf19 else} \{\par
2692                         m_tokenBuffer.push_back(\par
2693                             \{ TokenType::Argument, next \} );\par
2694                     \}\par
2695                 \}\par
2696             \}\par
2697 \par
2698             TokenStream::TokenStream( Args {\cf17 const}& args ):\par
2699                 TokenStream( args.m_args.begin(), args.m_args.end() ) \{\}\par
2700 \par
2701             TokenStream::TokenStream( Iterator it_, Iterator itEnd_ ):\par
2702                 it( it_ ), itEnd( itEnd_ ) \{\par
2703                 loadBuffer();\par
2704             \}\par
2705 \par
2706             TokenStream& TokenStream::operator++() \{\par
2707                 {\cf19 if} ( m_tokenBuffer.size() >= 2 ) \{\par
2708                     m_tokenBuffer.erase( m_tokenBuffer.begin() );\par
2709                 \} {\cf19 else} \{\par
2710                     {\cf19 if} ( it != itEnd )\par
2711                         ++it;\par
2712                     loadBuffer();\par
2713                 \}\par
2714                 {\cf19 return} *{\cf17 this};\par
2715             \}\par
2716 \par
2717             ParserResult convertInto( std::string {\cf17 const}& source,\par
2718                                       std::string& target ) \{\par
2719                 target = source;\par
2720                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2721             \}\par
2722 \par
2723             ParserResult convertInto( std::string {\cf17 const}& source,\par
2724                                       {\cf18 bool}& target ) \{\par
2725                 std::string srcLC = toLower( source );\par
2726 \par
2727                 {\cf19 if} ( srcLC == {\cf22 "y"} || srcLC == {\cf22 "1"} || srcLC == {\cf22 "true"} ||\par
2728                      srcLC == {\cf22 "yes"} || srcLC == {\cf22 "on"} ) \{\par
2729                     target = {\cf17 true};\par
2730                 \} {\cf19 else} {\cf19 if} ( srcLC == {\cf22 "n"} || srcLC == {\cf22 "0"} || srcLC == {\cf22 "false"} ||\par
2731                             srcLC == {\cf22 "no"} || srcLC == {\cf22 "off"} ) \{\par
2732                     target = {\cf17 false};\par
2733                 \} {\cf19 else} \{\par
2734                     {\cf19 return} ParserResult::runtimeError(\par
2735                         {\cf22 "Expected a boolean value but did not recognise: '"} +\par
2736                         source + {\cf23 '\\''} );\par
2737                 \}\par
2738                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2739             \}\par
2740 \par
2741             {\cf18 size_t} ParserBase::cardinality(){\cf17  const }\{ {\cf19 return} 1; \}\par
2742 \par
2743             InternalParseResult ParserBase::parse( Args {\cf17 const}& args ){\cf17  const }\{\par
2744                 {\cf19 return} parse( {\cf17 static_cast<}std::string{\cf17 >}(args.exeName()), TokenStream( args ) );\par
2745             \}\par
2746 \par
2747             ParseState::ParseState( ParseResultType type,\par
2748                                     TokenStream remainingTokens ):\par
2749                 m_type( type ), m_remainingTokens( CATCH_MOVE(remainingTokens) ) \{\}\par
2750 \par
2751             ParserResult BoundFlagRef::setFlag( {\cf18 bool} flag ) \{\par
2752                 m_ref = flag;\par
2753                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
2754             \}\par
2755 \par
2756             ResultBase::~ResultBase() = {\cf19 default};\par
2757 \par
2758             {\cf18 bool} BoundRef::isContainer(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
2759 \par
2760             {\cf18 bool} BoundRef::isFlag(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
2761 \par
2762             {\cf18 bool} BoundFlagRefBase::isFlag(){\cf17  const }\{ {\cf19 return} {\cf17 true}; \}\par
2763 \par
2764 \} {\cf20 // namespace Detail}\par
2765 \par
2766         Detail::InternalParseResult Arg::parse(std::string {\cf17 const}&,\par
2767                                                Detail::TokenStream tokens){\cf17  const }\{\par
2768             {\cf17 auto} validationResult = validate();\par
2769             {\cf19 if} (!validationResult)\par
2770                 {\cf19 return} Detail::InternalParseResult(validationResult);\par
2771 \par
2772             {\cf17 auto} token = *tokens;\par
2773             {\cf19 if} (token.type != Detail::TokenType::Argument)\par
2774                 {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2775                     ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2776 \par
2777             assert(!m_ref->isFlag());\par
2778             {\cf17 auto} valueRef =\par
2779                 {\cf17 static_cast<}Detail::BoundValueRefBase*{\cf17 >}(m_ref.get());\par
2780 \par
2781             {\cf17 auto} result = valueRef->setValue({\cf17 static_cast<}std::string{\cf17 >}(token.token));\par
2782             {\cf19 if} ( !result )\par
2783                 {\cf19 return} Detail::InternalParseResult( result );\par
2784             {\cf19 else}\par
2785                 {\cf19 return} Detail::InternalParseResult::ok(\par
2786                     Detail::ParseState( ParseResultType::Matched,\par
2787                                         CATCH_MOVE( ++tokens ) ) );\par
2788         \}\par
2789 \par
2790         Opt::Opt({\cf18 bool}& ref) :\par
2791             ParserRefImpl(std::make_shared<Detail::BoundFlagRef>(ref)) \{\}\par
2792 \par
2793         Detail::HelpColumns Opt::getHelpColumns(){\cf17  const }\{\par
2794             ReusableStringStream oss;\par
2795             {\cf18 bool} first = {\cf17 true};\par
2796             {\cf19 for} ({\cf17 auto} {\cf17 const}& opt : m_optNames) \{\par
2797                 {\cf19 if} (first)\par
2798                     first = {\cf17 false};\par
2799                 {\cf19 else}\par
2800                     oss << {\cf22 ", "};\par
2801                 oss << opt;\par
2802             \}\par
2803             {\cf19 if} (!m_hint.empty())\par
2804                 oss << {\cf22 " <"} << m_hint << {\cf23 '>'};\par
2805             {\cf19 return} \{ oss.str(), m_description \};\par
2806         \}\par
2807 \par
2808         {\cf18 bool} Opt::isMatch(StringRef optToken){\cf17  const }\{\par
2809             {\cf17 auto} normalisedToken = normaliseOpt(optToken);\par
2810             {\cf19 for} ({\cf17 auto} {\cf17 const}& name : m_optNames) \{\par
2811                 {\cf19 if} (normaliseOpt(name) == normalisedToken)\par
2812                     {\cf19 return} {\cf17 true};\par
2813             \}\par
2814             {\cf19 return} {\cf17 false};\par
2815         \}\par
2816 \par
2817         Detail::InternalParseResult Opt::parse(std::string {\cf17 const}&,\par
2818                                        Detail::TokenStream tokens){\cf17  const }\{\par
2819             {\cf17 auto} validationResult = validate();\par
2820             {\cf19 if} (!validationResult)\par
2821                 {\cf19 return} Detail::InternalParseResult(validationResult);\par
2822 \par
2823             {\cf19 if} (tokens &&\par
2824                 tokens->type == Detail::TokenType::Option) \{\par
2825                 {\cf17 auto} {\cf17 const}& token = *tokens;\par
2826                 {\cf19 if} (isMatch(token.token)) \{\par
2827                     {\cf19 if} (m_ref->isFlag()) \{\par
2828                         {\cf17 auto} flagRef =\par
2829                             {\cf17 static_cast<}Detail::BoundFlagRefBase*{\cf17 >}(\par
2830                                 m_ref.get());\par
2831                         {\cf17 auto} result = flagRef->setFlag({\cf17 true});\par
2832                         {\cf19 if} (!result)\par
2833                             {\cf19 return} Detail::InternalParseResult(result);\par
2834                         {\cf19 if} (result.value() ==\par
2835                             ParseResultType::ShortCircuitAll)\par
2836                             {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2837                                 result.value(), CATCH_MOVE(tokens)));\par
2838                     \} {\cf19 else} \{\par
2839                         {\cf17 auto} valueRef =\par
2840                             {\cf17 static_cast<}Detail::BoundValueRefBase*{\cf17 >}(\par
2841                                 m_ref.get());\par
2842                         ++tokens;\par
2843                         {\cf19 if} (!tokens)\par
2844                             {\cf19 return} Detail::InternalParseResult::runtimeError(\par
2845                                 {\cf22 "Expected argument following "} +\par
2846                                 token.token);\par
2847                         {\cf17 auto} {\cf17 const}& argToken = *tokens;\par
2848                         {\cf19 if} (argToken.type != Detail::TokenType::Argument)\par
2849                             {\cf19 return} Detail::InternalParseResult::runtimeError(\par
2850                                 {\cf22 "Expected argument following "} +\par
2851                                 token.token);\par
2852                         {\cf17 const} {\cf17 auto} result = valueRef->setValue({\cf17 static_cast<}std::string{\cf17 >}(argToken.token));\par
2853                         {\cf19 if} (!result)\par
2854                             {\cf19 return} Detail::InternalParseResult(result);\par
2855                         {\cf19 if} (result.value() ==\par
2856                             ParseResultType::ShortCircuitAll)\par
2857                             {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2858                                 result.value(), CATCH_MOVE(tokens)));\par
2859                     \}\par
2860                     {\cf19 return} Detail::InternalParseResult::ok(Detail::ParseState(\par
2861                         ParseResultType::Matched, CATCH_MOVE(++tokens)));\par
2862                 \}\par
2863             \}\par
2864             {\cf19 return} Detail::InternalParseResult::ok(\par
2865                 Detail::ParseState(ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2866         \}\par
2867 \par
2868         Detail::Result Opt::validate(){\cf17  const }\{\par
2869             {\cf19 if} (m_optNames.empty())\par
2870                 {\cf19 return} Detail::Result::logicError({\cf22 "No options supplied to Opt"});\par
2871             {\cf19 for} ({\cf17 auto} {\cf17 const}& name : m_optNames) \{\par
2872                 {\cf19 if} (name.empty())\par
2873                     {\cf19 return} Detail::Result::logicError(\par
2874                         {\cf22 "Option name cannot be empty"});\par
2875 {\cf21 #ifdef CATCH_PLATFORM_WINDOWS}\par
2876                 {\cf19 if} (name[0] != {\cf23 '-'} && name[0] != {\cf23 '/'})\par
2877                     {\cf19 return} Detail::Result::logicError(\par
2878                         {\cf22 "Option name must begin with '-' or '/'"});\par
2879 {\cf21 #else}\par
2880                 {\cf19 if} (name[0] != {\cf23 '-'})\par
2881                     {\cf19 return} Detail::Result::logicError(\par
2882                         {\cf22 "Option name must begin with '-'"});\par
2883 {\cf21 #endif}\par
2884             \}\par
2885             {\cf19 return} ParserRefImpl::validate();\par
2886         \}\par
2887 \par
2888         ExeName::ExeName() :\par
2889             m_name(std::make_shared<std::string>({\cf22 "<executable>"})) \{\}\par
2890 \par
2891         ExeName::ExeName(std::string& ref) : ExeName() \{\par
2892             m_ref = std::make_shared<Detail::BoundValueRef<std::string>>(ref);\par
2893         \}\par
2894 \par
2895         Detail::InternalParseResult\par
2896             ExeName::parse(std::string {\cf17 const}&,\par
2897                            Detail::TokenStream tokens){\cf17  const }\{\par
2898             {\cf19 return} Detail::InternalParseResult::ok(\par
2899                 Detail::ParseState(ParseResultType::NoMatch, CATCH_MOVE(tokens)));\par
2900         \}\par
2901 \par
2902         ParserResult ExeName::set(std::string {\cf17 const}& newName) \{\par
2903             {\cf17 auto} lastSlash = newName.find_last_of({\cf22 "\\\\/"});\par
2904             {\cf17 auto} filename = (lastSlash == std::string::npos)\par
2905                 ? newName\par
2906                 : newName.substr(lastSlash + 1);\par
2907 \par
2908             *m_name = filename;\par
2909             {\cf19 if} (m_ref)\par
2910                 {\cf19 return} m_ref->setValue(filename);\par
2911             {\cf19 else}\par
2912                 {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
2913         \}\par
2914 \par
2915 \par
2916 \par
2917 \par
2918         Parser& Parser::operator|=( Parser {\cf17 const}& other ) \{\par
2919             m_options.insert( m_options.end(),\par
2920                               other.m_options.begin(),\par
2921                               other.m_options.end() );\par
2922             m_args.insert(\par
2923                 m_args.end(), other.m_args.begin(), other.m_args.end() );\par
2924             {\cf19 return} *{\cf17 this};\par
2925         \}\par
2926 \par
2927         std::vector<Detail::HelpColumns> Parser::getHelpColumns(){\cf17  const }\{\par
2928             std::vector<Detail::HelpColumns> cols;\par
2929             cols.reserve( m_options.size() );\par
2930             {\cf19 for} ( {\cf17 auto} {\cf17 const}& o : m_options ) \{\par
2931                 cols.push_back(o.getHelpColumns());\par
2932             \}\par
2933             {\cf19 return} cols;\par
2934         \}\par
2935 \par
2936         {\cf18 void} Parser::writeToStream( std::ostream& os ){\cf17  const }\{\par
2937             {\cf19 if} ( !m_exeName.name().empty() ) \{\par
2938                 os << {\cf22 "usage:\\n"}\par
2939                    << {\cf22 "  "} << m_exeName.name() << {\cf23 ' '};\par
2940                 {\cf18 bool} required = {\cf17 true}, first = {\cf17 true};\par
2941                 {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
2942                     {\cf19 if} ( first )\par
2943                         first = {\cf17 false};\par
2944                     {\cf19 else}\par
2945                         os << {\cf23 ' '};\par
2946                     {\cf19 if} ( arg.isOptional() && required ) \{\par
2947                         os << {\cf23 '['};\par
2948                         required = {\cf17 false};\par
2949                     \}\par
2950                     os << {\cf23 '<'} << arg.hint() << {\cf23 '>'};\par
2951                     {\cf19 if} ( arg.cardinality() == 0 )\par
2952                         os << {\cf22 " ... "};\par
2953                 \}\par
2954                 {\cf19 if} ( !required )\par
2955                     os << {\cf23 ']'};\par
2956                 {\cf19 if} ( !m_options.empty() )\par
2957                     os << {\cf22 " options"};\par
2958                 os << {\cf22 "\\n\\nwhere options are:\\n"};\par
2959             \}\par
2960 \par
2961             {\cf17 auto} rows = getHelpColumns();\par
2962             {\cf18 size_t} consoleWidth = CATCH_CONFIG_CONSOLE_WIDTH;\par
2963             {\cf18 size_t} optWidth = 0;\par
2964             {\cf19 for} ( {\cf17 auto} {\cf17 const}& cols : rows )\par
2965                 optWidth = ( std::max )( optWidth, cols.left.size() + 2 );\par
2966 \par
2967             optWidth = ( std::min )( optWidth, consoleWidth / 2 );\par
2968 \par
2969             {\cf19 for} ( {\cf17 auto}& cols : rows ) \{\par
2970                 {\cf17 auto} row = TextFlow::Column( CATCH_MOVE(cols.left) )\par
2971                                .width( optWidth )\par
2972                                .indent( 2 ) +\par
2973                            TextFlow::Spacer( 4 ) +\par
2974                            TextFlow::Column( {\cf17 static_cast<}std::string{\cf17 >}(cols.descriptions) )\par
2975                                .width( consoleWidth - 7 - optWidth );\par
2976                 os << row << {\cf23 '\\n'};\par
2977             \}\par
2978         \}\par
2979 \par
2980         Detail::Result Parser::validate(){\cf17  const }\{\par
2981             {\cf19 for} ( {\cf17 auto} {\cf17 const}& opt : m_options ) \{\par
2982                 {\cf17 auto} result = opt.validate();\par
2983                 {\cf19 if} ( !result )\par
2984                     {\cf19 return} result;\par
2985             \}\par
2986             {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
2987                 {\cf17 auto} result = arg.validate();\par
2988                 {\cf19 if} ( !result )\par
2989                     {\cf19 return} result;\par
2990             \}\par
2991             {\cf19 return} Detail::Result::ok();\par
2992         \}\par
2993 \par
2994         Detail::InternalParseResult\par
2995         Parser::parse( std::string {\cf17 const}& exeName,\par
2996                        Detail::TokenStream tokens ){\cf17  const }\{\par
2997 \par
2998             {\cf17 struct }ParserInfo \{\par
2999                 ParserBase {\cf17 const}* parser = {\cf17 nullptr};\par
3000                 {\cf18 size_t} count = 0;\par
3001             \};\par
3002             std::vector<ParserInfo> parseInfos;\par
3003             parseInfos.reserve( m_options.size() + m_args.size() );\par
3004             {\cf19 for} ( {\cf17 auto} {\cf17 const}& opt : m_options ) \{\par
3005                 parseInfos.push_back( \{ &opt, 0 \} );\par
3006             \}\par
3007             {\cf19 for} ( {\cf17 auto} {\cf17 const}& arg : m_args ) \{\par
3008                 parseInfos.push_back( \{ &arg, 0 \} );\par
3009             \}\par
3010 \par
3011             m_exeName.set( exeName );\par
3012 \par
3013             {\cf17 auto} result = Detail::InternalParseResult::ok(\par
3014                 Detail::ParseState( ParseResultType::NoMatch, CATCH_MOVE(tokens) ) );\par
3015             {\cf19 while} ( result.value().remainingTokens() ) \{\par
3016                 {\cf18 bool} tokenParsed = {\cf17 false};\par
3017 \par
3018                 {\cf19 for} ( {\cf17 auto}& parseInfo : parseInfos ) \{\par
3019                     {\cf19 if} ( parseInfo.parser->cardinality() == 0 ||\par
3020                          parseInfo.count < parseInfo.parser->cardinality() ) \{\par
3021                         result = parseInfo.parser->parse(\par
3022                             exeName, CATCH_MOVE(result).value().remainingTokens() );\par
3023                         {\cf19 if} ( !result )\par
3024                             {\cf19 return} result;\par
3025                         {\cf19 if} ( result.value().type() !=\par
3026                              ParseResultType::NoMatch ) \{\par
3027                             tokenParsed = {\cf17 true};\par
3028                             ++parseInfo.count;\par
3029                             {\cf19 break};\par
3030                         \}\par
3031                     \}\par
3032                 \}\par
3033 \par
3034                 {\cf19 if} ( result.value().type() == ParseResultType::ShortCircuitAll )\par
3035                     {\cf19 return} result;\par
3036                 {\cf19 if} ( !tokenParsed )\par
3037                     {\cf19 return} Detail::InternalParseResult::runtimeError(\par
3038                         {\cf22 "Unrecognised token: "} +\par
3039                         result.value().remainingTokens()->token );\par
3040             \}\par
3041             {\cf20 // !TBD Check missing required options}\par
3042             {\cf19 return} result;\par
3043         \}\par
3044 \par
3045         Args::Args({\cf18 int} argc, {\cf18 char} {\cf17 const}* {\cf17 const}* argv) :\par
3046             m_exeName(argv[0]), m_args(argv + 1, argv + argc) \{\}\par
3047 \par
3048         Args::Args(std::initializer_list<StringRef> args) :\par
3049             m_exeName(*args.begin()),\par
3050             m_args(args.begin() + 1, args.end()) \{\}\par
3051 \par
3052 \par
3053         Help::Help( {\cf18 bool}& showHelpFlag ):\par
3054             Opt( [&]( bool flag ) \{\par
3055                 showHelpFlag = flag;\par
3056                 {\cf19 return} ParserResult::ok( ParseResultType::ShortCircuitAll );\par
3057             \} ) \{\par
3058             {\cf17 static_cast<}Opt&{\cf17 >} ( *this )(\par
3059                 {\cf22 "display usage information"} )[{\cf22 "-?"}][{\cf22 "-h"}][{\cf22 "--help"}]\par
3060                 .optional();\par
3061         \}\par
3062 \par
3063     \} {\cf20 // namespace Clara}\par
3064 \} {\cf20 // namespace Catch}\par
3065 \par
3066 \par
3067 \par
3068 \par
3069 {\cf21 #include <fstream>}\par
3070 {\cf21 #include <string>}\par
3071 \par
3072 {\cf17 namespace }Catch \{\par
3073 \par
3074     Clara::Parser makeCommandLineParser( ConfigData& config ) \{\par
3075 \par
3076         {\cf17 using namespace }Clara;\par
3077 \par
3078         {\cf17 auto} {\cf17 const} setWarning = [&]( std::string {\cf17 const}& warning ) \{\par
3079             {\cf19 if} ( warning == {\cf22 "NoAssertions"} ) \{\par
3080                 config.warnings = {\cf17 static_cast<}WarnAbout::What{\cf17 >}(config.warnings | WarnAbout::NoAssertions);\par
3081                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3082             \} {\cf19 else} {\cf19 if} ( warning == {\cf22 "UnmatchedTestSpec"} ) \{\par
3083                 config.warnings = {\cf17 static_cast<}WarnAbout::What{\cf17 >}(config.warnings | WarnAbout::UnmatchedTestSpec);\par
3084                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3085             \}\par
3086 \par
3087             {\cf19 return} ParserResult ::runtimeError(\par
3088                 {\cf22 "Unrecognised warning option: '"} + warning + {\cf23 '\\''} );\par
3089         \};\par
3090         {\cf17 auto} {\cf17 const} loadTestNamesFromFile = [&]( std::string {\cf17 const}& filename ) \{\par
3091                 std::ifstream f( filename.c_str() );\par
3092                 {\cf19 if}( !f.is_open() )\par
3093                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unable to load input file: '"} + filename + {\cf23 '\\''} );\par
3094 \par
3095                 std::string line;\par
3096                 {\cf19 while}( std::getline( f, line ) ) \{\par
3097                     line = trim(line);\par
3098                     {\cf19 if}( !line.empty() && !startsWith( line, {\cf23 '#'} ) ) \{\par
3099                         {\cf19 if}( !startsWith( line, {\cf23 '"'} ) )\par
3100                             line = {\cf23 '"'} + CATCH_MOVE(line) + {\cf23 '"'};\par
3101                         config.testsOrTags.push_back( line );\par
3102                         config.testsOrTags.emplace_back( {\cf22 ","} );\par
3103                     \}\par
3104                 \}\par
3105                 {\cf20 //Remove comma in the end}\par
3106                 {\cf19 if}(!config.testsOrTags.empty())\par
3107                     config.testsOrTags.erase( config.testsOrTags.end()-1 );\par
3108 \par
3109                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3110             \};\par
3111         {\cf17 auto} {\cf17 const} setTestOrder = [&]( std::string {\cf17 const}& order ) \{\par
3112                 {\cf19 if}( startsWith( {\cf22 "declared"}, order ) )\par
3113                     config.runOrder = TestRunOrder::Declared;\par
3114                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "lexical"}, order ) )\par
3115                     config.runOrder = TestRunOrder::LexicographicallySorted;\par
3116                 {\cf19 else} {\cf19 if}( startsWith( {\cf22 "random"}, order ) )\par
3117                     config.runOrder = TestRunOrder::Randomized;\par
3118                 {\cf19 else}\par
3119                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised ordering: '"} + order + {\cf23 '\\''} );\par
3120                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3121             \};\par
3122         {\cf17 auto} {\cf17 const} setRngSeed = [&]( std::string {\cf17 const}& seed ) \{\par
3123                 {\cf19 if}( seed == {\cf22 "time"} ) \{\par
3124                     config.rngSeed = generateRandomSeed(GenerateFrom::Time);\par
3125                     {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
3126                 \} {\cf19 else} {\cf19 if} (seed == {\cf22 "random-device"}) \{\par
3127                     config.rngSeed = generateRandomSeed(GenerateFrom::RandomDevice);\par
3128                     {\cf19 return} ParserResult::ok(ParseResultType::Matched);\par
3129                 \}\par
3130 \par
3131                 {\cf20 // TODO: ideally we should be parsing uint32_t directly}\par
3132                 {\cf20 //       fix this later when we add new parse overload}\par
3133                 {\cf17 auto} parsedSeed = parseUInt( seed, 0 );\par
3134                 {\cf19 if} ( !parsedSeed ) \{\par
3135                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Could not parse '"} + seed + {\cf22 "' as seed"} );\par
3136                 \}\par
3137                 config.rngSeed = *parsedSeed;\par
3138                 {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3139             \};\par
3140         {\cf17 auto} {\cf17 const} setDefaultColourMode = [&]( std::string {\cf17 const}& colourMode ) \{\par
3141             Optional<ColourMode> maybeMode = Catch::Detail::stringToColourMode(toLower( colourMode ));\par
3142             {\cf19 if} ( !maybeMode ) \{\par
3143                 {\cf19 return} ParserResult::runtimeError(\par
3144                     {\cf22 "colour mode must be one of: default, ansi, win32, "}\par
3145                     {\cf22 "or none. '"} +\par
3146                     colourMode + {\cf22 "' is not recognised"} );\par
3147             \}\par
3148             {\cf17 auto} mode = *maybeMode;\par
3149             {\cf19 if} ( !isColourImplAvailable( mode ) ) \{\par
3150                 {\cf19 return} ParserResult::runtimeError(\par
3151                     {\cf22 "colour mode '"} + colourMode +\par
3152                     {\cf22 "' is not supported in this binary"} );\par
3153             \}\par
3154             config.defaultColourMode = mode;\par
3155             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3156         \};\par
3157         {\cf17 auto} {\cf17 const} setWaitForKeypress = [&]( std::string {\cf17 const}& keypress ) \{\par
3158                 {\cf17 auto} keypressLc = toLower( keypress );\par
3159                 {\cf19 if} (keypressLc == {\cf22 "never"})\par
3160                     config.waitForKeypress = WaitForKeypress::Never;\par
3161                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "start"} )\par
3162                     config.waitForKeypress = WaitForKeypress::BeforeStart;\par
3163                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "exit"} )\par
3164                     config.waitForKeypress = WaitForKeypress::BeforeExit;\par
3165                 {\cf19 else} {\cf19 if}( keypressLc == {\cf22 "both"} )\par
3166                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;\par
3167                 {\cf19 else}\par
3168                     {\cf19 return} ParserResult::runtimeError( {\cf22 "keypress argument must be one of: never, start, exit or both. '"} + keypress + {\cf22 "' not recognised"} );\par
3169             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3170             \};\par
3171         {\cf17 auto} {\cf17 const} setVerbosity = [&]( std::string {\cf17 const}& verbosity ) \{\par
3172             {\cf17 auto} lcVerbosity = toLower( verbosity );\par
3173             {\cf19 if}( lcVerbosity == {\cf22 "quiet"} )\par
3174                 config.verbosity = Verbosity::Quiet;\par
3175             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "normal"} )\par
3176                 config.verbosity = Verbosity::Normal;\par
3177             {\cf19 else} {\cf19 if}( lcVerbosity == {\cf22 "high"} )\par
3178                 config.verbosity = Verbosity::High;\par
3179             {\cf19 else}\par
3180                 {\cf19 return} ParserResult::runtimeError( {\cf22 "Unrecognised verbosity, '"} + verbosity + {\cf23 '\\''} );\par
3181             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3182         \};\par
3183         {\cf17 auto} {\cf17 const} setReporter = [&]( std::string {\cf17 const}& userReporterSpec ) \{\par
3184             {\cf19 if} ( userReporterSpec.empty() ) \{\par
3185                 {\cf19 return} ParserResult::runtimeError( {\cf22 "Received empty reporter spec."} );\par
3186             \}\par
3187 \par
3188             Optional<ReporterSpec> parsed =\par
3189                 parseReporterSpec( userReporterSpec );\par
3190             {\cf19 if} ( !parsed ) \{\par
3191                 {\cf19 return} ParserResult::runtimeError(\par
3192                     {\cf22 "Could not parse reporter spec '"} + userReporterSpec +\par
3193                     {\cf22 "'"} );\par
3194             \}\par
3195 \par
3196             {\cf17 auto} {\cf17 const}& reporterSpec = *parsed;\par
3197 \par
3198             {\cf17 auto} {\cf17 const}& factories =\par
3199                 getRegistryHub().getReporterRegistry().getFactories();\par
3200             {\cf17 auto} result = factories.find( reporterSpec.name() );\par
3201 \par
3202             {\cf19 if} ( result == factories.end() ) \{\par
3203                 {\cf19 return} ParserResult::runtimeError(\par
3204                     {\cf22 "Unrecognized reporter, '"} + reporterSpec.name() +\par
3205                     {\cf22 "'. Check available with --list-reporters"} );\par
3206             \}\par
3207 \par
3208 \par
3209             {\cf17 const} {\cf18 bool} hadOutputFile = reporterSpec.outputFile().some();\par
3210             config.reporterSpecifications.push_back( CATCH_MOVE( *parsed ) );\par
3211             {\cf20 // It would be enough to check this only once at the very end, but}\par
3212             {\cf20 // there is  not a place where we could call this check, so do it}\par
3213             {\cf20 // every time it could fail. For valid inputs, this is still called}\par
3214             {\cf20 // at most once.}\par
3215             {\cf19 if} (!hadOutputFile) \{\par
3216                 {\cf18 int} n_reporters_without_file = 0;\par
3217                 {\cf19 for} ({\cf17 auto} {\cf17 const}& spec : config.reporterSpecifications) \{\par
3218                     {\cf19 if} (spec.outputFile().none()) \{\par
3219                         n_reporters_without_file++;\par
3220                     \}\par
3221                 \}\par
3222                 {\cf19 if} (n_reporters_without_file > 1) \{\par
3223                     {\cf19 return} ParserResult::runtimeError( {\cf22 "Only one reporter may have unspecified output file."} );\par
3224                 \}\par
3225             \}\par
3226 \par
3227             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3228         \};\par
3229         {\cf17 auto} {\cf17 const} setShardCount = [&]( std::string {\cf17 const}& shardCount ) \{\par
3230             {\cf17 auto} parsedCount = parseUInt( shardCount );\par
3231             {\cf19 if} ( !parsedCount ) \{\par
3232                 {\cf19 return} ParserResult::runtimeError(\par
3233                     {\cf22 "Could not parse '"} + shardCount + {\cf22 "' as shard count"} );\par
3234             \}\par
3235             {\cf19 if} ( *parsedCount == 0 ) \{\par
3236                 {\cf19 return} ParserResult::runtimeError(\par
3237                     {\cf22 "Shard count must be positive"} );\par
3238             \}\par
3239             config.shardCount = *parsedCount;\par
3240             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3241         \};\par
3242 \par
3243         {\cf17 auto} {\cf17 const} setShardIndex = [&](std::string {\cf17 const}& shardIndex) \{\par
3244             {\cf17 auto} parsedIndex = parseUInt( shardIndex );\par
3245             {\cf19 if} ( !parsedIndex ) \{\par
3246                 {\cf19 return} ParserResult::runtimeError(\par
3247                     {\cf22 "Could not parse '"} + shardIndex + {\cf22 "' as shard index"} );\par
3248             \}\par
3249             config.shardIndex = *parsedIndex;\par
3250             {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
3251         \};\par
3252 \par
3253         {\cf17 auto} cli\par
3254             = ExeName( config.processName )\par
3255             | Help( config.showHelp )\par
3256             | Opt( config.showSuccessfulTests )\par
3257                 [{\cf22 "-s"}][{\cf22 "--success"}]\par
3258                 ( {\cf22 "include successful tests in output"} )\par
3259             | Opt( config.shouldDebugBreak )\par
3260                 [{\cf22 "-b"}][{\cf22 "--break"}]\par
3261                 ( {\cf22 "break into debugger on failure"} )\par
3262             | Opt( config.noThrow )\par
3263                 [{\cf22 "-e"}][{\cf22 "--nothrow"}]\par
3264                 ( {\cf22 "skip exception tests"} )\par
3265             | Opt( config.showInvisibles )\par
3266                 [{\cf22 "-i"}][{\cf22 "--invisibles"}]\par
3267                 ( {\cf22 "show invisibles (tabs, newlines)"} )\par
3268             | Opt( config.defaultOutputFilename, {\cf22 "filename"} )\par
3269                 [{\cf22 "-o"}][{\cf22 "--out"}]\par
3270                 ( {\cf22 "default output filename"} )\par
3271             | Opt( accept_many, setReporter, {\cf22 "name[::key=value]*"} )\par
3272                 [{\cf22 "-r"}][{\cf22 "--reporter"}]\par
3273                 ( {\cf22 "reporter to use (defaults to console)"} )\par
3274             | Opt( config.name, {\cf22 "name"} )\par
3275                 [{\cf22 "-n"}][{\cf22 "--name"}]\par
3276                 ( {\cf22 "suite name"} )\par
3277             | Opt( [&]( {\cf18 bool} )\{ config.abortAfter = 1; \} )\par
3278                 [{\cf22 "-a"}][{\cf22 "--abort"}]\par
3279                 ( {\cf22 "abort at first failure"} )\par
3280             | Opt( [&]( {\cf18 int} x )\{ config.abortAfter = x; \}, {\cf22 "no. failures"} )\par
3281                 [{\cf22 "-x"}][{\cf22 "--abortx"}]\par
3282                 ( {\cf22 "abort after x failures"} )\par
3283             | Opt( accept_many, setWarning, {\cf22 "warning name"} )\par
3284                 [{\cf22 "-w"}][{\cf22 "--warn"}]\par
3285                 ( {\cf22 "enable warnings"} )\par
3286             | Opt( [&]( {\cf18 bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, {\cf22 "yes|no"} )\par
3287                 [{\cf22 "-d"}][{\cf22 "--durations"}]\par
3288                 ( {\cf22 "show test durations"} )\par
3289             | Opt( config.minDuration, {\cf22 "seconds"} )\par
3290                 [{\cf22 "-D"}][{\cf22 "--min-duration"}]\par
3291                 ( {\cf22 "show test durations for tests taking at least the given number of seconds"} )\par
3292             | Opt( loadTestNamesFromFile, {\cf22 "filename"} )\par
3293                 [{\cf22 "-f"}][{\cf22 "--input-file"}]\par
3294                 ( {\cf22 "load test names to run from a file"} )\par
3295             | Opt( config.filenamesAsTags )\par
3296                 [{\cf22 "-#"}][{\cf22 "--filenames-as-tags"}]\par
3297                 ( {\cf22 "adds a tag for the filename"} )\par
3298             | Opt( config.sectionsToRun, {\cf22 "section name"} )\par
3299                 [{\cf22 "-c"}][{\cf22 "--section"}]\par
3300                 ( {\cf22 "specify section to run"} )\par
3301             | Opt( setVerbosity, {\cf22 "quiet|normal|high"} )\par
3302                 [{\cf22 "-v"}][{\cf22 "--verbosity"}]\par
3303                 ( {\cf22 "set output verbosity"} )\par
3304             | Opt( config.listTests )\par
3305                 [{\cf22 "--list-tests"}]\par
3306                 ( {\cf22 "list all/matching test cases"} )\par
3307             | Opt( config.listTags )\par
3308                 [{\cf22 "--list-tags"}]\par
3309                 ( {\cf22 "list all/matching tags"} )\par
3310             | Opt( config.listReporters )\par
3311                 [{\cf22 "--list-reporters"}]\par
3312                 ( {\cf22 "list all available reporters"} )\par
3313             | Opt( config.listListeners )\par
3314                 [{\cf22 "--list-listeners"}]\par
3315                 ( {\cf22 "list all listeners"} )\par
3316             | Opt( setTestOrder, {\cf22 "decl|lex|rand"} )\par
3317                 [{\cf22 "--order"}]\par
3318                 ( {\cf22 "test case order (defaults to decl)"} )\par
3319             | Opt( setRngSeed, {\cf22 "'time'|'random-device'|number"} )\par
3320                 [{\cf22 "--rng-seed"}]\par
3321                 ( {\cf22 "set a specific seed for random numbers"} )\par
3322             | Opt( setDefaultColourMode, {\cf22 "ansi|win32|none|default"} )\par
3323                 [{\cf22 "--colour-mode"}]\par
3324                 ( {\cf22 "what color mode should be used as default"} )\par
3325             | Opt( config.libIdentify )\par
3326                 [{\cf22 "--libidentify"}]\par
3327                 ( {\cf22 "report name and version according to libidentify standard"} )\par
3328             | Opt( setWaitForKeypress, {\cf22 "never|start|exit|both"} )\par
3329                 [{\cf22 "--wait-for-keypress"}]\par
3330                 ( {\cf22 "waits for a keypress before exiting"} )\par
3331             | Opt( config.skipBenchmarks)\par
3332                 [{\cf22 "--skip-benchmarks"}]\par
3333                 ( {\cf22 "disable running benchmarks"})\par
3334             | Opt( config.benchmarkSamples, {\cf22 "samples"} )\par
3335                 [{\cf22 "--benchmark-samples"}]\par
3336                 ( {\cf22 "number of samples to collect (default: 100)"} )\par
3337             | Opt( config.benchmarkResamples, {\cf22 "resamples"} )\par
3338                 [{\cf22 "--benchmark-resamples"}]\par
3339                 ( {\cf22 "number of resamples for the bootstrap (default: 100000)"} )\par
3340             | Opt( config.benchmarkConfidenceInterval, {\cf22 "confidence interval"} )\par
3341                 [{\cf22 "--benchmark-confidence-interval"}]\par
3342                 ( {\cf22 "confidence interval for the bootstrap (between 0 and 1, default: 0.95)"} )\par
3343             | Opt( config.benchmarkNoAnalysis )\par
3344                 [{\cf22 "--benchmark-no-analysis"}]\par
3345                 ( {\cf22 "perform only measurements; do not perform any analysis"} )\par
3346             | Opt( config.benchmarkWarmupTime, {\cf22 "benchmarkWarmupTime"} )\par
3347                 [{\cf22 "--benchmark-warmup-time"}]\par
3348                 ( {\cf22 "amount of time in milliseconds spent on warming up each test (default: 100)"} )\par
3349             | Opt( setShardCount, {\cf22 "shard count"} )\par
3350                 [{\cf22 "--shard-count"}]\par
3351                 ( {\cf22 "split the tests to execute into this many groups"} )\par
3352             | Opt( setShardIndex, {\cf22 "shard index"} )\par
3353                 [{\cf22 "--shard-index"}]\par
3354                 ( {\cf22 "index of the group of tests to execute (see --shard-count)"} )\par
3355             | Opt( config.allowZeroTests )\par
3356                 [{\cf22 "--allow-running-no-tests"}]\par
3357                 ( {\cf22 "Treat 'No tests run' as a success"} )\par
3358             | Arg( config.testsOrTags, {\cf22 "test name|pattern|tags"} )\par
3359                 ( {\cf22 "which test or tests to use"} );\par
3360 \par
3361         {\cf19 return} cli;\par
3362     \}\par
3363 \par
3364 \} {\cf20 // end namespace Catch}\par
3365 \par
3366 \par
3367 {\cf21 #if defined(__clang__)}\par
3368 {\cf21 #    pragma clang diagnostic push}\par
3369 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
3370 {\cf21 #endif}\par
3371 \par
3372 \par
3373 \par
3374 {\cf21 #include <cassert>}\par
3375 {\cf21 #include <ostream>}\par
3376 {\cf21 #include <utility>}\par
3377 \par
3378 {\cf17 namespace }Catch \{\par
3379 \par
3380     ColourImpl::~ColourImpl() = {\cf19 default};\par
3381 \par
3382     ColourImpl::ColourGuard ColourImpl::guardColour( Colour::Code colourCode ) \{\par
3383         {\cf19 return} ColourGuard(colourCode, {\cf17 this} );\par
3384     \}\par
3385 \par
3386     {\cf18 void} ColourImpl::ColourGuard::engageImpl( std::ostream& stream ) \{\par
3387         assert( &stream == &m_colourImpl->m_stream->stream() &&\par
3388                 {\cf22 "Engaging colour guard for different stream than used by the "}\par
3389                 {\cf22 "parent colour implementation"} );\par
3390         {\cf17 static_cast<}{\cf18 void}{\cf17 >}( stream );\par
3391 \par
3392         m_engaged = {\cf17 true};\par
3393         m_colourImpl->use( m_code );\par
3394     \}\par
3395 \par
3396     ColourImpl::ColourGuard::ColourGuard( Colour::Code code,\par
3397                                           ColourImpl {\cf17 const}* colour ):\par
3398         m_colourImpl( colour ), m_code( code ) \{\par
3399     \}\par
3400     ColourImpl::ColourGuard::ColourGuard( ColourGuard&& rhs ) {\cf17 noexcept}:\par
3401         m_colourImpl( rhs.m_colourImpl ),\par
3402         m_code( rhs.m_code ),\par
3403         m_engaged( rhs.m_engaged ) \{\par
3404         rhs.m_engaged = {\cf17 false};\par
3405     \}\par
3406     ColourImpl::ColourGuard&\par
3407     ColourImpl::ColourGuard::operator=( ColourGuard&& rhs ) {\cf17 noexcept} \{\par
3408         {\cf17 using }std::swap;\par
3409         swap( m_colourImpl, rhs.m_colourImpl );\par
3410         swap( m_code, rhs.m_code );\par
3411         swap( m_engaged, rhs.m_engaged );\par
3412 \par
3413         {\cf19 return} *{\cf17 this};\par
3414     \}\par
3415     ColourImpl::ColourGuard::~ColourGuard() \{\par
3416         {\cf19 if} ( m_engaged ) \{\par
3417             m_colourImpl->use( Colour::None );\par
3418         \}\par
3419     \}\par
3420 \par
3421     ColourImpl::ColourGuard&\par
3422     ColourImpl::ColourGuard::engage( std::ostream& stream ) & \{\par
3423         engageImpl( stream );\par
3424         {\cf19 return} *{\cf17 this};\par
3425     \}\par
3426 \par
3427     ColourImpl::ColourGuard&&\par
3428     ColourImpl::ColourGuard::engage( std::ostream& stream ) && \{\par
3429         engageImpl( stream );\par
3430         {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
3431     \}\par
3432 \par
3433     {\cf17 namespace }\{\par
3436         {\cf17 class }NoColourImpl final : {\cf17 public} ColourImpl \{\par
3437         {\cf17 public}:\par
3438             NoColourImpl( IStream* stream ): ColourImpl( stream ) \{\}\par
3439 \par
3440         {\cf17 private}:\par
3441             {\cf18 void} use( Colour::Code ){\cf17  const override }\{\}\par
3442         \};\par
3443     \} {\cf20 // namespace}\par
3444 \par
3445 \par
3446 \} {\cf20 // namespace Catch}\par
3447 \par
3448 \par
3449 {\cf21 #if defined ( CATCH_CONFIG_COLOUR_WIN32 ) }\par
3450 \par
3451 {\cf17 namespace }Catch \{\par
3452 {\cf17 namespace }\{\par
3453 \par
3454     {\cf17 class }Win32ColourImpl final : {\cf17 public} ColourImpl \{\par
3455     {\cf17 public}:\par
3456         Win32ColourImpl(IStream* stream):\par
3457             ColourImpl(stream) \{\par
3458             CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\par
3459             GetConsoleScreenBufferInfo( GetStdHandle( STD_OUTPUT_HANDLE ),\par
3460                                         &csbiInfo );\par
3461             originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );\par
3462             originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );\par
3463         \}\par
3464 \par
3465         {\cf17 static} {\cf18 bool} useImplementationForStream(IStream {\cf17 const}& stream) \{\par
3466             {\cf20 // Win32 text colour APIs can only be used on console streams}\par
3467             {\cf20 // We cannot check that the output hasn't been redirected,}\par
3468             {\cf20 // so we just check that the original stream is console stream.}\par
3469             {\cf19 return} stream.isConsole();\par
3470         \}\par
3471 \par
3472     {\cf17 private}:\par
3473         {\cf18 void} use( Colour::Code _colourCode ){\cf17  const override }\{\par
3474             {\cf19 switch}( _colourCode ) \{\par
3475                 {\cf19 case} Colour::None:      {\cf19 return} setTextAttribute( originalForegroundAttributes );\par
3476                 {\cf19 case} Colour::White:     {\cf19 return} setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\par
3477                 {\cf19 case} Colour::Red:       {\cf19 return} setTextAttribute( FOREGROUND_RED );\par
3478                 {\cf19 case} Colour::Green:     {\cf19 return} setTextAttribute( FOREGROUND_GREEN );\par
3479                 {\cf19 case} Colour::Blue:      {\cf19 return} setTextAttribute( FOREGROUND_BLUE );\par
3480                 {\cf19 case} Colour::Cyan:      {\cf19 return} setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );\par
3481                 {\cf19 case} Colour::Yellow:    {\cf19 return} setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );\par
3482                 {\cf19 case} Colour::Grey:      {\cf19 return} setTextAttribute( 0 );\par
3483 \par
3484                 {\cf19 case} Colour::LightGrey:     {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY );\par
3485                 {\cf19 case} Colour::BrightRed:     {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );\par
3486                 {\cf19 case} Colour::BrightGreen:   {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );\par
3487                 {\cf19 case} Colour::BrightWhite:   {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );\par
3488                 {\cf19 case} Colour::BrightYellow:  {\cf19 return} setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );\par
3489 \par
3490                 {\cf19 case} Colour::Bright: CATCH_INTERNAL_ERROR( {\cf22 "not a colour"} );\par
3491 \par
3492                 {\cf19 default}:\par
3493                     CATCH_ERROR( {\cf22 "Unknown colour requested"} );\par
3494             \}\par
3495         \}\par
3496 \par
3497         {\cf18 void} setTextAttribute( WORD _textAttribute ){\cf17  const }\{\par
3498             SetConsoleTextAttribute( GetStdHandle( STD_OUTPUT_HANDLE ),\par
3499                                      _textAttribute |\par
3500                                          originalBackgroundAttributes );\par
3501         \}\par
3502         WORD originalForegroundAttributes;\par
3503         WORD originalBackgroundAttributes;\par
3504     \};\par
3505 \par
3506 \} {\cf20 // end anon namespace}\par
3507 \} {\cf20 // end namespace Catch}\par
3508 \par
3509 {\cf21 #endif }{\cf20 // Windows/ ANSI/ None}\par
3510 \par
3511 \par
3512 {\cf21 #if defined( CATCH_PLATFORM_LINUX ) || defined( CATCH_PLATFORM_MAC )}\par
3513 {\cf21 #    define CATCH_INTERNAL_HAS_ISATTY}\par
3514 {\cf21 #    include <unistd.h>}\par
3515 {\cf21 #endif}\par
3516 \par
3517 {\cf17 namespace }Catch \{\par
3518 {\cf17 namespace }\{\par
3519 \par
3520     {\cf17 class }ANSIColourImpl final : {\cf17 public} ColourImpl \{\par
3521     {\cf17 public}:\par
3522         ANSIColourImpl( IStream* stream ): ColourImpl( stream ) \{\}\par
3523 \par
3524         {\cf17 static} {\cf18 bool} useImplementationForStream(IStream {\cf17 const}& stream) \{\par
3525             {\cf20 // This is kinda messy due to trying to support a bunch of}\par
3526             {\cf20 // different platforms at once.}\par
3527             {\cf20 // The basic idea is that if we are asked to do autodetection (as}\par
3528             {\cf20 // opposed to being told to use posixy colours outright), then we}\par
3529             {\cf20 // only want to use the colours if we are writing to console.}\par
3530             {\cf20 // However, console might be redirected, so we make an attempt at}\par
3531             {\cf20 // checking for that on platforms where we know how to do that.}\par
3532             {\cf18 bool} useColour = stream.isConsole();\par
3533 {\cf21 #if defined( CATCH_INTERNAL_HAS_ISATTY ) && \\}\par
3534 {\cf21     !( defined( __DJGPP__ ) && defined( __STRICT_ANSI__ ) )}\par
3535             ErrnoGuard _; {\cf20 // for isatty}\par
3536             useColour = useColour && isatty( STDOUT_FILENO );\par
3537 {\cf21 #    endif}\par
3538 {\cf21 #    if defined( CATCH_PLATFORM_MAC ) || defined( CATCH_PLATFORM_IPHONE )}\par
3539             useColour = useColour && !isDebuggerActive();\par
3540 {\cf21 #    endif}\par
3541 \par
3542             {\cf19 return} useColour;\par
3543         \}\par
3544 \par
3545     {\cf17 private}:\par
3546         {\cf18 void} use( Colour::Code _colourCode ){\cf17  const override }\{\par
3547             {\cf17 auto} setColour = [&out =\par
3548                                   m_stream->stream()]( {\cf18 char} {\cf17 const}* escapeCode ) \{\par
3549                 {\cf20 // The escape sequence must be flushed to console, otherwise}\par
3550                 {\cf20 // if stdin and stderr are intermixed, we'd get accidentally}\par
3551                 {\cf20 // coloured output.}\par
3552                 out << {\cf23 '\\033'} << escapeCode << std::flush;\par
3553             \};\par
3554             {\cf19 switch}( _colourCode ) \{\par
3555                 {\cf19 case} Colour::None:\par
3556                 {\cf19 case} Colour::White:     {\cf19 return} setColour( {\cf22 "[0m"} );\par
3557                 {\cf19 case} Colour::Red:       {\cf19 return} setColour( {\cf22 "[0;31m"} );\par
3558                 {\cf19 case} Colour::Green:     {\cf19 return} setColour( {\cf22 "[0;32m"} );\par
3559                 {\cf19 case} Colour::Blue:      {\cf19 return} setColour( {\cf22 "[0;34m"} );\par
3560                 {\cf19 case} Colour::Cyan:      {\cf19 return} setColour( {\cf22 "[0;36m"} );\par
3561                 {\cf19 case} Colour::Yellow:    {\cf19 return} setColour( {\cf22 "[0;33m"} );\par
3562                 {\cf19 case} Colour::Grey:      {\cf19 return} setColour( {\cf22 "[1;30m"} );\par
3563 \par
3564                 {\cf19 case} Colour::LightGrey:     {\cf19 return} setColour( {\cf22 "[0;37m"} );\par
3565                 {\cf19 case} Colour::BrightRed:     {\cf19 return} setColour( {\cf22 "[1;31m"} );\par
3566                 {\cf19 case} Colour::BrightGreen:   {\cf19 return} setColour( {\cf22 "[1;32m"} );\par
3567                 {\cf19 case} Colour::BrightWhite:   {\cf19 return} setColour( {\cf22 "[1;37m"} );\par
3568                 {\cf19 case} Colour::BrightYellow:  {\cf19 return} setColour( {\cf22 "[1;33m"} );\par
3569 \par
3570                 {\cf19 case} Colour::Bright: CATCH_INTERNAL_ERROR( {\cf22 "not a colour"} );\par
3571                 {\cf19 default}: CATCH_INTERNAL_ERROR( {\cf22 "Unknown colour requested"} );\par
3572             \}\par
3573         \}\par
3574     \};\par
3575 \par
3576 \} {\cf20 // end anon namespace}\par
3577 \} {\cf20 // end namespace Catch}\par
3578 \par
3579 {\cf17 namespace }Catch \{\par
3580 \par
3581     Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,\par
3582                                                    IStream* stream ) \{\par
3583 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3584         {\cf19 if} ( colourSelection == ColourMode::Win32 ) \{\par
3585             {\cf19 return} Detail::make_unique<Win32ColourImpl>( stream );\par
3586         \}\par
3587 {\cf21 #endif}\par
3588         {\cf19 if} ( colourSelection == ColourMode::ANSI ) \{\par
3589             {\cf19 return} Detail::make_unique<ANSIColourImpl>( stream );\par
3590         \}\par
3591         {\cf19 if} ( colourSelection == ColourMode::None ) \{\par
3592             {\cf19 return} Detail::make_unique<NoColourImpl>( stream );\par
3593         \}\par
3594 \par
3595         {\cf19 if} ( colourSelection == ColourMode::PlatformDefault) \{\par
3596 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3597             {\cf19 if} ( Win32ColourImpl::useImplementationForStream( *stream ) ) \{\par
3598                 {\cf19 return} Detail::make_unique<Win32ColourImpl>( stream );\par
3599             \}\par
3600 {\cf21 #endif}\par
3601             {\cf19 if} ( ANSIColourImpl::useImplementationForStream( *stream ) ) \{\par
3602                 {\cf19 return} Detail::make_unique<ANSIColourImpl>( stream );\par
3603             \}\par
3604             {\cf19 return} Detail::make_unique<NoColourImpl>( stream );\par
3605         \}\par
3606 \par
3607         CATCH_ERROR( {\cf22 "Could not create colour impl for selection "} << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(colourSelection) );\par
3608     \}\par
3609 \par
3610     {\cf18 bool} isColourImplAvailable( ColourMode colourSelection ) \{\par
3611         {\cf19 switch} ( colourSelection ) \{\par
3612 {\cf21 #if defined( CATCH_CONFIG_COLOUR_WIN32 )}\par
3613         {\cf19 case} ColourMode::Win32:\par
3614 {\cf21 #endif}\par
3615         {\cf19 case} ColourMode::ANSI:\par
3616         {\cf19 case} ColourMode::None:\par
3617         {\cf19 case} ColourMode::PlatformDefault:\par
3618             {\cf19 return} {\cf17 true};\par
3619         {\cf19 default}:\par
3620             {\cf19 return} {\cf17 false};\par
3621         \}\par
3622     \}\par
3623 \par
3624 \par
3625 \} {\cf20 // end namespace Catch}\par
3626 \par
3627 {\cf21 #if defined(__clang__)}\par
3628 {\cf21 #    pragma clang diagnostic pop}\par
3629 {\cf21 #endif}\par
3630 \par
3631 \par
3632 \par
3633 \par
3634 {\cf17 namespace }Catch \{\par
3635 \par
3636     Context* Context::currentContext = {\cf17 nullptr};\par
3637 \par
3638     {\cf18 void} cleanUpContext() \{\par
3639         {\cf17 delete} Context::currentContext;\par
3640         Context::currentContext = {\cf17 nullptr};\par
3641     \}\par
3642     {\cf18 void} Context::createContext() \{\par
3643         currentContext = {\cf17 new} Context();\par
3644     \}\par
3645 \par
3646     Context& getCurrentMutableContext() \{\par
3647         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
3648         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
3649         {\cf19 return} *Context::currentContext;\par
3650     \}\par
3651 \par
3652     {\cf18 void} Context::setResultCapture( IResultCapture* resultCapture ) \{\par
3653         m_resultCapture = resultCapture;\par
3654     \}\par
3655 \par
3656     {\cf18 void} Context::setConfig( IConfig {\cf17 const}* config ) \{ m_config = config; \}\par
3657 \par
3658     SimplePcg32& sharedRng() \{\par
3659         {\cf17 static} SimplePcg32 s_rng;\par
3660         {\cf19 return} s_rng;\par
3661     \}\par
3662 \par
3663 \}\par
3664 \par
3665 \par
3666 \par
3667 \par
3668 \par
3669 {\cf21 #include <ostream>}\par
3670 \par
3671 {\cf21 #if defined(CATCH_CONFIG_ANDROID_LOGWRITE)}\par
3672 {\cf21 #include <android/log.h>}\par
3673 \par
3674     {\cf17 namespace }Catch \{\par
3675         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
3676             __android_log_write( ANDROID_LOG_DEBUG, {\cf22 "Catch"}, text.c_str() );\par
3677         \}\par
3678     \}\par
3679 \par
3680 {\cf21 #elif defined(CATCH_PLATFORM_WINDOWS)}\par
3681 \par
3682     {\cf17 namespace }Catch \{\par
3683         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
3684             ::OutputDebugStringA( text.c_str() );\par
3685         \}\par
3686     \}\par
3687 \par
3688 {\cf21 #else}\par
3689 \par
3690     {\cf17 namespace }Catch \{\par
3691         {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text ) \{\par
3692             {\cf20 // !TBD: Need a version for Mac/ XCode and other IDEs}\par
3693             Catch::cout() << text;\par
3694         \}\par
3695     \}\par
3696 \par
3697 {\cf21 #endif }{\cf20 // Platform}\par
3698 \par
3699 \par
3700 \par
3701 {\cf21 #if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)}\par
3702 \par
3703 {\cf21 #  include <cassert>}\par
3704 {\cf21 #  include <sys/types.h>}\par
3705 {\cf21 #  include <unistd.h>}\par
3706 {\cf21 #  include <cstddef>}\par
3707 {\cf21 #  include <ostream>}\par
3708 \par
3709 {\cf21 #ifdef __apple_build_version__}\par
3710     {\cf20 // These headers will only compile with AppleClang (XCode)}\par
3711     {\cf20 // For other compilers (Clang, GCC, ... ) we need to exclude them}\par
3712 {\cf21 #  include <sys/sysctl.h>}\par
3713 {\cf21 #endif}\par
3714 \par
3715     {\cf17 namespace }Catch \{\par
3716 {\cf21         #ifdef __apple_build_version__}\par
3717         {\cf20 // The following function is taken directly from the following technical note:}\par
3718         {\cf20 // https://developer.apple.com/library/archive/qa/qa1361/_index.html}\par
3719 \par
3720         {\cf20 // Returns true if the current process is being debugged (either}\par
3721         {\cf20 // running under the debugger or has a debugger attached post facto).}\par
3722         {\cf18 bool} isDebuggerActive()\{\par
3723             {\cf18 int}                 mib[4];\par
3724             {\cf17 struct }kinfo_proc   info;\par
3725             std::size_t         size;\par
3726 \par
3727             {\cf20 // Initialize the flags so that, if sysctl fails for some bizarre}\par
3728             {\cf20 // reason, we get a predictable result.}\par
3729 \par
3730             info.kp_proc.p_flag = 0;\par
3731 \par
3732             {\cf20 // Initialize mib, which tells sysctl the info we want, in this case}\par
3733             {\cf20 // we're looking for information about a specific process ID.}\par
3734 \par
3735             mib[0] = CTL_KERN;\par
3736             mib[1] = KERN_PROC;\par
3737             mib[2] = KERN_PROC_PID;\par
3738             mib[3] = getpid();\par
3739 \par
3740             {\cf20 // Call sysctl.}\par
3741 \par
3742             size = {\cf17 sizeof}(info);\par
3743             {\cf19 if}( sysctl(mib, {\cf17 sizeof}(mib) / {\cf17 sizeof}(*mib), &info, &size, {\cf17 nullptr}, 0) != 0 ) \{\par
3744                 Catch::cerr() << {\cf22 "\\n** Call to sysctl failed - unable to determine if debugger is active **\\n\\n"} << std::flush;\par
3745                 {\cf19 return} {\cf17 false};\par
3746             \}\par
3747 \par
3748             {\cf20 // We're being debugged if the P_TRACED flag is set.}\par
3749 \par
3750             {\cf19 return} ( (info.kp_proc.p_flag & P_TRACED) != 0 );\par
3751         \}\par
3752 {\cf21         #else}\par
3753         {\cf18 bool} isDebuggerActive() \{\par
3754             {\cf20 // We need to find another way to determine this for non-appleclang compilers on macOS}\par
3755             {\cf19 return} {\cf17 false};\par
3756         \}\par
3757 {\cf21         #endif}\par
3758     \} {\cf20 // namespace Catch}\par
3759 \par
3760 {\cf21 #elif defined(CATCH_PLATFORM_LINUX)}\par
3761 {\cf21     #include <fstream>}\par
3762 {\cf21     #include <string>}\par
3763 \par
3764     {\cf17 namespace }Catch\{\par
3765         {\cf20 // The standard POSIX way of detecting a debugger is to attempt to}\par
3766         {\cf20 // ptrace() the process, but this needs to be done from a child and not}\par
3767         {\cf20 // this process itself to still allow attaching to this process later}\par
3768         {\cf20 // if wanted, so is rather heavy. Under Linux we have the PID of the}\par
3769         {\cf20 // "debugger" (which doesn't need to be gdb, of course, it could also}\par
3770         {\cf20 // be strace, for example) in /proc/$PID/status, so just get it from}\par
3771         {\cf20 // there instead.}\par
3772         {\cf18 bool} isDebuggerActive()\{\par
3773             {\cf20 // Libstdc++ has a bug, where std::ifstream sets errno to 0}\par
3774             {\cf20 // This way our users can properly assert over errno values}\par
3775             ErrnoGuard guard;\par
3776             std::ifstream in({\cf22 "/proc/self/status"});\par
3777             {\cf19 for}( std::string line; std::getline(in, line); ) \{\par
3778                 {\cf17 static} {\cf17 const} {\cf18 int} PREFIX_LEN = 11;\par
3779                 {\cf19 if}( line.compare(0, PREFIX_LEN, {\cf22 "TracerPid:\\t"}) == 0 ) \{\par
3780                     {\cf20 // We're traced if the PID is not 0 and no other PID starts}\par
3781                     {\cf20 // with 0 digit, so it's enough to check for just a single}\par
3782                     {\cf20 // character.}\par
3783                     {\cf19 return} line.length() > PREFIX_LEN && line[PREFIX_LEN] != {\cf23 '0'};\par
3784                 \}\par
3785             \}\par
3786 \par
3787             {\cf19 return} {\cf17 false};\par
3788         \}\par
3789     \} {\cf20 // namespace Catch}\par
3790 {\cf21 #elif defined(_MSC_VER)}\par
3791     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 int} __stdcall IsDebuggerPresent();\par
3792     {\cf17 namespace }Catch \{\par
3793         {\cf18 bool} isDebuggerActive() \{\par
3794             {\cf19 return} IsDebuggerPresent() != 0;\par
3795         \}\par
3796     \}\par
3797 {\cf21 #elif defined(__MINGW32__)}\par
3798     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 int} __stdcall IsDebuggerPresent();\par
3799     {\cf17 namespace }Catch \{\par
3800         {\cf18 bool} isDebuggerActive() \{\par
3801             {\cf19 return} IsDebuggerPresent() != 0;\par
3802         \}\par
3803     \}\par
3804 {\cf21 #else}\par
3805     {\cf17 namespace }Catch \{\par
3806        {\cf18 bool} isDebuggerActive() \{ {\cf19 return} {\cf17 false}; \}\par
3807     \}\par
3808 {\cf21 #endif }{\cf20 // Platform}\par
3809 \par
3810 \par
3811 \par
3812 \par
3813 {\cf17 namespace }Catch \{\par
3814 \par
3815     {\cf18 void} ITransientExpression::streamReconstructedExpression(\par
3816         std::ostream& os ){\cf17  const }\{\par
3817         {\cf20 // We can't make this function pure virtual to keep ITransientExpression}\par
3818         {\cf20 // constexpr, so we write error message instead}\par
3819         os << {\cf22 "Some class derived from ITransientExpression without overriding streamReconstructedExpression"};\par
3820     \}\par
3821 \par
3822     {\cf18 void} formatReconstructedExpression( std::ostream &os, std::string {\cf17 const}& lhs, StringRef op, std::string {\cf17 const}& rhs ) \{\par
3823         {\cf19 if}( lhs.size() + rhs.size() < 40 &&\par
3824                 lhs.find({\cf23 '\\n'}) == std::string::npos &&\par
3825                 rhs.find({\cf23 '\\n'}) == std::string::npos )\par
3826             os << lhs << {\cf23 ' '} << op << {\cf23 ' '} << rhs;\par
3827         {\cf19 else}\par
3828             os << lhs << {\cf23 '\\n'} << op << {\cf23 '\\n'} << rhs;\par
3829     \}\par
3830 \}\par
3831 \par
3832 \par
3833 \par
3834 {\cf21 #include <stdexcept>}\par
3835 \par
3836 \par
3837 {\cf17 namespace }Catch \{\par
3838 {\cf21 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)}\par
3839     [[noreturn]]\par
3840     {\cf18 void} throw_exception(std::exception {\cf17 const}& e) \{\par
3841         Catch::cerr() << {\cf22 "Catch will terminate because it needed to throw an exception.\\n"}\par
3842                       << {\cf22 "The message was: "} << e.what() << {\cf23 '\\n'};\par
3843         std::terminate();\par
3844     \}\par
3845 {\cf21 #endif}\par
3846 \par
3847     [[noreturn]]\par
3848     {\cf18 void} throw_logic_error(std::string {\cf17 const}& msg) \{\par
3849         throw_exception(std::logic_error(msg));\par
3850     \}\par
3851 \par
3852     [[noreturn]]\par
3853     {\cf18 void} throw_domain_error(std::string {\cf17 const}& msg) \{\par
3854         throw_exception(std::domain_error(msg));\par
3855     \}\par
3856 \par
3857     [[noreturn]]\par
3858     {\cf18 void} throw_runtime_error(std::string {\cf17 const}& msg) \{\par
3859         throw_exception(std::runtime_error(msg));\par
3860     \}\par
3861 \par
3862 \par
3863 \par
3864 \} {\cf20 // namespace Catch;}\par
3865 \par
3866 \par
3867 \par
3868 {\cf21 #include <cassert>}\par
3869 \par
3870 {\cf17 namespace }Catch \{\par
3871 \par
3872     IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() = {\cf19 default};\par
3873 \par
3874     {\cf17 namespace }Detail \{\par
3875 \par
3876         {\cf17 namespace }\{\par
3877             {\cf20 // Extracts the actual name part of an enum instance}\par
3878             {\cf20 // In other words, it returns the Blue part of Bikeshed::Colour::Blue}\par
3879             StringRef extractInstanceName(StringRef enumInstance) \{\par
3880                 {\cf20 // Find last occurrence of ":"}\par
3881                 {\cf18 size_t} name_start = enumInstance.size();\par
3882                 {\cf19 while} (name_start > 0 && enumInstance[name_start - 1] != {\cf23 ':'}) \{\par
3883                     --name_start;\par
3884                 \}\par
3885                 {\cf19 return} enumInstance.substr(name_start, enumInstance.size() - name_start);\par
3886             \}\par
3887         \}\par
3888 \par
3889         std::vector<StringRef> parseEnums( StringRef enums ) \{\par
3890             {\cf17 auto} enumValues = splitStringRef( enums, {\cf23 ','} );\par
3891             std::vector<StringRef> parsed;\par
3892             parsed.reserve( enumValues.size() );\par
3893             {\cf19 for}( {\cf17 auto} {\cf17 const}& enumValue : enumValues ) \{\par
3894                 parsed.push_back(trim(extractInstanceName(enumValue)));\par
3895             \}\par
3896             {\cf19 return} parsed;\par
3897         \}\par
3898 \par
3899         EnumInfo::~EnumInfo() = {\cf19 default};\par
3900 \par
3901         StringRef EnumInfo::lookup( {\cf18 int} value ){\cf17  const }\{\par
3902             {\cf19 for}( {\cf17 auto} {\cf17 const}& valueToName : m_values ) \{\par
3903                 {\cf19 if}( valueToName.first == value )\par
3904                     {\cf19 return} valueToName.second;\par
3905             \}\par
3906             {\cf19 return} {\cf22 "\{** unexpected enum value **\}"}_sr;\par
3907         \}\par
3908 \par
3909         Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values ) \{\par
3910             {\cf17 auto} enumInfo = Catch::Detail::make_unique<EnumInfo>();\par
3911             enumInfo->m_name = enumName;\par
3912             enumInfo->m_values.reserve( values.size() );\par
3913 \par
3914             {\cf17 const} {\cf17 auto} valueNames = Catch::Detail::parseEnums( allValueNames );\par
3915             assert( valueNames.size() == values.size() );\par
3916             std::size_t i = 0;\par
3917             {\cf19 for}( {\cf17 auto} value : values )\par
3918                 enumInfo->m_values.emplace_back(value, valueNames[i++]);\par
3919 \par
3920             {\cf19 return} enumInfo;\par
3921         \}\par
3922 \par
3923         EnumInfo {\cf17 const}& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values ) \{\par
3924             m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));\par
3925             {\cf19 return} *m_enumInfos.back();\par
3926         \}\par
3927 \par
3928     \} {\cf20 // Detail}\par
3929 \} {\cf20 // Catch}\par
3930 \par
3931 \par
3932 \par
3933 \par
3934 \par
3935 {\cf21 #include <cerrno>}\par
3936 \par
3937 {\cf17 namespace }Catch \{\par
3938         ErrnoGuard::ErrnoGuard():m_oldErrno(errno)\{\}\par
3939         ErrnoGuard::~ErrnoGuard() \{ errno = m_oldErrno; \}\par
3940 \}\par
3941 \par
3942 \par
3943 \par
3944 {\cf21 #include <exception>}\par
3945 \par
3946 {\cf17 namespace }Catch \{\par
3947 \par
3948 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
3949     {\cf17 namespace }\{\par
3950         {\cf17 static} std::string tryTranslators(\par
3951             std::vector<\par
3952                 Detail::unique_ptr<IExceptionTranslator const>> {\cf17 const}& translators ) \{\par
3953             {\cf19 if} ( translators.empty() ) \{\par
3954                 std::rethrow_exception( std::current_exception() );\par
3955             \} {\cf19 else} \{\par
3956                 {\cf19 return} translators[0]->translate( translators.begin() + 1,\par
3957                                                   translators.end() );\par
3958             \}\par
3959         \}\par
3960 \par
3961     \}\par
3962 {\cf21 #endif }\par
3963 \par
3964     ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() = {\cf19 default};\par
3965 \par
3966     {\cf18 void} ExceptionTranslatorRegistry::registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator ) \{\par
3967         m_translators.push_back( CATCH_MOVE( translator ) );\par
3968     \}\par
3969 \par
3970 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
3971     std::string ExceptionTranslatorRegistry::translateActiveException(){\cf17  const }\{\par
3972         {\cf20 // Compiling a mixed mode project with MSVC means that CLR}\par
3973         {\cf20 // exceptions will be caught in (...) as well. However, these do}\par
3974         {\cf20 // do not fill-in std::current_exception and thus lead to crash}\par
3975         {\cf20 // when attempting rethrow.}\par
3976         {\cf20 // /EHa switch also causes structured exceptions to be caught}\par
3977         {\cf20 // here, but they fill-in current_exception properly, so}\par
3978         {\cf20 // at worst the output should be a little weird, instead of}\par
3979         {\cf20 // causing a crash.}\par
3980         {\cf19 if} ( std::current_exception() == {\cf17 nullptr} ) \{\par
3981             {\cf19 return} {\cf22 "Non C++ exception. Possibly a CLR exception."};\par
3982         \}\par
3983 \par
3984         {\cf20 // First we try user-registered translators. If none of them can}\par
3985         {\cf20 // handle the exception, it will be rethrown handled by our defaults.}\par
3986         {\cf19 try} \{\par
3987             {\cf19 return} tryTranslators(m_translators);\par
3988         \}\par
3989         {\cf20 // To avoid having to handle TFE explicitly everywhere, we just}\par
3990         {\cf20 // rethrow it so that it goes back up the caller.}\par
3991         {\cf19 catch}( TestFailureException& ) \{\par
3992             std::rethrow_exception(std::current_exception());\par
3993         \}\par
3994         {\cf19 catch}( TestSkipException& ) \{\par
3995             std::rethrow_exception(std::current_exception());\par
3996         \}\par
3997         {\cf19 catch}( std::exception {\cf17 const}& ex ) \{\par
3998             {\cf19 return} ex.what();\par
3999         \}\par
4000         {\cf19 catch}( std::string {\cf17 const}& msg ) \{\par
4001             {\cf19 return} msg;\par
4002         \}\par
4003         {\cf19 catch}( {\cf17 const} {\cf18 char}* msg ) \{\par
4004             {\cf19 return} msg;\par
4005         \}\par
4006         {\cf19 catch}(...) \{\par
4007             {\cf19 return} {\cf22 "Unknown exception"};\par
4008         \}\par
4009     \}\par
4010 \par
4011 {\cf21 #else }{\cf20 // ^^ Exceptions are enabled // Exceptions are disabled vv}\par
4012     std::string ExceptionTranslatorRegistry::translateActiveException(){\cf17  const }\{\par
4013         CATCH_INTERNAL_ERROR({\cf22 "Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!"});\par
4014     \}\par
4015 {\cf21 #endif}\par
4016 \par
4017 \}\par
4018 \par
4019 \par
4020 \par
4041 {\cf21 #include <algorithm>}\par
4042 \par
4043 {\cf21 #if !defined( CATCH_CONFIG_WINDOWS_SEH ) && !defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4044 \par
4045 {\cf17 namespace }Catch \{\par
4046 \par
4047     {\cf20 // If neither SEH nor signal handling is required, the handler impls}\par
4048     {\cf20 // do not have to do anything, and can be empty.}\par
4049     {\cf18 void} FatalConditionHandler::engage_platform() \{\}\par
4050     {\cf18 void} FatalConditionHandler::disengage_platform() noexcept \{\}\par
4051     FatalConditionHandler::FatalConditionHandler() = {\cf19 default};\par
4052     FatalConditionHandler::~FatalConditionHandler() = {\cf19 default};\par
4053 \par
4054 \} {\cf20 // end namespace Catch}\par
4055 \par
4056 {\cf21 #endif }{\cf20 // !CATCH_CONFIG_WINDOWS_SEH && !CATCH_CONFIG_POSIX_SIGNALS}\par
4057 \par
4058 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH ) && defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4059 {\cf21 #error "Inconsistent configuration: Windows' SEH handling and POSIX signals cannot be enabled at the same time"}\par
4060 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_SEH && CATCH_CONFIG_POSIX_SIGNALS}\par
4061 \par
4062 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4063 \par
4064 {\cf17 namespace }\{\par
4066     {\cf18 void} reportFatal( {\cf18 char} {\cf17 const} * {\cf17 const} message ) \{\par
4067         Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );\par
4068     \}\par
4069 \par
4073     {\cf17 constexpr} std::size_t minStackSizeForErrors = 32 * 1024;\par
4074 \} {\cf20 // end unnamed namespace}\par
4075 \par
4076 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_SEH || CATCH_CONFIG_POSIX_SIGNALS}\par
4077 \par
4078 {\cf21 #if defined( CATCH_CONFIG_WINDOWS_SEH )}\par
4079 \par
4080 {\cf17 namespace }Catch \{\par
4081 \par
4082     {\cf17 struct }SignalDefs \{ DWORD id; {\cf17 const} {\cf18 char}* name; \};\par
4083 \par
4084     {\cf20 // There is no 1-1 mapping between signals and windows exceptions.}\par
4085     {\cf20 // Windows can easily distinguish between SO and SigSegV,}\par
4086     {\cf20 // but SigInt, SigTerm, etc are handled differently.}\par
4087     {\cf17 static} SignalDefs signalDefs[] = \{\par
4088         \{ EXCEPTION_ILLEGAL_INSTRUCTION,  {\cf22 "SIGILL - Illegal instruction signal"} \},\par
4089         \{ EXCEPTION_STACK_OVERFLOW, {\cf22 "SIGSEGV - Stack overflow"} \},\par
4090         \{ EXCEPTION_ACCESS_VIOLATION, {\cf22 "SIGSEGV - Segmentation violation signal"} \},\par
4091         \{ EXCEPTION_INT_DIVIDE_BY_ZERO, {\cf22 "Divide by zero error"} \},\par
4092     \};\par
4093 \par
4094     {\cf17 static} LONG CALLBACK topLevelExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo) \{\par
4095         {\cf19 for} ({\cf17 auto} {\cf17 const}& def : signalDefs) \{\par
4096             {\cf19 if} (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) \{\par
4097                 reportFatal(def.name);\par
4098             \}\par
4099         \}\par
4100         {\cf20 // If its not an exception we care about, pass it along.}\par
4101         {\cf20 // This stops us from eating debugger breaks etc.}\par
4102         {\cf19 return} EXCEPTION_CONTINUE_SEARCH;\par
4103     \}\par
4104 \par
4105     {\cf20 // Since we do not support multiple instantiations, we put these}\par
4106     {\cf20 // into global variables and rely on cleaning them up in outlined}\par
4107     {\cf20 // constructors/destructors}\par
4108     {\cf17 static} LPTOP_LEVEL_EXCEPTION_FILTER previousTopLevelExceptionFilter = {\cf17 nullptr};\par
4109 \par
4110 \par
4111     {\cf20 // For MSVC, we reserve part of the stack memory for handling}\par
4112     {\cf20 // memory overflow structured exception.}\par
4113     FatalConditionHandler::FatalConditionHandler() \{\par
4114         ULONG guaranteeSize = {\cf17 static_cast<}ULONG{\cf17 >}(minStackSizeForErrors);\par
4115         {\cf19 if} (!SetThreadStackGuarantee(&guaranteeSize)) \{\par
4116             {\cf20 // We do not want to fully error out, because needing}\par
4117             {\cf20 // the stack reserve should be rare enough anyway.}\par
4118             Catch::cerr()\par
4119                 << {\cf22 "Failed to reserve piece of stack."}\par
4120                 << {\cf22 " Stack overflows will not be reported successfully."};\par
4121         \}\par
4122     \}\par
4123 \par
4124     {\cf20 // We do not attempt to unset the stack guarantee, because}\par
4125     {\cf20 // Windows does not support lowering the stack size guarantee.}\par
4126     FatalConditionHandler::~FatalConditionHandler() = {\cf19 default};\par
4127 \par
4128 \par
4129     {\cf18 void} FatalConditionHandler::engage_platform() \{\par
4130         {\cf20 // Register as a the top level exception filter.}\par
4131         previousTopLevelExceptionFilter = SetUnhandledExceptionFilter(topLevelExceptionFilter);\par
4132     \}\par
4133 \par
4134     {\cf18 void} FatalConditionHandler::disengage_platform() noexcept \{\par
4135         {\cf19 if} (SetUnhandledExceptionFilter(previousTopLevelExceptionFilter) != topLevelExceptionFilter) \{\par
4136             Catch::cerr()\par
4137                 << {\cf22 "Unexpected SEH unhandled exception filter on disengage."}\par
4138                 << {\cf22 " The filter was restored, but might be rolled back unexpectedly."};\par
4139         \}\par
4140         previousTopLevelExceptionFilter = {\cf17 nullptr};\par
4141     \}\par
4142 \par
4143 \} {\cf20 // end namespace Catch}\par
4144 \par
4145 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_SEH}\par
4146 \par
4147 {\cf21 #if defined( CATCH_CONFIG_POSIX_SIGNALS )}\par
4148 \par
4149 {\cf21 #include <signal.h>}\par
4150 \par
4151 {\cf17 namespace }Catch \{\par
4152 \par
4153     {\cf17 struct }SignalDefs \{\par
4154         {\cf18 int} id;\par
4155         {\cf17 const} {\cf18 char}* name;\par
4156     \};\par
4157 \par
4158     {\cf17 static} SignalDefs signalDefs[] = \{\par
4159         \{ SIGINT,  {\cf22 "SIGINT - Terminal interrupt signal"} \},\par
4160         \{ SIGILL,  {\cf22 "SIGILL - Illegal instruction signal"} \},\par
4161         \{ SIGFPE,  {\cf22 "SIGFPE - Floating point error signal"} \},\par
4162         \{ SIGSEGV, {\cf22 "SIGSEGV - Segmentation violation signal"} \},\par
4163         \{ SIGTERM, {\cf22 "SIGTERM - Termination request signal"} \},\par
4164         \{ SIGABRT, {\cf22 "SIGABRT - Abort (abnormal termination) signal"} \}\par
4165     \};\par
4166 \par
4167 {\cf20 // Older GCCs trigger -Wmissing-field-initializers for T foo = \{\}}\par
4168 {\cf20 // which is zero initialization, but not explicit. We want to avoid}\par
4169 {\cf20 // that.}\par
4170 {\cf21 #if defined(__GNUC__)}\par
4171 {\cf21 #    pragma GCC diagnostic push}\par
4172 {\cf21 #    pragma GCC diagnostic ignored "-Wmissing-field-initializers"}\par
4173 {\cf21 #endif}\par
4174 \par
4175     {\cf17 static} {\cf18 char}* altStackMem = {\cf17 nullptr};\par
4176     {\cf17 static} std::size_t altStackSize = 0;\par
4177     {\cf17 static} stack_t oldSigStack\{\};\par
4178     {\cf17 static} {\cf17 struct }sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]\{\};\par
4179 \par
4180     {\cf17 static} {\cf18 void} restorePreviousSignalHandlers() noexcept \{\par
4181         {\cf20 // We set signal handlers back to the previous ones. Hopefully}\par
4182         {\cf20 // nobody overwrote them in the meantime, and doesn't expect}\par
4183         {\cf20 // their signal handlers to live past ours given that they}\par
4184         {\cf20 // installed them after ours..}\par
4185         {\cf19 for} (std::size_t i = 0; i < {\cf17 sizeof}(signalDefs) / {\cf17 sizeof}(SignalDefs); ++i) \{\par
4186             sigaction(signalDefs[i].{\cf18 id}, &oldSigActions[i], {\cf17 nullptr});\par
4187         \}\par
4188         {\cf20 // Return the old stack}\par
4189         sigaltstack(&oldSigStack, {\cf17 nullptr});\par
4190     \}\par
4191 \par
4192     {\cf17 static} {\cf18 void} handleSignal( {\cf18 int} sig ) \{\par
4193         {\cf18 char} {\cf17 const} * name = {\cf22 "<unknown signal>"};\par
4194         {\cf19 for} ({\cf17 auto} {\cf17 const}& def : signalDefs) \{\par
4195             {\cf19 if} (sig == def.id) \{\par
4196                 name = def.name;\par
4197                 {\cf19 break};\par
4198             \}\par
4199         \}\par
4200         {\cf20 // We need to restore previous signal handlers and let them do}\par
4201         {\cf20 // their thing, so that the users can have the debugger break}\par
4202         {\cf20 // when a signal is raised, and so on.}\par
4203         restorePreviousSignalHandlers();\par
4204         reportFatal( name );\par
4205         raise( sig );\par
4206     \}\par
4207 \par
4208     FatalConditionHandler::FatalConditionHandler() \{\par
4209         assert(!altStackMem && {\cf22 "Cannot initialize POSIX signal handler when one already exists"});\par
4210         {\cf19 if} (altStackSize == 0) \{\par
4211             altStackSize = std::max({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(SIGSTKSZ), minStackSizeForErrors);\par
4212         \}\par
4213         altStackMem = {\cf17 new} {\cf18 char}[altStackSize]();\par
4214     \}\par
4215 \par
4216     FatalConditionHandler::~FatalConditionHandler() \{\par
4217         {\cf17 delete}[] altStackMem;\par
4218         {\cf20 // We signal that another instance can be constructed by zeroing}\par
4219         {\cf20 // out the pointer.}\par
4220         altStackMem = {\cf17 nullptr};\par
4221     \}\par
4222 \par
4223     {\cf18 void} FatalConditionHandler::engage_platform() \{\par
4224         stack_t sigStack;\par
4225         sigStack.ss_sp = altStackMem;\par
4226         sigStack.ss_size = altStackSize;\par
4227         sigStack.ss_flags = 0;\par
4228         sigaltstack(&sigStack, &oldSigStack);\par
4229         {\cf17 struct }sigaction sa = \{ \};\par
4230 \par
4231         sa.sa_handler = handleSignal;\par
4232         sa.sa_flags = SA_ONSTACK;\par
4233         {\cf19 for} (std::size_t i = 0; i < {\cf17 sizeof}(signalDefs)/{\cf17 sizeof}(SignalDefs); ++i) \{\par
4234             sigaction(signalDefs[i].{\cf18 id}, &sa, &oldSigActions[i]);\par
4235         \}\par
4236     \}\par
4237 \par
4238 {\cf21 #if defined(__GNUC__)}\par
4239 {\cf21 #    pragma GCC diagnostic pop}\par
4240 {\cf21 #endif}\par
4241 \par
4242 \par
4243     {\cf18 void} FatalConditionHandler::disengage_platform() noexcept \{\par
4244         restorePreviousSignalHandlers();\par
4245     \}\par
4246 \par
4247 \} {\cf20 // end namespace Catch}\par
4248 \par
4249 {\cf21 #endif }{\cf20 // CATCH_CONFIG_POSIX_SIGNALS}\par
4250 \par
4251 \par
4252 \par
4253 \par
4254 {\cf21 #include <cstring>}\par
4255 \par
4256 {\cf17 namespace }Catch \{\par
4257     {\cf17 namespace }Detail \{\par
4258 \par
4259         uint32_t convertToBits({\cf18 float} f) \{\par
4260             {\cf17 static_assert}({\cf17 sizeof}(float) == {\cf17 sizeof}(uint32_t), {\cf22 "Important ULP matcher assumption violated"});\par
4261             uint32_t i;\par
4262             std::memcpy(&i, &f, {\cf17 sizeof}(f));\par
4263             {\cf19 return} i;\par
4264         \}\par
4265 \par
4266         uint64_t convertToBits({\cf18 double} d) \{\par
4267             {\cf17 static_assert}({\cf17 sizeof}(double) == {\cf17 sizeof}(uint64_t), {\cf22 "Important ULP matcher assumption violated"});\par
4268             uint64_t i;\par
4269             std::memcpy(&i, &d, {\cf17 sizeof}(d));\par
4270             {\cf19 return} i;\par
4271         \}\par
4272 \par
4273 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
4274 {\cf21 #    pragma GCC diagnostic push}\par
4275 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
4276 {\cf21 #endif}\par
4277         {\cf18 bool} directCompare( {\cf18 float} lhs, {\cf18 float} rhs ) \{ {\cf19 return} lhs == rhs; \}\par
4278         {\cf18 bool} directCompare( {\cf18 double} lhs, {\cf18 double} rhs ) \{ {\cf19 return} lhs == rhs; \}\par
4279 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
4280 {\cf21 #    pragma GCC diagnostic pop}\par
4281 {\cf21 #endif}\par
4282 \par
4283 \par
4284     \} {\cf20 // end namespace Detail}\par
4285 \} {\cf20 // end namespace Catch}\par
4286 \par
4287 \par
4288 \par
4289 \par
4290 \par
4291 \par
4292 {\cf21 #include <cstdlib>}\par
4293 \par
4294 {\cf17 namespace }Catch \{\par
4295     {\cf17 namespace }Detail \{\par
4296 \par
4297 {\cf21 #if !defined (CATCH_CONFIG_GETENV)}\par
4298         {\cf18 char} {\cf17 const}* getEnv( {\cf18 char} {\cf17 const}* ) \{ {\cf19 return} {\cf17 nullptr}; \}\par
4299 {\cf21 #else}\par
4300 \par
4301         {\cf18 char} {\cf17 const}* getEnv( {\cf18 char} {\cf17 const}* varName ) \{\par
4302 {\cf21 #    if defined( _MSC_VER )}\par
4303 {\cf21 #        pragma warning( push )}\par
4304 {\cf21 #        pragma warning( disable : 4996 ) }{\cf20 // use getenv_s instead of getenv}\par
4305 {\cf21 #    endif}\par
4306 \par
4307             {\cf19 return} std::getenv( varName );\par
4308 \par
4309 {\cf21 #    if defined( _MSC_VER )}\par
4310 {\cf21 #        pragma warning( pop )}\par
4311 {\cf21 #    endif}\par
4312         \}\par
4313 {\cf21 #endif}\par
4314 \} {\cf20 // namespace Detail}\par
4315 \} {\cf20 // namespace Catch}\par
4316 \par
4317 \par
4318 \par
4319 \par
4320 {\cf21 #include <cstdio>}\par
4321 {\cf21 #include <fstream>}\par
4322 {\cf21 #include <sstream>}\par
4323 {\cf21 #include <vector>}\par
4324 \par
4325 {\cf17 namespace }Catch \{\par
4326 \par
4327     Catch::IStream::~IStream() = {\cf19 default};\par
4328 \par
4329 {\cf17 namespace }Detail \{\par
4330     {\cf17 namespace }\{\par
4331         {\cf17 template}<{\cf17 typename} WriterF, std::{\cf18 size_t} bufferSize=256>\par
4332         {\cf17 class }StreamBufImpl final : {\cf17 public} std::streambuf \{\par
4333             {\cf18 char} data[bufferSize];\par
4334             WriterF m_writer;\par
4335 \par
4336         {\cf17 public}:\par
4337             StreamBufImpl() \{\par
4338                 setp( data, data + {\cf17 sizeof}(data) );\par
4339             \}\par
4340 \par
4341             ~StreamBufImpl() noexcept{\cf17  override }\{\par
4342                 StreamBufImpl::sync();\par
4343             \}\par
4344 \par
4345         {\cf17 private}:\par
4346             {\cf18 int} overflow( {\cf18 int} c ){\cf17  override }\{\par
4347                 sync();\par
4348 \par
4349                 {\cf19 if}( c != EOF ) \{\par
4350                     {\cf19 if}( pbase() == epptr() )\par
4351                         m_writer( std::string( 1, {\cf17 static_cast<}{\cf18 char}{\cf17 >}( c ) ) );\par
4352                     {\cf19 else}\par
4353                         sputc( {\cf17 static_cast<}{\cf18 char}{\cf17 >}( c ) );\par
4354                 \}\par
4355                 {\cf19 return} 0;\par
4356             \}\par
4357 \par
4358             {\cf18 int} sync(){\cf17  override }\{\par
4359                 {\cf19 if}( pbase() != pptr() ) \{\par
4360                     m_writer( std::string( pbase(), {\cf17 static_cast<}std::string::size_type{\cf17 >}( pptr() - pbase() ) ) );\par
4361                     setp( pbase(), epptr() );\par
4362                 \}\par
4363                 {\cf19 return} 0;\par
4364             \}\par
4365         \};\par
4366 \par
4368 \par
4369         {\cf17 struct }OutputDebugWriter \{\par
4370 \par
4371             {\cf18 void} operator()( std::string {\cf17 const}& str ) \{\par
4372                 {\cf19 if} ( !str.empty() ) \{\par
4373                     writeToDebugConsole( str );\par
4374                 \}\par
4375             \}\par
4376         \};\par
4377 \par
4379 \par
4380         {\cf17 class }FileStream final : {\cf17 public} IStream \{\par
4381             std::ofstream m_ofs;\par
4382         {\cf17 public}:\par
4383             FileStream( std::string {\cf17 const}& filename ) \{\par
4384                 m_ofs.open( filename.c_str() );\par
4385                 CATCH_ENFORCE( !m_ofs.fail(), {\cf22 "Unable to open file: '"} << filename << {\cf23 '\\''} );\par
4386                 m_ofs << std::unitbuf;\par
4387             \}\par
4388         {\cf17 public}: {\cf20 // IStream}\par
4389             std::ostream& stream(){\cf17  override }\{\par
4390                 {\cf19 return} m_ofs;\par
4391             \}\par
4392         \};\par
4393 \par
4395 \par
4396         {\cf17 class }CoutStream final : {\cf17 public} IStream \{\par
4397             std::ostream m_os;\par
4398         {\cf17 public}:\par
4399             {\cf20 // Store the streambuf from cout up-front because}\par
4400             {\cf20 // cout may get redirected when running tests}\par
4401             CoutStream() : m_os( Catch::cout().rdbuf() ) \{\}\par
4402 \par
4403         {\cf17 public}: {\cf20 // IStream}\par
4404             std::ostream& stream(){\cf17  override }\{ {\cf19 return} m_os; \}\par
4405             {\cf18 bool} isConsole(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
4406         \};\par
4407 \par
4408         {\cf17 class }CerrStream : {\cf17 public} IStream \{\par
4409             std::ostream m_os;\par
4410 \par
4411         {\cf17 public}:\par
4412             {\cf20 // Store the streambuf from cerr up-front because}\par
4413             {\cf20 // cout may get redirected when running tests}\par
4414             CerrStream(): m_os( Catch::cerr().rdbuf() ) \{\}\par
4415 \par
4416         {\cf17 public}: {\cf20 // IStream}\par
4417             std::ostream& stream(){\cf17  override }\{ {\cf19 return} m_os; \}\par
4418             {\cf18 bool} isConsole(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
4419         \};\par
4420 \par
4422 \par
4423         {\cf17 class }DebugOutStream final : {\cf17 public} IStream \{\par
4424             Detail::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;\par
4425             std::ostream m_os;\par
4426         {\cf17 public}:\par
4427             DebugOutStream()\par
4428             :   m_streamBuf( Detail::make_unique<StreamBufImpl<OutputDebugWriter>>() ),\par
4429                 m_os( m_streamBuf.get() )\par
4430             \{\}\par
4431 \par
4432         {\cf17 public}: {\cf20 // IStream}\par
4433             std::ostream& stream(){\cf17  override }\{ {\cf19 return} m_os; \}\par
4434         \};\par
4435 \par
4436     \} {\cf20 // unnamed namespace}\par
4437 \} {\cf20 // namespace Detail}\par
4438 \par
4440 \par
4441     {\cf17 auto} makeStream( std::string {\cf17 const}& filename ) -> Detail::unique_ptr<IStream> \{\par
4442         {\cf19 if} ( filename.empty() || filename == {\cf22 "-"} ) \{\par
4443             {\cf19 return} Detail::make_unique<Detail::CoutStream>();\par
4444         \}\par
4445         {\cf19 if}( filename[0] == {\cf23 '%'} ) \{\par
4446             {\cf19 if} ( filename == {\cf22 "%debug"} ) \{\par
4447                 {\cf19 return} Detail::make_unique<Detail::DebugOutStream>();\par
4448             \} {\cf19 else} {\cf19 if} ( filename == {\cf22 "%stderr"} ) \{\par
4449                 {\cf19 return} Detail::make_unique<Detail::CerrStream>();\par
4450             \} {\cf19 else} {\cf19 if} ( filename == {\cf22 "%stdout"} ) \{\par
4451                 {\cf19 return} Detail::make_unique<Detail::CoutStream>();\par
4452             \} {\cf19 else} \{\par
4453                 CATCH_ERROR( {\cf22 "Unrecognised stream: '"} << filename << {\cf23 '\\''} );\par
4454             \}\par
4455         \}\par
4456         {\cf19 return} Detail::make_unique<Detail::FileStream>( filename );\par
4457     \}\par
4458 \par
4459 \}\par
4460 \par
4461 \par
4462 \par
4463 {\cf17 namespace }Catch \{\par
4464     {\cf18 void} JsonUtils::indent( std::ostream& os, std::uint64_t level ) \{\par
4465         {\cf19 for} ( std::uint64_t i = 0; i < level; ++i ) \{\par
4466             os << {\cf22 "  "};\par
4467         \}\par
4468     \}\par
4469     {\cf18 void} JsonUtils::appendCommaNewline( std::ostream& os,\par
4470                                         {\cf18 bool}& should_comma,\par
4471                                         std::uint64_t level ) \{\par
4472         {\cf19 if} ( should_comma ) \{ os << {\cf23 ','}; \}\par
4473         should_comma = {\cf17 true};\par
4474         os << {\cf23 '\\n'};\par
4475         indent( os, level );\par
4476     \}\par
4477 \par
4478     JsonObjectWriter::JsonObjectWriter( std::ostream& os ):\par
4479         JsonObjectWriter\{ os, 0 \} \{\}\par
4480 \par
4481     JsonObjectWriter::JsonObjectWriter( std::ostream& os,\par
4482                                         std::uint64_t indent_level ):\par
4483         m_os\{ os \}, m_indent_level\{ indent_level \} \{\par
4484         m_os << {\cf23 '\{'};\par
4485     \}\par
4486     JsonObjectWriter::JsonObjectWriter( JsonObjectWriter&& source ) {\cf17 noexcept}:\par
4487         m_os\{ source.m_os \},\par
4488         m_indent_level\{ source.m_indent_level \},\par
4489         m_should_comma\{ source.m_should_comma \},\par
4490         m_active\{ source.m_active \} \{\par
4491         source.m_active = {\cf17 false};\par
4492     \}\par
4493 \par
4494     JsonObjectWriter::~JsonObjectWriter() \{\par
4495         {\cf19 if} ( !m_active ) \{ {\cf19 return}; \}\par
4496 \par
4497         m_os << {\cf23 '\\n'};\par
4498         JsonUtils::indent( m_os, m_indent_level );\par
4499         m_os << {\cf23 '\}'};\par
4500     \}\par
4501 \par
4502     JsonValueWriter JsonObjectWriter::write( StringRef key ) \{\par
4503         JsonUtils::appendCommaNewline(\par
4504             m_os, m_should_comma, m_indent_level + 1 );\par
4505 \par
4506         m_os << {\cf23 '"'} << key << {\cf22 "\\": "};\par
4507         {\cf19 return} JsonValueWriter\{ m_os, m_indent_level + 1 \};\par
4508     \}\par
4509 \par
4510     JsonArrayWriter::JsonArrayWriter( std::ostream& os ):\par
4511         JsonArrayWriter\{ os, 0 \} \{\}\par
4512     JsonArrayWriter::JsonArrayWriter( std::ostream& os,\par
4513                                       std::uint64_t indent_level ):\par
4514         m_os\{ os \}, m_indent_level\{ indent_level \} \{\par
4515         m_os << {\cf23 '['};\par
4516     \}\par
4517     JsonArrayWriter::JsonArrayWriter( JsonArrayWriter&& source ) {\cf17 noexcept}:\par
4518         m_os\{ source.m_os \},\par
4519         m_indent_level\{ source.m_indent_level \},\par
4520         m_should_comma\{ source.m_should_comma \},\par
4521         m_active\{ source.m_active \} \{\par
4522         source.m_active = {\cf17 false};\par
4523     \}\par
4524     JsonArrayWriter::~JsonArrayWriter() \{\par
4525         {\cf19 if} ( !m_active ) \{ {\cf19 return}; \}\par
4526 \par
4527         m_os << {\cf23 '\\n'};\par
4528         JsonUtils::indent( m_os, m_indent_level );\par
4529         m_os << {\cf23 ']'};\par
4530     \}\par
4531 \par
4532     JsonObjectWriter JsonArrayWriter::writeObject() \{\par
4533         JsonUtils::appendCommaNewline(\par
4534             m_os, m_should_comma, m_indent_level + 1 );\par
4535         {\cf19 return} JsonObjectWriter\{ m_os, m_indent_level + 1 \};\par
4536     \}\par
4537 \par
4538     JsonArrayWriter JsonArrayWriter::writeArray() \{\par
4539         JsonUtils::appendCommaNewline(\par
4540             m_os, m_should_comma, m_indent_level + 1 );\par
4541         {\cf19 return} JsonArrayWriter\{ m_os, m_indent_level + 1 \};\par
4542     \}\par
4543 \par
4544     JsonArrayWriter& JsonArrayWriter::write( {\cf18 bool} value ) \{\par
4545         {\cf19 return} writeImpl( value );\par
4546     \}\par
4547 \par
4548     JsonValueWriter::JsonValueWriter( std::ostream& os ):\par
4549         JsonValueWriter\{ os, 0 \} \{\}\par
4550 \par
4551     JsonValueWriter::JsonValueWriter( std::ostream& os,\par
4552                                       std::uint64_t indent_level ):\par
4553         m_os\{ os \}, m_indent_level\{ indent_level \} \{\}\par
4554 \par
4555     JsonObjectWriter JsonValueWriter::writeObject() && \{\par
4556         {\cf19 return} JsonObjectWriter\{ m_os, m_indent_level \};\par
4557     \}\par
4558 \par
4559     JsonArrayWriter JsonValueWriter::writeArray() && \{\par
4560         {\cf19 return} JsonArrayWriter\{ m_os, m_indent_level \};\par
4561     \}\par
4562 \par
4563     {\cf18 void} JsonValueWriter::write( Catch::StringRef value ) && \{\par
4564         writeImpl( value, {\cf17 true} );\par
4565     \}\par
4566 \par
4567     {\cf18 void} JsonValueWriter::write( {\cf18 bool} value ) && \{\par
4568         writeImpl( value ? {\cf22 "true"}_sr : {\cf22 "false"}_sr, {\cf17 false} );\par
4569     \}\par
4570 \par
4571     {\cf18 void} JsonValueWriter::writeImpl( Catch::StringRef value, {\cf18 bool} quote ) \{\par
4572         {\cf19 if} ( quote ) \{ m_os << {\cf23 '"'}; \}\par
4573         {\cf19 for} ({\cf18 char} c : value) \{\par
4574             {\cf20 // Escape list taken from https://www.json.org/json-en.html,}\par
4575             {\cf20 // string definition.}\par
4576             {\cf20 // Note that while forward slash _can_ be escaped, it does}\par
4577             {\cf20 // not have to be, if JSON is not further embedded somewhere}\par
4578             {\cf20 // where forward slash is meaningful.}\par
4579             {\cf19 if} ( c == {\cf23 '"'} ) \{\par
4580                 m_os << {\cf22 "\\\\\\""};\par
4581             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\\\'} ) \{\par
4582                 m_os << {\cf22 "\\\\\\\\"};\par
4583             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\b'} ) \{\par
4584                 m_os << {\cf22 "\\\\b"};\par
4585             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\f'} ) \{\par
4586                 m_os << {\cf22 "\\\\f"};\par
4587             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\n'} ) \{\par
4588                 m_os << {\cf22 "\\\\n"};\par
4589             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\r'} ) \{\par
4590                 m_os << {\cf22 "\\\\r"};\par
4591             \} {\cf19 else} {\cf19 if} ( c == {\cf23 '\\t'} ) \{\par
4592                 m_os << {\cf22 "\\\\t"};\par
4593             \} {\cf19 else} \{\par
4594                 m_os << c;\par
4595             \}\par
4596         \}\par
4597         {\cf19 if} ( quote ) \{ m_os << {\cf23 '"'}; \}\par
4598     \}\par
4599 \par
4600 \} {\cf20 // namespace Catch}\par
4601 \par
4602 \par
4603 \par
4604 \par
4605 {\cf17 namespace }Catch \{\par
4606 \par
4607     {\cf17 auto} operator << (std::ostream& os, LazyExpression {\cf17 const}& lazyExpr) -> std::ostream& \{\par
4608         {\cf19 if} (lazyExpr.m_isNegated)\par
4609             os << {\cf23 '!'};\par
4610 \par
4611         {\cf19 if} (lazyExpr) \{\par
4612             {\cf19 if} (lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression())\par
4613                 os << {\cf23 '('} << *lazyExpr.m_transientExpression << {\cf23 ')'};\par
4614             {\cf19 else}\par
4615                 os << *lazyExpr.m_transientExpression;\par
4616         \} {\cf19 else} \{\par
4617             os << {\cf22 "\{** error - unchecked empty expression requested **\}"};\par
4618         \}\par
4619         {\cf19 return} os;\par
4620     \}\par
4621 \par
4622 \} {\cf20 // namespace Catch}\par
4623 \par
4624 \par
4625 \par
4626 \par
4627 {\cf21 #ifdef CATCH_CONFIG_WINDOWS_CRTDBG}\par
4628 {\cf21 #include <crtdbg.h>}\par
4629 \par
4630 {\cf17 namespace }Catch \{\par
4631 \par
4632     LeakDetector::LeakDetector() \{\par
4633         {\cf18 int} flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);\par
4634         flag |= _CRTDBG_LEAK_CHECK_DF;\par
4635         flag |= _CRTDBG_ALLOC_MEM_DF;\par
4636         _CrtSetDbgFlag(flag);\par
4637         _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\par
4638         _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\par
4639         {\cf20 // Change this to leaking allocation's number to break there}\par
4640         _CrtSetBreakAlloc(-1);\par
4641     \}\par
4642 \}\par
4643 \par
4644 {\cf21 #else }{\cf20 // ^^ Windows crt debug heap enabled // Windows crt debug heap disabled vv}\par
4645 \par
4646     Catch::LeakDetector::LeakDetector() = {\cf19 default};\par
4647 \par
4648 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WINDOWS_CRTDBG}\par
4649 \par
4650 Catch::LeakDetector::~LeakDetector() \{\par
4651     Catch::cleanUp();\par
4652 \}\par
4653 \par
4654 \par
4655 \par
4656 \par
4657 {\cf17 namespace }Catch \{\par
4658     {\cf17 namespace }\{\par
4659 \par
4660         {\cf18 void} listTests(IEventListener& reporter, IConfig {\cf17 const}& config) \{\par
4661             {\cf17 auto} {\cf17 const}& testSpec = config.testSpec();\par
4662             {\cf17 auto} matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);\par
4663             reporter.listTests(matchedTestCases);\par
4664         \}\par
4665 \par
4666         {\cf18 void} listTags(IEventListener& reporter, IConfig {\cf17 const}& config) \{\par
4667             {\cf17 auto} {\cf17 const}& testSpec = config.testSpec();\par
4668             std::vector<TestCaseHandle> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);\par
4669 \par
4670             std::map<StringRef, TagInfo, Detail::CaseInsensitiveLess> tagCounts;\par
4671             {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : matchedTestCases) \{\par
4672                 {\cf19 for} ({\cf17 auto} {\cf17 const}& tagName : testCase.getTestCaseInfo().tags) \{\par
4673                     {\cf17 auto} it = tagCounts.find(tagName.original);\par
4674                     {\cf19 if} (it == tagCounts.end())\par
4675                         it = tagCounts.insert(std::make_pair(tagName.original, TagInfo())).first;\par
4676                     it->second.add(tagName.original);\par
4677                 \}\par
4678             \}\par
4679 \par
4680             std::vector<TagInfo> infos; infos.reserve(tagCounts.size());\par
4681             {\cf19 for} ({\cf17 auto}& tagc : tagCounts) \{\par
4682                 infos.push_back(CATCH_MOVE(tagc.second));\par
4683             \}\par
4684 \par
4685             reporter.listTags(infos);\par
4686         \}\par
4687 \par
4688         {\cf18 void} listReporters(IEventListener& reporter) \{\par
4689             std::vector<ReporterDescription> descriptions;\par
4690 \par
4691             {\cf17 auto} {\cf17 const}& factories = getRegistryHub().getReporterRegistry().getFactories();\par
4692             descriptions.reserve(factories.size());\par
4693             {\cf19 for} ({\cf17 auto} {\cf17 const}& fac : factories) \{\par
4694                 descriptions.push_back(\{ fac.first, fac.second->getDescription() \});\par
4695             \}\par
4696 \par
4697             reporter.listReporters(descriptions);\par
4698         \}\par
4699 \par
4700         {\cf18 void} listListeners(IEventListener& reporter) \{\par
4701             std::vector<ListenerDescription> descriptions;\par
4702 \par
4703             {\cf17 auto} {\cf17 const}& factories =\par
4704                 getRegistryHub().getReporterRegistry().getListeners();\par
4705             descriptions.reserve( factories.size() );\par
4706             {\cf19 for} ( {\cf17 auto} {\cf17 const}& fac : factories ) \{\par
4707                 descriptions.push_back( \{ fac->getName(), fac->getDescription() \} );\par
4708             \}\par
4709 \par
4710             reporter.listListeners( descriptions );\par
4711         \}\par
4712 \par
4713     \} {\cf20 // end anonymous namespace}\par
4714 \par
4715     {\cf18 void} TagInfo::add( StringRef spelling ) \{\par
4716         ++count;\par
4717         spellings.insert( spelling );\par
4718     \}\par
4719 \par
4720     std::string TagInfo::all(){\cf17  const }\{\par
4721         {\cf20 // 2 per tag for brackets '[' and ']'}\par
4722         {\cf18 size_t} size =  spellings.size() * 2;\par
4723         {\cf19 for} ({\cf17 auto} {\cf17 const}& spelling : spellings) \{\par
4724             size += spelling.size();\par
4725         \}\par
4726 \par
4727         std::string out; out.reserve(size);\par
4728         {\cf19 for} ({\cf17 auto} {\cf17 const}& spelling : spellings) \{\par
4729             out += {\cf23 '['};\par
4730             out += spelling;\par
4731             out += {\cf23 ']'};\par
4732         \}\par
4733         {\cf19 return} out;\par
4734     \}\par
4735 \par
4736     {\cf18 bool} list( IEventListener& reporter, Config {\cf17 const}& config ) \{\par
4737         {\cf18 bool} listed = {\cf17 false};\par
4738         {\cf19 if} (config.listTests()) \{\par
4739             listed = {\cf17 true};\par
4740             listTests(reporter, config);\par
4741         \}\par
4742         {\cf19 if} (config.listTags()) \{\par
4743             listed = {\cf17 true};\par
4744             listTags(reporter, config);\par
4745         \}\par
4746         {\cf19 if} (config.listReporters()) \{\par
4747             listed = {\cf17 true};\par
4748             listReporters(reporter);\par
4749         \}\par
4750         {\cf19 if} ( config.listListeners() ) \{\par
4751             listed = {\cf17 true};\par
4752             listListeners( reporter );\par
4753         \}\par
4754         {\cf19 return} listed;\par
4755     \}\par
4756 \par
4757 \} {\cf20 // end namespace Catch}\par
4758 \par
4759 \par
4760 \par
4761 {\cf17 namespace }Catch \{\par
4762     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION\par
4763     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\par
4764     {\cf17 static} LeakDetector leakDetector;\par
4765     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\par
4766 \}\par
4767 \par
4768 {\cf20 // Allow users of amalgamated .cpp file to remove our main and provide their own.}\par
4769 {\cf21 #if !defined(CATCH_AMALGAMATED_CUSTOM_MAIN)}\par
4770 \par
4771 {\cf21 #if defined(CATCH_CONFIG_WCHAR) && defined(CATCH_PLATFORM_WINDOWS) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)}\par
4772 {\cf20 // Standard C/C++ Win32 Unicode wmain entry point}\par
4773 {\cf17 extern} {\cf22 "C"} {\cf18 int} __cdecl wmain ({\cf18 int} argc, {\cf18 wchar_t} * argv[], {\cf18 wchar_t} * []) \{\par
4774 {\cf21 #else}\par
4775 {\cf20 // Standard C/C++ main entry point}\par
4776 {\cf18 int} main ({\cf18 int} argc, {\cf18 char} * argv[]) \{\par
4777 {\cf21 #endif}\par
4778 \par
4779     {\cf20 // We want to force the linker not to discard the global variable}\par
4780     {\cf20 // and its constructor, as it (optionally) registers leak detector}\par
4781     (void)&Catch::leakDetector;\par
4782 \par
4783     {\cf19 return} Catch::Session().run( argc, argv );\par
4784 \}\par
4785 \par
4786 {\cf21 #endif }{\cf20 // !defined(CATCH_AMALGAMATED_CUSTOM_MAIN}\par
4787 \par
4788 \par
4789 \par
4790 \par
4791 {\cf17 namespace }Catch \{\par
4792 \par
4793     MessageInfo::MessageInfo(   StringRef _macroName,\par
4794                                 SourceLineInfo {\cf17 const}& _lineInfo,\par
4795                                 ResultWas::OfType _type )\par
4796     :   macroName( _macroName ),\par
4797         lineInfo( _lineInfo ),\par
4798         type( _type ),\par
4799         sequence( ++globalCount )\par
4800     \{\}\par
4801 \par
4802     {\cf20 // This may need protecting if threading support is added}\par
4803     {\cf18 unsigned} {\cf18 int} MessageInfo::globalCount = 0;\par
4804 \par
4805 \} {\cf20 // end namespace Catch}\par
4806 \par
4807 \par
4808 \par
4809 {\cf21 #include <cstdio>}\par
4810 {\cf21 #include <cstring>}\par
4811 {\cf21 #include <sstream>}\par
4812 \par
4813 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
4814 {\cf21     #if defined(_MSC_VER)}\par
4815 {\cf21     #include <io.h>}      {\cf20 //_dup and _dup2}\par
4816 {\cf21     #define dup _dup}\par
4817 {\cf21     #define dup2 _dup2}\par
4818 {\cf21     #define fileno _fileno}\par
4819 {\cf21     #else}\par
4820 {\cf21     #include <unistd.h>}  {\cf20 // dup and dup2}\par
4821 {\cf21     #endif}\par
4822 {\cf21 #endif}\par
4823 \par
4824 \par
4825 {\cf17 namespace }Catch \{\par
4826 \par
4827     RedirectedStream::RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )\par
4828     :   m_originalStream( originalStream ),\par
4829         m_redirectionStream( redirectionStream ),\par
4830         m_prevBuf( m_originalStream.rdbuf() )\par
4831     \{\par
4832         m_originalStream.rdbuf( m_redirectionStream.rdbuf() );\par
4833     \}\par
4834 \par
4835     RedirectedStream::~RedirectedStream() \{\par
4836         m_originalStream.rdbuf( m_prevBuf );\par
4837     \}\par
4838 \par
4839     RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) \{\}\par
4840     {\cf17 auto} RedirectedStdOut::str() const -> std::{\cf18 string} \{ {\cf19 return} m_rss.str(); \}\par
4841 \par
4842     RedirectedStdErr::RedirectedStdErr()\par
4843     :   m_cerr( Catch::cerr(), m_rss.get() ),\par
4844         m_clog( Catch::clog(), m_rss.get() )\par
4845     \{\}\par
4846     {\cf17 auto} RedirectedStdErr::str() const -> std::{\cf18 string} \{ {\cf19 return} m_rss.str(); \}\par
4847 \par
4848     RedirectedStreams::RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr)\par
4849     :   m_redirectedCout(redirectedCout),\par
4850         m_redirectedCerr(redirectedCerr)\par
4851     \{\}\par
4852 \par
4853     RedirectedStreams::~RedirectedStreams() \{\par
4854         m_redirectedCout += m_redirectedStdOut.str();\par
4855         m_redirectedCerr += m_redirectedStdErr.str();\par
4856     \}\par
4857 \par
4858 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
4859 \par
4860 {\cf21 #if defined(_MSC_VER)}\par
4861     TempFile::TempFile() \{\par
4862         {\cf19 if} (tmpnam_s(m_buffer)) \{\par
4863             CATCH_RUNTIME_ERROR({\cf22 "Could not get a temp filename"});\par
4864         \}\par
4865         {\cf19 if} (fopen_s(&m_file, m_buffer, {\cf22 "w+"})) \{\par
4866             {\cf18 char} buffer[100];\par
4867             {\cf19 if} (strerror_s(buffer, errno)) \{\par
4868                 CATCH_RUNTIME_ERROR({\cf22 "Could not translate errno to a string"});\par
4869             \}\par
4870             CATCH_RUNTIME_ERROR({\cf22 "Could not open the temp file: '"} << m_buffer << {\cf22 "' because: "} << buffer);\par
4871         \}\par
4872     \}\par
4873 {\cf21 #else}\par
4874     TempFile::TempFile() \{\par
4875         m_file = std::tmpfile();\par
4876         {\cf19 if} (!m_file) \{\par
4877             CATCH_RUNTIME_ERROR({\cf22 "Could not create a temp file."});\par
4878         \}\par
4879     \}\par
4880 \par
4881 {\cf21 #endif}\par
4882 \par
4883     TempFile::~TempFile() \{\par
4884          {\cf20 // TBD: What to do about errors here?}\par
4885          std::fclose(m_file);\par
4886          {\cf20 // We manually create the file on Windows only, on Linux}\par
4887          {\cf20 // it will be autodeleted}\par
4888 {\cf21 #if defined(_MSC_VER)}\par
4889          std::remove(m_buffer);\par
4890 {\cf21 #endif}\par
4891     \}\par
4892 \par
4893 \par
4894     FILE* TempFile::getFile() \{\par
4895         {\cf19 return} m_file;\par
4896     \}\par
4897 \par
4898     std::string TempFile::getContents() \{\par
4899         std::stringstream sstr;\par
4900         {\cf18 char} buffer[100] = \{\};\par
4901         std::rewind(m_file);\par
4902         {\cf19 while} (std::fgets(buffer, {\cf17 sizeof}(buffer), m_file)) \{\par
4903             sstr << buffer;\par
4904         \}\par
4905         {\cf19 return} sstr.str();\par
4906     \}\par
4907 \par
4908     OutputRedirect::OutputRedirect(std::string& stdout_dest, std::string& stderr_dest) :\par
4909         m_originalStdout(dup(1)),\par
4910         m_originalStderr(dup(2)),\par
4911         m_stdoutDest(stdout_dest),\par
4912         m_stderrDest(stderr_dest) \{\par
4913         dup2(fileno(m_stdoutFile.getFile()), 1);\par
4914         dup2(fileno(m_stderrFile.getFile()), 2);\par
4915     \}\par
4916 \par
4917     OutputRedirect::~OutputRedirect() \{\par
4918         Catch::cout() << std::flush;\par
4919         fflush(stdout);\par
4920         {\cf20 // Since we support overriding these streams, we flush cerr}\par
4921         {\cf20 // even though std::cerr is unbuffered}\par
4922         Catch::cerr() << std::flush;\par
4923         Catch::clog() << std::flush;\par
4924         fflush(stderr);\par
4925 \par
4926         dup2(m_originalStdout, 1);\par
4927         dup2(m_originalStderr, 2);\par
4928 \par
4929         m_stdoutDest += m_stdoutFile.getContents();\par
4930         m_stderrDest += m_stderrFile.getContents();\par
4931     \}\par
4932 \par
4933 {\cf21 #endif }{\cf20 // CATCH_CONFIG_NEW_CAPTURE}\par
4934 \par
4935 \} {\cf20 // namespace Catch}\par
4936 \par
4937 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
4938 {\cf21     #if defined(_MSC_VER)}\par
4939 {\cf21     #undef dup}\par
4940 {\cf21     #undef dup2}\par
4941 {\cf21     #undef fileno}\par
4942 {\cf21     #endif}\par
4943 {\cf21 #endif}\par
4944 \par
4945 \par
4946 \par
4947 \par
4948 {\cf21 #include <limits>}\par
4949 {\cf21 #include <stdexcept>}\par
4950 \par
4951 {\cf17 namespace }Catch \{\par
4952 \par
4953     Optional<unsigned int> parseUInt(std::string {\cf17 const}& input, {\cf18 int} base) \{\par
4954         {\cf17 auto} trimmed = trim( input );\par
4955         {\cf20 // std::stoull is annoying and accepts numbers starting with '-',}\par
4956         {\cf20 // it just negates them into unsigned int}\par
4957         {\cf19 if} ( trimmed.empty() || trimmed[0] == {\cf23 '-'} ) \{\par
4958             {\cf19 return} \{\};\par
4959         \}\par
4960 \par
4961         CATCH_TRY \{\par
4962             {\cf18 size_t} pos = 0;\par
4963             {\cf17 const} {\cf17 auto} ret = std::stoull( trimmed, &pos, base );\par
4964 \par
4965             {\cf20 // We did not consume the whole input, so there is an issue}\par
4966             {\cf20 // This can be bunch of different stuff, like multiple numbers}\par
4967             {\cf20 // in the input, or invalid digits/characters and so on. Either}\par
4968             {\cf20 // way, we do not want to return the partially parsed result.}\par
4969             {\cf19 if} ( pos != trimmed.size() ) \{\par
4970                 {\cf19 return} \{\};\par
4971             \}\par
4972             {\cf20 // Too large}\par
4973             {\cf19 if} ( ret > std::numeric_limits<unsigned int>::max() ) \{\par
4974                 {\cf19 return} \{\};\par
4975             \}\par
4976             {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(ret);\par
4977         \}\par
4978         CATCH_CATCH_ANON( std::invalid_argument {\cf17 const}& ) \{\par
4979             {\cf20 // no conversion could be performed}\par
4980         \}\par
4981         CATCH_CATCH_ANON( std::out_of_range {\cf17 const}& ) \{\par
4982             {\cf20 // the input does not fit into an unsigned long long}\par
4983         \}\par
4984         {\cf19 return} \{\};\par
4985     \}\par
4986 \par
4987 \} {\cf20 // namespace Catch}\par
4988 \par
4989 \par
4990 \par
4991 \par
4992 {\cf21 #include <cmath>}\par
4993 \par
4994 {\cf17 namespace }Catch \{\par
4995 \par
4996 {\cf21 #if !defined(CATCH_CONFIG_POLYFILL_ISNAN)}\par
4997     {\cf18 bool} isnan({\cf18 float} f) \{\par
4998         {\cf19 return} std::isnan(f);\par
4999     \}\par
5000     {\cf18 bool} isnan({\cf18 double} d) \{\par
5001         {\cf19 return} std::isnan(d);\par
5002     \}\par
5003 {\cf21 #else}\par
5004     {\cf20 // For now we only use this for embarcadero}\par
5005     {\cf18 bool} isnan({\cf18 float} f) \{\par
5006         {\cf19 return} std::_isnan(f);\par
5007     \}\par
5008     {\cf18 bool} isnan({\cf18 double} d) \{\par
5009         {\cf19 return} std::_isnan(d);\par
5010     \}\par
5011 {\cf21 #endif}\par
5012 \par
5013 {\cf21 #if !defined( CATCH_CONFIG_GLOBAL_NEXTAFTER )}\par
5014     {\cf18 float} nextafter( {\cf18 float} x, {\cf18 float} y ) \{ {\cf19 return} std::nextafter( x, y ); \}\par
5015     {\cf18 double} nextafter( {\cf18 double} x, {\cf18 double} y ) \{ {\cf19 return} std::nextafter( x, y ); \}\par
5016 {\cf21 #else}\par
5017     {\cf18 float} nextafter( {\cf18 float} x, {\cf18 float} y ) \{ return ::nextafterf( x, y ); \}\par
5018     {\cf18 double} nextafter( {\cf18 double} x, {\cf18 double} y ) \{ return ::nextafter( x, y ); \}\par
5019 {\cf21 #endif}\par
5020 \par
5021 \} {\cf20 // end namespace Catch}\par
5022 \par
5023 \par
5024 \par
5025 {\cf17 namespace }Catch \{\par
5026 \par
5027 {\cf17 namespace }\{\par
5028 \par
5029 {\cf21 #if defined(_MSC_VER)}\par
5030 {\cf21 #pragma warning(push)}\par
5031 {\cf21 #pragma warning(disable:4146) }{\cf20 // we negate uint32 during the rotate}\par
5032 {\cf21 #endif}\par
5033         {\cf20 // Safe rotr implementation thanks to John Regehr}\par
5034         uint32_t rotate_right(uint32_t val, uint32_t count) \{\par
5035             {\cf17 const} uint32_t mask = 31;\par
5036             count &= mask;\par
5037             {\cf19 return} (val >> count) | (val << (-count & mask));\par
5038         \}\par
5039 \par
5040 {\cf21 #if defined(_MSC_VER)}\par
5041 {\cf21 #pragma warning(pop)}\par
5042 {\cf21 #endif}\par
5043 \par
5044 \}\par
5045 \par
5046 \par
5047     SimplePcg32::SimplePcg32(result_type seed_) \{\par
5048         seed(seed_);\par
5049     \}\par
5050 \par
5051 \par
5052     {\cf18 void} SimplePcg32::seed(result_type seed_) \{\par
5053         m_state = 0;\par
5054         (*this)();\par
5055         m_state += seed_;\par
5056         (*this)();\par
5057     \}\par
5058 \par
5059     {\cf18 void} SimplePcg32::discard(uint64_t skip) \{\par
5060         {\cf20 // We could implement this to run in O(log n) steps, but this}\par
5061         {\cf20 // should suffice for our use case.}\par
5062         {\cf19 for} (uint64_t s = 0; s < skip; ++s) \{\par
5063             {\cf17 static_cast<}{\cf18 void}{\cf17 >}((*this)());\par
5064         \}\par
5065     \}\par
5066 \par
5067     SimplePcg32::result_type SimplePcg32::operator()() \{\par
5068         {\cf20 // prepare the output value}\par
5069         {\cf17 const} uint32_t xorshifted = {\cf17 static_cast<}uint32_t{\cf17 >}(((m_state >> 18u) ^ m_state) >> 27u);\par
5070         {\cf17 const} {\cf17 auto} output = rotate_right(xorshifted, m_state >> 59u);\par
5071 \par
5072         {\cf20 // advance state}\par
5073         m_state = m_state * 6364136223846793005ULL + s_inc;\par
5074 \par
5075         {\cf19 return} output;\par
5076     \}\par
5077 \par
5078     {\cf18 bool} operator==(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs) \{\par
5079         {\cf19 return} lhs.m_state == rhs.m_state;\par
5080     \}\par
5081 \par
5082     {\cf18 bool} operator!=(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs) \{\par
5083         {\cf19 return} lhs.m_state != rhs.m_state;\par
5084     \}\par
5085 \}\par
5086 \par
5087 \par
5088 \par
5089 \par
5090 \par
5091 {\cf21 #include <ctime>}\par
5092 {\cf21 #include <random>}\par
5093 \par
5094 {\cf17 namespace }Catch \{\par
5095 \par
5096     std::uint32_t generateRandomSeed( GenerateFrom from ) \{\par
5097         {\cf19 switch} ( from ) \{\par
5098         {\cf19 case} GenerateFrom::Time:\par
5099             {\cf19 return} {\cf17 static_cast<}std::uint32_t{\cf17 >}( std::time( {\cf17 nullptr} ) );\par
5100 \par
5101         {\cf19 case} GenerateFrom::Default:\par
5102         {\cf19 case} GenerateFrom::RandomDevice: \{\par
5103             std::random_device rd;\par
5104             {\cf19 return} Detail::fillBitsFrom<std::uint32_t>( rd );\par
5105         \}\par
5106 \par
5107         {\cf19 default}:\par
5108             CATCH_ERROR({\cf22 "Unknown generation method"});\par
5109         \}\par
5110     \}\par
5111 \par
5112 \} {\cf20 // end namespace Catch}\par
5113 \par
5114 \par
5115 \par
5116 \par
5117 {\cf17 namespace }Catch \{\par
5118     {\cf17 struct }ReporterRegistry::ReporterRegistryImpl \{\par
5119         std::vector<Detail::unique_ptr<EventListenerFactory>> listeners;\par
5120         std::map<std::string, IReporterFactoryPtr, Detail::CaseInsensitiveLess>\par
5121             factories;\par
5122     \};\par
5123 \par
5124     ReporterRegistry::ReporterRegistry():\par
5125         m_impl( Detail::make_unique<ReporterRegistryImpl>() ) \{\par
5126         {\cf20 // Because it is impossible to move out of initializer list,}\par
5127         {\cf20 // we have to add the elements manually}\par
5128         m_impl->factories[{\cf22 "Automake"}] =\par
5129             Detail::make_unique<ReporterFactory<AutomakeReporter>>();\par
5130         m_impl->factories[{\cf22 "compact"}] =\par
5131             Detail::make_unique<ReporterFactory<CompactReporter>>();\par
5132         m_impl->factories[{\cf22 "console"}] =\par
5133             Detail::make_unique<ReporterFactory<ConsoleReporter>>();\par
5134         m_impl->factories[{\cf22 "JUnit"}] =\par
5135             Detail::make_unique<ReporterFactory<JunitReporter>>();\par
5136         m_impl->factories[{\cf22 "SonarQube"}] =\par
5137             Detail::make_unique<ReporterFactory<SonarQubeReporter>>();\par
5138         m_impl->factories[{\cf22 "TAP"}] =\par
5139             Detail::make_unique<ReporterFactory<TAPReporter>>();\par
5140         m_impl->factories[{\cf22 "TeamCity"}] =\par
5141             Detail::make_unique<ReporterFactory<TeamCityReporter>>();\par
5142         m_impl->factories[{\cf22 "XML"}] =\par
5143             Detail::make_unique<ReporterFactory<XmlReporter>>();\par
5144         m_impl->factories[{\cf22 "JSON"}] =\par
5145             Detail::make_unique<ReporterFactory<JsonReporter>>();\par
5146     \}\par
5147 \par
5148     ReporterRegistry::~ReporterRegistry() = {\cf19 default};\par
5149 \par
5150     IEventListenerPtr\par
5151     ReporterRegistry::create( std::string {\cf17 const}& name,\par
5152                               ReporterConfig&& config ){\cf17  const }\{\par
5153         {\cf17 auto} it = m_impl->factories.find( name );\par
5154         {\cf19 if} ( it == m_impl->factories.end() ) {\cf19 return} {\cf17 nullptr};\par
5155         {\cf19 return} it->second->create( CATCH_MOVE( config ) );\par
5156     \}\par
5157 \par
5158     {\cf18 void} ReporterRegistry::registerReporter( std::string {\cf17 const}& name,\par
5159                                              IReporterFactoryPtr factory ) \{\par
5160         CATCH_ENFORCE( name.find( {\cf22 "::"} ) == name.npos,\par
5161                        {\cf22 "'::' is not allowed in reporter name: '"} + name +\par
5162                            {\cf23 '\\''} );\par
5163         {\cf17 auto} ret = m_impl->factories.emplace( name, CATCH_MOVE( factory ) );\par
5164         CATCH_ENFORCE( ret.second,\par
5165                        {\cf22 "reporter using '"} + name +\par
5166                            {\cf22 "' as name was already registered"} );\par
5167     \}\par
5168     {\cf18 void} ReporterRegistry::registerListener(\par
5169         Detail::unique_ptr<EventListenerFactory> factory ) \{\par
5170         m_impl->listeners.push_back( CATCH_MOVE( factory ) );\par
5171     \}\par
5172 \par
5173     std::map<std::string,\par
5174              IReporterFactoryPtr,\par
5175              Detail::CaseInsensitiveLess> {\cf17 const}&\par
5176     ReporterRegistry::getFactories(){\cf17  const }\{\par
5177         {\cf19 return} m_impl->factories;\par
5178     \}\par
5179 \par
5180     std::vector<Detail::unique_ptr<EventListenerFactory>> {\cf17 const}&\par
5181     ReporterRegistry::getListeners(){\cf17  const }\{\par
5182         {\cf19 return} m_impl->listeners;\par
5183     \}\par
5184 \} {\cf20 // namespace Catch}\par
5185 \par
5186 \par
5187 \par
5188 \par
5189 \par
5190 {\cf21 #include <algorithm>}\par
5191 \par
5192 {\cf17 namespace }Catch \{\par
5193 \par
5194     {\cf17 namespace }\{\par
5195         {\cf17 struct }kvPair \{\par
5196             StringRef key, value;\par
5197         \};\par
5198 \par
5199         kvPair splitKVPair(StringRef kvString) \{\par
5200             {\cf17 auto} splitPos = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
5201                 std::find( kvString.begin(), kvString.end(), {\cf23 '='} ) -\par
5202                 kvString.begin() );\par
5203 \par
5204             {\cf19 return} \{ kvString.substr( 0, splitPos ),\par
5205                      kvString.substr( splitPos + 1, kvString.size() ) \};\par
5206         \}\par
5207     \}\par
5208 \par
5209     {\cf17 namespace }Detail \{\par
5210         std::vector<std::string> splitReporterSpec( StringRef reporterSpec ) \{\par
5211             {\cf17 static} {\cf17 constexpr} {\cf17 auto} separator = {\cf22 "::"};\par
5212             {\cf17 static} {\cf17 constexpr} {\cf18 size_t} separatorSize = 2;\par
5213 \par
5214             {\cf18 size_t} separatorPos = 0;\par
5215             {\cf17 auto} findNextSeparator = [&reporterSpec]( {\cf18 size_t} startPos ) \{\par
5216                 {\cf17 static_assert}(\par
5217                     separatorSize == 2,\par
5218                     {\cf22 "The code below currently assumes 2 char separator"} );\par
5219 \par
5220                 {\cf17 auto} currentPos = startPos;\par
5221                 {\cf19 do} \{\par
5222                     {\cf19 while} ( currentPos < reporterSpec.size() &&\par
5223                             reporterSpec[currentPos] != separator[0] ) \{\par
5224                         ++currentPos;\par
5225                     \}\par
5226                     {\cf19 if} ( currentPos + 1 < reporterSpec.size() &&\par
5227                          reporterSpec[currentPos + 1] == separator[1] ) \{\par
5228                         {\cf19 return} currentPos;\par
5229                     \}\par
5230                     ++currentPos;\par
5231                 \} {\cf19 while} ( currentPos < reporterSpec.size() );\par
5232 \par
5233                 {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( -1 );\par
5234             \};\par
5235 \par
5236             std::vector<std::string> parts;\par
5237 \par
5238             {\cf19 while} ( separatorPos < reporterSpec.size() ) \{\par
5239                 {\cf17 const} {\cf17 auto} nextSeparator = findNextSeparator( separatorPos );\par
5240                 parts.push_back( {\cf17 static_cast<}std::string{\cf17 >}( reporterSpec.substr(\par
5241                     separatorPos, nextSeparator - separatorPos ) ) );\par
5242 \par
5243                 {\cf19 if} ( nextSeparator == {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}( -1 ) ) \{\par
5244                     {\cf19 break};\par
5245                 \}\par
5246                 separatorPos = nextSeparator + separatorSize;\par
5247             \}\par
5248 \par
5249             {\cf20 // Handle a separator at the end.}\par
5250             {\cf20 // This is not a valid spec, but we want to do validation in a}\par
5251             {\cf20 // centralized place}\par
5252             {\cf19 if} ( separatorPos == reporterSpec.size() ) \{\par
5253                 parts.emplace_back();\par
5254             \}\par
5255 \par
5256             {\cf19 return} parts;\par
5257         \}\par
5258 \par
5259         Optional<ColourMode> stringToColourMode( StringRef colourMode ) \{\par
5260             {\cf19 if} ( colourMode == {\cf22 "default"} ) \{\par
5261                 {\cf19 return} ColourMode::PlatformDefault;\par
5262             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "ansi"} ) \{\par
5263                 {\cf19 return} ColourMode::ANSI;\par
5264             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "win32"} ) \{\par
5265                 {\cf19 return} ColourMode::Win32;\par
5266             \} {\cf19 else} {\cf19 if} ( colourMode == {\cf22 "none"} ) \{\par
5267                 {\cf19 return} ColourMode::None;\par
5268             \} {\cf19 else} \{\par
5269                 {\cf19 return} \{\};\par
5270             \}\par
5271         \}\par
5272     \} {\cf20 // namespace Detail}\par
5273 \par
5274 \par
5275     {\cf18 bool} operator==( ReporterSpec {\cf17 const}& lhs, ReporterSpec {\cf17 const}& rhs ) \{\par
5276         {\cf19 return} lhs.m_name == rhs.m_name &&\par
5277                lhs.m_outputFileName == rhs.m_outputFileName &&\par
5278                lhs.m_colourMode == rhs.m_colourMode &&\par
5279                lhs.m_customOptions == rhs.m_customOptions;\par
5280     \}\par
5281 \par
5282     Optional<ReporterSpec> parseReporterSpec( StringRef reporterSpec ) \{\par
5283         {\cf17 auto} parts = Detail::splitReporterSpec( reporterSpec );\par
5284 \par
5285         assert( parts.size() > 0 && {\cf22 "Split should never return empty vector"} );\par
5286 \par
5287         std::map<std::string, std::string> kvPairs;\par
5288         Optional<std::string> outputFileName;\par
5289         Optional<ColourMode> colourMode;\par
5290 \par
5291         {\cf20 // First part is always reporter name, so we skip it}\par
5292         {\cf19 for} ( {\cf18 size_t} i = 1; i < parts.size(); ++i ) \{\par
5293             {\cf17 auto} kv = splitKVPair( parts[i] );\par
5294             {\cf17 auto} key = kv.key, value = kv.value;\par
5295 \par
5296             {\cf19 if} ( key.empty() || value.empty() ) \{ {\cf20 // NOLINT(bugprone-branch-clone)}\par
5297                 {\cf19 return} \{\};\par
5298             \} {\cf19 else} {\cf19 if} ( key[0] == {\cf23 'X'} ) \{\par
5299                 {\cf20 // This is a reporter-specific option, we don't check these}\par
5300                 {\cf20 // apart from basic sanity checks}\par
5301                 {\cf19 if} ( key.size() == 1 ) \{\par
5302                     {\cf19 return} \{\};\par
5303                 \}\par
5304 \par
5305                 {\cf17 auto} ret = kvPairs.emplace( std::string(kv.key), std::string(kv.value) );\par
5306                 {\cf19 if} ( !ret.second ) \{\par
5307                     {\cf20 // Duplicated key. We might want to handle this differently,}\par
5308                     {\cf20 // e.g. by overwriting the existing value?}\par
5309                     {\cf19 return} \{\};\par
5310                 \}\par
5311             \} {\cf19 else} {\cf19 if} ( key == {\cf22 "out"} ) \{\par
5312                 {\cf20 // Duplicated key}\par
5313                 {\cf19 if} ( outputFileName ) \{\par
5314                     {\cf19 return} \{\};\par
5315                 \}\par
5316                 outputFileName = {\cf17 static_cast<}std::string{\cf17 >}( value );\par
5317             \} {\cf19 else} {\cf19 if} ( key == {\cf22 "colour-mode"} ) \{\par
5318                 {\cf20 // Duplicated key}\par
5319                 {\cf19 if} ( colourMode ) \{\par
5320                     {\cf19 return} \{\};\par
5321                 \}\par
5322                 colourMode = Detail::stringToColourMode( value );\par
5323                 {\cf20 // Parsing failed}\par
5324                 {\cf19 if} ( !colourMode ) \{\par
5325                     {\cf19 return} \{\};\par
5326                 \}\par
5327             \} {\cf19 else} \{\par
5328                 {\cf20 // Unrecognized option}\par
5329                 {\cf19 return} \{\};\par
5330             \}\par
5331         \}\par
5332 \par
5333         {\cf19 return} ReporterSpec\{ CATCH_MOVE( parts[0] ),\par
5334                              CATCH_MOVE( outputFileName ),\par
5335                              CATCH_MOVE( colourMode ),\par
5336                              CATCH_MOVE( kvPairs ) \};\par
5337     \}\par
5338 \par
5339 ReporterSpec::ReporterSpec(\par
5340         std::string name,\par
5341         Optional<std::string> outputFileName,\par
5342         Optional<ColourMode> colourMode,\par
5343         std::map<std::string, std::string> customOptions ):\par
5344         m_name( CATCH_MOVE( name ) ),\par
5345         m_outputFileName( CATCH_MOVE( outputFileName ) ),\par
5346         m_colourMode( CATCH_MOVE( colourMode ) ),\par
5347         m_customOptions( CATCH_MOVE( customOptions ) ) \{\}\par
5348 \par
5349 \} {\cf20 // namespace Catch}\par
5350 \par
5351 \par
5352 \par
5353 {\cf17 namespace }Catch \{\par
5354 \par
5355     {\cf18 bool} isOk( ResultWas::OfType resultType ) \{\par
5356         {\cf19 return} ( resultType & ResultWas::FailureBit ) == 0;\par
5357     \}\par
5358     {\cf18 bool} isJustInfo( {\cf18 int} flags ) \{\par
5359         {\cf19 return} flags == ResultWas::Info;\par
5360     \}\par
5361 \par
5362     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{\par
5363         {\cf19 return} {\cf17 static_cast<}ResultDisposition::Flags{\cf17 >}( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( lhs ) | {\cf17 static_cast<}{\cf18 int}{\cf17 >}( rhs ) );\par
5364     \}\par
5365 \par
5366     {\cf18 bool} shouldContinueOnFailure( {\cf18 int} flags )    \{ {\cf19 return} ( flags & ResultDisposition::ContinueOnFailure ) != 0; \}\par
5367     {\cf18 bool} shouldSuppressFailure( {\cf18 int} flags )      \{ {\cf19 return} ( flags & ResultDisposition::SuppressFail ) != 0; \}\par
5368 \par
5369 \} {\cf20 // end namespace Catch}\par
5370 \par
5371 \par
5372 \par
5373 {\cf21 #include <cstdio>}\par
5374 {\cf21 #include <sstream>}\par
5375 {\cf21 #include <vector>}\par
5376 \par
5377 {\cf17 namespace }Catch \{\par
5378 \par
5379     {\cf20 // This class encapsulates the idea of a pool of ostringstreams that can be reused.}\par
5380     {\cf17 struct }StringStreams \{\par
5381         std::vector<Detail::unique_ptr<std::ostringstream>> m_streams;\par
5382         std::vector<std::size_t> m_unused;\par
5383         std::ostringstream m_referenceStream; {\cf20 // Used for copy state/ flags from}\par
5384 \par
5385         {\cf17 auto} add() -> std::size_t \{\par
5386             {\cf19 if}( m_unused.empty() ) \{\par
5387                 m_streams.push_back( Detail::make_unique<std::ostringstream>() );\par
5388                 {\cf19 return} m_streams.size()-1;\par
5389             \}\par
5390             {\cf19 else} \{\par
5391                 {\cf17 auto} index = m_unused.back();\par
5392                 m_unused.pop_back();\par
5393                 {\cf19 return} index;\par
5394             \}\par
5395         \}\par
5396 \par
5397         {\cf18 void} release( std::size_t index ) \{\par
5398             m_streams[index]->copyfmt( m_referenceStream ); {\cf20 // Restore initial flags and other state}\par
5399             m_unused.push_back(index);\par
5400         \}\par
5401     \};\par
5402 \par
5403     ReusableStringStream::ReusableStringStream()\par
5404     :   m_index( Singleton<StringStreams>::getMutable().add() ),\par
5405         m_oss( Singleton<StringStreams>::getMutable().m_streams[m_index].get() )\par
5406     \{\}\par
5407 \par
5408     ReusableStringStream::~ReusableStringStream() \{\par
5409         {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str({\cf22 ""});\par
5410         m_oss->clear();\par
5411         Singleton<StringStreams>::getMutable().release( m_index );\par
5412     \}\par
5413 \par
5414     std::string ReusableStringStream::str(){\cf17  const }\{\par
5415         {\cf19 return} {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str();\par
5416     \}\par
5417 \par
5418     {\cf18 void} ReusableStringStream::str( std::string {\cf17 const}& str ) \{\par
5419         {\cf17 static_cast<}std::ostringstream*{\cf17 >}( m_oss )->str( str );\par
5420     \}\par
5421 \par
5422 \par
5423 \}\par
5424 \par
5425 \par
5426 \par
5427 \par
5428 {\cf21 #include <cassert>}\par
5429 {\cf21 #include <algorithm>}\par
5430 \par
5431 {\cf17 namespace }Catch \{\par
5432 \par
5433     {\cf17 namespace }Generators \{\par
5434         {\cf17 namespace }\{\par
5435             {\cf17 struct }GeneratorTracker final : TestCaseTracking::TrackerBase,\par
5436                                       IGeneratorTracker \{\par
5437                 GeneratorBasePtr m_generator;\par
5438 \par
5439                 GeneratorTracker(\par
5440                     TestCaseTracking::NameAndLocation&& nameAndLocation,\par
5441                     TrackerContext& ctx,\par
5442                     ITracker* parent ):\par
5443                     TrackerBase( CATCH_MOVE( nameAndLocation ), ctx, parent ) \{\}\par
5444 \par
5445                 {\cf17 static} GeneratorTracker*\par
5446                 acquire( TrackerContext& ctx,\par
5447                          TestCaseTracking::NameAndLocationRef {\cf17 const}&\par
5448                              nameAndLocation ) \{\par
5449                     GeneratorTracker* tracker;\par
5450 \par
5451                     ITracker& currentTracker = ctx.currentTracker();\par
5452                     {\cf20 // Under specific circumstances, the generator we want}\par
5453                     {\cf20 // to acquire is also the current tracker. If this is}\par
5454                     {\cf20 // the case, we have to avoid looking through current}\par
5455                     {\cf20 // tracker's children, and instead return the current}\par
5456                     {\cf20 // tracker.}\par
5457                     {\cf20 // A case where this check is important is e.g.}\par
5458                     {\cf20 //     for (int i = 0; i < 5; ++i) \{}\par
5459                     {\cf20 //         int n = GENERATE(1, 2);}\par
5460                     {\cf20 //     \}}\par
5461                     {\cf20 //}\par
5462                     {\cf20 // without it, the code above creates 5 nested generators.}\par
5463                     {\cf19 if} ( currentTracker.nameAndLocation() == nameAndLocation ) \{\par
5464                         {\cf17 auto} thisTracker = currentTracker.parent()->findChild(\par
5465                             nameAndLocation );\par
5466                         assert( thisTracker );\par
5467                         assert( thisTracker->isGeneratorTracker() );\par
5468                         tracker = {\cf17 static_cast<}GeneratorTracker*{\cf17 >}( thisTracker );\par
5469                     \} {\cf19 else} {\cf19 if} ( ITracker* childTracker =\par
5470                                     currentTracker.findChild(\par
5471                                         nameAndLocation ) ) \{\par
5472                         assert( childTracker );\par
5473                         assert( childTracker->isGeneratorTracker() );\par
5474                         tracker =\par
5475                             {\cf17 static_cast<}GeneratorTracker*{\cf17 >}( childTracker );\par
5476                     \} {\cf19 else} \{\par
5477                         {\cf19 return} {\cf17 nullptr};\par
5478                     \}\par
5479 \par
5480                     {\cf19 if} ( !tracker->isComplete() ) \{ tracker->open(); \}\par
5481 \par
5482                     {\cf19 return} tracker;\par
5483                 \}\par
5484 \par
5485                 {\cf20 // TrackerBase interface}\par
5486                 {\cf18 bool} isGeneratorTracker(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
5487                 {\cf17 auto} hasGenerator() const -> {\cf18 bool}{\cf17  override }\{\par
5488                     {\cf19 return} !!m_generator;\par
5489                 \}\par
5490                 {\cf18 void} close(){\cf17  override }\{\par
5491                     TrackerBase::close();\par
5492                     {\cf20 // If a generator has a child (it is followed by a section)}\par
5493                     {\cf20 // and none of its children have started, then we must wait}\par
5494                     {\cf20 // until later to start consuming its values.}\par
5495                     {\cf20 // This catches cases where `GENERATE` is placed between two}\par
5496                     {\cf20 // `SECTION`s.}\par
5497                     {\cf20 // **The check for m_children.empty cannot be removed**.}\par
5498                     {\cf20 // doing so would break `GENERATE` _not_ followed by}\par
5499                     {\cf20 // `SECTION`s.}\par
5500                     {\cf17 const} {\cf18 bool} should_wait_for_child = [&]() \{\par
5501                         {\cf20 // No children -> nobody to wait for}\par
5502                         {\cf19 if} ( m_children.empty() ) \{ {\cf19 return} {\cf17 false}; \}\par
5503                         {\cf20 // If at least one child started executing, don't wait}\par
5504                         {\cf19 if} ( std::find_if(\par
5505                                  m_children.begin(),\par
5506                                  m_children.end(),\par
5507                                  []( TestCaseTracking::ITrackerPtr {\cf17 const}&\par
5508                                          tracker ) \{\par
5509                                      return tracker->hasStarted();\par
5510                                  \} ) != m_children.end() ) \{\par
5511                             {\cf19 return} {\cf17 false};\par
5512                         \}\par
5513 \par
5514                         {\cf20 // No children have started. We need to check if they}\par
5515                         {\cf20 // _can_ start, and thus we should wait for them, or}\par
5516                         {\cf20 // they cannot start (due to filters), and we shouldn't}\par
5517                         {\cf20 // wait for them}\par
5518                         ITracker* parent = m_parent;\par
5519                         {\cf20 // This is safe: there is always at least one section}\par
5520                         {\cf20 // tracker in a test case tracking tree}\par
5521                         {\cf19 while} ( !parent->isSectionTracker() ) \{\par
5522                             parent = parent->parent();\par
5523                         \}\par
5524                         assert( parent &&\par
5525                                 {\cf22 "Missing root (test case) level section"} );\par
5526 \par
5527                         {\cf17 auto} {\cf17 const}& parentSection =\par
5528                             {\cf17 static_cast<}SectionTracker const&{\cf17 >}( *parent );\par
5529                         {\cf17 auto} {\cf17 const}& filters = parentSection.getFilters();\par
5530                         {\cf20 // No filters -> no restrictions on running sections}\par
5531                         {\cf19 if} ( filters.empty() ) \{ {\cf19 return} {\cf17 true}; \}\par
5532 \par
5533                         {\cf19 for} ( {\cf17 auto} {\cf17 const}& child : m_children ) \{\par
5534                             {\cf19 if} ( child->isSectionTracker() &&\par
5535                                  std::find( filters.begin(),\par
5536                                             filters.end(),\par
5537                                             {\cf17 static_cast<}SectionTracker const&{\cf17 >}(\par
5538                                                 *child )\par
5539                                                 .trimmedName() ) !=\par
5540                                      filters.end() ) \{\par
5541                                 {\cf19 return} {\cf17 true};\par
5542                             \}\par
5543                         \}\par
5544                         {\cf19 return} {\cf17 false};\par
5545                     \}();\par
5546 \par
5547                     {\cf20 // This check is a bit tricky, because m_generator->next()}\par
5548                     {\cf20 // has a side-effect, where it consumes generator's current}\par
5549                     {\cf20 // value, but we do not want to invoke the side-effect if}\par
5550                     {\cf20 // this generator is still waiting for any child to start.}\par
5551                     assert( m_generator && {\cf22 "Tracker without generator"} );\par
5552                     {\cf19 if} ( should_wait_for_child ||\par
5553                          ( m_runState == CompletedSuccessfully &&\par
5554                            m_generator->countedNext() ) ) \{\par
5555                         m_children.clear();\par
5556                         m_runState = Executing;\par
5557                     \}\par
5558                 \}\par
5559 \par
5560                 {\cf20 // IGeneratorTracker interface}\par
5561                 {\cf17 auto} getGenerator() const -> GeneratorBasePtr const&{\cf17  override }\{\par
5562                     {\cf19 return} m_generator;\par
5563                 \}\par
5564                 {\cf18 void} setGenerator( GeneratorBasePtr&& generator ){\cf17  override }\{\par
5565                     m_generator = CATCH_MOVE( generator );\par
5566                 \}\par
5567             \};\par
5568         \} {\cf20 // namespace}\par
5569     \}\par
5570 \par
5571     RunContext::RunContext(IConfig {\cf17 const}* _config, IEventListenerPtr&& reporter)\par
5572     :   m_runInfo(_config->name()),\par
5573         m_config(_config),\par
5574         m_reporter(CATCH_MOVE(reporter)),\par
5575         m_lastAssertionInfo\{ StringRef(), SourceLineInfo({\cf22 ""},0), StringRef(), ResultDisposition::Normal \},\par
5576         m_includeSuccessfulResults( m_config->includeSuccessfulResults() || m_reporter->getPreferences().shouldReportAllAssertions )\par
5577     \{\par
5578         getCurrentMutableContext().setResultCapture( {\cf17 this} );\par
5579         m_reporter->testRunStarting(m_runInfo);\par
5580     \}\par
5581 \par
5582     RunContext::~RunContext() \{\par
5583         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));\par
5584     \}\par
5585 \par
5586     Totals RunContext::runTest(TestCaseHandle {\cf17 const}& testCase) \{\par
5587         {\cf17 const} Totals prevTotals = m_totals;\par
5588 \par
5589         {\cf17 auto} {\cf17 const}& testInfo = testCase.getTestCaseInfo();\par
5590         m_reporter->testCaseStarting(testInfo);\par
5591         m_activeTestCase = &testCase;\par
5592 \par
5593 \par
5594         ITracker& rootTracker = m_trackerContext.startRun();\par
5595         assert(rootTracker.isSectionTracker());\par
5596         {\cf17 static_cast<}SectionTracker&{\cf17 >}(rootTracker).addInitialFilters(m_config->getSectionsToRun());\par
5597 \par
5598         {\cf20 // We intentionally only seed the internal RNG once per test case,}\par
5599         {\cf20 // before it is first invoked. The reason for that is a complex}\par
5600         {\cf20 // interplay of generator/section implementation details and the}\par
5601         {\cf20 // Random*Generator types.}\par
5602         {\cf20 //}\par
5603         {\cf20 // The issue boils down to us needing to seed the Random*Generators}\par
5604         {\cf20 // with different seed each, so that they return different sequences}\par
5605         {\cf20 // of random numbers. We do this by giving them a number from the}\par
5606         {\cf20 // shared RNG instance as their seed.}\par
5607         {\cf20 //}\par
5608         {\cf20 // However, this runs into an issue if the reseeding happens each}\par
5609         {\cf20 // time the test case is entered (as opposed to first time only),}\par
5610         {\cf20 // because multiple generators could get the same seed, e.g. in}\par
5611         {\cf20 // ```cpp}\par
5612         {\cf20 // TEST_CASE() \{}\par
5613         {\cf20 //     auto i = GENERATE(take(10, random(0, 100));}\par
5614         {\cf20 //     SECTION("A") \{}\par
5615         {\cf20 //         auto j = GENERATE(take(10, random(0, 100));}\par
5616         {\cf20 //     \}}\par
5617         {\cf20 //     SECTION("B") \{}\par
5618         {\cf20 //         auto k = GENERATE(take(10, random(0, 100));}\par
5619         {\cf20 //     \}}\par
5620         {\cf20 // \}}\par
5621         {\cf20 // ```}\par
5622         {\cf20 // `i` and `j` would properly return values from different sequences,}\par
5623         {\cf20 // but `i` and `k` would return the same sequence, because their seed}\par
5624         {\cf20 // would be the same.}\par
5625         {\cf20 // (The reason their seeds would be the same is that the generator}\par
5626         {\cf20 //  for k would be initialized when the test case is entered the second}\par
5627         {\cf20 //  time, after the shared RNG instance was reset to the same value}\par
5628         {\cf20 //  it had when the generator for i was initialized.)}\par
5629         seedRng( *m_config );\par
5630 \par
5631         uint64_t testRuns = 0;\par
5632         std::string redirectedCout;\par
5633         std::string redirectedCerr;\par
5634         {\cf19 do} \{\par
5635             m_trackerContext.startCycle();\par
5636             m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocationRef(testInfo.name, testInfo.lineInfo));\par
5637 \par
5638             m_reporter->testCasePartialStarting(testInfo, testRuns);\par
5639 \par
5640             {\cf17 const} {\cf17 auto} beforeRunTotals = m_totals;\par
5641             std::string oneRunCout, oneRunCerr;\par
5642             runCurrentTest(oneRunCout, oneRunCerr);\par
5643             redirectedCout += oneRunCout;\par
5644             redirectedCerr += oneRunCerr;\par
5645 \par
5646             {\cf17 const} {\cf17 auto} singleRunTotals = m_totals.delta(beforeRunTotals);\par
5647             {\cf17 auto} statsForOneRun = TestCaseStats(testInfo, singleRunTotals, CATCH_MOVE(oneRunCout), CATCH_MOVE(oneRunCerr), aborting());\par
5648 \par
5649             m_reporter->testCasePartialEnded(statsForOneRun, testRuns);\par
5650             ++testRuns;\par
5651         \} {\cf19 while} (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());\par
5652 \par
5653         Totals deltaTotals = m_totals.delta(prevTotals);\par
5654         {\cf19 if} (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) \{\par
5655             deltaTotals.assertions.failed++;\par
5656             deltaTotals.testCases.passed--;\par
5657             deltaTotals.testCases.failed++;\par
5658         \}\par
5659         m_totals.testCases += deltaTotals.testCases;\par
5660         m_reporter->testCaseEnded(TestCaseStats(testInfo,\par
5661                                   deltaTotals,\par
5662                                   CATCH_MOVE(redirectedCout),\par
5663                                   CATCH_MOVE(redirectedCerr),\par
5664                                   aborting()));\par
5665 \par
5666         m_activeTestCase = {\cf17 nullptr};\par
5667         m_testCaseTracker = {\cf17 nullptr};\par
5668 \par
5669         {\cf19 return} deltaTotals;\par
5670     \}\par
5671 \par
5672 \par
5673     {\cf18 void} RunContext::assertionEnded(AssertionResult&& result) \{\par
5674         {\cf19 if} (result.getResultType() == ResultWas::Ok) \{\par
5675             m_totals.assertions.passed++;\par
5676             m_lastAssertionPassed = {\cf17 true};\par
5677         \} {\cf19 else} {\cf19 if} (result.getResultType() == ResultWas::ExplicitSkip) \{\par
5678             m_totals.assertions.skipped++;\par
5679             m_lastAssertionPassed = {\cf17 true};\par
5680         \} {\cf19 else} {\cf19 if} (!result.succeeded()) \{\par
5681             m_lastAssertionPassed = {\cf17 false};\par
5682             {\cf19 if} (result.isOk()) \{\par
5683             \}\par
5684             {\cf19 else} {\cf19 if}( m_activeTestCase->getTestCaseInfo().okToFail() )\par
5685                 m_totals.assertions.failedButOk++;\par
5686             {\cf19 else}\par
5687                 m_totals.assertions.failed++;\par
5688         \}\par
5689         {\cf19 else} \{\par
5690             m_lastAssertionPassed = {\cf17 true};\par
5691         \}\par
5692 \par
5693         m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals));\par
5694 \par
5695         {\cf19 if} ( result.getResultType() != ResultWas::Warning ) \{\par
5696             m_messageScopes.clear();\par
5697         \}\par
5698 \par
5699         {\cf20 // Reset working state. assertion info will be reset after}\par
5700         {\cf20 // populateReaction is run if it is needed}\par
5701         m_lastResult = CATCH_MOVE( result );\par
5702     \}\par
5703     {\cf18 void} RunContext::resetAssertionInfo() \{\par
5704         m_lastAssertionInfo.macroName = StringRef();\par
5705         m_lastAssertionInfo.capturedExpression = {\cf22 "\{Unknown expression after the reported line\}"}_sr;\par
5706         m_lastAssertionInfo.resultDisposition = ResultDisposition::Normal;\par
5707     \}\par
5708 \par
5709     {\cf18 void} RunContext::notifyAssertionStarted( AssertionInfo {\cf17 const}& info ) \{\par
5710         m_reporter->assertionStarting( info );\par
5711     \}\par
5712 \par
5713     {\cf18 bool} RunContext::sectionStarted( StringRef sectionName,\par
5714                                      SourceLineInfo {\cf17 const}& sectionLineInfo,\par
5715                                      Counts& assertions ) \{\par
5716         ITracker& sectionTracker =\par
5717             SectionTracker::acquire( m_trackerContext,\par
5718                                      TestCaseTracking::NameAndLocationRef(\par
5719                                          sectionName, sectionLineInfo ) );\par
5720 \par
5721         {\cf19 if} (!sectionTracker.isOpen())\par
5722             {\cf19 return} {\cf17 false};\par
5723         m_activeSections.push_back(&sectionTracker);\par
5724 \par
5725         SectionInfo sectionInfo( sectionLineInfo, {\cf17 static_cast<}std::string{\cf17 >}(sectionName) );\par
5726         m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;\par
5727 \par
5728         m_reporter->sectionStarting(sectionInfo);\par
5729 \par
5730         assertions = m_totals.assertions;\par
5731 \par
5732         {\cf19 return} {\cf17 true};\par
5733     \}\par
5734     IGeneratorTracker*\par
5735     RunContext::acquireGeneratorTracker( StringRef generatorName,\par
5736                                          SourceLineInfo {\cf17 const}& lineInfo ) \{\par
5737         {\cf17 using namespace }Generators;\par
5738         GeneratorTracker* tracker = GeneratorTracker::acquire(\par
5739             m_trackerContext,\par
5740             TestCaseTracking::NameAndLocationRef(\par
5741                  generatorName, lineInfo ) );\par
5742         m_lastAssertionInfo.lineInfo = lineInfo;\par
5743         {\cf19 return} tracker;\par
5744     \}\par
5745 \par
5746     IGeneratorTracker* RunContext::createGeneratorTracker(\par
5747         StringRef generatorName,\par
5748         SourceLineInfo lineInfo,\par
5749         Generators::GeneratorBasePtr&& generator ) \{\par
5750 \par
5751         {\cf17 auto} nameAndLoc = TestCaseTracking::NameAndLocation( {\cf17 static_cast<}std::string{\cf17 >}( generatorName ), lineInfo );\par
5752         {\cf17 auto}& currentTracker = m_trackerContext.currentTracker();\par
5753         assert(\par
5754             currentTracker.nameAndLocation() != nameAndLoc &&\par
5755             {\cf22 "Trying to create tracker for a genreator that already has one"} );\par
5756 \par
5757         {\cf17 auto} newTracker = Catch::Detail::make_unique<Generators::GeneratorTracker>(\par
5758             CATCH_MOVE(nameAndLoc), m_trackerContext, &currentTracker );\par
5759         {\cf17 auto} ret = newTracker.get();\par
5760         currentTracker.addChild( CATCH_MOVE( newTracker ) );\par
5761 \par
5762         ret->setGenerator( CATCH_MOVE( generator ) );\par
5763         ret->open();\par
5764         {\cf19 return} ret;\par
5765     \}\par
5766 \par
5767     {\cf18 bool} RunContext::testForMissingAssertions(Counts& assertions) \{\par
5768         {\cf19 if} (assertions.total() != 0)\par
5769             {\cf19 return} {\cf17 false};\par
5770         {\cf19 if} (!m_config->warnAboutMissingAssertions())\par
5771             {\cf19 return} {\cf17 false};\par
5772         {\cf19 if} (m_trackerContext.currentTracker().hasChildren())\par
5773             {\cf19 return} {\cf17 false};\par
5774         m_totals.assertions.failed++;\par
5775         assertions.failed++;\par
5776         {\cf19 return} {\cf17 true};\par
5777     \}\par
5778 \par
5779     {\cf18 void} RunContext::sectionEnded(SectionEndInfo&& endInfo) \{\par
5780         Counts assertions = m_totals.assertions - endInfo.prevAssertions;\par
5781         {\cf18 bool} missingAssertions = testForMissingAssertions(assertions);\par
5782 \par
5783         {\cf19 if} (!m_activeSections.empty()) \{\par
5784             m_activeSections.back()->close();\par
5785             m_activeSections.pop_back();\par
5786         \}\par
5787 \par
5788         m_reporter->sectionEnded(SectionStats(CATCH_MOVE(endInfo.sectionInfo), assertions, endInfo.durationInSeconds, missingAssertions));\par
5789         m_messages.clear();\par
5790         m_messageScopes.clear();\par
5791     \}\par
5792 \par
5793     {\cf18 void} RunContext::sectionEndedEarly(SectionEndInfo&& endInfo) \{\par
5794         {\cf19 if} ( m_unfinishedSections.empty() ) \{\par
5795             m_activeSections.back()->fail();\par
5796         \} {\cf19 else} \{\par
5797             m_activeSections.back()->close();\par
5798         \}\par
5799         m_activeSections.pop_back();\par
5800 \par
5801         m_unfinishedSections.push_back(CATCH_MOVE(endInfo));\par
5802     \}\par
5803 \par
5804     {\cf18 void} RunContext::benchmarkPreparing( StringRef name ) \{\par
5805         m_reporter->benchmarkPreparing(name);\par
5806     \}\par
5807     {\cf18 void} RunContext::benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) \{\par
5808         m_reporter->benchmarkStarting( info );\par
5809     \}\par
5810     {\cf18 void} RunContext::benchmarkEnded( BenchmarkStats<> {\cf17 const}& stats ) \{\par
5811         m_reporter->benchmarkEnded( stats );\par
5812     \}\par
5813     {\cf18 void} RunContext::benchmarkFailed( StringRef error ) \{\par
5814         m_reporter->benchmarkFailed( error );\par
5815     \}\par
5816 \par
5817     {\cf18 void} RunContext::pushScopedMessage(MessageInfo {\cf17 const} & message) \{\par
5818         m_messages.push_back(message);\par
5819     \}\par
5820 \par
5821     {\cf18 void} RunContext::popScopedMessage(MessageInfo {\cf17 const} & message) \{\par
5822         m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());\par
5823     \}\par
5824 \par
5825     {\cf18 void} RunContext::emplaceUnscopedMessage( MessageBuilder&& builder ) \{\par
5826         m_messageScopes.emplace_back( CATCH_MOVE(builder) );\par
5827     \}\par
5828 \par
5829     std::string RunContext::getCurrentTestName(){\cf17  const }\{\par
5830         {\cf19 return} m_activeTestCase\par
5831             ? m_activeTestCase->getTestCaseInfo().name\par
5832             : std::string();\par
5833     \}\par
5834 \par
5835     {\cf17 const} AssertionResult * RunContext::getLastResult(){\cf17  const }\{\par
5836         {\cf19 return} &(*m_lastResult);\par
5837     \}\par
5838 \par
5839     {\cf18 void} RunContext::exceptionEarlyReported() \{\par
5840         m_shouldReportUnexpected = {\cf17 false};\par
5841     \}\par
5842 \par
5843     {\cf18 void} RunContext::handleFatalErrorCondition( StringRef message ) \{\par
5844         {\cf20 // First notify reporter that bad things happened}\par
5845         m_reporter->fatalErrorEncountered(message);\par
5846 \par
5847         {\cf20 // Don't rebuild the result -- the stringification itself can cause more fatal errors}\par
5848         {\cf20 // Instead, fake a result data.}\par
5849         AssertionResultData tempResult( ResultWas::FatalErrorCondition, \{ {\cf17 false} \} );\par
5850         tempResult.message = {\cf17 static_cast<}std::string{\cf17 >}(message);\par
5851         AssertionResult result(m_lastAssertionInfo, CATCH_MOVE(tempResult));\par
5852 \par
5853         assertionEnded(CATCH_MOVE(result) );\par
5854         resetAssertionInfo();\par
5855 \par
5856         {\cf20 // Best effort cleanup for sections that have not been destructed yet}\par
5857         {\cf20 // Since this is a fatal error, we have not had and won't have the opportunity to destruct them properly}\par
5858         {\cf19 while} (!m_activeSections.empty()) \{\par
5859             {\cf17 auto} nl = m_activeSections.back()->nameAndLocation();\par
5860             SectionEndInfo endInfo\{ SectionInfo(CATCH_MOVE(nl.location), CATCH_MOVE(nl.name)), \{\}, 0.0 \};\par
5861             sectionEndedEarly(CATCH_MOVE(endInfo));\par
5862         \}\par
5863         handleUnfinishedSections();\par
5864 \par
5865         {\cf20 // Recreate section for test case (as we will lose the one that was in scope)}\par
5866         {\cf17 auto} {\cf17 const}& testCaseInfo = m_activeTestCase->getTestCaseInfo();\par
5867         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);\par
5868 \par
5869         Counts assertions;\par
5870         assertions.failed = 1;\par
5871         SectionStats testCaseSectionStats(CATCH_MOVE(testCaseSection), assertions, 0, {\cf17 false});\par
5872         m_reporter->sectionEnded(testCaseSectionStats);\par
5873 \par
5874         {\cf17 auto} {\cf17 const}& testInfo = m_activeTestCase->getTestCaseInfo();\par
5875 \par
5876         Totals deltaTotals;\par
5877         deltaTotals.testCases.failed = 1;\par
5878         deltaTotals.assertions.failed = 1;\par
5879         m_reporter->testCaseEnded(TestCaseStats(testInfo,\par
5880                                   deltaTotals,\par
5881                                   std::string(),\par
5882                                   std::string(),\par
5883                                   {\cf17 false}));\par
5884         m_totals.testCases.failed++;\par
5885         m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, {\cf17 false}));\par
5886     \}\par
5887 \par
5888     {\cf18 bool} RunContext::lastAssertionPassed() \{\par
5889          {\cf19 return} m_lastAssertionPassed;\par
5890     \}\par
5891 \par
5892     {\cf18 void} RunContext::assertionPassed() \{\par
5893         m_lastAssertionPassed = {\cf17 true};\par
5894         ++m_totals.assertions.passed;\par
5895         resetAssertionInfo();\par
5896         m_messageScopes.clear();\par
5897     \}\par
5898 \par
5899     {\cf18 bool} RunContext::aborting(){\cf17  const }\{\par
5900         {\cf19 return} m_totals.assertions.failed >= {\cf17 static_cast<}std::size_t{\cf17 >}(m_config->abortAfter());\par
5901     \}\par
5902 \par
5903     {\cf18 void} RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) \{\par
5904         {\cf17 auto} {\cf17 const}& testCaseInfo = m_activeTestCase->getTestCaseInfo();\par
5905         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);\par
5906         m_reporter->sectionStarting(testCaseSection);\par
5907         Counts prevAssertions = m_totals.assertions;\par
5908         {\cf18 double} duration = 0;\par
5909         m_shouldReportUnexpected = {\cf17 true};\par
5910         m_lastAssertionInfo = \{ {\cf22 "TEST_CASE"}_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal \};\par
5911 \par
5912         Timer timer;\par
5913         CATCH_TRY \{\par
5914             {\cf19 if} (m_reporter->getPreferences().shouldRedirectStdOut) \{\par
5915 {\cf21 #if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)}\par
5916                 RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);\par
5917 \par
5918                 timer.start();\par
5919                 invokeActiveTestCase();\par
5920 {\cf21 #else}\par
5921                 OutputRedirect r(redirectedCout, redirectedCerr);\par
5922                 timer.start();\par
5923                 invokeActiveTestCase();\par
5924 {\cf21 #endif}\par
5925             \} {\cf19 else} \{\par
5926                 timer.start();\par
5927                 invokeActiveTestCase();\par
5928             \}\par
5929             duration = timer.getElapsedSeconds();\par
5930         \} CATCH_CATCH_ANON (TestFailureException&) \{\par
5931             {\cf20 // This just means the test was aborted due to failure}\par
5932         \} CATCH_CATCH_ANON (TestSkipException&) \{\par
5933             {\cf20 // This just means the test was explicitly skipped}\par
5934         \} CATCH_CATCH_ALL \{\par
5935             {\cf20 // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions}\par
5936             {\cf20 // are reported without translation at the point of origin.}\par
5937             {\cf19 if}( m_shouldReportUnexpected ) \{\par
5938                 AssertionReaction dummyReaction;\par
5939                 handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );\par
5940             \}\par
5941         \}\par
5942         Counts assertions = m_totals.assertions - prevAssertions;\par
5943         {\cf18 bool} missingAssertions = testForMissingAssertions(assertions);\par
5944 \par
5945         m_testCaseTracker->close();\par
5946         handleUnfinishedSections();\par
5947         m_messages.clear();\par
5948         m_messageScopes.clear();\par
5949 \par
5950         SectionStats testCaseSectionStats(CATCH_MOVE(testCaseSection), assertions, duration, missingAssertions);\par
5951         m_reporter->sectionEnded(testCaseSectionStats);\par
5952     \}\par
5953 \par
5954     {\cf18 void} RunContext::invokeActiveTestCase() \{\par
5955         {\cf20 // We need to engage a handler for signals/structured exceptions}\par
5956         {\cf20 // before running the tests themselves, or the binary can crash}\par
5957         {\cf20 // without failed test being reported.}\par
5958         FatalConditionHandlerGuard _(&m_fatalConditionhandler);\par
5959         {\cf20 // We keep having issue where some compilers warn about an unused}\par
5960         {\cf20 // variable, even though the type has non-trivial constructor and}\par
5961         {\cf20 // destructor. This is annoying and ugly, but it makes them stfu.}\par
5962         (void)_;\par
5963 \par
5964         m_activeTestCase->invoke();\par
5965     \}\par
5966 \par
5967     {\cf18 void} RunContext::handleUnfinishedSections() \{\par
5968         {\cf20 // If sections ended prematurely due to an exception we stored their}\par
5969         {\cf20 // infos here so we can tear them down outside the unwind process.}\par
5970         {\cf19 for} ({\cf17 auto} it = m_unfinishedSections.rbegin(),\par
5971              itEnd = m_unfinishedSections.rend();\par
5972              it != itEnd;\par
5973              ++it)\par
5974             sectionEnded(CATCH_MOVE(*it));\par
5975         m_unfinishedSections.clear();\par
5976     \}\par
5977 \par
5978     {\cf18 void} RunContext::handleExpr(\par
5979         AssertionInfo {\cf17 const}& info,\par
5980         ITransientExpression {\cf17 const}& expr,\par
5981         AssertionReaction& reaction\par
5982     ) \{\par
5983         {\cf18 bool} negated = isFalseTest( info.resultDisposition );\par
5984         {\cf18 bool} result = expr.getResult() != negated;\par
5985 \par
5986         {\cf19 if}( result ) \{\par
5987             {\cf19 if} (!m_includeSuccessfulResults) \{\par
5988                 assertionPassed();\par
5989             \}\par
5990             {\cf19 else} \{\par
5991                 reportExpr(info, ResultWas::Ok, &expr, negated);\par
5992             \}\par
5993         \}\par
5994         {\cf19 else} \{\par
5995             reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );\par
5996             populateReaction( reaction );\par
5997         \}\par
5998         resetAssertionInfo();\par
5999     \}\par
6000     {\cf18 void} RunContext::reportExpr(\par
6001             AssertionInfo {\cf17 const} &info,\par
6002             ResultWas::OfType resultType,\par
6003             ITransientExpression {\cf17 const} *expr,\par
6004             {\cf18 bool} negated ) \{\par
6005 \par
6006         m_lastAssertionInfo = info;\par
6007         AssertionResultData data( resultType, LazyExpression( negated ) );\par
6008 \par
6009         AssertionResult assertionResult\{ info, CATCH_MOVE( data ) \};\par
6010         assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;\par
6011 \par
6012         assertionEnded( CATCH_MOVE(assertionResult) );\par
6013     \}\par
6014 \par
6015     {\cf18 void} RunContext::handleMessage(\par
6016             AssertionInfo {\cf17 const}& info,\par
6017             ResultWas::OfType resultType,\par
6018             StringRef message,\par
6019             AssertionReaction& reaction\par
6020     ) \{\par
6021         m_lastAssertionInfo = info;\par
6022 \par
6023         AssertionResultData data( resultType, LazyExpression( {\cf17 false} ) );\par
6024         data.message = {\cf17 static_cast<}std::string{\cf17 >}(message);\par
6025         AssertionResult assertionResult\{ m_lastAssertionInfo,\par
6026                                          CATCH_MOVE( data ) \};\par
6027 \par
6028         {\cf17 const} {\cf17 auto} isOk = assertionResult.isOk();\par
6029         assertionEnded( CATCH_MOVE(assertionResult) );\par
6030         {\cf19 if} ( !isOk ) \{\par
6031             populateReaction( reaction );\par
6032         \} {\cf19 else} {\cf19 if} ( resultType == ResultWas::ExplicitSkip ) \{\par
6033             {\cf20 // TODO: Need to handle this explicitly, as ExplicitSkip is}\par
6034             {\cf20 // considered "OK"}\par
6035             reaction.shouldSkip = {\cf17 true};\par
6036         \}\par
6037         resetAssertionInfo();\par
6038     \}\par
6039     {\cf18 void} RunContext::handleUnexpectedExceptionNotThrown(\par
6040             AssertionInfo {\cf17 const}& info,\par
6041             AssertionReaction& reaction\par
6042     ) \{\par
6043         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);\par
6044     \}\par
6045 \par
6046     {\cf18 void} RunContext::handleUnexpectedInflightException(\par
6047             AssertionInfo {\cf17 const}& info,\par
6048             std::string&& message,\par
6049             AssertionReaction& reaction\par
6050     ) \{\par
6051         m_lastAssertionInfo = info;\par
6052 \par
6053         AssertionResultData data( ResultWas::ThrewException, LazyExpression( {\cf17 false} ) );\par
6054         data.message = CATCH_MOVE(message);\par
6055         AssertionResult assertionResult\{ info, CATCH_MOVE(data) \};\par
6056         assertionEnded( CATCH_MOVE(assertionResult) );\par
6057         populateReaction( reaction );\par
6058         resetAssertionInfo();\par
6059     \}\par
6060 \par
6061     {\cf18 void} RunContext::populateReaction( AssertionReaction& reaction ) \{\par
6062         reaction.shouldDebugBreak = m_config->shouldDebugBreak();\par
6063         reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);\par
6064     \}\par
6065 \par
6066     {\cf18 void} RunContext::handleIncomplete(\par
6067             AssertionInfo {\cf17 const}& info\par
6068     ) \{\par
6069         {\cf17 using namespace }std::string_literals;\par
6070         m_lastAssertionInfo = info;\par
6071 \par
6072         AssertionResultData data( ResultWas::ThrewException, LazyExpression( {\cf17 false} ) );\par
6073         data.message = {\cf22 "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE"}s;\par
6074         AssertionResult assertionResult\{ info, CATCH_MOVE( data ) \};\par
6075         assertionEnded( CATCH_MOVE(assertionResult) );\par
6076         resetAssertionInfo();\par
6077     \}\par
6078     {\cf18 void} RunContext::handleNonExpr(\par
6079             AssertionInfo {\cf17 const} &info,\par
6080             ResultWas::OfType resultType,\par
6081             AssertionReaction &reaction\par
6082     ) \{\par
6083         m_lastAssertionInfo = info;\par
6084 \par
6085         AssertionResultData data( resultType, LazyExpression( {\cf17 false} ) );\par
6086         AssertionResult assertionResult\{ info, CATCH_MOVE( data ) \};\par
6087 \par
6088         {\cf17 const} {\cf17 auto} isOk = assertionResult.isOk();\par
6089         assertionEnded( CATCH_MOVE(assertionResult) );\par
6090         {\cf19 if} ( !isOk ) \{ populateReaction( reaction ); \}\par
6091         resetAssertionInfo();\par
6092     \}\par
6093 \par
6094 \par
6095     IResultCapture& getResultCapture() \{\par
6096         {\cf19 if} ({\cf17 auto}* capture = getCurrentContext().getResultCapture())\par
6097             {\cf19 return} *capture;\par
6098         {\cf19 else}\par
6099             CATCH_INTERNAL_ERROR({\cf22 "No result capture instance"});\par
6100     \}\par
6101 \par
6102     {\cf18 void} seedRng(IConfig {\cf17 const}& config) \{\par
6103         sharedRng().seed(config.rngSeed());\par
6104     \}\par
6105 \par
6106     {\cf18 unsigned} {\cf18 int} rngSeed() \{\par
6107         {\cf19 return} getCurrentContext().getConfig()->rngSeed();\par
6108     \}\par
6109 \par
6110 \}\par
6111 \par
6112 \par
6113 \par
6114 {\cf17 namespace }Catch \{\par
6115 \par
6116     Section::Section( SectionInfo&& info ):\par
6117         m_info( CATCH_MOVE( info ) ),\par
6118         m_sectionIncluded(\par
6119             getResultCapture().sectionStarted( m_info.name, m_info.lineInfo, m_assertions ) ) \{\par
6120         {\cf20 // Non-"included" sections will not use the timing information}\par
6121         {\cf20 // anyway, so don't bother with the potential syscall.}\par
6122         {\cf19 if} (m_sectionIncluded) \{\par
6123             m_timer.start();\par
6124         \}\par
6125     \}\par
6126 \par
6127     Section::Section( SourceLineInfo {\cf17 const}& _lineInfo,\par
6128                       StringRef _name,\par
6129                       {\cf17 const} {\cf18 char}* {\cf17 const} ):\par
6130         m_info( \{ {\cf22 "invalid"}, {\cf17 static_cast<}std::size_t{\cf17 >}( -1 ) \}, std::string\{\} ),\par
6131         m_sectionIncluded(\par
6132             getResultCapture().sectionStarted( _name, _lineInfo, m_assertions ) ) \{\par
6133         {\cf20 // We delay initialization the SectionInfo member until we know}\par
6134         {\cf20 // this section needs it, so we avoid allocating std::string for name.}\par
6135         {\cf20 // We also delay timer start to avoid the potential syscall unless we}\par
6136         {\cf20 // will actually use the result.}\par
6137         {\cf19 if} ( m_sectionIncluded ) \{\par
6138             m_info.name = {\cf17 static_cast<}std::string{\cf17 >}( _name );\par
6139             m_info.lineInfo = _lineInfo;\par
6140             m_timer.start();\par
6141         \}\par
6142     \}\par
6143 \par
6144     Section::~Section() \{\par
6145         {\cf19 if}( m_sectionIncluded ) \{\par
6146             SectionEndInfo endInfo\{ CATCH_MOVE(m_info), m_assertions, m_timer.getElapsedSeconds() \};\par
6147             {\cf19 if} ( uncaught_exceptions() ) \{\par
6148                 getResultCapture().sectionEndedEarly( CATCH_MOVE(endInfo) );\par
6149             \} {\cf19 else} \{\par
6150                 getResultCapture().sectionEnded( CATCH_MOVE( endInfo ) );\par
6151             \}\par
6152         \}\par
6153     \}\par
6154 \par
6155     {\cf20 // This indicates whether the section should be executed or not}\par
6156     Section::operator bool(){\cf17  const }\{\par
6157         {\cf19 return} m_sectionIncluded;\par
6158     \}\par
6159 \par
6160 \par
6161 \} {\cf20 // end namespace Catch}\par
6162 \par
6163 \par
6164 \par
6165 {\cf21 #include <vector>}\par
6166 \par
6167 {\cf17 namespace }Catch \{\par
6168 \par
6169     {\cf17 namespace }\{\par
6170         {\cf17 static} {\cf17 auto} getSingletons() -> std::vector<ISingleton*>*& \{\par
6171             {\cf17 static} std::vector<ISingleton*>* g_singletons = {\cf17 nullptr};\par
6172             {\cf19 if}( !g_singletons )\par
6173                 g_singletons = {\cf17 new} std::vector<ISingleton*>();\par
6174             {\cf19 return} g_singletons;\par
6175         \}\par
6176     \}\par
6177 \par
6178     ISingleton::~ISingleton() = {\cf19 default};\par
6179 \par
6180     {\cf18 void} addSingleton(ISingleton* singleton ) \{\par
6181         getSingletons()->push_back( singleton );\par
6182     \}\par
6183     {\cf18 void} cleanupSingletons() \{\par
6184         {\cf17 auto}& singletons = getSingletons();\par
6185         {\cf19 for}( {\cf17 auto} singleton : *singletons )\par
6186             {\cf17 delete} singleton;\par
6187         {\cf17 delete} singletons;\par
6188         singletons = {\cf17 nullptr};\par
6189     \}\par
6190 \par
6191 \} {\cf20 // namespace Catch}\par
6192 \par
6193 \par
6194 \par
6195 {\cf21 #include <cstring>}\par
6196 {\cf21 #include <ostream>}\par
6197 \par
6198 {\cf17 namespace }Catch \{\par
6199 \par
6200     {\cf18 bool} SourceLineInfo::operator == ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} \{\par
6201         {\cf19 return} line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);\par
6202     \}\par
6203     {\cf18 bool} SourceLineInfo::operator < ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept} \{\par
6204         {\cf20 // We can assume that the same file will usually have the same pointer.}\par
6205         {\cf20 // Thus, if the pointers are the same, there is no point in calling the strcmp}\par
6206         {\cf19 return} line < other.line || ( line == other.line && file != other.file && (std::strcmp(file, other.file) < 0));\par
6207     \}\par
6208 \par
6209     std::ostream& operator << ( std::ostream& os, SourceLineInfo {\cf17 const}& info ) \{\par
6210 {\cf21 #ifndef __GNUG__}\par
6211         os << info.file << {\cf23 '('} << info.line << {\cf23 ')'};\par
6212 {\cf21 #else}\par
6213         os << info.file << {\cf23 ':'} << info.line;\par
6214 {\cf21 #endif}\par
6215         {\cf19 return} os;\par
6216     \}\par
6217 \par
6218 \} {\cf20 // end namespace Catch}\par
6219 \par
6220 \par
6221 \par
6222 \par
6223 {\cf17 namespace }Catch \{\par
6224 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
6225     {\cf18 void} StartupExceptionRegistry::add( std::exception_ptr {\cf17 const}& exception ) {\cf17 noexcept} \{\par
6226         CATCH_TRY \{\par
6227             m_exceptions.push_back(exception);\par
6228         \} CATCH_CATCH_ALL \{\par
6229             {\cf20 // If we run out of memory during start-up there's really not a lot more we can do about it}\par
6230             std::terminate();\par
6231         \}\par
6232     \}\par
6233 \par
6234     std::vector<std::exception_ptr> {\cf17 const}& StartupExceptionRegistry::getExceptions() const noexcept \{\par
6235         {\cf19 return} m_exceptions;\par
6236     \}\par
6237 {\cf21 #endif}\par
6238 \par
6239 \} {\cf20 // end namespace Catch}\par
6240 \par
6241 \par
6242 \par
6243 \par
6244 \par
6245 {\cf21 #include <iostream>}\par
6246 \par
6247 {\cf17 namespace }Catch \{\par
6248 \par
6249 {\cf20 // If you #define this you must implement these functions}\par
6250 {\cf21 #if !defined( CATCH_CONFIG_NOSTDOUT )}\par
6251     std::ostream& cout() \{ {\cf19 return} std::cout; \}\par
6252     std::ostream& cerr() \{ {\cf19 return} std::cerr; \}\par
6253     std::ostream& clog() \{ {\cf19 return} std::clog; \}\par
6254 {\cf21 #endif}\par
6255 \par
6256 \} {\cf20 // namespace Catch}\par
6257 \par
6258 \par
6259 \par
6260 {\cf21 #include <ostream>}\par
6261 {\cf21 #include <cstring>}\par
6262 {\cf21 #include <cctype>}\par
6263 {\cf21 #include <vector>}\par
6264 \par
6265 {\cf17 namespace }Catch \{\par
6266 \par
6267     {\cf18 bool} startsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& prefix ) \{\par
6268         {\cf19 return} s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());\par
6269     \}\par
6270     {\cf18 bool} startsWith( StringRef s, {\cf18 char} prefix ) \{\par
6271         {\cf19 return} !s.empty() && s[0] == prefix;\par
6272     \}\par
6273     {\cf18 bool} endsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& suffix ) \{\par
6274         {\cf19 return} s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());\par
6275     \}\par
6276     {\cf18 bool} endsWith( std::string {\cf17 const}& s, {\cf18 char} suffix ) \{\par
6277         {\cf19 return} !s.empty() && s[s.size()-1] == suffix;\par
6278     \}\par
6279     {\cf18 bool} contains( std::string {\cf17 const}& s, std::string {\cf17 const}& infix ) \{\par
6280         {\cf19 return} s.find( infix ) != std::string::npos;\par
6281     \}\par
6282     {\cf18 void} toLowerInPlace( std::string& s ) \{\par
6283         {\cf19 for} ( {\cf18 char}& c : s ) \{\par
6284             c = toLower( c );\par
6285         \}\par
6286     \}\par
6287     std::string toLower( std::string {\cf17 const}& s ) \{\par
6288         std::string lc = s;\par
6289         toLowerInPlace( lc );\par
6290         {\cf19 return} lc;\par
6291     \}\par
6292     {\cf18 char} toLower({\cf18 char} c) \{\par
6293         {\cf19 return} {\cf17 static_cast<}{\cf18 char}{\cf17 >}(std::tolower({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c)));\par
6294     \}\par
6295 \par
6296     std::string trim( std::string {\cf17 const}& str ) \{\par
6297         {\cf17 static} {\cf18 char} {\cf17 const}* whitespaceChars = {\cf22 "\\n\\r\\t "};\par
6298         std::string::size_type start = str.find_first_not_of( whitespaceChars );\par
6299         std::string::size_type end = str.find_last_not_of( whitespaceChars );\par
6300 \par
6301         {\cf19 return} start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();\par
6302     \}\par
6303 \par
6304     StringRef trim(StringRef ref) \{\par
6305         {\cf17 const} {\cf17 auto} is_ws = []({\cf18 char} c) \{\par
6306             {\cf19 return} c == {\cf23 ' '} || c == {\cf23 '\\t'} || c == {\cf23 '\\n'} || c == {\cf23 '\\r'};\par
6307         \};\par
6308         {\cf18 size_t} real_begin = 0;\par
6309         {\cf19 while} (real_begin < ref.size() && is_ws(ref[real_begin])) \{ ++real_begin; \}\par
6310         {\cf18 size_t} real_end = ref.size();\par
6311         {\cf19 while} (real_end > real_begin && is_ws(ref[real_end - 1])) \{ --real_end; \}\par
6312 \par
6313         {\cf19 return} ref.substr(real_begin, real_end - real_begin);\par
6314     \}\par
6315 \par
6316     {\cf18 bool} replaceInPlace( std::string& str, std::string {\cf17 const}& replaceThis, std::string {\cf17 const}& withThis ) \{\par
6317         std::size_t i = str.find( replaceThis );\par
6318         {\cf19 if} (i == std::string::npos) \{\par
6319             {\cf19 return} {\cf17 false};\par
6320         \}\par
6321         std::size_t copyBegin = 0;\par
6322         std::string origStr = CATCH_MOVE(str);\par
6323         str.clear();\par
6324         {\cf20 // There is at least one replacement, so reserve with the best guess}\par
6325         {\cf20 // we can make without actually counting the number of occurences.}\par
6326         str.reserve(origStr.size() - replaceThis.size() + withThis.size());\par
6327         {\cf19 do} \{\par
6328             str.append(origStr, copyBegin, i-copyBegin );\par
6329             str += withThis;\par
6330             copyBegin = i + replaceThis.size();\par
6331             {\cf19 if}( copyBegin < origStr.size() )\par
6332                 i = origStr.find( replaceThis, copyBegin );\par
6333             {\cf19 else}\par
6334                 i = std::string::npos;\par
6335         \} {\cf19 while}( i != std::string::npos );\par
6336         {\cf19 if} ( copyBegin < origStr.size() ) \{\par
6337             str.append(origStr, copyBegin, origStr.size() );\par
6338         \}\par
6339         {\cf19 return} {\cf17 true};\par
6340     \}\par
6341 \par
6342     std::vector<StringRef> splitStringRef( StringRef str, {\cf18 char} delimiter ) \{\par
6343         std::vector<StringRef> subStrings;\par
6344         std::size_t start = 0;\par
6345         {\cf19 for}(std::size_t pos = 0; pos < str.size(); ++pos ) \{\par
6346             {\cf19 if}( str[pos] == delimiter ) \{\par
6347                 {\cf19 if}( pos - start > 1 )\par
6348                     subStrings.push_back( str.substr( start, pos-start ) );\par
6349                 start = pos+1;\par
6350             \}\par
6351         \}\par
6352         {\cf19 if}( start < str.size() )\par
6353             subStrings.push_back( str.substr( start, str.size()-start ) );\par
6354         {\cf19 return} subStrings;\par
6355     \}\par
6356 \par
6357     std::ostream& operator << ( std::ostream& os, pluralise {\cf17 const}& pluraliser ) \{\par
6358         os << pluraliser.m_count << {\cf23 ' '} << pluraliser.m_label;\par
6359         {\cf19 if}( pluraliser.m_count != 1 )\par
6360             os << {\cf23 's'};\par
6361         {\cf19 return} os;\par
6362     \}\par
6363 \par
6364 \}\par
6365 \par
6366 \par
6367 \par
6368 {\cf21 #include <algorithm>}\par
6369 {\cf21 #include <ostream>}\par
6370 {\cf21 #include <cstring>}\par
6371 {\cf21 #include <cstdint>}\par
6372 \par
6373 {\cf17 namespace }Catch \{\par
6374     StringRef::StringRef( {\cf18 char} {\cf17 const}* rawChars ) noexcept\par
6375     : StringRef( rawChars, std::strlen(rawChars) )\par
6376     \{\}\par
6377 \par
6378 \par
6379     {\cf18 bool} StringRef::operator<(StringRef rhs) {\cf17 const} {\cf17 noexcept} \{\par
6380         {\cf19 if} (m_size < rhs.m_size) \{\par
6381             {\cf19 return} strncmp(m_start, rhs.m_start, m_size) <= 0;\par
6382         \}\par
6383         {\cf19 return} strncmp(m_start, rhs.m_start, rhs.m_size) < 0;\par
6384     \}\par
6385 \par
6386     {\cf18 int} StringRef::compare( StringRef rhs ){\cf17  const }\{\par
6387         {\cf17 auto} cmpResult =\par
6388             strncmp( m_start, rhs.m_start, std::min( m_size, rhs.m_size ) );\par
6389 \par
6390         {\cf20 // This means that strncmp found a difference before the strings}\par
6391         {\cf20 // ended, and we can return it directly}\par
6392         {\cf19 if} ( cmpResult != 0 ) \{\par
6393             {\cf19 return} cmpResult;\par
6394         \}\par
6395 \par
6396         {\cf20 // If strings are equal up to length, then their comparison results on}\par
6397         {\cf20 // their size}\par
6398         {\cf19 if} ( m_size < rhs.m_size ) \{\par
6399             {\cf19 return} -1;\par
6400         \} {\cf19 else} {\cf19 if} ( m_size > rhs.m_size ) \{\par
6401             {\cf19 return} 1;\par
6402         \} {\cf19 else} \{\par
6403             {\cf19 return} 0;\par
6404         \}\par
6405     \}\par
6406 \par
6407     {\cf17 auto} operator << ( std::ostream& os, StringRef str ) -> std::ostream& \{\par
6408         {\cf19 return} os.write(str.data(), {\cf17 static_cast<}std::streamsize{\cf17 >}(str.size()));\par
6409     \}\par
6410 \par
6411     std::string operator+(StringRef lhs, StringRef rhs) \{\par
6412         std::string ret;\par
6413         ret.reserve(lhs.size() + rhs.size());\par
6414         ret += lhs;\par
6415         ret += rhs;\par
6416         {\cf19 return} ret;\par
6417     \}\par
6418 \par
6419     {\cf17 auto} operator+=( std::string& lhs, StringRef rhs ) -> std::string& \{\par
6420         lhs.append(rhs.data(), rhs.size());\par
6421         {\cf19 return} lhs;\par
6422     \}\par
6423 \par
6424 \} {\cf20 // namespace Catch}\par
6425 \par
6426 \par
6427 \par
6428 {\cf17 namespace }Catch \{\par
6429 \par
6430     TagAliasRegistry::~TagAliasRegistry() = {\cf19 default};\par
6431 \par
6432     TagAlias {\cf17 const}* TagAliasRegistry::find( std::string {\cf17 const}& alias ){\cf17  const }\{\par
6433         {\cf17 auto} it = m_registry.find( alias );\par
6434         {\cf19 if}( it != m_registry.end() )\par
6435             {\cf19 return} &(it->second);\par
6436         {\cf19 else}\par
6437             {\cf19 return} {\cf17 nullptr};\par
6438     \}\par
6439 \par
6440     std::string TagAliasRegistry::expandAliases( std::string {\cf17 const}& unexpandedTestSpec ){\cf17  const }\{\par
6441         std::string expandedTestSpec = unexpandedTestSpec;\par
6442         {\cf19 for}( {\cf17 auto} {\cf17 const}& registryKvp : m_registry ) \{\par
6443             std::size_t pos = expandedTestSpec.find( registryKvp.first );\par
6444             {\cf19 if}( pos != std::string::npos ) \{\par
6445                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +\par
6446                                     registryKvp.second.tag +\par
6447                                     expandedTestSpec.substr( pos + registryKvp.first.size() );\par
6448             \}\par
6449         \}\par
6450         {\cf19 return} expandedTestSpec;\par
6451     \}\par
6452 \par
6453     {\cf18 void} TagAliasRegistry::add( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ) \{\par
6454         CATCH_ENFORCE( startsWith(alias, {\cf22 "[@"}) && endsWith(alias, {\cf23 ']'}),\par
6455                       {\cf22 "error: tag alias, '"} << alias << {\cf22 "' is not of the form [@alias name].\\n"} << lineInfo );\par
6456 \par
6457         CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,\par
6458                       {\cf22 "error: tag alias, '"} << alias << {\cf22 "' already registered.\\n"}\par
6459                       << {\cf22 "\\tFirst seen at: "} << find(alias)->lineInfo << {\cf22 "\\n"}\par
6460                       << {\cf22 "\\tRedefined at: "} << lineInfo );\par
6461     \}\par
6462 \par
6463     ITagAliasRegistry::~ITagAliasRegistry() = {\cf19 default};\par
6464 \par
6465     ITagAliasRegistry {\cf17 const}& ITagAliasRegistry::get() \{\par
6466         {\cf19 return} getRegistryHub().getTagAliasRegistry();\par
6467     \}\par
6468 \par
6469 \} {\cf20 // end namespace Catch}\par
6470 \par
6471 \par
6472 \par
6473 \par
6474 {\cf17 namespace }Catch \{\par
6475     TestCaseInfoHasher::TestCaseInfoHasher( hash_t seed ): m_seed( seed ) \{\}\par
6476 \par
6477     uint32_t TestCaseInfoHasher::operator()( TestCaseInfo {\cf17 const}& t ){\cf17  const }\{\par
6478         {\cf20 // FNV-1a hash algorithm that is designed for uniqueness:}\par
6479         {\cf17 const} hash_t prime = 1099511628211u;\par
6480         hash_t hash = 14695981039346656037u;\par
6481         {\cf19 for} ( {\cf17 const} {\cf18 char} c : t.name ) \{\par
6482             hash ^= c;\par
6483             hash *= prime;\par
6484         \}\par
6485         {\cf19 for} ( {\cf17 const} {\cf18 char} c : t.className ) \{\par
6486             hash ^= c;\par
6487             hash *= prime;\par
6488         \}\par
6489         {\cf19 for} ( {\cf17 const} Tag& tag : t.tags ) \{\par
6490             {\cf19 for} ( {\cf17 const} {\cf18 char} c : tag.original ) \{\par
6491                 hash ^= c;\par
6492                 hash *= prime;\par
6493             \}\par
6494         \}\par
6495         hash ^= m_seed;\par
6496         hash *= prime;\par
6497         {\cf17 const} uint32_t low\{ {\cf17 static_cast<}uint32_t{\cf17 >}( hash ) \};\par
6498         {\cf17 const} uint32_t high\{ {\cf17 static_cast<}uint32_t{\cf17 >}( hash >> 32 ) \};\par
6499         {\cf19 return} low * high;\par
6500     \}\par
6501 \} {\cf20 // namespace Catch}\par
6502 \par
6503 \par
6504 \par
6505 \par
6506 {\cf21 #include <algorithm>}\par
6507 {\cf21 #include <set>}\par
6508 \par
6509 {\cf17 namespace }Catch \{\par
6510 \par
6511     {\cf17 namespace }\{\par
6512         {\cf17 static} {\cf18 void} enforceNoDuplicateTestCases(\par
6513             std::vector<TestCaseHandle> {\cf17 const}& tests ) \{\par
6514             {\cf17 auto} testInfoCmp = []( TestCaseInfo {\cf17 const}* lhs,\par
6515                                    TestCaseInfo {\cf17 const}* rhs ) \{\par
6516                 {\cf19 return} *lhs < *rhs;\par
6517             \};\par
6518             std::set<TestCaseInfo {\cf17 const}*, {\cf17 decltype}( testInfoCmp )&> seenTests(\par
6519                 testInfoCmp );\par
6520             {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : tests ) \{\par
6521                 {\cf17 const} {\cf17 auto} infoPtr = &test.getTestCaseInfo();\par
6522                 {\cf17 const} {\cf17 auto} prev = seenTests.insert( infoPtr );\par
6523                 CATCH_ENFORCE( prev.second,\par
6524                                {\cf22 "error: test case \\""}\par
6525                                    << infoPtr->name << {\cf22 "\\", with tags \\""}\par
6526                                    << infoPtr->tagsAsString()\par
6527                                    << {\cf22 "\\" already defined.\\n"}\par
6528                                    << {\cf22 "\\tFirst seen at "}\par
6529                                    << ( *prev.first )->lineInfo << {\cf22 "\\n"}\par
6530                                    << {\cf22 "\\tRedefined at "} << infoPtr->lineInfo );\par
6531             \}\par
6532         \}\par
6533 \par
6534         {\cf17 static} {\cf18 bool} matchTest( TestCaseHandle {\cf17 const}& testCase,\par
6535                                TestSpec {\cf17 const}& testSpec,\par
6536                                IConfig {\cf17 const}& config ) \{\par
6537             {\cf19 return} testSpec.matches( testCase.getTestCaseInfo() ) &&\par
6538                    isThrowSafe( testCase, config );\par
6539         \}\par
6540 \par
6541     \} {\cf20 // end unnamed namespace}\par
6542 \par
6543     std::vector<TestCaseHandle> sortTests( IConfig {\cf17 const}& config, std::vector<TestCaseHandle> {\cf17 const}& unsortedTestCases ) \{\par
6544         {\cf19 switch} (config.runOrder()) \{\par
6545         {\cf19 case} TestRunOrder::Declared:\par
6546             {\cf19 return} unsortedTestCases;\par
6547 \par
6548         {\cf19 case} TestRunOrder::LexicographicallySorted: \{\par
6549             std::vector<TestCaseHandle> sorted = unsortedTestCases;\par
6550             std::sort(\par
6551                 sorted.begin(),\par
6552                 sorted.end(),\par
6553                 []( TestCaseHandle {\cf17 const}& lhs, TestCaseHandle {\cf17 const}& rhs ) \{\par
6554                     return lhs.getTestCaseInfo() < rhs.getTestCaseInfo();\par
6555                 \}\par
6556             );\par
6557             {\cf19 return} sorted;\par
6558         \}\par
6559         {\cf19 case} TestRunOrder::Randomized: \{\par
6560             {\cf17 using }TestWithHash = std::pair<TestCaseInfoHasher::hash_t, TestCaseHandle>;\par
6561 \par
6562             TestCaseInfoHasher h\{ config.rngSeed() \};\par
6563             std::vector<TestWithHash> indexed_tests;\par
6564             indexed_tests.reserve(unsortedTestCases.size());\par
6565 \par
6566             {\cf19 for} ({\cf17 auto} {\cf17 const}& handle : unsortedTestCases) \{\par
6567                 indexed_tests.emplace_back(h(handle.getTestCaseInfo()), handle);\par
6568             \}\par
6569 \par
6570             std::sort( indexed_tests.begin(),\par
6571                        indexed_tests.end(),\par
6572                        []( TestWithHash {\cf17 const}& lhs, TestWithHash {\cf17 const}& rhs ) \{\par
6573                            if ( lhs.first == rhs.first ) \{\par
6574                                return lhs.second.getTestCaseInfo() <\par
6575                                       rhs.second.getTestCaseInfo();\par
6576                            \}\par
6577                            {\cf19 return} lhs.first < rhs.first;\par
6578                        \} );\par
6579 \par
6580             std::vector<TestCaseHandle> randomized;\par
6581             randomized.reserve(indexed_tests.size());\par
6582 \par
6583             {\cf19 for} ({\cf17 auto} {\cf17 const}& indexed : indexed_tests) \{\par
6584                 randomized.push_back(indexed.second);\par
6585             \}\par
6586 \par
6587             {\cf19 return} randomized;\par
6588         \}\par
6589         \}\par
6590 \par
6591         CATCH_INTERNAL_ERROR({\cf22 "Unknown test order value!"});\par
6592     \}\par
6593 \par
6594     {\cf18 bool} isThrowSafe( TestCaseHandle {\cf17 const}& testCase, IConfig {\cf17 const}& config ) \{\par
6595         {\cf19 return} !testCase.getTestCaseInfo().throws() || config.allowThrows();\par
6596     \}\par
6597 \par
6598     std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> {\cf17 const}& testCases, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config ) \{\par
6599         std::vector<TestCaseHandle> filtered;\par
6600         filtered.reserve( testCases.size() );\par
6601         {\cf19 for} ({\cf17 auto} {\cf17 const}& testCase : testCases) \{\par
6602             {\cf19 if} ((!testSpec.hasFilters() && !testCase.getTestCaseInfo().isHidden()) ||\par
6603                 (testSpec.hasFilters() && matchTest(testCase, testSpec, config))) \{\par
6604                 filtered.push_back(testCase);\par
6605             \}\par
6606         \}\par
6607         {\cf19 return} createShard(filtered, config.shardCount(), config.shardIndex());\par
6608     \}\par
6609     std::vector<TestCaseHandle> {\cf17 const}& getAllTestCasesSorted( IConfig {\cf17 const}& config ) \{\par
6610         {\cf19 return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );\par
6611     \}\par
6612 \par
6613     TestRegistry::~TestRegistry() = {\cf19 default};\par
6614 \par
6615     {\cf18 void} TestRegistry::registerTest(Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker) \{\par
6616         m_handles.emplace_back(testInfo.get(), testInvoker.get());\par
6617         m_viewed_test_infos.push_back(testInfo.get());\par
6618         m_owned_test_infos.push_back(CATCH_MOVE(testInfo));\par
6619         m_invokers.push_back(CATCH_MOVE(testInvoker));\par
6620     \}\par
6621 \par
6622     std::vector<TestCaseInfo*> {\cf17 const}& TestRegistry::getAllInfos(){\cf17  const }\{\par
6623         {\cf19 return} m_viewed_test_infos;\par
6624     \}\par
6625 \par
6626     std::vector<TestCaseHandle> {\cf17 const}& TestRegistry::getAllTests(){\cf17  const }\{\par
6627         {\cf19 return} m_handles;\par
6628     \}\par
6629     std::vector<TestCaseHandle> {\cf17 const}& TestRegistry::getAllTestsSorted( IConfig {\cf17 const}& config ){\cf17  const }\{\par
6630         {\cf19 if}( m_sortedFunctions.empty() )\par
6631             enforceNoDuplicateTestCases( m_handles );\par
6632 \par
6633         {\cf19 if}(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) \{\par
6634             m_sortedFunctions = sortTests( config, m_handles );\par
6635             m_currentSortOrder = config.runOrder();\par
6636         \}\par
6637         {\cf19 return} m_sortedFunctions;\par
6638     \}\par
6639 \par
6640 \} {\cf20 // end namespace Catch}\par
6641 \par
6642 \par
6643 \par
6644 \par
6645 {\cf21 #include <algorithm>}\par
6646 {\cf21 #include <cassert>}\par
6647 \par
6648 {\cf21 #if defined(__clang__)}\par
6649 {\cf21 #    pragma clang diagnostic push}\par
6650 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
6651 {\cf21 #endif}\par
6652 \par
6653 {\cf17 namespace }Catch \{\par
6654 {\cf17 namespace }TestCaseTracking \{\par
6655 \par
6656     NameAndLocation::NameAndLocation( std::string&& _name, SourceLineInfo {\cf17 const}& _location )\par
6657     :   name( CATCH_MOVE(_name) ),\par
6658         location( _location )\par
6659     \{\}\par
6660 \par
6661 \par
6662     ITracker::~ITracker() = {\cf19 default};\par
6663 \par
6664     {\cf18 void} ITracker::markAsNeedingAnotherRun() \{\par
6665         m_runState = NeedsAnotherRun;\par
6666     \}\par
6667 \par
6668     {\cf18 void} ITracker::addChild( ITrackerPtr&& child ) \{\par
6669         m_children.push_back( CATCH_MOVE(child) );\par
6670     \}\par
6671 \par
6672     ITracker* ITracker::findChild( NameAndLocationRef {\cf17 const}& nameAndLocation ) \{\par
6673         {\cf17 auto} it = std::find_if(\par
6674             m_children.begin(),\par
6675             m_children.end(),\par
6676             [&nameAndLocation]( ITrackerPtr {\cf17 const}& tracker ) \{\par
6677                 auto const& tnameAndLoc = tracker->nameAndLocation();\par
6678                 if ( tnameAndLoc.location.line !=\par
6679                      nameAndLocation.location.line ) \{\par
6680                     return false;\par
6681                 \}\par
6682                 {\cf19 return} tnameAndLoc == nameAndLocation;\par
6683             \} );\par
6684         {\cf19 return} ( it != m_children.end() ) ? it->get() : {\cf17 nullptr};\par
6685     \}\par
6686 \par
6687     {\cf18 bool} ITracker::isSectionTracker(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
6688     {\cf18 bool} ITracker::isGeneratorTracker(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
6689 \par
6690     {\cf18 bool} ITracker::isOpen(){\cf17  const }\{\par
6691         {\cf19 return} m_runState != NotStarted && !isComplete();\par
6692     \}\par
6693 \par
6694     {\cf18 bool} ITracker::hasStarted(){\cf17  const }\{ {\cf19 return} m_runState != NotStarted; \}\par
6695 \par
6696     {\cf18 void} ITracker::openChild() \{\par
6697         {\cf19 if} (m_runState != ExecutingChildren) \{\par
6698             m_runState = ExecutingChildren;\par
6699             {\cf19 if} (m_parent) \{\par
6700                 m_parent->openChild();\par
6701             \}\par
6702         \}\par
6703     \}\par
6704 \par
6705     ITracker& TrackerContext::startRun() \{\par
6706         {\cf17 using namespace }std::string_literals;\par
6707         m_rootTracker = Catch::Detail::make_unique<SectionTracker>(\par
6708             NameAndLocation( {\cf22 "\{root\}"}s, CATCH_INTERNAL_LINEINFO ),\par
6709             *{\cf17 this},\par
6710             {\cf17 nullptr} );\par
6711         m_currentTracker = {\cf17 nullptr};\par
6712         m_runState = Executing;\par
6713         {\cf19 return} *m_rootTracker;\par
6714     \}\par
6715 \par
6716     {\cf18 void} TrackerContext::completeCycle() \{\par
6717         m_runState = CompletedCycle;\par
6718     \}\par
6719 \par
6720     {\cf18 bool} TrackerContext::completedCycle(){\cf17  const }\{\par
6721         {\cf19 return} m_runState == CompletedCycle;\par
6722     \}\par
6723     {\cf18 void} TrackerContext::setCurrentTracker( ITracker* tracker ) \{\par
6724         m_currentTracker = tracker;\par
6725     \}\par
6726 \par
6727 \par
6728     TrackerBase::TrackerBase( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent ):\par
6729         ITracker(CATCH_MOVE(nameAndLocation), parent),\par
6730         m_ctx( ctx )\par
6731     \{\}\par
6732 \par
6733     {\cf18 bool} TrackerBase::isComplete(){\cf17  const }\{\par
6734         {\cf19 return} m_runState == CompletedSuccessfully || m_runState == Failed;\par
6735     \}\par
6736 \par
6737     {\cf18 void} TrackerBase::open() \{\par
6738         m_runState = Executing;\par
6739         moveToThis();\par
6740         {\cf19 if}( m_parent )\par
6741             m_parent->openChild();\par
6742     \}\par
6743 \par
6744     {\cf18 void} TrackerBase::close() \{\par
6745 \par
6746         {\cf20 // Close any still open children (e.g. generators)}\par
6747         {\cf19 while}( &m_ctx.currentTracker() != {\cf17 this} )\par
6748             m_ctx.currentTracker().close();\par
6749 \par
6750         {\cf19 switch}( m_runState ) \{\par
6751             {\cf19 case} NeedsAnotherRun:\par
6752                 {\cf19 break};\par
6753 \par
6754             {\cf19 case} Executing:\par
6755                 m_runState = CompletedSuccessfully;\par
6756                 {\cf19 break};\par
6757             {\cf19 case} ExecutingChildren:\par
6758                 {\cf19 if}( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr {\cf17 const}& t)\{ return t->isComplete(); \}) )\par
6759                     m_runState = CompletedSuccessfully;\par
6760                 {\cf19 break};\par
6761 \par
6762             {\cf19 case} NotStarted:\par
6763             {\cf19 case} CompletedSuccessfully:\par
6764             {\cf19 case} Failed:\par
6765                 CATCH_INTERNAL_ERROR( {\cf22 "Illogical state: "} << m_runState );\par
6766 \par
6767             {\cf19 default}:\par
6768                 CATCH_INTERNAL_ERROR( {\cf22 "Unknown state: "} << m_runState );\par
6769         \}\par
6770         moveToParent();\par
6771         m_ctx.completeCycle();\par
6772     \}\par
6773     {\cf18 void} TrackerBase::fail() \{\par
6774         m_runState = Failed;\par
6775         {\cf19 if}( m_parent )\par
6776             m_parent->markAsNeedingAnotherRun();\par
6777         moveToParent();\par
6778         m_ctx.completeCycle();\par
6779     \}\par
6780 \par
6781     {\cf18 void} TrackerBase::moveToParent() \{\par
6782         assert( m_parent );\par
6783         m_ctx.setCurrentTracker( m_parent );\par
6784     \}\par
6785     {\cf18 void} TrackerBase::moveToThis() \{\par
6786         m_ctx.setCurrentTracker( {\cf17 this} );\par
6787     \}\par
6788 \par
6789     SectionTracker::SectionTracker( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent )\par
6790     :   TrackerBase( CATCH_MOVE(nameAndLocation), ctx, parent ),\par
6791         m_trimmed_name(trim(StringRef(ITracker::nameAndLocation().name)))\par
6792     \{\par
6793         {\cf19 if}( parent ) \{\par
6794             {\cf19 while} ( !parent->isSectionTracker() ) \{\par
6795                 parent = parent->parent();\par
6796             \}\par
6797 \par
6798             SectionTracker& parentSection = {\cf17 static_cast<}SectionTracker&{\cf17 >}( *parent );\par
6799             addNextFilters( parentSection.m_filters );\par
6800         \}\par
6801     \}\par
6802 \par
6803     {\cf18 bool} SectionTracker::isComplete(){\cf17  const }\{\par
6804         {\cf18 bool} complete = {\cf17 true};\par
6805 \par
6806         {\cf19 if} (m_filters.empty()\par
6807             || m_filters[0].empty()\par
6808             || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) \{\par
6809             complete = TrackerBase::isComplete();\par
6810         \}\par
6811         {\cf19 return} complete;\par
6812     \}\par
6813 \par
6814     {\cf18 bool} SectionTracker::isSectionTracker(){\cf17  const }\{ {\cf19 return} {\cf17 true}; \}\par
6815 \par
6816     SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocationRef {\cf17 const}& nameAndLocation ) \{\par
6817         SectionTracker* tracker;\par
6818 \par
6819         ITracker& currentTracker = ctx.currentTracker();\par
6820         {\cf19 if} ( ITracker* childTracker =\par
6821                  currentTracker.findChild( nameAndLocation ) ) \{\par
6822             assert( childTracker );\par
6823             assert( childTracker->isSectionTracker() );\par
6824             tracker = {\cf17 static_cast<}SectionTracker*{\cf17 >}( childTracker );\par
6825         \} {\cf19 else} \{\par
6826             {\cf17 auto} newTracker = Catch::Detail::make_unique<SectionTracker>(\par
6827                 NameAndLocation\{ {\cf17 static_cast<}std::string{\cf17 >}(nameAndLocation.name),\par
6828                                  nameAndLocation.location \},\par
6829                 ctx,\par
6830                 &currentTracker );\par
6831             tracker = newTracker.get();\par
6832             currentTracker.addChild( CATCH_MOVE( newTracker ) );\par
6833         \}\par
6834 \par
6835         {\cf19 if} ( !ctx.completedCycle() ) \{\par
6836             tracker->tryOpen();\par
6837         \}\par
6838 \par
6839         {\cf19 return} *tracker;\par
6840     \}\par
6841 \par
6842     {\cf18 void} SectionTracker::tryOpen() \{\par
6843         {\cf19 if}( !isComplete() )\par
6844             open();\par
6845     \}\par
6846 \par
6847     {\cf18 void} SectionTracker::addInitialFilters( std::vector<std::string> {\cf17 const}& filters ) \{\par
6848         {\cf19 if}( !filters.empty() ) \{\par
6849             m_filters.reserve( m_filters.size() + filters.size() + 2 );\par
6850             m_filters.emplace_back(StringRef\{\}); {\cf20 // Root - should never be consulted}\par
6851             m_filters.emplace_back(StringRef\{\}); {\cf20 // Test Case - not a section filter}\par
6852             m_filters.insert( m_filters.end(), filters.begin(), filters.end() );\par
6853         \}\par
6854     \}\par
6855     {\cf18 void} SectionTracker::addNextFilters( std::vector<StringRef> {\cf17 const}& filters ) \{\par
6856         {\cf19 if}( filters.size() > 1 )\par
6857             m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );\par
6858     \}\par
6859 \par
6860     StringRef SectionTracker::trimmedName(){\cf17  const }\{\par
6861         {\cf19 return} m_trimmed_name;\par
6862     \}\par
6863 \par
6864 \} {\cf20 // namespace TestCaseTracking}\par
6865 \par
6866 \} {\cf20 // namespace Catch}\par
6867 \par
6868 {\cf21 #if defined(__clang__)}\par
6869 {\cf21 #    pragma clang diagnostic pop}\par
6870 {\cf21 #endif}\par
6871 \par
6872 \par
6873 \par
6874 \par
6875 {\cf17 namespace }Catch \{\par
6876 \par
6877     {\cf18 void} throw_test_failure_exception() \{\par
6878 {\cf21 #if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )}\par
6879         {\cf19 throw} TestFailureException\{\};\par
6880 {\cf21 #else}\par
6881         CATCH_ERROR( {\cf22 "Test failure requires aborting test!"} );\par
6882 {\cf21 #endif}\par
6883     \}\par
6884 \par
6885     {\cf18 void} throw_test_skip_exception() \{\par
6886 {\cf21 #if !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS )}\par
6887         {\cf19 throw} Catch::TestSkipException();\par
6888 {\cf21 #else}\par
6889         CATCH_ERROR( {\cf22 "Explicitly skipping tests during runtime requires exceptions"} );\par
6890 {\cf21 #endif}\par
6891     \}\par
6892 \par
6893 \} {\cf20 // namespace Catch}\par
6894 \par
6895 \par
6896 \par
6897 {\cf21 #include <algorithm>}\par
6898 {\cf21 #include <iterator>}\par
6899 \par
6900 {\cf17 namespace }Catch \{\par
6901     ITestInvoker::~ITestInvoker() = {\cf19 default};\par
6902 \par
6903     {\cf17 namespace }\{\par
6904         {\cf17 static} StringRef extractClassName( StringRef classOrMethodName ) \{\par
6905             {\cf19 if} ( !startsWith( classOrMethodName, {\cf23 '&'} ) ) \{\par
6906                 {\cf19 return} classOrMethodName;\par
6907             \}\par
6908 \par
6909             {\cf20 // Remove the leading '&' to avoid having to special case it later}\par
6910             {\cf17 const} {\cf17 auto} methodName =\par
6911                 classOrMethodName.substr( 1, classOrMethodName.size() );\par
6912 \par
6913             {\cf17 auto} reverseStart = std::make_reverse_iterator( methodName.end() );\par
6914             {\cf17 auto} reverseEnd = std::make_reverse_iterator( methodName.begin() );\par
6915 \par
6916             {\cf20 // We make a simplifying assumption that ":" is only present}\par
6917             {\cf20 // in the input as part of "::" from C++ typenames (this is}\par
6918             {\cf20 // relatively safe assumption because the input is generated}\par
6919             {\cf20 // as stringification of type through preprocessor).}\par
6920             {\cf17 auto} lastColons = std::find( reverseStart, reverseEnd, {\cf23 ':'} ) + 1;\par
6921             {\cf17 auto} secondLastColons =\par
6922                 std::find( lastColons + 1, reverseEnd, {\cf23 ':'} );\par
6923 \par
6924             {\cf17 auto} {\cf17 const} startIdx = reverseEnd - secondLastColons;\par
6925             {\cf17 auto} {\cf17 const} classNameSize = secondLastColons - lastColons - 1;\par
6926 \par
6927             {\cf19 return} methodName.substr(\par
6928                 {\cf17 static_cast<}std::size_t{\cf17 >}( startIdx ),\par
6929                 {\cf17 static_cast<}std::size_t{\cf17 >}( classNameSize ) );\par
6930         \}\par
6931 \par
6932         {\cf17 class }TestInvokerAsFunction final : {\cf17 public} ITestInvoker \{\par
6933             {\cf17 using }TestType = void ( * )();\par
6934             TestType m_testAsFunction;\par
6935 \par
6936         {\cf17 public}:\par
6937             TestInvokerAsFunction( TestType testAsFunction ) {\cf17 noexcept}:\par
6938                 m_testAsFunction( testAsFunction ) \{\}\par
6939 \par
6940             {\cf18 void} invoke(){\cf17  const override }\{ m_testAsFunction(); \}\par
6941         \};\par
6942 \par
6943     \} {\cf20 // namespace}\par
6944 \par
6945     Detail::unique_ptr<ITestInvoker> makeTestInvoker( {\cf18 void}(*testAsFunction)() ) \{\par
6946         {\cf19 return} Detail::make_unique<TestInvokerAsFunction>( testAsFunction );\par
6947     \}\par
6948 \par
6949     AutoReg::AutoReg( Detail::unique_ptr<ITestInvoker> invoker, SourceLineInfo {\cf17 const}& lineInfo, StringRef classOrMethod, NameAndTags {\cf17 const}& nameAndTags ) {\cf17 noexcept} \{\par
6950         CATCH_TRY \{\par
6951             getMutableRegistryHub()\par
6952                     .registerTest(\par
6953                         makeTestCaseInfo(\par
6954                             extractClassName( classOrMethod ),\par
6955                             nameAndTags,\par
6956                             lineInfo),\par
6957                         CATCH_MOVE(invoker)\par
6958                     );\par
6959         \} CATCH_CATCH_ALL \{\par
6960             {\cf20 // Do not throw when constructing global objects, instead register the exception to be processed later}\par
6961             getMutableRegistryHub().registerStartupException();\par
6962         \}\par
6963     \}\par
6964 \}\par
6965 \par
6966 \par
6967 \par
6968 \par
6969 \par
6970 {\cf17 namespace }Catch \{\par
6971 \par
6972     TestSpecParser::TestSpecParser( ITagAliasRegistry {\cf17 const}& tagAliases ) : m_tagAliases( &tagAliases ) \{\}\par
6973 \par
6974     TestSpecParser& TestSpecParser::parse( std::string {\cf17 const}& arg ) \{\par
6975         m_mode = None;\par
6976         m_exclusion = {\cf17 false};\par
6977         m_arg = m_tagAliases->expandAliases( arg );\par
6978         m_escapeChars.clear();\par
6979         m_substring.reserve(m_arg.size());\par
6980         m_patternName.reserve(m_arg.size());\par
6981         m_realPatternPos = 0;\par
6982 \par
6983         {\cf19 for}( m_pos = 0; m_pos < m_arg.size(); ++m_pos )\par
6984           {\cf20 //if visitChar fails}\par
6985            {\cf19 if}( !visitChar( m_arg[m_pos] ) )\{\par
6986                m_testSpec.m_invalidSpecs.push_back(arg);\par
6987                {\cf19 break};\par
6988            \}\par
6989         endMode();\par
6990         {\cf19 return} *{\cf17 this};\par
6991     \}\par
6992     TestSpec TestSpecParser::testSpec() \{\par
6993         addFilter();\par
6994         {\cf19 return} CATCH_MOVE(m_testSpec);\par
6995     \}\par
6996     {\cf18 bool} TestSpecParser::visitChar( {\cf18 char} c ) \{\par
6997         {\cf19 if}( (m_mode != EscapedName) && (c == {\cf23 '\\\\'}) ) \{\par
6998             escape();\par
6999             addCharToPattern(c);\par
7000             {\cf19 return} {\cf17 true};\par
7001         \}{\cf19 else} {\cf19 if}((m_mode != EscapedName) && (c == {\cf23 ','}) )  \{\par
7002             {\cf19 return} separate();\par
7003         \}\par
7004 \par
7005         {\cf19 switch}( m_mode ) \{\par
7006         {\cf19 case} None:\par
7007             {\cf19 if}( processNoneChar( c ) )\par
7008                 {\cf19 return} {\cf17 true};\par
7009             {\cf19 break};\par
7010         {\cf19 case} Name:\par
7011             processNameChar( c );\par
7012             {\cf19 break};\par
7013         {\cf19 case} EscapedName:\par
7014             endMode();\par
7015             addCharToPattern(c);\par
7016             {\cf19 return} {\cf17 true};\par
7017         {\cf19 default}:\par
7018         {\cf19 case} Tag:\par
7019         {\cf19 case} QuotedName:\par
7020             {\cf19 if}( processOtherChar( c ) )\par
7021                 {\cf19 return} {\cf17 true};\par
7022             {\cf19 break};\par
7023         \}\par
7024 \par
7025         m_substring += c;\par
7026         {\cf19 if}( !isControlChar( c ) ) \{\par
7027             m_patternName += c;\par
7028             m_realPatternPos++;\par
7029         \}\par
7030         {\cf19 return} {\cf17 true};\par
7031     \}\par
7032     {\cf20 // Two of the processing methods return true to signal the caller to return}\par
7033     {\cf20 // without adding the given character to the current pattern strings}\par
7034     {\cf18 bool} TestSpecParser::processNoneChar( {\cf18 char} c ) \{\par
7035         {\cf19 switch}( c ) \{\par
7036         {\cf19 case} {\cf23 ' '}:\par
7037             {\cf19 return} {\cf17 true};\par
7038         {\cf19 case} {\cf23 '~'}:\par
7039             m_exclusion = {\cf17 true};\par
7040             {\cf19 return} {\cf17 false};\par
7041         {\cf19 case} {\cf23 '['}:\par
7042             startNewMode( Tag );\par
7043             {\cf19 return} {\cf17 false};\par
7044         {\cf19 case} {\cf23 '"'}:\par
7045             startNewMode( QuotedName );\par
7046             {\cf19 return} {\cf17 false};\par
7047         {\cf19 default}:\par
7048             startNewMode( Name );\par
7049             {\cf19 return} {\cf17 false};\par
7050         \}\par
7051     \}\par
7052     {\cf18 void} TestSpecParser::processNameChar( {\cf18 char} c ) \{\par
7053         {\cf19 if}( c == {\cf23 '['} ) \{\par
7054             {\cf19 if}( m_substring == {\cf22 "exclude:"} )\par
7055                 m_exclusion = {\cf17 true};\par
7056             {\cf19 else}\par
7057                 endMode();\par
7058             startNewMode( Tag );\par
7059         \}\par
7060     \}\par
7061     {\cf18 bool} TestSpecParser::processOtherChar( {\cf18 char} c ) \{\par
7062         {\cf19 if}( !isControlChar( c ) )\par
7063             {\cf19 return} {\cf17 false};\par
7064         m_substring += c;\par
7065         endMode();\par
7066         {\cf19 return} {\cf17 true};\par
7067     \}\par
7068     {\cf18 void} TestSpecParser::startNewMode( Mode mode ) \{\par
7069         m_mode = mode;\par
7070     \}\par
7071     {\cf18 void} TestSpecParser::endMode() \{\par
7072         {\cf19 switch}( m_mode ) \{\par
7073         {\cf19 case} Name:\par
7074         {\cf19 case} QuotedName:\par
7075             {\cf19 return} addNamePattern();\par
7076         {\cf19 case} Tag:\par
7077             {\cf19 return} addTagPattern();\par
7078         {\cf19 case} EscapedName:\par
7079             revertBackToLastMode();\par
7080             {\cf19 return};\par
7081         {\cf19 case} None:\par
7082         {\cf19 default}:\par
7083             {\cf19 return} startNewMode( None );\par
7084         \}\par
7085     \}\par
7086     {\cf18 void} TestSpecParser::escape() \{\par
7087         saveLastMode();\par
7088         m_mode = EscapedName;\par
7089         m_escapeChars.push_back(m_realPatternPos);\par
7090     \}\par
7091     {\cf18 bool} TestSpecParser::isControlChar( {\cf18 char} c ){\cf17  const }\{\par
7092         {\cf19 switch}( m_mode ) \{\par
7093             {\cf19 default}:\par
7094                 {\cf19 return} {\cf17 false};\par
7095             {\cf19 case} None:\par
7096                 {\cf19 return} c == {\cf23 '~'};\par
7097             {\cf19 case} Name:\par
7098                 {\cf19 return} c == {\cf23 '['};\par
7099             {\cf19 case} EscapedName:\par
7100                 {\cf19 return} {\cf17 true};\par
7101             {\cf19 case} QuotedName:\par
7102                 {\cf19 return} c == {\cf23 '"'};\par
7103             {\cf19 case} Tag:\par
7104                 {\cf19 return} c == {\cf23 '['} || c == {\cf23 ']'};\par
7105         \}\par
7106     \}\par
7107 \par
7108     {\cf18 void} TestSpecParser::addFilter() \{\par
7109         {\cf19 if}( !m_currentFilter.m_required.empty() || !m_currentFilter.m_forbidden.empty() ) \{\par
7110             m_testSpec.m_filters.push_back( CATCH_MOVE(m_currentFilter) );\par
7111             m_currentFilter = TestSpec::Filter();\par
7112         \}\par
7113     \}\par
7114 \par
7115     {\cf18 void} TestSpecParser::saveLastMode() \{\par
7116       lastMode = m_mode;\par
7117     \}\par
7118 \par
7119     {\cf18 void} TestSpecParser::revertBackToLastMode() \{\par
7120       m_mode = lastMode;\par
7121     \}\par
7122 \par
7123     {\cf18 bool} TestSpecParser::separate() \{\par
7124       {\cf19 if}( (m_mode==QuotedName) || (m_mode==Tag) )\{\par
7125          {\cf20 //invalid argument, signal failure to previous scope.}\par
7126          m_mode = None;\par
7127          m_pos = m_arg.size();\par
7128          m_substring.clear();\par
7129          m_patternName.clear();\par
7130          m_realPatternPos = 0;\par
7131          {\cf19 return} {\cf17 false};\par
7132       \}\par
7133       endMode();\par
7134       addFilter();\par
7135       {\cf19 return} {\cf17 true}; {\cf20 //success}\par
7136     \}\par
7137 \par
7138     std::string TestSpecParser::preprocessPattern() \{\par
7139         std::string token = m_patternName;\par
7140         {\cf19 for} (std::size_t i = 0; i < m_escapeChars.size(); ++i)\par
7141             token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);\par
7142         m_escapeChars.clear();\par
7143         {\cf19 if} (startsWith(token, {\cf22 "exclude:"})) \{\par
7144             m_exclusion = {\cf17 true};\par
7145             token = token.substr(8);\par
7146         \}\par
7147 \par
7148         m_patternName.clear();\par
7149         m_realPatternPos = 0;\par
7150 \par
7151         {\cf19 return} token;\par
7152     \}\par
7153 \par
7154     {\cf18 void} TestSpecParser::addNamePattern() \{\par
7155         {\cf17 auto} token = preprocessPattern();\par
7156 \par
7157         {\cf19 if} (!token.empty()) \{\par
7158             {\cf19 if} (m_exclusion) \{\par
7159                 m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::NamePattern>(token, m_substring));\par
7160             \} {\cf19 else} \{\par
7161                 m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::NamePattern>(token, m_substring));\par
7162             \}\par
7163         \}\par
7164         m_substring.clear();\par
7165         m_exclusion = {\cf17 false};\par
7166         m_mode = None;\par
7167     \}\par
7168 \par
7169     {\cf18 void} TestSpecParser::addTagPattern() \{\par
7170         {\cf17 auto} token = preprocessPattern();\par
7171 \par
7172         {\cf19 if} (!token.empty()) \{\par
7173             {\cf20 // If the tag pattern is the "hide and tag" shorthand (e.g. [.foo])}\par
7174             {\cf20 // we have to create a separate hide tag and shorten the real one}\par
7175             {\cf19 if} (token.size() > 1 && token[0] == {\cf23 '.'}) \{\par
7176                 token.erase(token.begin());\par
7177                 {\cf19 if} (m_exclusion) \{\par
7178                     m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::TagPattern>({\cf22 "."}, m_substring));\par
7179                 \} {\cf19 else} \{\par
7180                     m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::TagPattern>({\cf22 "."}, m_substring));\par
7181                 \}\par
7182             \}\par
7183             {\cf19 if} (m_exclusion) \{\par
7184                 m_currentFilter.m_forbidden.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));\par
7185             \} {\cf19 else} \{\par
7186                 m_currentFilter.m_required.emplace_back(Detail::make_unique<TestSpec::TagPattern>(token, m_substring));\par
7187             \}\par
7188         \}\par
7189         m_substring.clear();\par
7190         m_exclusion = {\cf17 false};\par
7191         m_mode = None;\par
7192     \}\par
7193 \par
7194 \} {\cf20 // namespace Catch}\par
7195 \par
7196 \par
7197 \par
7198 {\cf21 #include <algorithm>}\par
7199 {\cf21 #include <cstring>}\par
7200 {\cf21 #include <ostream>}\par
7201 \par
7202 {\cf17 namespace }\{\par
7203     {\cf18 bool} isWhitespace( {\cf18 char} c ) \{\par
7204         {\cf19 return} c == {\cf23 ' '} || c == {\cf23 '\\t'} || c == {\cf23 '\\n'} || c == {\cf23 '\\r'};\par
7205     \}\par
7206 \par
7207     {\cf18 bool} isBreakableBefore( {\cf18 char} c ) \{\par
7208         {\cf17 static} {\cf17 const} {\cf18 char} chars[] = {\cf22 "[(\{<|"};\par
7209         {\cf19 return} std::memchr( chars, c, {\cf17 sizeof}( chars ) - 1 ) != {\cf17 nullptr};\par
7210     \}\par
7211 \par
7212     {\cf18 bool} isBreakableAfter( {\cf18 char} c ) \{\par
7213         {\cf17 static} {\cf17 const} {\cf18 char} chars[] = {\cf22 "])\}>.,:;*+-=&/\\\\"};\par
7214         {\cf19 return} std::memchr( chars, c, {\cf17 sizeof}( chars ) - 1 ) != {\cf17 nullptr};\par
7215     \}\par
7216 \par
7217 \} {\cf20 // namespace}\par
7218 \par
7219 {\cf17 namespace }Catch \{\par
7220     {\cf17 namespace }TextFlow \{\par
7221         {\cf18 void} AnsiSkippingString::preprocessString() \{\par
7222             {\cf19 for} ( {\cf17 auto} it = m_string.begin(); it != m_string.end(); ) \{\par
7223                 {\cf20 // try to read through an ansi sequence}\par
7224                 {\cf19 while} ( it != m_string.end() && *it == {\cf23 '\\033'} &&\par
7225                         it + 1 != m_string.end() && *( it + 1 ) == {\cf23 '['} ) \{\par
7226                     {\cf17 auto} cursor = it + 2;\par
7227                     {\cf19 while} ( cursor != m_string.end() &&\par
7228                             ( isdigit( *cursor ) || *cursor == {\cf23 ';'} ) ) \{\par
7229                         ++cursor;\par
7230                     \}\par
7231                     {\cf19 if} ( cursor == m_string.end() || *cursor != {\cf23 'm'} ) \{\par
7232                         {\cf19 break};\par
7233                     \}\par
7234                     {\cf20 // 'm' -> 0xff}\par
7235                     *cursor = AnsiSkippingString::sentinel;\par
7236                     {\cf20 // if we've read an ansi sequence, set the iterator and}\par
7237                     {\cf20 // return to the top of the loop}\par
7238                     it = cursor + 1;\par
7239                 \}\par
7240                 {\cf19 if} ( it != m_string.end() ) \{\par
7241                     ++m_size;\par
7242                     ++it;\par
7243                 \}\par
7244             \}\par
7245         \}\par
7246 \par
7247         AnsiSkippingString::AnsiSkippingString( std::string {\cf17 const}& text ):\par
7248             m_string( text ) \{\par
7249             preprocessString();\par
7250         \}\par
7251 \par
7252         AnsiSkippingString::AnsiSkippingString( std::string&& text ):\par
7253             m_string( CATCH_MOVE( text ) ) \{\par
7254             preprocessString();\par
7255         \}\par
7256 \par
7257         AnsiSkippingString::const_iterator AnsiSkippingString::begin(){\cf17  const }\{\par
7258             {\cf19 return} const_iterator( m_string );\par
7259         \}\par
7260 \par
7261         AnsiSkippingString::const_iterator AnsiSkippingString::end(){\cf17  const }\{\par
7262             {\cf19 return} const_iterator( m_string, const_iterator::EndTag\{\} );\par
7263         \}\par
7264 \par
7265         std::string AnsiSkippingString::substring( const_iterator begin,\par
7266                                                    const_iterator end ){\cf17  const }\{\par
7267             {\cf20 // There's one caveat here to an otherwise simple substring: when}\par
7268             {\cf20 // making a begin iterator we might have skipped ansi sequences at}\par
7269             {\cf20 // the start. If `begin` here is a begin iterator, skipped over}\par
7270             {\cf20 // initial ansi sequences, we'll use the true beginning of the}\par
7271             {\cf20 // string. Lastly: We need to transform any chars we replaced with}\par
7272             {\cf20 // 0xff back to 'm'}\par
7273             {\cf17 auto} str = std::string( begin == this->begin() ? m_string.begin()\par
7274                                                            : begin.m_it,\par
7275                                     end.m_it );\par
7276             std::transform( str.begin(), str.end(), str.begin(), []( {\cf18 char} c ) \{\par
7277                 return c == AnsiSkippingString::sentinel ? {\cf22 'm'} : c;\par
7278             \} );\par
7279             {\cf19 return} str;\par
7280         \}\par
7281 \par
7282         {\cf18 void} AnsiSkippingString::const_iterator::tryParseAnsiEscapes() \{\par
7283             {\cf20 // check if we've landed on an ansi sequence, and if so read through}\par
7284             {\cf20 // it}\par
7285             {\cf19 while} ( m_it != m_string->end() && *m_it == {\cf23 '\\033'} &&\par
7286                     m_it + 1 != m_string->end() &&  *( m_it + 1 ) == {\cf23 '['} ) \{\par
7287                 {\cf17 auto} cursor = m_it + 2;\par
7288                 {\cf19 while} ( cursor != m_string->end() &&\par
7289                         ( isdigit( *cursor ) || *cursor == {\cf23 ';'} ) ) \{\par
7290                     ++cursor;\par
7291                 \}\par
7292                 {\cf19 if} ( cursor == m_string->end() ||\par
7293                      *cursor != AnsiSkippingString::sentinel ) \{\par
7294                     {\cf19 break};\par
7295                 \}\par
7296                 {\cf20 // if we've read an ansi sequence, set the iterator and}\par
7297                 {\cf20 // return to the top of the loop}\par
7298                 m_it = cursor + 1;\par
7299             \}\par
7300         \}\par
7301 \par
7302         {\cf18 void} AnsiSkippingString::const_iterator::advance() \{\par
7303             assert( m_it != m_string->end() );\par
7304             m_it++;\par
7305             tryParseAnsiEscapes();\par
7306         \}\par
7307 \par
7308         {\cf18 void} AnsiSkippingString::const_iterator::unadvance() \{\par
7309             assert( m_it != m_string->begin() );\par
7310             m_it--;\par
7311             {\cf20 // if *m_it is 0xff, scan back to the \\033 and then m_it-- once more}\par
7312             {\cf20 // (and repeat check)}\par
7313             {\cf19 while} ( *m_it == AnsiSkippingString::sentinel ) \{\par
7314                 {\cf19 while} ( *m_it != {\cf23 '\\033'} ) \{\par
7315                     assert( m_it != m_string->begin() );\par
7316                     m_it--;\par
7317                 \}\par
7318                 {\cf20 // if this happens, we must have been a begin iterator that had}\par
7319                 {\cf20 // skipped over ansi sequences at the start of a string}\par
7320                 assert( m_it != m_string->begin() );\par
7321                 assert( *m_it == {\cf23 '\\033'} );\par
7322                 m_it--;\par
7323             \}\par
7324         \}\par
7325 \par
7326         {\cf17 static} {\cf18 bool} isBoundary( AnsiSkippingString {\cf17 const}& line,\par
7327                                 AnsiSkippingString::const_iterator it ) \{\par
7328             {\cf19 return} it == line.end() ||\par
7329                    ( isWhitespace( *it ) &&\par
7330                      !isWhitespace( *it.oneBefore() ) ) ||\par
7331                    isBreakableBefore( *it ) ||\par
7332                    isBreakableAfter( *it.oneBefore() );\par
7333         \}\par
7334 \par
7335         {\cf18 void} Column::const_iterator::calcLength() \{\par
7336             m_addHyphen = {\cf17 false};\par
7337             m_parsedTo = m_lineStart;\par
7338             AnsiSkippingString {\cf17 const}& current_line = m_column.m_string;\par
7339 \par
7340             {\cf19 if} ( m_parsedTo == current_line.end() ) \{\par
7341                 m_lineEnd = m_parsedTo;\par
7342                 {\cf19 return};\par
7343             \}\par
7344 \par
7345             assert( m_lineStart != current_line.end() );\par
7346             {\cf19 if} ( *m_lineStart == {\cf23 '\\n'} ) \{ ++m_parsedTo; \}\par
7347 \par
7348             {\cf17 const} {\cf17 auto} maxLineLength = m_column.m_width - indentSize();\par
7349             std::size_t lineLength = 0;\par
7350             {\cf19 while} ( m_parsedTo != current_line.end() &&\par
7351                     lineLength < maxLineLength && *m_parsedTo != {\cf23 '\\n'} ) \{\par
7352                 ++m_parsedTo;\par
7353                 ++lineLength;\par
7354             \}\par
7355 \par
7356             {\cf20 // If we encountered a newline before the column is filled,}\par
7357             {\cf20 // then we linebreak at the newline and consider this line}\par
7358             {\cf20 // finished.}\par
7359             {\cf19 if} ( lineLength < maxLineLength ) \{\par
7360                 m_lineEnd = m_parsedTo;\par
7361             \} {\cf19 else} \{\par
7362                 {\cf20 // Look for a natural linebreak boundary in the column}\par
7363                 {\cf20 // (We look from the end, so that the first found boundary is}\par
7364                 {\cf20 // the right one)}\par
7365                 m_lineEnd = m_parsedTo;\par
7366                 {\cf19 while} ( lineLength > 0 &&\par
7367                         !isBoundary( current_line, m_lineEnd ) ) \{\par
7368                     --lineLength;\par
7369                     --m_lineEnd;\par
7370                 \}\par
7371                 {\cf19 while} ( lineLength > 0 &&\par
7372                         isWhitespace( *m_lineEnd.oneBefore() ) ) \{\par
7373                     --lineLength;\par
7374                     --m_lineEnd;\par
7375                 \}\par
7376 \par
7377                 {\cf20 // If we found one, then that is where we linebreak, otherwise}\par
7378                 {\cf20 // we have to split text with a hyphen}\par
7379                 {\cf19 if} ( lineLength == 0 ) \{\par
7380                     m_addHyphen = {\cf17 true};\par
7381                     m_lineEnd = m_parsedTo.oneBefore();\par
7382                 \}\par
7383             \}\par
7384         \}\par
7385 \par
7386         {\cf18 size_t} Column::const_iterator::indentSize(){\cf17  const }\{\par
7387             {\cf17 auto} initial = m_lineStart == m_column.m_string.begin()\par
7388                                ? m_column.m_initialIndent\par
7389                                : std::string::npos;\par
7390             {\cf19 return} initial == std::string::npos ? m_column.m_indent : initial;\par
7391         \}\par
7392 \par
7393         std::string Column::const_iterator::addIndentAndSuffix(\par
7394             AnsiSkippingString::const_iterator start,\par
7395             AnsiSkippingString::const_iterator end ){\cf17  const }\{\par
7396             std::string ret;\par
7397             {\cf17 const} {\cf17 auto} desired_indent = indentSize();\par
7398             {\cf20 // ret.reserve( desired_indent + (end - start) + m_addHyphen );}\par
7399             ret.append( desired_indent, {\cf23 ' '} );\par
7400             {\cf20 // ret.append( start, end );}\par
7401             ret += m_column.m_string.substring( start, end );\par
7402             {\cf19 if} ( m_addHyphen ) \{ ret.push_back( {\cf23 '-'} ); \}\par
7403 \par
7404             {\cf19 return} ret;\par
7405         \}\par
7406 \par
7407         Column::const_iterator::const_iterator( Column {\cf17 const}& column ):\par
7408             m_column( column ),\par
7409             m_lineStart( column.m_string.begin() ),\par
7410             m_lineEnd( column.m_string.begin() ),\par
7411             m_parsedTo( column.m_string.begin() ) \{\par
7412             assert( m_column.m_width > m_column.m_indent );\par
7413             assert( m_column.m_initialIndent == std::string::npos ||\par
7414                     m_column.m_width > m_column.m_initialIndent );\par
7415             calcLength();\par
7416             {\cf19 if} ( m_lineStart == m_lineEnd ) \{\par
7417                 m_lineStart = m_column.m_string.end();\par
7418             \}\par
7419         \}\par
7420 \par
7421         std::string Column::const_iterator::operator*(){\cf17  const }\{\par
7422             assert( m_lineStart <= m_parsedTo );\par
7423             {\cf19 return} addIndentAndSuffix( m_lineStart, m_lineEnd );\par
7424         \}\par
7425 \par
7426         Column::const_iterator& Column::const_iterator::operator++() \{\par
7427             m_lineStart = m_lineEnd;\par
7428             AnsiSkippingString {\cf17 const}& current_line = m_column.m_string;\par
7429             {\cf19 if} ( m_lineStart != current_line.end() && *m_lineStart == {\cf23 '\\n'} ) \{\par
7430                 m_lineStart++;\par
7431             \} {\cf19 else} \{\par
7432                 {\cf19 while} ( m_lineStart != current_line.end() &&\par
7433                         isWhitespace( *m_lineStart ) ) \{\par
7434                     ++m_lineStart;\par
7435                 \}\par
7436             \}\par
7437 \par
7438             {\cf19 if} ( m_lineStart != current_line.end() ) \{ calcLength(); \}\par
7439             {\cf19 return} *{\cf17 this};\par
7440         \}\par
7441 \par
7442         Column::const_iterator Column::const_iterator::operator++( {\cf18 int} ) \{\par
7443             const_iterator prev( *{\cf17 this} );\par
7444             operator++();\par
7445             {\cf19 return} prev;\par
7446         \}\par
7447 \par
7448         std::ostream& operator<<( std::ostream& os, Column {\cf17 const}& col ) \{\par
7449             {\cf18 bool} first = {\cf17 true};\par
7450             {\cf19 for} ( {\cf17 auto} line : col ) \{\par
7451                 {\cf19 if} ( first ) \{\par
7452                     first = {\cf17 false};\par
7453                 \} {\cf19 else} \{\par
7454                     os << {\cf23 '\\n'};\par
7455                 \}\par
7456                 os << line;\par
7457             \}\par
7458             {\cf19 return} os;\par
7459         \}\par
7460 \par
7461         Column Spacer( {\cf18 size_t} spaceWidth ) \{\par
7462             Column ret\{ {\cf22 ""} \};\par
7463             ret.width( spaceWidth );\par
7464             {\cf19 return} ret;\par
7465         \}\par
7466 \par
7467         Columns::iterator::iterator( Columns {\cf17 const}& columns, EndTag ):\par
7468             m_columns( columns.m_columns ), m_activeIterators( 0 ) \{\par
7469 \par
7470             m_iterators.reserve( m_columns.size() );\par
7471             for ( {\cf17 auto} {\cf17 const}& col : m_columns ) \{\par
7472                 m_iterators.push_back( col.end() );\par
7473             \}\par
7474         \}\par
7475 \par
7476         Columns::iterator::iterator( Columns {\cf17 const}& columns ):\par
7477             m_columns( columns.m_columns ),\par
7478             m_activeIterators( m_columns.size() ) \{\par
7479 \par
7480             m_iterators.reserve( m_columns.size() );\par
7481             for ( {\cf17 auto} {\cf17 const}& col : m_columns ) \{\par
7482                 m_iterators.push_back( col.begin() );\par
7483             \}\par
7484         \}\par
7485 \par
7486         std::string Columns::iterator::operator*(){\cf17  const }\{\par
7487             std::string row, padding;\par
7488 \par
7489             {\cf19 for} ( {\cf18 size_t} i = 0; i < m_columns.size(); ++i ) \{\par
7490                 {\cf17 const} {\cf17 auto} width = m_columns[i].width();\par
7491                 {\cf19 if} ( m_iterators[i] != m_columns[i].end() ) \{\par
7492                     std::string col = *m_iterators[i];\par
7493                     row += padding;\par
7494                     row += col;\par
7495 \par
7496                     padding.clear();\par
7497                     {\cf19 if} ( col.size() < width ) \{\par
7498                         padding.append( width - col.size(), {\cf23 ' '} );\par
7499                     \}\par
7500                 \} {\cf19 else} \{\par
7501                     padding.append( width, {\cf23 ' '} );\par
7502                 \}\par
7503             \}\par
7504             {\cf19 return} row;\par
7505         \}\par
7506 \par
7507         Columns::iterator& Columns::iterator::operator++() \{\par
7508             {\cf19 for} ( {\cf18 size_t} i = 0; i < m_columns.size(); ++i ) \{\par
7509                 {\cf19 if} ( m_iterators[i] != m_columns[i].end() ) \{\par
7510                     ++m_iterators[i];\par
7511                 \}\par
7512             \}\par
7513             {\cf19 return} *{\cf17 this};\par
7514         \}\par
7515 \par
7516         Columns::iterator Columns::iterator::operator++( {\cf18 int} ) \{\par
7517             iterator prev( *{\cf17 this} );\par
7518             operator++();\par
7519             {\cf19 return} prev;\par
7520         \}\par
7521 \par
7522         std::ostream& operator<<( std::ostream& os, Columns {\cf17 const}& cols ) \{\par
7523             {\cf18 bool} first = {\cf17 true};\par
7524             {\cf19 for} ( {\cf17 auto} line : cols ) \{\par
7525                 {\cf19 if} ( first ) \{\par
7526                     first = {\cf17 false};\par
7527                 \} {\cf19 else} \{\par
7528                     os << {\cf23 '\\n'};\par
7529                 \}\par
7530                 os << line;\par
7531             \}\par
7532             {\cf19 return} os;\par
7533         \}\par
7534 \par
7535         Columns operator+( Column {\cf17 const}& lhs, Column {\cf17 const}& rhs ) \{\par
7536             Columns cols;\par
7537             cols += lhs;\par
7538             cols += rhs;\par
7539             {\cf19 return} cols;\par
7540         \}\par
7541         Columns operator+( Column&& lhs, Column&& rhs ) \{\par
7542             Columns cols;\par
7543             cols += CATCH_MOVE( lhs );\par
7544             cols += CATCH_MOVE( rhs );\par
7545             {\cf19 return} cols;\par
7546         \}\par
7547 \par
7548         Columns& operator+=( Columns& lhs, Column {\cf17 const}& rhs ) \{\par
7549             lhs.m_columns.push_back( rhs );\par
7550             {\cf19 return} lhs;\par
7551         \}\par
7552         Columns& operator+=( Columns& lhs, Column&& rhs ) \{\par
7553             lhs.m_columns.push_back( CATCH_MOVE( rhs ) );\par
7554             {\cf19 return} lhs;\par
7555         \}\par
7556         Columns operator+( Columns {\cf17 const}& lhs, Column {\cf17 const}& rhs ) \{\par
7557             {\cf17 auto} combined( lhs );\par
7558             combined += rhs;\par
7559             {\cf19 return} combined;\par
7560         \}\par
7561         Columns operator+( Columns&& lhs, Column&& rhs ) \{\par
7562             lhs += CATCH_MOVE( rhs );\par
7563             {\cf19 return} CATCH_MOVE( lhs );\par
7564         \}\par
7565 \par
7566     \} {\cf20 // namespace TextFlow}\par
7567 \} {\cf20 // namespace Catch}\par
7568 \par
7569 \par
7570 \par
7571 \par
7572 {\cf21 #include <exception>}\par
7573 \par
7574 {\cf17 namespace }Catch \{\par
7575     {\cf18 bool} uncaught_exceptions() \{\par
7576 {\cf21 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
7577         {\cf19 return} {\cf17 false};\par
7578 {\cf21 #elif defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
7579         {\cf19 return} std::uncaught_exceptions() > 0;\par
7580 {\cf21 #else}\par
7581         {\cf19 return} std::uncaught_exception();\par
7582 {\cf21 #endif}\par
7583   \}\par
7584 \} {\cf20 // end namespace Catch}\par
7585 \par
7586 \par
7587 \par
7588 {\cf17 namespace }Catch \{\par
7589 \par
7590     WildcardPattern::WildcardPattern( std::string {\cf17 const}& pattern,\par
7591                                       CaseSensitive caseSensitivity )\par
7592     :   m_caseSensitivity( caseSensitivity ),\par
7593         m_pattern( normaliseString( pattern ) )\par
7594     \{\par
7595         {\cf19 if}( startsWith( m_pattern, {\cf23 '*'} ) ) \{\par
7596             m_pattern = m_pattern.substr( 1 );\par
7597             m_wildcard = WildcardAtStart;\par
7598         \}\par
7599         {\cf19 if}( endsWith( m_pattern, {\cf23 '*'} ) ) \{\par
7600             m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );\par
7601             m_wildcard = {\cf17 static_cast<}WildcardPosition{\cf17 >}( m_wildcard | WildcardAtEnd );\par
7602         \}\par
7603     \}\par
7604 \par
7605     {\cf18 bool} WildcardPattern::matches( std::string {\cf17 const}& str ){\cf17  const }\{\par
7606         {\cf19 switch}( m_wildcard ) \{\par
7607             {\cf19 case} NoWildcard:\par
7608                 {\cf19 return} m_pattern == normaliseString( str );\par
7609             {\cf19 case} WildcardAtStart:\par
7610                 {\cf19 return} endsWith( normaliseString( str ), m_pattern );\par
7611             {\cf19 case} WildcardAtEnd:\par
7612                 {\cf19 return} startsWith( normaliseString( str ), m_pattern );\par
7613             {\cf19 case} WildcardAtBothEnds:\par
7614                 {\cf19 return} contains( normaliseString( str ), m_pattern );\par
7615             {\cf19 default}:\par
7616                 CATCH_INTERNAL_ERROR( {\cf22 "Unknown enum"} );\par
7617         \}\par
7618     \}\par
7619 \par
7620     std::string WildcardPattern::normaliseString( std::string {\cf17 const}& str ){\cf17  const }\{\par
7621         {\cf19 return} trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );\par
7622     \}\par
7623 \}\par
7624 \par
7625 \par
7626 {\cf20 // Note: swapping these two includes around causes MSVC to error out}\par
7627 {\cf20 //       while in /permissive- mode. No, I don't know why.}\par
7628 {\cf20 //       Tested on VS 2019, 18.\{3, 4\}.x}\par
7629 \par
7630 {\cf21 #include <cstdint>}\par
7631 {\cf21 #include <iomanip>}\par
7632 {\cf21 #include <type_traits>}\par
7633 \par
7634 {\cf17 namespace }Catch \{\par
7635 \par
7636 {\cf17 namespace }\{\par
7637 \par
7638     {\cf18 size_t} trailingBytes({\cf18 unsigned} {\cf18 char} c) \{\par
7639         {\cf19 if} ((c & 0xE0) == 0xC0) \{\par
7640             {\cf19 return} 2;\par
7641         \}\par
7642         {\cf19 if} ((c & 0xF0) == 0xE0) \{\par
7643             {\cf19 return} 3;\par
7644         \}\par
7645         {\cf19 if} ((c & 0xF8) == 0xF0) \{\par
7646             {\cf19 return} 4;\par
7647         \}\par
7648         CATCH_INTERNAL_ERROR({\cf22 "Invalid multibyte utf-8 start byte encountered"});\par
7649     \}\par
7650 \par
7651     uint32_t headerValue({\cf18 unsigned} {\cf18 char} c) \{\par
7652         {\cf19 if} ((c & 0xE0) == 0xC0) \{\par
7653             {\cf19 return} c & 0x1F;\par
7654         \}\par
7655         {\cf19 if} ((c & 0xF0) == 0xE0) \{\par
7656             {\cf19 return} c & 0x0F;\par
7657         \}\par
7658         {\cf19 if} ((c & 0xF8) == 0xF0) \{\par
7659             {\cf19 return} c & 0x07;\par
7660         \}\par
7661         CATCH_INTERNAL_ERROR({\cf22 "Invalid multibyte utf-8 start byte encountered"});\par
7662     \}\par
7663 \par
7664     {\cf18 void} hexEscapeChar(std::ostream& os, {\cf18 unsigned} {\cf18 char} c) \{\par
7665         std::ios_base::fmtflags f(os.flags());\par
7666         os << {\cf22 "\\\\x"}\par
7667             << std::uppercase << std::hex << std::setfill({\cf23 '0'}) << std::setw(2)\par
7668             << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(c);\par
7669         os.flags(f);\par
7670     \}\par
7671 \par
7672     {\cf18 bool} shouldNewline(XmlFormatting fmt) \{\par
7673         {\cf19 return} !!({\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(fmt & XmlFormatting::Newline));\par
7674     \}\par
7675 \par
7676     {\cf18 bool} shouldIndent(XmlFormatting fmt) \{\par
7677         {\cf19 return} !!({\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(fmt & XmlFormatting::Indent));\par
7678     \}\par
7679 \par
7680 \} {\cf20 // anonymous namespace}\par
7681 \par
7682     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) \{\par
7683         {\cf19 return} {\cf17 static_cast<}XmlFormatting{\cf17 >}(\par
7684             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(lhs) |\par
7685             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(rhs)\par
7686         );\par
7687     \}\par
7688 \par
7689     XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs) \{\par
7690         {\cf19 return} {\cf17 static_cast<}XmlFormatting{\cf17 >}(\par
7691             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(lhs) &\par
7692             {\cf17 static_cast<}std::underlying_type_t<XmlFormatting>{\cf17 >}(rhs)\par
7693         );\par
7694     \}\par
7695 \par
7696 \par
7697     XmlEncode::XmlEncode( StringRef str, ForWhat forWhat )\par
7698     :   m_str( str ),\par
7699         m_forWhat( forWhat )\par
7700     \{\}\par
7701 \par
7702     {\cf18 void} XmlEncode::encodeTo( std::ostream& os ){\cf17  const }\{\par
7703         {\cf20 // Apostrophe escaping not necessary if we always use " to write attributes}\par
7704         {\cf20 // (see: http://www.w3.org/TR/xml/#syntax)}\par
7705 \par
7706         {\cf19 for}( std::size_t idx = 0; idx < m_str.size(); ++ idx ) \{\par
7707             {\cf18 unsigned} {\cf18 char} c = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(m_str[idx]);\par
7708             {\cf19 switch} (c) \{\par
7709             {\cf19 case} {\cf23 '<'}:   os << {\cf22 "&lt;"}; {\cf19 break};\par
7710             {\cf19 case} {\cf23 '&'}:   os << {\cf22 "&amp;"}; {\cf19 break};\par
7711 \par
7712             {\cf19 case} {\cf23 '>'}:\par
7713                 {\cf20 // See: http://www.w3.org/TR/xml/#syntax}\par
7714                 {\cf19 if} (idx > 2 && m_str[idx - 1] == {\cf23 ']'} && m_str[idx - 2] == {\cf23 ']'})\par
7715                     os << {\cf22 "&gt;"};\par
7716                 {\cf19 else}\par
7717                     os << c;\par
7718                 {\cf19 break};\par
7719 \par
7720             {\cf19 case} {\cf23 '\\"'}:\par
7721                 {\cf19 if} (m_forWhat == ForAttributes)\par
7722                     os << {\cf22 "&quot;"};\par
7723                 {\cf19 else}\par
7724                     os << c;\par
7725                 {\cf19 break};\par
7726 \par
7727             {\cf19 default}:\par
7728                 {\cf20 // Check for control characters and invalid utf-8}\par
7729 \par
7730                 {\cf20 // Escape control characters in standard ascii}\par
7731                 {\cf20 // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0}\par
7732                 {\cf19 if} (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) \{\par
7733                     hexEscapeChar(os, c);\par
7734                     {\cf19 break};\par
7735                 \}\par
7736 \par
7737                 {\cf20 // Plain ASCII: Write it to stream}\par
7738                 {\cf19 if} (c < 0x7F) \{\par
7739                     os << c;\par
7740                     {\cf19 break};\par
7741                 \}\par
7742 \par
7743                 {\cf20 // UTF-8 territory}\par
7744                 {\cf20 // Check if the encoding is valid and if it is not, hex escape bytes.}\par
7745                 {\cf20 // Important: We do not check the exact decoded values for validity, only the encoding format}\par
7746                 {\cf20 // First check that this bytes is a valid lead byte:}\par
7747                 {\cf20 // This means that it is not encoded as 1111 1XXX}\par
7748                 {\cf20 // Or as 10XX XXXX}\par
7749                 {\cf19 if} (c <  0xC0 ||\par
7750                     c >= 0xF8) \{\par
7751                     hexEscapeChar(os, c);\par
7752                     {\cf19 break};\par
7753                 \}\par
7754 \par
7755                 {\cf17 auto} encBytes = trailingBytes(c);\par
7756                 {\cf20 // Are there enough bytes left to avoid accessing out-of-bounds memory?}\par
7757                 {\cf19 if} (idx + encBytes - 1 >= m_str.size()) \{\par
7758                     hexEscapeChar(os, c);\par
7759                     {\cf19 break};\par
7760                 \}\par
7761                 {\cf20 // The header is valid, check data}\par
7762                 {\cf20 // The next encBytes bytes must together be a valid utf-8}\par
7763                 {\cf20 // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)}\par
7764                 {\cf18 bool} valid = {\cf17 true};\par
7765                 uint32_t value = headerValue(c);\par
7766                 {\cf19 for} (std::size_t n = 1; n < encBytes; ++n) \{\par
7767                     {\cf18 unsigned} {\cf18 char} nc = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(m_str[idx + n]);\par
7768                     valid &= ((nc & 0xC0) == 0x80);\par
7769                     value = (value << 6) | (nc & 0x3F);\par
7770                 \}\par
7771 \par
7772                 {\cf19 if} (\par
7773                     {\cf20 // Wrong bit pattern of following bytes}\par
7774                     (!valid) ||\par
7775                     {\cf20 // Overlong encodings}\par
7776                     (value < 0x80) ||\par
7777                     (0x80 <= value && value < 0x800   && encBytes > 2) ||\par
7778                     (0x800 < value && value < 0x10000 && encBytes > 3) ||\par
7779                     {\cf20 // Encoded value out of range}\par
7780                     (value >= 0x110000)\par
7781                     ) \{\par
7782                     hexEscapeChar(os, c);\par
7783                     {\cf19 break};\par
7784                 \}\par
7785 \par
7786                 {\cf20 // If we got here, this is in fact a valid(ish) utf-8 sequence}\par
7787                 {\cf19 for} (std::size_t n = 0; n < encBytes; ++n) \{\par
7788                     os << m_str[idx + n];\par
7789                 \}\par
7790                 idx += encBytes - 1;\par
7791                 {\cf19 break};\par
7792             \}\par
7793         \}\par
7794     \}\par
7795 \par
7796     std::ostream& operator << ( std::ostream& os, XmlEncode {\cf17 const}& xmlEncode ) \{\par
7797         xmlEncode.encodeTo( os );\par
7798         {\cf19 return} os;\par
7799     \}\par
7800 \par
7801     XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )\par
7802     :   m_writer( writer ),\par
7803         m_fmt(fmt)\par
7804     \{\}\par
7805 \par
7806     XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept\par
7807     :   m_writer( other.m_writer ),\par
7808         m_fmt(other.m_fmt)\par
7809     \{\par
7810         other.m_writer = {\cf17 nullptr};\par
7811         other.m_fmt = XmlFormatting::None;\par
7812     \}\par
7813     XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) {\cf17 noexcept} \{\par
7814         {\cf19 if} ( m_writer ) \{\par
7815             m_writer->endElement();\par
7816         \}\par
7817         m_writer = other.m_writer;\par
7818         other.m_writer = {\cf17 nullptr};\par
7819         m_fmt = other.m_fmt;\par
7820         other.m_fmt = XmlFormatting::None;\par
7821         {\cf19 return} *{\cf17 this};\par
7822     \}\par
7823 \par
7824 \par
7825     XmlWriter::ScopedElement::~ScopedElement() \{\par
7826         {\cf19 if} (m_writer) \{\par
7827             m_writer->endElement(m_fmt);\par
7828         \}\par
7829     \}\par
7830 \par
7831     XmlWriter::ScopedElement&\par
7832     XmlWriter::ScopedElement::writeText( StringRef text, XmlFormatting fmt ) \{\par
7833         m_writer->writeText( text, fmt );\par
7834         {\cf19 return} *{\cf17 this};\par
7835     \}\par
7836 \par
7837     XmlWriter::ScopedElement&\par
7838     XmlWriter::ScopedElement::writeAttribute( StringRef name,\par
7839                                               StringRef attribute ) \{\par
7840         m_writer->writeAttribute( name, attribute );\par
7841         {\cf19 return} *{\cf17 this};\par
7842     \}\par
7843 \par
7844 \par
7845     XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )\par
7846     \{\par
7847         writeDeclaration();\par
7848     \}\par
7849 \par
7850     XmlWriter::~XmlWriter() \{\par
7851         {\cf19 while} (!m_tags.empty()) \{\par
7852             endElement();\par
7853         \}\par
7854         newlineIfNecessary();\par
7855     \}\par
7856 \par
7857     XmlWriter& XmlWriter::startElement( std::string {\cf17 const}& name, XmlFormatting fmt ) \{\par
7858         ensureTagClosed();\par
7859         newlineIfNecessary();\par
7860         {\cf19 if} (shouldIndent(fmt)) \{\par
7861             m_os << m_indent;\par
7862             m_indent += {\cf22 "  "};\par
7863         \}\par
7864         m_os << {\cf23 '<'} << name;\par
7865         m_tags.push_back( name );\par
7866         m_tagIsOpen = {\cf17 true};\par
7867         applyFormatting(fmt);\par
7868         {\cf19 return} *{\cf17 this};\par
7869     \}\par
7870 \par
7871     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string {\cf17 const}& name, XmlFormatting fmt ) \{\par
7872         ScopedElement scoped( {\cf17 this}, fmt );\par
7873         startElement( name, fmt );\par
7874         {\cf19 return} scoped;\par
7875     \}\par
7876 \par
7877     XmlWriter& XmlWriter::endElement(XmlFormatting fmt) \{\par
7878         m_indent = m_indent.substr(0, m_indent.size() - 2);\par
7879 \par
7880         {\cf19 if}( m_tagIsOpen ) \{\par
7881             m_os << {\cf22 "/>"};\par
7882             m_tagIsOpen = {\cf17 false};\par
7883         \} {\cf19 else} \{\par
7884             newlineIfNecessary();\par
7885             {\cf19 if} (shouldIndent(fmt)) \{\par
7886                 m_os << m_indent;\par
7887             \}\par
7888             m_os << {\cf22 "</"} << m_tags.back() << {\cf23 '>'};\par
7889         \}\par
7890         m_os << std::flush;\par
7891         applyFormatting(fmt);\par
7892         m_tags.pop_back();\par
7893         {\cf19 return} *{\cf17 this};\par
7894     \}\par
7895 \par
7896     XmlWriter& XmlWriter::writeAttribute( StringRef name,\par
7897                                           StringRef attribute ) \{\par
7898         {\cf19 if}( !name.empty() && !attribute.empty() )\par
7899             m_os << {\cf23 ' '} << name << {\cf22 "=\\""} << XmlEncode( attribute, XmlEncode::ForAttributes ) << {\cf23 '"'};\par
7900         {\cf19 return} *{\cf17 this};\par
7901     \}\par
7902 \par
7903     XmlWriter& XmlWriter::writeAttribute( StringRef name, {\cf18 bool} attribute ) \{\par
7904         writeAttribute(name, (attribute ? {\cf22 "true"}_sr : {\cf22 "false"}_sr));\par
7905         {\cf19 return} *{\cf17 this};\par
7906     \}\par
7907 \par
7908     XmlWriter& XmlWriter::writeAttribute( StringRef name,\par
7909                                           {\cf18 char} {\cf17 const}* attribute ) \{\par
7910         writeAttribute( name, StringRef( attribute ) );\par
7911         {\cf19 return} *{\cf17 this};\par
7912     \}\par
7913 \par
7914     XmlWriter& XmlWriter::writeText( StringRef text, XmlFormatting fmt ) \{\par
7915         CATCH_ENFORCE(!m_tags.empty(), {\cf22 "Cannot write text as top level element"});\par
7916         {\cf19 if}( !text.empty() )\{\par
7917             {\cf18 bool} tagWasOpen = m_tagIsOpen;\par
7918             ensureTagClosed();\par
7919             {\cf19 if} (tagWasOpen && shouldIndent(fmt)) \{\par
7920                 m_os << m_indent;\par
7921             \}\par
7922             m_os << XmlEncode( text, XmlEncode::ForTextNodes );\par
7923             applyFormatting(fmt);\par
7924         \}\par
7925         {\cf19 return} *{\cf17 this};\par
7926     \}\par
7927 \par
7928     XmlWriter& XmlWriter::writeComment( StringRef text, XmlFormatting fmt ) \{\par
7929         ensureTagClosed();\par
7930         {\cf19 if} (shouldIndent(fmt)) \{\par
7931             m_os << m_indent;\par
7932         \}\par
7933         m_os << {\cf22 "<!-- "} << text << {\cf22 " -->"};\par
7934         applyFormatting(fmt);\par
7935         {\cf19 return} *{\cf17 this};\par
7936     \}\par
7937 \par
7938     {\cf18 void} XmlWriter::writeStylesheetRef( StringRef url ) \{\par
7939         m_os << R{\cf22 "(<?xml-stylesheet type="text/xsl" href=")" << url << R}{\cf22 "("?>)" << }{\cf23 '\\n'};\par
7940     \}\par
7941 \par
7942     {\cf18 void} XmlWriter::ensureTagClosed() \{\par
7943         {\cf19 if}( m_tagIsOpen ) \{\par
7944             m_os << {\cf23 '>'} << std::flush;\par
7945             newlineIfNecessary();\par
7946             m_tagIsOpen = {\cf17 false};\par
7947         \}\par
7948     \}\par
7949 \par
7950     {\cf18 void} XmlWriter::applyFormatting(XmlFormatting fmt) \{\par
7951         m_needsNewline = shouldNewline(fmt);\par
7952     \}\par
7953 \par
7954     {\cf18 void} XmlWriter::writeDeclaration() \{\par
7955         m_os << R{\cf22 "(<?xml version="1.0" encoding="UTF-8"?>)" << }{\cf23 '\\n'};\par
7956     \}\par
7957 \par
7958     {\cf18 void} XmlWriter::newlineIfNecessary() \{\par
7959         {\cf19 if}( m_needsNewline ) \{\par
7960             m_os << {\cf23 '\\n'} << std::flush;\par
7961             m_needsNewline = {\cf17 false};\par
7962         \}\par
7963     \}\par
7964 \}\par
7965 \par
7966 \par
7967 \par
7968 \par
7969 \par
7970 {\cf17 namespace }Catch \{\par
7971 {\cf17 namespace }Matchers \{\par
7972 \par
7973     std::string MatcherUntypedBase::toString(){\cf17  const }\{\par
7974         {\cf19 if} (m_cachedToString.empty()) \{\par
7975             m_cachedToString = describe();\par
7976         \}\par
7977         {\cf19 return} m_cachedToString;\par
7978     \}\par
7979 \par
7980     MatcherUntypedBase::~MatcherUntypedBase() = {\cf19 default};\par
7981 \par
7982 \} {\cf20 // namespace Matchers}\par
7983 \} {\cf20 // namespace Catch}\par
7984 \par
7985 \par
7986 \par
7987 \par
7988 {\cf17 namespace }Catch \{\par
7989 {\cf17 namespace }Matchers \{\par
7990 \par
7991     std::string IsEmptyMatcher::describe(){\cf17  const }\{\par
7992         {\cf19 return} {\cf22 "is empty"};\par
7993     \}\par
7994 \par
7995     std::string HasSizeMatcher::describe(){\cf17  const }\{\par
7996         ReusableStringStream sstr;\par
7997         sstr << {\cf22 "has size == "} << m_target_size;\par
7998         {\cf19 return} sstr.str();\par
7999     \}\par
8000 \par
8001     IsEmptyMatcher IsEmpty() \{\par
8002         {\cf19 return} \{\};\par
8003     \}\par
8004 \par
8005     HasSizeMatcher SizeIs(std::size_t sz) \{\par
8006         {\cf19 return} HasSizeMatcher\{ sz \};\par
8007     \}\par
8008 \par
8009 \} {\cf20 // end namespace Matchers}\par
8010 \} {\cf20 // end namespace Catch}\par
8011 \par
8012 \par
8013 \par
8014 {\cf17 namespace }Catch \{\par
8015 {\cf17 namespace }Matchers \{\par
8016 \par
8017 {\cf18 bool} ExceptionMessageMatcher::match(std::exception {\cf17 const}& ex){\cf17  const }\{\par
8018     {\cf19 return} ex.what() == m_message;\par
8019 \}\par
8020 \par
8021 std::string ExceptionMessageMatcher::describe(){\cf17  const }\{\par
8022     {\cf19 return} {\cf22 "exception message matches \\""} + m_message + {\cf23 '"'};\par
8023 \}\par
8024 \par
8025 ExceptionMessageMatcher Message(std::string {\cf17 const}& message) \{\par
8026     {\cf19 return} ExceptionMessageMatcher(message);\par
8027 \}\par
8028 \par
8029 \} {\cf20 // namespace Matchers}\par
8030 \} {\cf20 // namespace Catch}\par
8031 \par
8032 \par
8033 \par
8034 {\cf21 #include <algorithm>}\par
8035 {\cf21 #include <cmath>}\par
8036 {\cf21 #include <cstdlib>}\par
8037 {\cf21 #include <cstdint>}\par
8038 {\cf21 #include <sstream>}\par
8039 {\cf21 #include <iomanip>}\par
8040 {\cf21 #include <limits>}\par
8041 \par
8042 \par
8043 {\cf17 namespace }Catch \{\par
8044 {\cf17 namespace }\{\par
8045 \par
8046     {\cf17 template} <{\cf17 typename} FP>\par
8047     {\cf18 bool} almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) \{\par
8048         {\cf20 // Comparison with NaN should always be false.}\par
8049         {\cf20 // This way we can rule it out before getting into the ugly details}\par
8050         {\cf19 if} (Catch::isnan(lhs) || Catch::isnan(rhs)) \{\par
8051             {\cf19 return} {\cf17 false};\par
8052         \}\par
8053 \par
8054         {\cf20 // This should also handle positive and negative zeros, infinities}\par
8055         {\cf17 const} {\cf17 auto} ulpDist = ulpDistance(lhs, rhs);\par
8056 \par
8057         {\cf19 return} ulpDist <= maxUlpDiff;\par
8058     \}\par
8059 \par
8060 \par
8061 {\cf17 template} <{\cf17 typename} FP>\par
8062 FP step(FP start, FP direction, uint64_t steps) \{\par
8063     {\cf19 for} (uint64_t i = 0; i < steps; ++i) \{\par
8064         start = Catch::nextafter(start, direction);\par
8065     \}\par
8066     {\cf19 return} start;\par
8067 \}\par
8068 \par
8069 {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
8070 {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
8071 {\cf18 bool} marginComparison({\cf18 double} lhs, {\cf18 double} rhs, {\cf18 double} margin) \{\par
8072     {\cf19 return} (lhs + margin >= rhs) && (rhs + margin >= lhs);\par
8073 \}\par
8074 \par
8075 {\cf17 template} <{\cf17 typename} FloatingPo{\cf18 int}>\par
8076 {\cf18 void} write(std::ostream& out, FloatingPoint num) \{\par
8077     out << std::scientific\par
8078         << std::setprecision(std::numeric_limits<FloatingPoint>::max_digits10 - 1)\par
8079         << num;\par
8080 \}\par
8081 \par
8082 \} {\cf20 // end anonymous namespace}\par
8083 \par
8084 {\cf17 namespace }Matchers \{\par
8085 {\cf17 namespace }Detail \{\par
8086 \par
8087     {\cf17 enum class} FloatingPointKind : uint8_t \{\par
8088         Float,\par
8089         Double\par
8090     \};\par
8091 \par
8092 \} {\cf20 // end namespace Detail}\par
8093 \par
8094 \par
8095     WithinAbsMatcher::WithinAbsMatcher({\cf18 double} target, {\cf18 double} margin)\par
8096         :m_target\{ target \}, m_margin\{ margin \} \{\par
8097         CATCH_ENFORCE(margin >= 0, {\cf22 "Invalid margin: "} << margin << {\cf23 '.'}\par
8098             << {\cf22 " Margin has to be non-negative."});\par
8099     \}\par
8100 \par
8101     {\cf20 // Performs equivalent check of std::fabs(lhs - rhs) <= margin}\par
8102     {\cf20 // But without the subtraction to allow for INFINITY in comparison}\par
8103     {\cf18 bool} WithinAbsMatcher::match({\cf18 double} {\cf17 const}& matchee){\cf17  const }\{\par
8104         {\cf19 return} (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);\par
8105     \}\par
8106 \par
8107     std::string WithinAbsMatcher::describe(){\cf17  const }\{\par
8108         {\cf19 return} {\cf22 "is within "} + ::Catch::Detail::stringify(m_margin) + {\cf22 " of "} + ::Catch::Detail::stringify(m_target);\par
8109     \}\par
8110 \par
8111 \par
8112     WithinUlpsMatcher::WithinUlpsMatcher({\cf18 double} target, uint64_t ulps, Detail::FloatingPointKind baseType)\par
8113         :m_target\{ target \}, m_ulps\{ ulps \}, m_type\{ baseType \} \{\par
8114         CATCH_ENFORCE(m_type == Detail::FloatingPointKind::Double\par
8115                    || m_ulps < (std::numeric_limits<uint32_t>::max)(),\par
8116             {\cf22 "Provided ULP is impossibly large for a float comparison."});\par
8117         CATCH_ENFORCE( std::numeric_limits<double>::is_iec559,\par
8118                        {\cf22 "WithinUlp matcher only supports platforms with "}\par
8119                        {\cf22 "IEEE-754 compatible floating point representation"} );\par
8120     \}\par
8121 \par
8122 {\cf21 #if defined(__clang__)}\par
8123 {\cf21 #pragma clang diagnostic push}\par
8124 {\cf20 // Clang <3.5 reports on the default branch in the switch below}\par
8125 {\cf21 #pragma clang diagnostic ignored "-Wunreachable-code"}\par
8126 {\cf21 #endif}\par
8127 \par
8128     {\cf18 bool} WithinUlpsMatcher::match({\cf18 double} {\cf17 const}& matchee){\cf17  const }\{\par
8129         {\cf19 switch} (m_type) \{\par
8130         {\cf19 case} Detail::FloatingPointKind::Float:\par
8131             {\cf19 return} almostEqualUlps<float>({\cf17 static_cast<}{\cf18 float}{\cf17 >}(matchee), {\cf17 static_cast<}{\cf18 float}{\cf17 >}(m_target), m_ulps);\par
8132         {\cf19 case} Detail::FloatingPointKind::Double:\par
8133             {\cf19 return} almostEqualUlps<double>(matchee, m_target, m_ulps);\par
8134         {\cf19 default}:\par
8135             CATCH_INTERNAL_ERROR( {\cf22 "Unknown Detail::FloatingPointKind value"} );\par
8136         \}\par
8137     \}\par
8138 \par
8139 {\cf21 #if defined(__clang__)}\par
8140 {\cf21 #pragma clang diagnostic pop}\par
8141 {\cf21 #endif}\par
8142 \par
8143     std::string WithinUlpsMatcher::describe(){\cf17  const }\{\par
8144         std::stringstream ret;\par
8145 \par
8146         ret << {\cf22 "is within "} << m_ulps << {\cf22 " ULPs of "};\par
8147 \par
8148         {\cf19 if} (m_type == Detail::FloatingPointKind::Float) \{\par
8149             write(ret, {\cf17 static_cast<}{\cf18 float}{\cf17 >}(m_target));\par
8150             ret << {\cf23 'f'};\par
8151         \} {\cf19 else} \{\par
8152             write(ret, m_target);\par
8153         \}\par
8154 \par
8155         ret << {\cf22 " (["};\par
8156         {\cf19 if} (m_type == Detail::FloatingPointKind::Double) \{\par
8157             write( ret,\par
8158                    step( m_target,\par
8159                          -std::numeric_limits<double>::infinity(),\par
8160                          m_ulps ) );\par
8161             ret << {\cf22 ", "};\par
8162             write( ret,\par
8163                    step( m_target,\par
8164                          std::numeric_limits<double>::infinity(),\par
8165                          m_ulps ) );\par
8166         \} {\cf19 else} \{\par
8167             {\cf20 // We have to cast INFINITY to float because of MinGW, see #1782}\par
8168             write( ret,\par
8169                    step( {\cf17 static_cast<}{\cf18 float}{\cf17 >}( m_target ),\par
8170                          -std::numeric_limits<float>::infinity(),\par
8171                          m_ulps ) );\par
8172             ret << {\cf22 ", "};\par
8173             write( ret,\par
8174                    step( {\cf17 static_cast<}{\cf18 float}{\cf17 >}( m_target ),\par
8175                          std::numeric_limits<float>::infinity(),\par
8176                          m_ulps ) );\par
8177         \}\par
8178         ret << {\cf22 "])"};\par
8179 \par
8180         {\cf19 return} ret.str();\par
8181     \}\par
8182 \par
8183     WithinRelMatcher::WithinRelMatcher({\cf18 double} target, {\cf18 double} epsilon):\par
8184         m_target(target),\par
8185         m_epsilon(epsilon)\{\par
8186         CATCH_ENFORCE(m_epsilon >= 0., {\cf22 "Relative comparison with epsilon <  0 does not make sense."});\par
8187         CATCH_ENFORCE(m_epsilon  < 1., "Relative comparison with epsilon >= 1 does not make sense.{\cf22 ");}\par
8188 {\cf22     \}}\par
8189 {\cf22 }\par
8190 {\cf22     bool WithinRelMatcher::match(double const& matchee) const \{}\par
8191 {\cf22         const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));}\par
8192 {\cf22         return marginComparison(matchee, m_target,}\par
8193 {\cf22                                 std::isinf(relMargin)? 0 : relMargin);}\par
8194 {\cf22     \}}\par
8195 {\cf22 }\par
8196 {\cf22     std::string WithinRelMatcher::describe() const \{}\par
8197 {\cf22         Catch::ReusableStringStream sstr;}\par
8198 {\cf22         sstr << "}and {\cf22 " << ::Catch::Detail::stringify(m_target) << "} are within {\cf22 " << m_epsilon * 100. << "}% of each other{\cf22 ";}\par
8199 {\cf22         return sstr.str();}\par
8200 {\cf22     \}}\par
8201 {\cf22 }\par
8202 {\cf22 }\par
8203 {\cf22 WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) \{}\par
8204 {\cf22     return WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Double);}\par
8205 {\cf22 \}}\par
8206 {\cf22 }\par
8207 {\cf22 WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) \{}\par
8208 {\cf22     return WithinUlpsMatcher(target, maxUlpDiff, Detail::FloatingPointKind::Float);}\par
8209 {\cf22 \}}\par
8210 {\cf22 }\par
8211 {\cf22 WithinAbsMatcher WithinAbs(double target, double margin) \{}\par
8212 {\cf22     return WithinAbsMatcher(target, margin);}\par
8213 {\cf22 \}}\par
8214 {\cf22 }\par
8215 {\cf22 WithinRelMatcher WithinRel(double target, double eps) \{}\par
8216 {\cf22     return WithinRelMatcher(target, eps);}\par
8217 {\cf22 \}}\par
8218 {\cf22 }\par
8219 {\cf22 WithinRelMatcher WithinRel(double target) \{}\par
8220 {\cf22     return WithinRelMatcher(target, std::numeric_limits<double>::epsilon() * 100);}\par
8221 {\cf22 \}}\par
8222 {\cf22 }\par
8223 {\cf22 WithinRelMatcher WithinRel(float target, float eps) \{}\par
8224 {\cf22     return WithinRelMatcher(target, eps);}\par
8225 {\cf22 \}}\par
8226 {\cf22 }\par
8227 {\cf22 WithinRelMatcher WithinRel(float target) \{}\par
8228 {\cf22     return WithinRelMatcher(target, std::numeric_limits<float>::epsilon() * 100);}\par
8229 {\cf22 \}}\par
8230 {\cf22 }\par
8231 {\cf22 }\par
8232 {\cf22 }\par
8233 {\cf22 bool IsNaNMatcher::match( double const& matchee ) const \{}\par
8234 {\cf22     return std::isnan( matchee );}\par
8235 {\cf22 \}}\par
8236 {\cf22 }\par
8237 {\cf22 std::string IsNaNMatcher::describe() const \{}\par
8238 {\cf22     using namespace std::string_literals;}\par
8239 {\cf22     return "}is NaN{\cf22 "s;}\par
8240 {\cf22 \}}\par
8241 {\cf22 }\par
8242 {\cf22 IsNaNMatcher IsNaN() \{ return IsNaNMatcher(); \}}\par
8243 {\cf22 }\par
8244 {\cf22     \} // namespace Matchers}\par
8245 {\cf22 \} // namespace Catch}\par
8246 {\cf22 }\par
8247 {\cf22 }\par
8248 {\cf22 }\par
8249 {\cf22 }\par
8250 {\cf22 std::string Catch::Matchers::Detail::finalizeDescription(const std::string& desc) \{}\par
8251 {\cf22     if (desc.empty()) \{}\par
8252 {\cf22         return "}matches undescribed predicate{\cf22 ";}\par
8253 {\cf22     \} else \{}\par
8254 {\cf22         return "}matches predicate: \\{\cf22 ""} + desc + {\cf23 '"'};\par
8255     \}\par
8256 \}\par
8257 \par
8258 \par
8259 \par
8260 {\cf17 namespace }Catch \{\par
8261     {\cf17 namespace }Matchers \{\par
8262         std::string AllTrueMatcher::describe(){\cf17  const }\{ {\cf19 return} {\cf22 "contains only true"}; \}\par
8263 \par
8264         AllTrueMatcher AllTrue() \{ {\cf19 return} AllTrueMatcher\{\}; \}\par
8265 \par
8266         std::string NoneTrueMatcher::describe(){\cf17  const }\{ {\cf19 return} {\cf22 "contains no true"}; \}\par
8267 \par
8268         NoneTrueMatcher NoneTrue() \{ {\cf19 return} NoneTrueMatcher\{\}; \}\par
8269 \par
8270         std::string AnyTrueMatcher::describe(){\cf17  const }\{ {\cf19 return} {\cf22 "contains at least one true"}; \}\par
8271 \par
8272         AnyTrueMatcher AnyTrue() \{ {\cf19 return} AnyTrueMatcher\{\}; \}\par
8273     \} {\cf20 // namespace Matchers}\par
8274 \} {\cf20 // namespace Catch}\par
8275 \par
8276 \par
8277 \par
8278 {\cf21 #include <regex>}\par
8279 \par
8280 {\cf17 namespace }Catch \{\par
8281 {\cf17 namespace }Matchers \{\par
8282 \par
8283     CasedString::CasedString( std::string {\cf17 const}& str, CaseSensitive caseSensitivity )\par
8284     :   m_caseSensitivity( caseSensitivity ),\par
8285         m_str( adjustString( str ) )\par
8286     \{\}\par
8287     std::string CasedString::adjustString( std::string {\cf17 const}& str ){\cf17  const }\{\par
8288         {\cf19 return} m_caseSensitivity == CaseSensitive::No\par
8289                ? toLower( str )\par
8290                : str;\par
8291     \}\par
8292     StringRef CasedString::caseSensitivitySuffix(){\cf17  const }\{\par
8293         {\cf19 return} m_caseSensitivity == CaseSensitive::Yes\par
8294                    ? StringRef()\par
8295                    : {\cf22 " (case insensitive)"}_sr;\par
8296     \}\par
8297 \par
8298 \par
8299     StringMatcherBase::StringMatcherBase( StringRef operation, CasedString {\cf17 const}& comparator )\par
8300     : m_comparator( comparator ),\par
8301       m_operation( operation ) \{\par
8302     \}\par
8303 \par
8304     std::string StringMatcherBase::describe(){\cf17  const }\{\par
8305         std::string description;\par
8306         description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +\par
8307                                     m_comparator.caseSensitivitySuffix().size());\par
8308         description += m_operation;\par
8309         description += {\cf22 ": \\""};\par
8310         description += m_comparator.m_str;\par
8311         description += {\cf23 '"'};\par
8312         description += m_comparator.caseSensitivitySuffix();\par
8313         {\cf19 return} description;\par
8314     \}\par
8315 \par
8316     StringEqualsMatcher::StringEqualsMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "equals"}_sr, comparator ) \{\}\par
8317 \par
8318     {\cf18 bool} StringEqualsMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8319         {\cf19 return} m_comparator.adjustString( source ) == m_comparator.m_str;\par
8320     \}\par
8321 \par
8322 \par
8323     StringContainsMatcher::StringContainsMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "contains"}_sr, comparator ) \{\}\par
8324 \par
8325     {\cf18 bool} StringContainsMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8326         {\cf19 return} contains( m_comparator.adjustString( source ), m_comparator.m_str );\par
8327     \}\par
8328 \par
8329 \par
8330     StartsWithMatcher::StartsWithMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "starts with"}_sr, comparator ) \{\}\par
8331 \par
8332     {\cf18 bool} StartsWithMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8333         {\cf19 return} startsWith( m_comparator.adjustString( source ), m_comparator.m_str );\par
8334     \}\par
8335 \par
8336 \par
8337     EndsWithMatcher::EndsWithMatcher( CasedString {\cf17 const}& comparator ) : StringMatcherBase( {\cf22 "ends with"}_sr, comparator ) \{\}\par
8338 \par
8339     {\cf18 bool} EndsWithMatcher::match( std::string {\cf17 const}& source ){\cf17  const }\{\par
8340         {\cf19 return} endsWith( m_comparator.adjustString( source ), m_comparator.m_str );\par
8341     \}\par
8342 \par
8343 \par
8344 \par
8345     RegexMatcher::RegexMatcher(std::string regex, CaseSensitive caseSensitivity): m_regex(CATCH_MOVE(regex)), m_caseSensitivity(caseSensitivity) \{\}\par
8346 \par
8347     {\cf18 bool} RegexMatcher::match(std::string {\cf17 const}& matchee){\cf17  const }\{\par
8348         {\cf17 auto} flags = std::regex::ECMAScript; {\cf20 // ECMAScript is the default syntax option anyway}\par
8349         {\cf19 if} (m_caseSensitivity == CaseSensitive::No) \{\par
8350             flags |= std::regex::icase;\par
8351         \}\par
8352         {\cf17 auto} reg = std::regex(m_regex, flags);\par
8353         {\cf19 return} std::regex_match(matchee, reg);\par
8354     \}\par
8355 \par
8356     std::string RegexMatcher::describe(){\cf17  const }\{\par
8357         {\cf19 return} {\cf22 "matches "} + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Yes)? {\cf22 " case sensitively"} : {\cf22 " case insensitively"});\par
8358     \}\par
8359 \par
8360 \par
8361     StringEqualsMatcher Equals( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8362         {\cf19 return} StringEqualsMatcher( CasedString( str, caseSensitivity) );\par
8363     \}\par
8364     StringContainsMatcher ContainsSubstring( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8365         {\cf19 return} StringContainsMatcher( CasedString( str, caseSensitivity) );\par
8366     \}\par
8367     EndsWithMatcher EndsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8368         {\cf19 return} EndsWithMatcher( CasedString( str, caseSensitivity) );\par
8369     \}\par
8370     StartsWithMatcher StartsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity ) \{\par
8371         {\cf19 return} StartsWithMatcher( CasedString( str, caseSensitivity) );\par
8372     \}\par
8373 \par
8374     RegexMatcher Matches(std::string {\cf17 const}& regex, CaseSensitive caseSensitivity) \{\par
8375         {\cf19 return} RegexMatcher(regex, caseSensitivity);\par
8376     \}\par
8377 \par
8378 \} {\cf20 // namespace Matchers}\par
8379 \} {\cf20 // namespace Catch}\par
8380 \par
8381 \par
8382 \par
8383 {\cf17 namespace }Catch \{\par
8384 {\cf17 namespace }Matchers \{\par
8385     MatcherGenericBase::~MatcherGenericBase() = {\cf19 default};\par
8386 \par
8387     {\cf17 namespace }Detail \{\par
8388 \par
8389         std::string describe_multi_matcher(StringRef combine, std::string {\cf17 const}* descriptions_begin, std::string {\cf17 const}* descriptions_end) \{\par
8390             std::string description;\par
8391             std::size_t combined_size = 4;\par
8392             {\cf19 for} ( {\cf17 auto} desc = descriptions_begin; desc != descriptions_end; ++desc ) \{\par
8393                 combined_size += desc->size();\par
8394             \}\par
8395             combined_size += {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(descriptions_end - descriptions_begin - 1) * combine.size();\par
8396 \par
8397             description.reserve(combined_size);\par
8398 \par
8399             description += {\cf22 "( "};\par
8400             {\cf18 bool} first = {\cf17 true};\par
8401             {\cf19 for}( {\cf17 auto} desc = descriptions_begin; desc != descriptions_end; ++desc ) \{\par
8402                 {\cf19 if}( first )\par
8403                     first = {\cf17 false};\par
8404                 {\cf19 else}\par
8405                     description += combine;\par
8406                 description += *desc;\par
8407             \}\par
8408             description += {\cf22 " )"};\par
8409             {\cf19 return} description;\par
8410         \}\par
8411 \par
8412     \} {\cf20 // namespace Detail}\par
8413 \} {\cf20 // namespace Matchers}\par
8414 \} {\cf20 // namespace Catch}\par
8415 \par
8416 \par
8417 \par
8418 \par
8419 {\cf17 namespace }Catch \{\par
8420 \par
8421     {\cf20 // This is the general overload that takes a any string matcher}\par
8422     {\cf20 // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers}\par
8423     {\cf20 // the Equals matcher (so the header does not mention matchers)}\par
8424     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher {\cf17 const}& matcher ) \{\par
8425         std::string exceptionMessage = Catch::translateActiveException();\par
8426         MatchExpr<std::string, StringMatcher const&> expr( CATCH_MOVE(exceptionMessage), matcher );\par
8427         handler.handleExpr( expr );\par
8428     \}\par
8429 \par
8430 \} {\cf20 // namespace Catch}\par
8431 \par
8432 \par
8433 \par
8434 {\cf21 #include <ostream>}\par
8435 \par
8436 {\cf17 namespace }Catch \{\par
8437 \par
8438     AutomakeReporter::~AutomakeReporter() = {\cf19 default};\par
8439 \par
8440     {\cf18 void} AutomakeReporter::testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) \{\par
8441         {\cf20 // Possible values to emit are PASS, XFAIL, SKIP, FAIL, XPASS and ERROR.}\par
8442         m_stream << {\cf22 ":test-result: "};\par
8443         {\cf19 if} ( _testCaseStats.totals.testCases.skipped > 0 ) \{\par
8444             m_stream << {\cf22 "SKIP"};\par
8445         \} {\cf19 else} {\cf19 if} (_testCaseStats.totals.assertions.allPassed()) \{\par
8446             m_stream << {\cf22 "PASS"};\par
8447         \} {\cf19 else} {\cf19 if} (_testCaseStats.totals.assertions.allOk()) \{\par
8448             m_stream << {\cf22 "XFAIL"};\par
8449         \} {\cf19 else} \{\par
8450             m_stream << {\cf22 "FAIL"};\par
8451         \}\par
8452         m_stream << {\cf23 ' '} << _testCaseStats.testInfo->name << {\cf23 '\\n'};\par
8453         StreamingReporterBase::testCaseEnded(_testCaseStats);\par
8454     \}\par
8455 \par
8456     {\cf18 void} AutomakeReporter::skipTest(TestCaseInfo {\cf17 const}& testInfo) \{\par
8457         m_stream << {\cf22 ":test-result: SKIP "} << testInfo.name << {\cf23 '\\n'};\par
8458     \}\par
8459 \par
8460 \} {\cf20 // end namespace Catch}\par
8461 \par
8462 \par
8463 \par
8464 \par
8465 \par
8466 \par
8467 {\cf17 namespace }Catch \{\par
8468     ReporterBase::ReporterBase( ReporterConfig&& config ):\par
8469         IEventListener( config.fullConfig() ),\par
8470         m_wrapped_stream( CATCH_MOVE(config).takeStream() ),\par
8471         m_stream( m_wrapped_stream->stream() ),\par
8472         m_colour( makeColourImpl( config.colourMode(), m_wrapped_stream.get() ) ),\par
8473         m_customOptions( config.customOptions() )\par
8474     \{\}\par
8475 \par
8476     ReporterBase::~ReporterBase() = {\cf19 default};\par
8477 \par
8478     {\cf18 void} ReporterBase::listReporters(\par
8479         std::vector<ReporterDescription> {\cf17 const}& descriptions ) \{\par
8480         defaultListReporters(m_stream, descriptions, m_config->verbosity());\par
8481     \}\par
8482 \par
8483     {\cf18 void} ReporterBase::listListeners(\par
8484         std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
8485         defaultListListeners( m_stream, descriptions );\par
8486     \}\par
8487 \par
8488     {\cf18 void} ReporterBase::listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
8489         defaultListTests(m_stream,\par
8490                          m_colour.get(),\par
8491                          tests,\par
8492                          m_config->hasTestFilters(),\par
8493                          m_config->verbosity());\par
8494     \}\par
8495 \par
8496     {\cf18 void} ReporterBase::listTags(std::vector<TagInfo> {\cf17 const}& tags) \{\par
8497         defaultListTags( m_stream, tags, m_config->hasTestFilters() );\par
8498     \}\par
8499 \par
8500 \} {\cf20 // namespace Catch}\par
8501 \par
8502 \par
8503 \par
8504 \par
8505 {\cf21 #include <ostream>}\par
8506 \par
8507 {\cf17 namespace }Catch \{\par
8508 {\cf17 namespace }\{\par
8509 \par
8510     {\cf20 // Colour::LightGrey}\par
8511     {\cf17 static} {\cf17 constexpr} Colour::Code compactDimColour = Colour::FileName;\par
8512 \par
8513 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
8514     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactFailedString = {\cf22 "FAILED"}_sr;\par
8515     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactPassedString = {\cf22 "PASSED"}_sr;\par
8516 {\cf21 #else}\par
8517     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactFailedString = {\cf22 "failed"}_sr;\par
8518     {\cf17 static} {\cf17 constexpr} Catch::StringRef compactPassedString = {\cf22 "passed"}_sr;\par
8519 {\cf21 #endif}\par
8520 \par
8521 {\cf20 // Implementation of CompactReporter formatting}\par
8522 {\cf17 class }AssertionPrinter \{\par
8523 {\cf17 public}:\par
8524     AssertionPrinter& operator= (AssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8525     AssertionPrinter(AssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8526     AssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, {\cf18 bool} _printInfoMessages, ColourImpl* colourImpl_)\par
8527         : stream(_stream)\par
8528         , result(_stats.assertionResult)\par
8529         , messages(_stats.infoMessages)\par
8530         , itMessage(_stats.infoMessages.begin())\par
8531         , printInfoMessages(_printInfoMessages)\par
8532         , colourImpl(colourImpl_)\par
8533     \{\}\par
8534 \par
8535     {\cf18 void} print() \{\par
8536         printSourceInfo();\par
8537 \par
8538         itMessage = messages.begin();\par
8539 \par
8540         {\cf19 switch} (result.getResultType()) \{\par
8541         {\cf19 case} ResultWas::Ok:\par
8542             printResultType(Colour::ResultSuccess, compactPassedString);\par
8543             printOriginalExpression();\par
8544             printReconstructedExpression();\par
8545             {\cf19 if} (!result.hasExpression())\par
8546                 printRemainingMessages(Colour::None);\par
8547             {\cf19 else}\par
8548                 printRemainingMessages();\par
8549             {\cf19 break};\par
8550         {\cf19 case} ResultWas::ExpressionFailed:\par
8551             {\cf19 if} (result.isOk())\par
8552                 printResultType(Colour::ResultSuccess, compactFailedString + {\cf22 " - but was ok"}_sr);\par
8553             {\cf19 else}\par
8554                 printResultType(Colour::Error, compactFailedString);\par
8555             printOriginalExpression();\par
8556             printReconstructedExpression();\par
8557             printRemainingMessages();\par
8558             {\cf19 break};\par
8559         {\cf19 case} ResultWas::ThrewException:\par
8560             printResultType(Colour::Error, compactFailedString);\par
8561             printIssue({\cf22 "unexpected exception with message:"});\par
8562             printMessage();\par
8563             printExpressionWas();\par
8564             printRemainingMessages();\par
8565             {\cf19 break};\par
8566         {\cf19 case} ResultWas::FatalErrorCondition:\par
8567             printResultType(Colour::Error, compactFailedString);\par
8568             printIssue({\cf22 "fatal error condition with message:"});\par
8569             printMessage();\par
8570             printExpressionWas();\par
8571             printRemainingMessages();\par
8572             {\cf19 break};\par
8573         {\cf19 case} ResultWas::DidntThrowException:\par
8574             printResultType(Colour::Error, compactFailedString);\par
8575             printIssue({\cf22 "expected exception, got none"});\par
8576             printExpressionWas();\par
8577             printRemainingMessages();\par
8578             {\cf19 break};\par
8579         {\cf19 case} ResultWas::Info:\par
8580             printResultType(Colour::None, {\cf22 "info"}_sr);\par
8581             printMessage();\par
8582             printRemainingMessages();\par
8583             {\cf19 break};\par
8584         {\cf19 case} ResultWas::Warning:\par
8585             printResultType(Colour::None, {\cf22 "warning"}_sr);\par
8586             printMessage();\par
8587             printRemainingMessages();\par
8588             {\cf19 break};\par
8589         {\cf19 case} ResultWas::ExplicitFailure:\par
8590             printResultType(Colour::Error, compactFailedString);\par
8591             printIssue({\cf22 "explicitly"});\par
8592             printRemainingMessages(Colour::None);\par
8593             {\cf19 break};\par
8594         {\cf19 case} ResultWas::ExplicitSkip:\par
8595             printResultType(Colour::Skip, {\cf22 "skipped"}_sr);\par
8596             printMessage();\par
8597             printRemainingMessages();\par
8598             {\cf19 break};\par
8599             {\cf20 // These cases are here to prevent compiler warnings}\par
8600         {\cf19 case} ResultWas::Unknown:\par
8601         {\cf19 case} ResultWas::FailureBit:\par
8602         {\cf19 case} ResultWas::Exception:\par
8603             printResultType(Colour::Error, {\cf22 "** internal error **"});\par
8604             {\cf19 break};\par
8605         \}\par
8606     \}\par
8607 \par
8608 {\cf17 private}:\par
8609     {\cf18 void} printSourceInfo(){\cf17  const }\{\par
8610         stream << colourImpl->guardColour( Colour::FileName )\par
8611                << result.getSourceInfo() << {\cf23 ':'};\par
8612     \}\par
8613 \par
8614     {\cf18 void} printResultType(Colour::Code colour, StringRef passOrFail){\cf17  const }\{\par
8615         {\cf19 if} (!passOrFail.empty()) \{\par
8616             stream << colourImpl->guardColour(colour) << {\cf23 ' '} << passOrFail;\par
8617             stream << {\cf23 ':'};\par
8618         \}\par
8619     \}\par
8620 \par
8621     {\cf18 void} printIssue({\cf18 char} {\cf17 const}* issue){\cf17  const }\{\par
8622         stream << {\cf23 ' '} << issue;\par
8623     \}\par
8624 \par
8625     {\cf18 void} printExpressionWas() \{\par
8626         {\cf19 if} (result.hasExpression()) \{\par
8627             stream << {\cf23 ';'};\par
8628             \{\par
8629                 stream << colourImpl->guardColour(compactDimColour) << {\cf22 " expression was:"};\par
8630             \}\par
8631             printOriginalExpression();\par
8632         \}\par
8633     \}\par
8634 \par
8635     {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
8636         {\cf19 if} (result.hasExpression()) \{\par
8637             stream << {\cf23 ' '} << result.getExpression();\par
8638         \}\par
8639     \}\par
8640 \par
8641     {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
8642         {\cf19 if} (result.hasExpandedExpression()) \{\par
8643             stream << colourImpl->guardColour(compactDimColour) << {\cf22 " for: "};\par
8644             stream << result.getExpandedExpression();\par
8645         \}\par
8646     \}\par
8647 \par
8648     {\cf18 void} printMessage() \{\par
8649         {\cf19 if} (itMessage != messages.end()) \{\par
8650             stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
8651             ++itMessage;\par
8652         \}\par
8653     \}\par
8654 \par
8655     {\cf18 void} printRemainingMessages(Colour::Code colour = compactDimColour) \{\par
8656         {\cf19 if} (itMessage == messages.end())\par
8657             {\cf19 return};\par
8658 \par
8659         {\cf17 const} {\cf17 auto} itEnd = messages.cend();\par
8660         {\cf17 const} {\cf17 auto} N = {\cf17 static_cast<}std::size_t{\cf17 >}(itEnd - itMessage);\par
8661 \par
8662         stream << colourImpl->guardColour( colour ) << {\cf22 " with "}\par
8663                << pluralise( N, {\cf22 "message"}_sr ) << {\cf23 ':'};\par
8664 \par
8665         {\cf19 while} (itMessage != itEnd) \{\par
8666             {\cf20 // If this assertion is a warning ignore any INFO messages}\par
8667             {\cf19 if} (printInfoMessages || itMessage->type != ResultWas::Info) \{\par
8668                 printMessage();\par
8669                 {\cf19 if} (itMessage != itEnd) \{\par
8670                     stream << colourImpl->guardColour(compactDimColour) << {\cf22 " and"};\par
8671                 \}\par
8672                 {\cf19 continue};\par
8673             \}\par
8674             ++itMessage;\par
8675         \}\par
8676     \}\par
8677 \par
8678 {\cf17 private}:\par
8679     std::ostream& stream;\par
8680     AssertionResult {\cf17 const}& result;\par
8681     std::vector<MessageInfo> {\cf17 const}& messages;\par
8682     std::vector<MessageInfo>::const_iterator itMessage;\par
8683     {\cf18 bool} printInfoMessages;\par
8684     ColourImpl* colourImpl;\par
8685 \};\par
8686 \par
8687 \} {\cf20 // anon namespace}\par
8688 \par
8689         std::string CompactReporter::getDescription() \{\par
8690             {\cf19 return} {\cf22 "Reports test results on a single line, suitable for IDEs"};\par
8691         \}\par
8692 \par
8693         {\cf18 void} CompactReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
8694             m_stream << {\cf22 "No test cases matched '"} << unmatchedSpec << {\cf22 "'\\n"};\par
8695         \}\par
8696 \par
8697         {\cf18 void} CompactReporter::testRunStarting( TestRunInfo {\cf17 const}& ) \{\par
8698             {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
8699                 m_stream << m_colour->guardColour( Colour::BrightYellow )\par
8700                          << {\cf22 "Filters: "}\par
8701                          << m_config->testSpec()\par
8702                          << {\cf23 '\\n'};\par
8703             \}\par
8704             m_stream << {\cf22 "RNG seed: "} << getSeed() << {\cf23 '\\n'};\par
8705         \}\par
8706 \par
8707         {\cf18 void} CompactReporter::assertionEnded( AssertionStats {\cf17 const}& _assertionStats ) \{\par
8708             AssertionResult {\cf17 const}& result = _assertionStats.assertionResult;\par
8709 \par
8710             {\cf18 bool} printInfoMessages = {\cf17 true};\par
8711 \par
8712             {\cf20 // Drop out if result was successful and we're not printing those}\par
8713             {\cf19 if}( !m_config->includeSuccessfulResults() && result.isOk() ) \{\par
8714                 {\cf19 if}( result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip )\par
8715                     {\cf19 return};\par
8716                 printInfoMessages = {\cf17 false};\par
8717             \}\par
8718 \par
8719             AssertionPrinter printer( m_stream, _assertionStats, printInfoMessages, m_colour.get() );\par
8720             printer.print();\par
8721 \par
8722             m_stream << {\cf23 '\\n'} << std::flush;\par
8723         \}\par
8724 \par
8725         {\cf18 void} CompactReporter::sectionEnded(SectionStats {\cf17 const}& _sectionStats) \{\par
8726             {\cf18 double} dur = _sectionStats.durationInSeconds;\par
8727             {\cf19 if} ( shouldShowDuration( *m_config, dur ) ) \{\par
8728                 m_stream << getFormattedDuration( dur ) << {\cf22 " s: "} << _sectionStats.sectionInfo.name << {\cf23 '\\n'} << std::flush;\par
8729             \}\par
8730         \}\par
8731 \par
8732         {\cf18 void} CompactReporter::testRunEnded( TestRunStats {\cf17 const}& _testRunStats ) \{\par
8733             printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\par
8734             m_stream << {\cf22 "\\n\\n"} << std::flush;\par
8735             StreamingReporterBase::testRunEnded( _testRunStats );\par
8736         \}\par
8737 \par
8738         CompactReporter::~CompactReporter() = {\cf19 default};\par
8739 \par
8740 \} {\cf20 // end namespace Catch}\par
8741 \par
8742 \par
8743 \par
8744 \par
8745 {\cf21 #include <cstdio>}\par
8746 \par
8747 {\cf21 #if defined(_MSC_VER)}\par
8748 {\cf21 #pragma warning(push)}\par
8749 {\cf21 #pragma warning(disable:4061) }{\cf20 // Not all labels are EXPLICITLY handled in switch}\par
8750  {\cf20 // Note that 4062 (not all labels are handled and default is missing) is enabled}\par
8751 {\cf21 #endif}\par
8752 \par
8753 {\cf21 #if defined(__clang__)}\par
8754 {\cf21 #  pragma clang diagnostic push}\par
8755 {\cf20 // For simplicity, benchmarking-only helpers are always enabled}\par
8756 {\cf21 #  pragma clang diagnostic ignored "-Wunused-function"}\par
8757 {\cf21 #endif}\par
8758 \par
8759 \par
8760 \par
8761 {\cf17 namespace }Catch \{\par
8762 \par
8763 {\cf17 namespace }\{\par
8764 \par
8765 {\cf20 // Formatter impl for ConsoleReporter}\par
8766 {\cf17 class }ConsoleAssertionPrinter \{\par
8767 {\cf17 public}:\par
8768     ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8769     ConsoleAssertionPrinter(ConsoleAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
8770     ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, ColourImpl* colourImpl_, {\cf18 bool} _printInfoMessages)\par
8771         : stream(_stream),\par
8772         stats(_stats),\par
8773         result(_stats.assertionResult),\par
8774         colour(Colour::None),\par
8775         messages(_stats.infoMessages),\par
8776         colourImpl(colourImpl_),\par
8777         printInfoMessages(_printInfoMessages) \{\par
8778         {\cf19 switch} (result.getResultType()) \{\par
8779         case ResultWas::Ok:\par
8780             colour = Colour::Success;\par
8781             passOrFail = {\cf22 "PASSED"}_sr;\par
8782             {\cf20 //if( result.hasMessage() )}\par
8783             if (messages.size() == 1)\par
8784                 messageLabel = {\cf22 "with message"}_sr;\par
8785             if (messages.size() > 1)\par
8786                 messageLabel = {\cf22 "with messages"}_sr;\par
8787             break;\par
8788         case ResultWas::ExpressionFailed:\par
8789             if (result.isOk()) \{\par
8790                 colour = Colour::Success;\par
8791                 passOrFail = {\cf22 "FAILED - but was ok"}_sr;\par
8792             \} {\cf19 else} \{\par
8793                 colour = Colour::Error;\par
8794                 passOrFail = {\cf22 "FAILED"}_sr;\par
8795             \}\par
8796             if (messages.size() == 1)\par
8797                 messageLabel = {\cf22 "with message"}_sr;\par
8798             if (messages.size() > 1)\par
8799                 messageLabel = {\cf22 "with messages"}_sr;\par
8800             {\cf19 break};\par
8801         {\cf19 case} ResultWas::ThrewException:\par
8802             colour = Colour::Error;\par
8803             passOrFail = {\cf22 "FAILED"}_sr;\par
8804             {\cf20 // todo switch}\par
8805             switch (messages.size()) \{ case 0:\par
8806                 messageLabel = {\cf22 "due to unexpected exception with "}_sr;\par
8807                 break;\par
8808             case 1:\par
8809                 messageLabel = {\cf22 "due to unexpected exception with message"}_sr;\par
8810                 break;\par
8811             default:\par
8812                 messageLabel = {\cf22 "due to unexpected exception with messages"}_sr;\par
8813                 break;\par
8814             \}\par
8815             {\cf19 break};\par
8816         {\cf19 case} ResultWas::FatalErrorCondition:\par
8817             colour = Colour::Error;\par
8818             passOrFail = {\cf22 "FAILED"}_sr;\par
8819             messageLabel = {\cf22 "due to a fatal error condition"}_sr;\par
8820             {\cf19 break};\par
8821         {\cf19 case} ResultWas::DidntThrowException:\par
8822             colour = Colour::Error;\par
8823             passOrFail = {\cf22 "FAILED"}_sr;\par
8824             messageLabel = {\cf22 "because no exception was thrown where one was expected"}_sr;\par
8825             {\cf19 break};\par
8826         {\cf19 case} ResultWas::Info:\par
8827             messageLabel = {\cf22 "info"}_sr;\par
8828             {\cf19 break};\par
8829         {\cf19 case} ResultWas::Warning:\par
8830             messageLabel = {\cf22 "warning"}_sr;\par
8831             {\cf19 break};\par
8832         {\cf19 case} ResultWas::ExplicitFailure:\par
8833             passOrFail = {\cf22 "FAILED"}_sr;\par
8834             colour = Colour::Error;\par
8835             if (messages.size() == 1)\par
8836                 messageLabel = {\cf22 "explicitly with message"}_sr;\par
8837             if (messages.size() > 1)\par
8838                 messageLabel = {\cf22 "explicitly with messages"}_sr;\par
8839             {\cf19 break};\par
8840         {\cf19 case} ResultWas::ExplicitSkip:\par
8841             colour = Colour::Skip;\par
8842             passOrFail = {\cf22 "SKIPPED"}_sr;\par
8843             if (messages.size() == 1)\par
8844                 messageLabel = {\cf22 "explicitly with message"}_sr;\par
8845             if (messages.size() > 1)\par
8846                 messageLabel = {\cf22 "explicitly with messages"}_sr;\par
8847             {\cf19 break};\par
8848             {\cf20 // These cases are here to prevent compiler warnings}\par
8849         {\cf19 case} ResultWas::Unknown:\par
8850         {\cf19 case} ResultWas::FailureBit:\par
8851         {\cf19 case} ResultWas::Exception:\par
8852             passOrFail = {\cf22 "** internal error **"}_sr;\par
8853             colour = Colour::Error;\par
8854             {\cf19 break};\par
8855         \}\par
8856     \}\par
8857 \par
8858     {\cf18 void} print(){\cf17  const }\{\par
8859         printSourceInfo();\par
8860         {\cf19 if} (stats.totals.assertions.total() > 0) \{\par
8861             printResultType();\par
8862             printOriginalExpression();\par
8863             printReconstructedExpression();\par
8864         \} {\cf19 else} \{\par
8865             stream << {\cf23 '\\n'};\par
8866         \}\par
8867         printMessage();\par
8868     \}\par
8869 \par
8870 {\cf17 private}:\par
8871     {\cf18 void} printResultType(){\cf17  const }\{\par
8872         {\cf19 if} (!passOrFail.empty()) \{\par
8873             stream << colourImpl->guardColour(colour) << passOrFail << {\cf22 ":\\n"};\par
8874         \}\par
8875     \}\par
8876     {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
8877         {\cf19 if} (result.hasExpression()) \{\par
8878             stream << colourImpl->guardColour( Colour::OriginalExpression )\par
8879                    << {\cf22 "  "} << result.getExpressionInMacro() << {\cf23 '\\n'};\par
8880         \}\par
8881     \}\par
8882     {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
8883         {\cf19 if} (result.hasExpandedExpression()) \{\par
8884             stream << {\cf22 "with expansion:\\n"};\par
8885             stream << colourImpl->guardColour( Colour::ReconstructedExpression )\par
8886                    << TextFlow::Column( result.getExpandedExpression() )\par
8887                           .indent( 2 )\par
8888                    << {\cf23 '\\n'};\par
8889         \}\par
8890     \}\par
8891     {\cf18 void} printMessage(){\cf17  const }\{\par
8892         {\cf19 if} (!messageLabel.empty())\par
8893             stream << messageLabel << {\cf23 ':'} << {\cf23 '\\n'};\par
8894         {\cf19 for} ({\cf17 auto} {\cf17 const}& msg : messages) \{\par
8895             {\cf20 // If this assertion is a warning ignore any INFO messages}\par
8896             {\cf19 if} (printInfoMessages || msg.type != ResultWas::Info)\par
8897                 stream << TextFlow::Column(msg.message).indent(2) << {\cf23 '\\n'};\par
8898         \}\par
8899     \}\par
8900     {\cf18 void} printSourceInfo(){\cf17  const }\{\par
8901         stream << colourImpl->guardColour( Colour::FileName )\par
8902                << result.getSourceInfo() << {\cf22 ": "};\par
8903     \}\par
8904 \par
8905     std::ostream& stream;\par
8906     AssertionStats {\cf17 const}& stats;\par
8907     AssertionResult {\cf17 const}& result;\par
8908     Colour::Code colour;\par
8909     StringRef passOrFail;\par
8910     StringRef messageLabel;\par
8911     std::vector<MessageInfo> {\cf17 const}& messages;\par
8912     ColourImpl* colourImpl;\par
8913     {\cf18 bool} printInfoMessages;\par
8914 \};\par
8915 \par
8916 std::size_t makeRatio( std::uint64_t number, std::uint64_t total ) \{\par
8917     {\cf17 const} {\cf17 auto} ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;\par
8918     {\cf19 return} (ratio == 0 && number > 0) ? 1 : {\cf17 static_cast<}std::size_t{\cf17 >}(ratio);\par
8919 \}\par
8920 \par
8921 std::size_t&\par
8922 findMax( std::size_t& i, std::size_t& j, std::size_t& k, std::size_t& l ) \{\par
8923     {\cf19 if} (i > j && i > k && i > l)\par
8924         {\cf19 return} i;\par
8925     {\cf19 else} {\cf19 if} (j > k && j > l)\par
8926         {\cf19 return} j;\par
8927     {\cf19 else} {\cf19 if} (k > l)\par
8928         {\cf19 return} k;\par
8929     {\cf19 else}\par
8930         {\cf19 return} l;\par
8931 \}\par
8932 \par
8933 {\cf17 struct }ColumnBreak \{\};\par
8934 {\cf17 struct }RowBreak \{\};\par
8935 {\cf17 struct }OutputFlush \{\};\par
8936 \par
8937 {\cf17 class }Duration \{\par
8938     {\cf17 enum class} Unit \{\par
8939         Auto,\par
8940         Nanoseconds,\par
8941         Microseconds,\par
8942         Milliseconds,\par
8943         Seconds,\par
8944         Minutes\par
8945     \};\par
8946     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMicrosecond = 1000;\par
8947     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;\par
8948     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;\par
8949     {\cf17 static} {\cf17 const} uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;\par
8950 \par
8951     {\cf18 double} m_inNanoseconds;\par
8952     Unit m_units;\par
8953 \par
8954 {\cf17 public}:\par
8955     {\cf17 explicit} Duration({\cf18 double} inNanoseconds, Unit units = Unit::Auto)\par
8956         : m_inNanoseconds(inNanoseconds),\par
8957         m_units(units) \{\par
8958         {\cf19 if} (m_units == Unit::Auto) \{\par
8959             {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMicrosecond)\par
8960                 m_units = Unit::Nanoseconds;\par
8961             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMillisecond)\par
8962                 m_units = Unit::Microseconds;\par
8963             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInASecond)\par
8964                 m_units = Unit::Milliseconds;\par
8965             {\cf19 else} {\cf19 if} (m_inNanoseconds < s_nanosecondsInAMinute)\par
8966                 m_units = Unit::Seconds;\par
8967             {\cf19 else}\par
8968                 m_units = Unit::Minutes;\par
8969         \}\par
8970 \par
8971     \}\par
8972 \par
8973     {\cf17 auto} value() const -> {\cf18 double} \{\par
8974         {\cf19 switch} (m_units) \{\par
8975         {\cf19 case} Unit::Microseconds:\par
8976             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMicrosecond);\par
8977         {\cf19 case} Unit::Milliseconds:\par
8978             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMillisecond);\par
8979         {\cf19 case} Unit::Seconds:\par
8980             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInASecond);\par
8981         {\cf19 case} Unit::Minutes:\par
8982             {\cf19 return} m_inNanoseconds / {\cf17 static_cast<}{\cf18 double}{\cf17 >}(s_nanosecondsInAMinute);\par
8983         {\cf19 default}:\par
8984             {\cf19 return} m_inNanoseconds;\par
8985         \}\par
8986     \}\par
8987     StringRef unitsAsString(){\cf17  const }\{\par
8988         {\cf19 switch} (m_units) \{\par
8989         {\cf19 case} Unit::Nanoseconds:\par
8990             {\cf19 return} {\cf22 "ns"}_sr;\par
8991         {\cf19 case} Unit::Microseconds:\par
8992             {\cf19 return} {\cf22 "us"}_sr;\par
8993         {\cf19 case} Unit::Milliseconds:\par
8994             {\cf19 return} {\cf22 "ms"}_sr;\par
8995         {\cf19 case} Unit::Seconds:\par
8996             {\cf19 return} {\cf22 "s"}_sr;\par
8997         {\cf19 case} Unit::Minutes:\par
8998             {\cf19 return} {\cf22 "m"}_sr;\par
8999         {\cf19 default}:\par
9000             {\cf19 return} {\cf22 "** internal error **"}_sr;\par
9001         \}\par
9002 \par
9003     \}\par
9004     {\cf17 friend} {\cf17 auto} operator << (std::ostream& os, Duration {\cf17 const}& duration) -> std::ostream& \{\par
9005         {\cf19 return} os << duration.value() << {\cf23 ' '} << duration.unitsAsString();\par
9006     \}\par
9007 \};\par
9008 \} {\cf20 // end anon namespace}\par
9009 \par
9010 {\cf17 enum class} Justification \{ Left, Right \};\par
9011 \par
9012 {\cf17 struct }ColumnInfo \{\par
9013     std::string name;\par
9014     std::size_t width;\par
9015     Justification justification;\par
9016 \};\par
9017 \par
9018 {\cf17 class }TablePrinter \{\par
9019     std::ostream& m_os;\par
9020     std::vector<ColumnInfo> m_columnInfos;\par
9021     ReusableStringStream m_oss;\par
9022     {\cf18 int} m_currentColumn = -1;\par
9023     {\cf18 bool} m_isOpen = {\cf17 false};\par
9024 \par
9025 {\cf17 public}:\par
9026     TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )\par
9027     :   m_os( os ),\par
9028         m_columnInfos( CATCH_MOVE( columnInfos ) ) \{\}\par
9029 \par
9030     {\cf17 auto} columnInfos() const -> std::vector<ColumnInfo> const& \{\par
9031         {\cf19 return} m_columnInfos;\par
9032     \}\par
9033 \par
9034     {\cf18 void} open() \{\par
9035         {\cf19 if} (!m_isOpen) \{\par
9036             m_isOpen = {\cf17 true};\par
9037             *{\cf17 this} << RowBreak();\par
9038 \par
9039             TextFlow::Columns headerCols;\par
9040             {\cf19 for} ({\cf17 auto} {\cf17 const}& info : m_columnInfos) \{\par
9041                 assert(info.width > 2);\par
9042                 headerCols += TextFlow::Column(info.name).width(info.width - 2);\par
9043                 headerCols += TextFlow::Spacer( 2 );\par
9044             \}\par
9045             m_os << headerCols << {\cf23 '\\n'};\par
9046 \par
9047             m_os << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
9048         \}\par
9049     \}\par
9050     {\cf18 void} close() \{\par
9051         {\cf19 if} (m_isOpen) \{\par
9052             *{\cf17 this} << RowBreak();\par
9053             m_os << {\cf23 '\\n'} << std::flush;\par
9054             m_isOpen = {\cf17 false};\par
9055         \}\par
9056     \}\par
9057 \par
9058     {\cf17 template}<{\cf17 typename} T>\par
9059     {\cf17 friend} TablePrinter& operator<< (TablePrinter& tp, T {\cf17 const}& value) \{\par
9060         tp.m_oss << value;\par
9061         {\cf19 return} tp;\par
9062     \}\par
9063 \par
9064     {\cf17 friend} TablePrinter& operator<< (TablePrinter& tp, ColumnBreak) \{\par
9065         {\cf17 auto} colStr = tp.m_oss.str();\par
9066         {\cf17 const} {\cf17 auto} strSize = colStr.size();\par
9067         tp.m_oss.str({\cf22 ""});\par
9068         tp.open();\par
9069         {\cf19 if} (tp.m_currentColumn == {\cf17 static_cast<}{\cf18 int}{\cf17 >}(tp.m_columnInfos.size() - 1)) \{\par
9070             tp.m_currentColumn = -1;\par
9071             tp.m_os << {\cf23 '\\n'};\par
9072         \}\par
9073         tp.m_currentColumn++;\par
9074 \par
9075         {\cf17 auto} colInfo = tp.m_columnInfos[tp.m_currentColumn];\par
9076         {\cf17 auto} padding = (strSize + 1 < colInfo.width)\par
9077             ? std::string(colInfo.width - (strSize + 1), {\cf23 ' '})\par
9078             : std::string();\par
9079         {\cf19 if} (colInfo.justification == Justification::Left)\par
9080             tp.m_os << colStr << padding << {\cf23 ' '};\par
9081         {\cf19 else}\par
9082             tp.m_os << padding << colStr << {\cf23 ' '};\par
9083         {\cf19 return} tp;\par
9084     \}\par
9085 \par
9086     {\cf17 friend} TablePrinter& operator<< (TablePrinter& tp, RowBreak) \{\par
9087         {\cf19 if} (tp.m_currentColumn > 0) \{\par
9088             tp.m_os << {\cf23 '\\n'};\par
9089             tp.m_currentColumn = -1;\par
9090         \}\par
9091         {\cf19 return} tp;\par
9092     \}\par
9093 \par
9094     {\cf17 friend} TablePrinter& operator<<(TablePrinter& tp, OutputFlush) \{\par
9095         tp.m_os << std::flush;\par
9096         {\cf19 return} tp;\par
9097     \}\par
9098 \};\par
9099 \par
9100 ConsoleReporter::ConsoleReporter(ReporterConfig&& config):\par
9101     StreamingReporterBase( CATCH_MOVE( config ) ),\par
9102     m_tablePrinter(Detail::make_unique<TablePrinter>(m_stream,\par
9103         [&config]() -> std::vector<ColumnInfo> \{\par
9104         {\cf19 if} (config.fullConfig()->benchmarkNoAnalysis())\par
9105         \{\par
9106             return\{\par
9107                 \{ {\cf22 "benchmark name"}, CATCH_CONFIG_CONSOLE_WIDTH - 43, Justification::Left \},\par
9108                 \{ {\cf22 "     samples"}, 14, Justification::Right \},\par
9109                 \{ {\cf22 "  iterations"}, 14, Justification::Right \},\par
9110                 \{ {\cf22 "        mean"}, 14, Justification::Right \}\par
9111             \};\par
9112         \}\par
9113         {\cf19 else}\par
9114         \{\par
9115             {\cf19 return}\{\par
9116                 \{ {\cf22 "benchmark name"}, CATCH_CONFIG_CONSOLE_WIDTH - 43, Justification::Left \},\par
9117                 \{ {\cf22 "samples      mean       std dev"}, 14, Justification::Right \},\par
9118                 \{ {\cf22 "iterations   low mean   low std dev"}, 14, Justification::Right \},\par
9119                 \{ {\cf22 "est run time high mean  high std dev"}, 14, Justification::Right \}\par
9120             \};\par
9121         \}\par
9122     \}())) \{\}\par
9123 ConsoleReporter::~ConsoleReporter() = {\cf19 default};\par
9124 \par
9125 std::string ConsoleReporter::getDescription() \{\par
9126     {\cf19 return} {\cf22 "Reports test results as plain lines of text"};\par
9127 \}\par
9128 \par
9129 {\cf18 void} ConsoleReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
9130     m_stream << {\cf22 "No test cases matched '"} << unmatchedSpec << {\cf22 "'\\n"};\par
9131 \}\par
9132 \par
9133 {\cf18 void} ConsoleReporter::reportInvalidTestSpec( StringRef arg ) \{\par
9134     m_stream << {\cf22 "Invalid Filter: "} << arg << {\cf23 '\\n'};\par
9135 \}\par
9136 \par
9137 {\cf18 void} ConsoleReporter::assertionStarting(AssertionInfo {\cf17 const}&) \{\}\par
9138 \par
9139 {\cf18 void} ConsoleReporter::assertionEnded(AssertionStats {\cf17 const}& _assertionStats) \{\par
9140     AssertionResult {\cf17 const}& result = _assertionStats.assertionResult;\par
9141 \par
9142     {\cf18 bool} includeResults = m_config->includeSuccessfulResults() || !result.isOk();\par
9143 \par
9144     {\cf20 // Drop out if result was successful but we're not printing them.}\par
9145     {\cf20 // TODO: Make configurable whether skips should be printed}\par
9146     {\cf19 if} (!includeResults && result.getResultType() != ResultWas::Warning && result.getResultType() != ResultWas::ExplicitSkip)\par
9147         {\cf19 return};\par
9148 \par
9149     lazyPrint();\par
9150 \par
9151     ConsoleAssertionPrinter printer(m_stream, _assertionStats, m_colour.get(), includeResults);\par
9152     printer.print();\par
9153     m_stream << {\cf23 '\\n'} << std::flush;\par
9154 \}\par
9155 \par
9156 {\cf18 void} ConsoleReporter::sectionStarting(SectionInfo {\cf17 const}& _sectionInfo) \{\par
9157     m_tablePrinter->close();\par
9158     m_headerPrinted = {\cf17 false};\par
9159     StreamingReporterBase::sectionStarting(_sectionInfo);\par
9160 \}\par
9161 {\cf18 void} ConsoleReporter::sectionEnded(SectionStats {\cf17 const}& _sectionStats) \{\par
9162     m_tablePrinter->close();\par
9163     {\cf19 if} (_sectionStats.missingAssertions) \{\par
9164         lazyPrint();\par
9165         {\cf17 auto} guard =\par
9166             m_colour->guardColour( Colour::ResultError ).engage( m_stream );\par
9167         {\cf19 if} (m_sectionStack.size() > 1)\par
9168             m_stream << {\cf22 "\\nNo assertions in section"};\par
9169         {\cf19 else}\par
9170             m_stream << {\cf22 "\\nNo assertions in test case"};\par
9171         m_stream << {\cf22 " '"} << _sectionStats.sectionInfo.name << {\cf22 "'\\n\\n"} << std::flush;\par
9172     \}\par
9173     {\cf18 double} dur = _sectionStats.durationInSeconds;\par
9174     {\cf19 if} (shouldShowDuration(*m_config, dur)) \{\par
9175         m_stream << getFormattedDuration(dur) << {\cf22 " s: "} << _sectionStats.sectionInfo.name << {\cf23 '\\n'} << std::flush;\par
9176     \}\par
9177     {\cf19 if} (m_headerPrinted) \{\par
9178         m_headerPrinted = {\cf17 false};\par
9179     \}\par
9180     StreamingReporterBase::sectionEnded(_sectionStats);\par
9181 \}\par
9182 \par
9183 {\cf18 void} ConsoleReporter::benchmarkPreparing( StringRef name ) \{\par
9184     lazyPrintWithoutClosingBenchmarkTable();\par
9185 \par
9186     {\cf17 auto} nameCol = TextFlow::Column( {\cf17 static_cast<}std::string{\cf17 >}( name ) )\par
9187                        .width( m_tablePrinter->columnInfos()[0].width - 2 );\par
9188 \par
9189     {\cf18 bool} firstLine = {\cf17 true};\par
9190     {\cf19 for} ({\cf17 auto} line : nameCol) \{\par
9191         {\cf19 if} (!firstLine)\par
9192             (*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();\par
9193         {\cf19 else}\par
9194             firstLine = {\cf17 false};\par
9195 \par
9196         (*m_tablePrinter) << line << ColumnBreak();\par
9197     \}\par
9198 \}\par
9199 \par
9200 {\cf18 void} ConsoleReporter::benchmarkStarting(BenchmarkInfo {\cf17 const}& info) \{\par
9201     (*m_tablePrinter) << info.samples << ColumnBreak()\par
9202         << info.iterations << ColumnBreak();\par
9203     {\cf19 if} ( !m_config->benchmarkNoAnalysis() ) \{\par
9204         ( *m_tablePrinter )\par
9205             << Duration( info.estimatedDuration ) << ColumnBreak();\par
9206     \}\par
9207     ( *m_tablePrinter ) << OutputFlush\{\};\par
9208 \}\par
9209 {\cf18 void} ConsoleReporter::benchmarkEnded(BenchmarkStats<> {\cf17 const}& stats) \{\par
9210     {\cf19 if} (m_config->benchmarkNoAnalysis())\par
9211     \{\par
9212         (*m_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();\par
9213     \}\par
9214     {\cf19 else}\par
9215     \{\par
9216         (*m_tablePrinter) << ColumnBreak()\par
9217             << Duration(stats.mean.point.count()) << ColumnBreak()\par
9218             << Duration(stats.mean.lower_bound.count()) << ColumnBreak()\par
9219             << Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()\par
9220             << Duration(stats.standardDeviation.point.count()) << ColumnBreak()\par
9221             << Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()\par
9222             << Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();\par
9223     \}\par
9224 \}\par
9225 \par
9226 {\cf18 void} ConsoleReporter::benchmarkFailed( StringRef error ) \{\par
9227     {\cf17 auto} guard = m_colour->guardColour( Colour::Red ).engage( m_stream );\par
9228     (*m_tablePrinter)\par
9229         << {\cf22 "Benchmark failed ("} << error << {\cf23 ')'}\par
9230         << ColumnBreak() << RowBreak();\par
9231 \}\par
9232 \par
9233 {\cf18 void} ConsoleReporter::testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) \{\par
9234     m_tablePrinter->close();\par
9235     StreamingReporterBase::testCaseEnded(_testCaseStats);\par
9236     m_headerPrinted = {\cf17 false};\par
9237 \}\par
9238 {\cf18 void} ConsoleReporter::testRunEnded(TestRunStats {\cf17 const}& _testRunStats) \{\par
9239     printTotalsDivider(_testRunStats.totals);\par
9240     printTestRunTotals( m_stream, *m_colour, _testRunStats.totals );\par
9241     m_stream << {\cf23 '\\n'} << std::flush;\par
9242     StreamingReporterBase::testRunEnded(_testRunStats);\par
9243 \}\par
9244 {\cf18 void} ConsoleReporter::testRunStarting(TestRunInfo {\cf17 const}& _testRunInfo) \{\par
9245     StreamingReporterBase::testRunStarting(_testRunInfo);\par
9246     {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
9247         m_stream << m_colour->guardColour( Colour::BrightYellow ) << {\cf22 "Filters: "}\par
9248                  << m_config->testSpec() << {\cf23 '\\n'};\par
9249     \}\par
9250     m_stream << {\cf22 "Randomness seeded to: "} << getSeed() << {\cf23 '\\n'};\par
9251 \}\par
9252 \par
9253 {\cf18 void} ConsoleReporter::lazyPrint() \{\par
9254 \par
9255     m_tablePrinter->close();\par
9256     lazyPrintWithoutClosingBenchmarkTable();\par
9257 \}\par
9258 \par
9259 {\cf18 void} ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() \{\par
9260 \par
9261     {\cf19 if} ( !m_testRunInfoPrinted ) \{\par
9262         lazyPrintRunInfo();\par
9263     \}\par
9264     {\cf19 if} (!m_headerPrinted) \{\par
9265         printTestCaseAndSectionHeader();\par
9266         m_headerPrinted = {\cf17 true};\par
9267     \}\par
9268 \}\par
9269 {\cf18 void} ConsoleReporter::lazyPrintRunInfo() \{\par
9270     m_stream << {\cf23 '\\n'}\par
9271              << lineOfChars( {\cf23 '~'} ) << {\cf23 '\\n'}\par
9272              << m_colour->guardColour( Colour::SecondaryText )\par
9273              << currentTestRunInfo.name << {\cf22 " is a Catch2 v"} << libraryVersion()\par
9274              << {\cf22 " host application.\\n"}\par
9275              << {\cf22 "Run with -? for options\\n\\n"};\par
9276 \par
9277     m_testRunInfoPrinted = {\cf17 true};\par
9278 \}\par
9279 {\cf18 void} ConsoleReporter::printTestCaseAndSectionHeader() \{\par
9280     assert(!m_sectionStack.empty());\par
9281     printOpenHeader(currentTestCaseInfo->name);\par
9282 \par
9283     {\cf19 if} (m_sectionStack.size() > 1) \{\par
9284         {\cf17 auto} guard = m_colour->guardColour( Colour::Headers ).engage( m_stream );\par
9285 \par
9286         {\cf17 auto}\par
9287             it = m_sectionStack.begin() + 1, {\cf20 // Skip first section (test case)}\par
9288             itEnd = m_sectionStack.end();\par
9289         {\cf19 for} (; it != itEnd; ++it)\par
9290             printHeaderString(it->name, 2);\par
9291     \}\par
9292 \par
9293     SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;\par
9294 \par
9295 \par
9296     m_stream << lineOfChars( {\cf23 '-'} ) << {\cf23 '\\n'}\par
9297              << m_colour->guardColour( Colour::FileName ) << lineInfo << {\cf23 '\\n'}\par
9298              << lineOfChars( {\cf23 '.'} ) << {\cf22 "\\n\\n"}\par
9299              << std::flush;\par
9300 \}\par
9301 \par
9302 {\cf18 void} ConsoleReporter::printClosedHeader(std::string {\cf17 const}& _name) \{\par
9303     printOpenHeader(_name);\par
9304     m_stream << lineOfChars({\cf23 '.'}) << {\cf23 '\\n'};\par
9305 \}\par
9306 {\cf18 void} ConsoleReporter::printOpenHeader(std::string {\cf17 const}& _name) \{\par
9307     m_stream << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
9308     \{\par
9309         {\cf17 auto} guard = m_colour->guardColour( Colour::Headers ).engage( m_stream );\par
9310         printHeaderString(_name);\par
9311     \}\par
9312 \}\par
9313 \par
9314 {\cf18 void} ConsoleReporter::printHeaderString(std::string {\cf17 const}& _string, std::size_t indent) \{\par
9315     {\cf20 // We want to get a bit fancy with line breaking here, so that subsequent}\par
9316     {\cf20 // lines start after ":" if one is present, e.g.}\par
9317     {\cf20 // ```}\par
9318     {\cf20 // blablabla: Fancy}\par
9319     {\cf20 //            linebreaking}\par
9320     {\cf20 // ```}\par
9321     {\cf20 // but we also want to avoid problems with overly long indentation causing}\par
9322     {\cf20 // the text to take up too many lines, e.g.}\par
9323     {\cf20 // ```}\par
9324     {\cf20 // blablabla: F}\par
9325     {\cf20 //            a}\par
9326     {\cf20 //            n}\par
9327     {\cf20 //            c}\par
9328     {\cf20 //            y}\par
9329     {\cf20 //            .}\par
9330     {\cf20 //            .}\par
9331     {\cf20 //            .}\par
9332     {\cf20 // ```}\par
9333     {\cf20 // So we limit the prefix indentation check to first quarter of the possible}\par
9334     {\cf20 // width}\par
9335     std::size_t idx = _string.find( {\cf22 ": "} );\par
9336     {\cf19 if} ( idx != std::string::npos && idx < CATCH_CONFIG_CONSOLE_WIDTH / 4 ) \{\par
9337         idx += 2;\par
9338     \} {\cf19 else} \{\par
9339         idx = 0;\par
9340     \}\par
9341     m_stream << TextFlow::Column( _string )\par
9342                   .indent( indent + idx )\par
9343                   .initialIndent( indent )\par
9344            << {\cf23 '\\n'};\par
9345 \}\par
9346 \par
9347 {\cf18 void} ConsoleReporter::printTotalsDivider(Totals {\cf17 const}& totals) \{\par
9348     {\cf19 if} (totals.testCases.total() > 0) \{\par
9349         std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());\par
9350         std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());\par
9351         std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());\par
9352         std::size_t skippedRatio = makeRatio(totals.testCases.skipped, totals.testCases.total());\par
9353         {\cf19 while} (failedRatio + failedButOkRatio + passedRatio + skippedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)\par
9354             findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)++;\par
9355         {\cf19 while} (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)\par
9356             findMax(failedRatio, failedButOkRatio, passedRatio, skippedRatio)--;\par
9357 \par
9358         m_stream << m_colour->guardColour( Colour::Error )\par
9359                  << std::string( failedRatio, {\cf23 '='} )\par
9360                  << m_colour->guardColour( Colour::ResultExpectedFailure )\par
9361                  << std::string( failedButOkRatio, {\cf23 '='} );\par
9362         {\cf19 if} ( totals.testCases.allPassed() ) \{\par
9363             m_stream << m_colour->guardColour( Colour::ResultSuccess )\par
9364                      << std::string( passedRatio, {\cf23 '='} );\par
9365         \} {\cf19 else} \{\par
9366             m_stream << m_colour->guardColour( Colour::Success )\par
9367                      << std::string( passedRatio, {\cf23 '='} );\par
9368         \}\par
9369         m_stream << m_colour->guardColour( Colour::Skip )\par
9370                  << std::string( skippedRatio, {\cf23 '='} );\par
9371     \} {\cf19 else} \{\par
9372         m_stream << m_colour->guardColour( Colour::Warning )\par
9373                  << std::string( CATCH_CONFIG_CONSOLE_WIDTH - 1, {\cf23 '='} );\par
9374     \}\par
9375     m_stream << {\cf23 '\\n'};\par
9376 \}\par
9377 \par
9378 \} {\cf20 // end namespace Catch}\par
9379 \par
9380 {\cf21 #if defined(_MSC_VER)}\par
9381 {\cf21 #pragma warning(pop)}\par
9382 {\cf21 #endif}\par
9383 \par
9384 {\cf21 #if defined(__clang__)}\par
9385 {\cf21 #  pragma clang diagnostic pop}\par
9386 {\cf21 #endif}\par
9387 \par
9388 \par
9389 \par
9390 \par
9391 {\cf21 #include <algorithm>}\par
9392 {\cf21 #include <cassert>}\par
9393 \par
9394 {\cf17 namespace }Catch \{\par
9395     {\cf17 namespace }\{\par
9396         {\cf17 struct }BySectionInfo \{\par
9397             BySectionInfo( SectionInfo {\cf17 const}& other ): m_other( other ) \{\}\par
9398             BySectionInfo( BySectionInfo {\cf17 const}& other ) = {\cf19 default};\par
9399             {\cf18 bool} operator()(\par
9400                 Detail::unique_ptr<CumulativeReporterBase::SectionNode> {\cf17 const}&\par
9401                     node ){\cf17  const }\{\par
9402                 {\cf19 return} (\par
9403                     ( node->stats.sectionInfo.name == m_other.name ) &&\par
9404                     ( node->stats.sectionInfo.lineInfo == m_other.lineInfo ) );\par
9405             \}\par
9406             {\cf18 void} operator=( BySectionInfo {\cf17 const}& ) = {\cf17 delete};\par
9407 \par
9408         {\cf17 private}:\par
9409             SectionInfo {\cf17 const}& m_other;\par
9410         \};\par
9411 \par
9412     \} {\cf20 // namespace}\par
9413 \par
9414     {\cf17 namespace }Detail \{\par
9415         AssertionOrBenchmarkResult::AssertionOrBenchmarkResult(\par
9416             AssertionStats {\cf17 const}& assertion ):\par
9417             m_assertion( assertion ) \{\}\par
9418 \par
9419         AssertionOrBenchmarkResult::AssertionOrBenchmarkResult(\par
9420             BenchmarkStats<> {\cf17 const}& benchmark ):\par
9421             m_benchmark( benchmark ) \{\}\par
9422 \par
9423         {\cf18 bool} AssertionOrBenchmarkResult::isAssertion(){\cf17  const }\{\par
9424             {\cf19 return} m_assertion.some();\par
9425         \}\par
9426         {\cf18 bool} AssertionOrBenchmarkResult::isBenchmark(){\cf17  const }\{\par
9427             {\cf19 return} m_benchmark.some();\par
9428         \}\par
9429 \par
9430         AssertionStats {\cf17 const}& AssertionOrBenchmarkResult::asAssertion(){\cf17  const }\{\par
9431             assert(m_assertion.some());\par
9432 \par
9433             {\cf19 return} *m_assertion;\par
9434         \}\par
9435         BenchmarkStats<> {\cf17 const}& AssertionOrBenchmarkResult::asBenchmark(){\cf17  const }\{\par
9436             assert(m_benchmark.some());\par
9437 \par
9438             {\cf19 return} *m_benchmark;\par
9439         \}\par
9440 \par
9441     \}\par
9442 \par
9443     CumulativeReporterBase::~CumulativeReporterBase() = {\cf19 default};\par
9444 \par
9445     {\cf18 void} CumulativeReporterBase::benchmarkEnded(BenchmarkStats<> {\cf17 const}& benchmarkStats) \{\par
9446         m_sectionStack.back()->assertionsAndBenchmarks.emplace_back(benchmarkStats);\par
9447     \}\par
9448 \par
9449     {\cf18 void}\par
9450     CumulativeReporterBase::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
9451         {\cf20 // We need a copy, because SectionStats expect to take ownership}\par
9452         SectionStats incompleteStats( SectionInfo(sectionInfo), Counts(), 0, {\cf17 false} );\par
9453         SectionNode* node;\par
9454         {\cf19 if} ( m_sectionStack.empty() ) \{\par
9455             {\cf19 if} ( !m_rootSection ) \{\par
9456                 m_rootSection =\par
9457                     Detail::make_unique<SectionNode>( incompleteStats );\par
9458             \}\par
9459             node = m_rootSection.get();\par
9460         \} {\cf19 else} \{\par
9461             SectionNode& parentNode = *m_sectionStack.back();\par
9462             {\cf17 auto} it = std::find_if( parentNode.childSections.begin(),\par
9463                                     parentNode.childSections.end(),\par
9464                                     BySectionInfo( sectionInfo ) );\par
9465             {\cf19 if} ( it == parentNode.childSections.end() ) \{\par
9466                 {\cf17 auto} newNode =\par
9467                     Detail::make_unique<SectionNode>( incompleteStats );\par
9468                 node = newNode.get();\par
9469                 parentNode.childSections.push_back( CATCH_MOVE( newNode ) );\par
9470             \} {\cf19 else} \{\par
9471                 node = it->get();\par
9472             \}\par
9473         \}\par
9474 \par
9475         m_deepestSection = node;\par
9476         m_sectionStack.push_back( node );\par
9477     \}\par
9478 \par
9479     {\cf18 void} CumulativeReporterBase::assertionEnded(\par
9480         AssertionStats {\cf17 const}& assertionStats ) \{\par
9481         assert( !m_sectionStack.empty() );\par
9482         {\cf20 // AssertionResult holds a pointer to a temporary DecomposedExpression,}\par
9483         {\cf20 // which getExpandedExpression() calls to build the expression string.}\par
9484         {\cf20 // Our section stack copy of the assertionResult will likely outlive the}\par
9485         {\cf20 // temporary, so it must be expanded or discarded now to avoid calling}\par
9486         {\cf20 // a destroyed object later.}\par
9487         {\cf19 if} ( m_shouldStoreFailedAssertions &&\par
9488              !assertionStats.assertionResult.isOk() ) \{\par
9489             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(\par
9490                 assertionStats.assertionResult.getExpandedExpression() );\par
9491         \}\par
9492         {\cf19 if} ( m_shouldStoreSuccesfulAssertions &&\par
9493              assertionStats.assertionResult.isOk() ) \{\par
9494             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(\par
9495                 assertionStats.assertionResult.getExpandedExpression() );\par
9496         \}\par
9497         SectionNode& sectionNode = *m_sectionStack.back();\par
9498         sectionNode.assertionsAndBenchmarks.emplace_back( assertionStats );\par
9499     \}\par
9500 \par
9501     {\cf18 void} CumulativeReporterBase::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
9502         assert( !m_sectionStack.empty() );\par
9503         SectionNode& node = *m_sectionStack.back();\par
9504         node.stats = sectionStats;\par
9505         m_sectionStack.pop_back();\par
9506     \}\par
9507 \par
9508     {\cf18 void} CumulativeReporterBase::testCaseEnded(\par
9509         TestCaseStats {\cf17 const}& testCaseStats ) \{\par
9510         {\cf17 auto} node = Detail::make_unique<TestCaseNode>( testCaseStats );\par
9511         assert( m_sectionStack.size() == 0 );\par
9512         node->children.push_back( CATCH_MOVE(m_rootSection) );\par
9513         m_testCases.push_back( CATCH_MOVE(node) );\par
9514 \par
9515         assert( m_deepestSection );\par
9516         m_deepestSection->stdOut = testCaseStats.stdOut;\par
9517         m_deepestSection->stdErr = testCaseStats.stdErr;\par
9518     \}\par
9519 \par
9520 \par
9521     {\cf18 void} CumulativeReporterBase::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
9522         assert(!m_testRun && {\cf22 "CumulativeReporterBase assumes there can only be one test run"});\par
9523         m_testRun = Detail::make_unique<TestRunNode>( testRunStats );\par
9524         m_testRun->children.swap( m_testCases );\par
9525         testRunEndedCumulative();\par
9526     \}\par
9527 \par
9528     {\cf18 bool} CumulativeReporterBase::SectionNode::hasAnyAssertions(){\cf17  const }\{\par
9529         {\cf19 return} std::any_of(\par
9530             assertionsAndBenchmarks.begin(),\par
9531             assertionsAndBenchmarks.end(),\par
9532             []( Detail::AssertionOrBenchmarkResult {\cf17 const}& res ) \{\par
9533                 return res.isAssertion();\par
9534             \} );\par
9535     \}\par
9536 \par
9537 \} {\cf20 // end namespace Catch}\par
9538 \par
9539 \par
9540 \par
9541 \par
9542 {\cf17 namespace }Catch \{\par
9543 \par
9544     {\cf18 void} EventListenerBase::fatalErrorEncountered( StringRef ) \{\}\par
9545 \par
9546     {\cf18 void} EventListenerBase::benchmarkPreparing( StringRef ) \{\}\par
9547     {\cf18 void} EventListenerBase::benchmarkStarting( BenchmarkInfo {\cf17 const}& ) \{\}\par
9548     {\cf18 void} EventListenerBase::benchmarkEnded( BenchmarkStats<> {\cf17 const}& ) \{\}\par
9549     {\cf18 void} EventListenerBase::benchmarkFailed( StringRef ) \{\}\par
9550 \par
9551     {\cf18 void} EventListenerBase::assertionStarting( AssertionInfo {\cf17 const}& ) \{\}\par
9552 \par
9553     {\cf18 void} EventListenerBase::assertionEnded( AssertionStats {\cf17 const}& ) \{\}\par
9554     {\cf18 void} EventListenerBase::listReporters(\par
9555         std::vector<ReporterDescription> {\cf17 const}& ) \{\}\par
9556     {\cf18 void} EventListenerBase::listListeners(\par
9557         std::vector<ListenerDescription> {\cf17 const}& ) \{\}\par
9558     {\cf18 void} EventListenerBase::listTests( std::vector<TestCaseHandle> {\cf17 const}& ) \{\}\par
9559     {\cf18 void} EventListenerBase::listTags( std::vector<TagInfo> {\cf17 const}& ) \{\}\par
9560     {\cf18 void} EventListenerBase::noMatchingTestCases( StringRef ) \{\}\par
9561     {\cf18 void} EventListenerBase::reportInvalidTestSpec( StringRef ) \{\}\par
9562     {\cf18 void} EventListenerBase::testRunStarting( TestRunInfo {\cf17 const}& ) \{\}\par
9563     {\cf18 void} EventListenerBase::testCaseStarting( TestCaseInfo {\cf17 const}& ) \{\}\par
9564     {\cf18 void} EventListenerBase::testCasePartialStarting(TestCaseInfo {\cf17 const}&, uint64_t) \{\}\par
9565     {\cf18 void} EventListenerBase::sectionStarting( SectionInfo {\cf17 const}& ) \{\}\par
9566     {\cf18 void} EventListenerBase::sectionEnded( SectionStats {\cf17 const}& ) \{\}\par
9567     {\cf18 void} EventListenerBase::testCasePartialEnded(TestCaseStats {\cf17 const}&, uint64_t) \{\}\par
9568     {\cf18 void} EventListenerBase::testCaseEnded( TestCaseStats {\cf17 const}& ) \{\}\par
9569     {\cf18 void} EventListenerBase::testRunEnded( TestRunStats {\cf17 const}& ) \{\}\par
9570     {\cf18 void} EventListenerBase::skipTest( TestCaseInfo {\cf17 const}& ) \{\}\par
9571 \} {\cf20 // namespace Catch}\par
9572 \par
9573 \par
9574 \par
9575 \par
9576 {\cf21 #include <algorithm>}\par
9577 {\cf21 #include <cfloat>}\par
9578 {\cf21 #include <cstdio>}\par
9579 {\cf21 #include <ostream>}\par
9580 {\cf21 #include <iomanip>}\par
9581 \par
9582 {\cf17 namespace }Catch \{\par
9583 \par
9584     {\cf17 namespace }\{\par
9585         {\cf18 void} listTestNamesOnly(std::ostream& out,\par
9586                                std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
9587             {\cf19 for} ({\cf17 auto} {\cf17 const}& test : tests) \{\par
9588                 {\cf17 auto} {\cf17 const}& testCaseInfo = test.getTestCaseInfo();\par
9589 \par
9590                 {\cf19 if} (startsWith(testCaseInfo.name, {\cf23 '#'})) \{\par
9591                     out << {\cf23 '"'} << testCaseInfo.name << {\cf23 '"'};\par
9592                 \} {\cf19 else} \{\par
9593                     out << testCaseInfo.name;\par
9594                 \}\par
9595 \par
9596                 out << {\cf23 '\\n'};\par
9597             \}\par
9598             out << std::flush;\par
9599         \}\par
9600     \} {\cf20 // end unnamed namespace}\par
9601 \par
9602 \par
9603     {\cf20 // Because formatting using c++ streams is stateful, drop down to C is}\par
9604     {\cf20 // required Alternatively we could use stringstream, but its performance}\par
9605     {\cf20 // is... not good.}\par
9606     std::string getFormattedDuration( {\cf18 double} duration ) \{\par
9607         {\cf20 // Max exponent + 1 is required to represent the whole part}\par
9608         {\cf20 // + 1 for decimal point}\par
9609         {\cf20 // + 3 for the 3 decimal places}\par
9610         {\cf20 // + 1 for null terminator}\par
9611         {\cf17 const} std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;\par
9612         {\cf18 char} buffer[maxDoubleSize];\par
9613 \par
9614         {\cf20 // Save previous errno, to prevent sprintf from overwriting it}\par
9615         ErrnoGuard guard;\par
9616 {\cf21 #ifdef _MSC_VER}\par
9617         {\cf18 size_t} printedLength = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
9618             sprintf_s( buffer, {\cf22 "%.3f"}, duration ) );\par
9619 {\cf21 #else}\par
9620         {\cf18 size_t} printedLength = {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
9621             std::snprintf( buffer, maxDoubleSize, {\cf22 "%.3f"}, duration ) );\par
9622 {\cf21 #endif}\par
9623         {\cf19 return} std::string( buffer, printedLength );\par
9624     \}\par
9625 \par
9626     {\cf18 bool} shouldShowDuration( IConfig {\cf17 const}& config, {\cf18 double} duration ) \{\par
9627         {\cf19 if} ( config.showDurations() == ShowDurations::Always ) \{\par
9628             {\cf19 return} {\cf17 true};\par
9629         \}\par
9630         {\cf19 if} ( config.showDurations() == ShowDurations::Never ) \{\par
9631             {\cf19 return} {\cf17 false};\par
9632         \}\par
9633         {\cf17 const} {\cf18 double} min = config.minDuration();\par
9634         {\cf19 return} min >= 0 && duration >= min;\par
9635     \}\par
9636 \par
9637     std::string serializeFilters( std::vector<std::string> {\cf17 const}& filters ) \{\par
9638         {\cf20 // We add a ' ' separator between each filter}\par
9639         {\cf18 size_t} serialized_size = filters.size() - 1;\par
9640         {\cf19 for} ({\cf17 auto} {\cf17 const}& filter : filters) \{\par
9641             serialized_size += filter.size();\par
9642         \}\par
9643 \par
9644         std::string serialized;\par
9645         serialized.reserve(serialized_size);\par
9646         {\cf18 bool} first = {\cf17 true};\par
9647 \par
9648         {\cf19 for} ({\cf17 auto} {\cf17 const}& filter : filters) \{\par
9649             {\cf19 if} (!first) \{\par
9650                 serialized.push_back({\cf23 ' '});\par
9651             \}\par
9652             first = {\cf17 false};\par
9653             serialized.append(filter);\par
9654         \}\par
9655 \par
9656         {\cf19 return} serialized;\par
9657     \}\par
9658 \par
9659     std::ostream& operator<<( std::ostream& out, lineOfChars value ) \{\par
9660         {\cf19 for} ( {\cf18 size_t} idx = 0; idx < CATCH_CONFIG_CONSOLE_WIDTH - 1; ++idx ) \{\par
9661             out.put( value.c );\par
9662         \}\par
9663         {\cf19 return} out;\par
9664     \}\par
9665 \par
9666     {\cf18 void}\par
9667     defaultListReporters( std::ostream& out,\par
9668                           std::vector<ReporterDescription> {\cf17 const}& descriptions,\par
9669                           Verbosity verbosity ) \{\par
9670         out << {\cf22 "Available reporters:\\n"};\par
9671         {\cf17 const} {\cf17 auto} maxNameLen =\par
9672             std::max_element( descriptions.begin(),\par
9673                               descriptions.end(),\par
9674                               []( ReporterDescription {\cf17 const}& lhs,\par
9675                                   ReporterDescription {\cf17 const}& rhs ) \{\par
9676                                   return lhs.name.size() < rhs.name.size();\par
9677                               \} )\par
9678                 ->name.size();\par
9679 \par
9680         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
9681             {\cf19 if} ( verbosity == Verbosity::Quiet ) \{\par
9682                 out << TextFlow::Column( desc.name )\par
9683                            .indent( 2 )\par
9684                            .width( 5 + maxNameLen )\par
9685                     << {\cf23 '\\n'};\par
9686             \} {\cf19 else} \{\par
9687                 out << TextFlow::Column( desc.name + {\cf23 ':'} )\par
9688                                .indent( 2 )\par
9689                                .width( 5 + maxNameLen ) +\par
9690                            TextFlow::Column( desc.description )\par
9691                                .initialIndent( 0 )\par
9692                                .indent( 2 )\par
9693                                .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\par
9694                     << {\cf23 '\\n'};\par
9695             \}\par
9696         \}\par
9697         out << {\cf23 '\\n'} << std::flush;\par
9698     \}\par
9699 \par
9700     {\cf18 void} defaultListListeners( std::ostream& out,\par
9701                                std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
9702         out << {\cf22 "Registered listeners:\\n"};\par
9703 \par
9704         {\cf19 if}(descriptions.empty()) \{\par
9705             {\cf19 return};\par
9706         \}\par
9707 \par
9708         {\cf17 const} {\cf17 auto} maxNameLen =\par
9709             std::max_element( descriptions.begin(),\par
9710                               descriptions.end(),\par
9711                               []( ListenerDescription {\cf17 const}& lhs,\par
9712                                   ListenerDescription {\cf17 const}& rhs ) \{\par
9713                                   return lhs.name.size() < rhs.name.size();\par
9714                               \} )\par
9715                 ->name.size();\par
9716 \par
9717         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
9718             out << TextFlow::Column( static_cast<std::string>( desc.name ) +\par
9719                                      {\cf23 ':'} )\par
9720                            .indent( 2 )\par
9721                            .width( maxNameLen + 5 ) +\par
9722                        TextFlow::Column( desc.description )\par
9723                            .initialIndent( 0 )\par
9724                            .indent( 2 )\par
9725                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8 )\par
9726                 << {\cf23 '\\n'};\par
9727         \}\par
9728 \par
9729         out << {\cf23 '\\n'} << std::flush;\par
9730     \}\par
9731 \par
9732     {\cf18 void} defaultListTags( std::ostream& out,\par
9733                           std::vector<TagInfo> {\cf17 const}& tags,\par
9734                           {\cf18 bool} isFiltered ) \{\par
9735         {\cf19 if} ( isFiltered ) \{\par
9736             out << {\cf22 "Tags for matching test cases:\\n"};\par
9737         \} {\cf19 else} \{\par
9738             out << {\cf22 "All available tags:\\n"};\par
9739         \}\par
9740 \par
9741         {\cf19 for} ( {\cf17 auto} {\cf17 const}& tagCount : tags ) \{\par
9742             ReusableStringStream rss;\par
9743             rss << {\cf22 "  "} << std::setw( 2 ) << tagCount.count << {\cf22 "  "};\par
9744             {\cf17 auto} str = rss.str();\par
9745             {\cf17 auto} wrapper = TextFlow::Column( tagCount.all() )\par
9746                                .initialIndent( 0 )\par
9747                                .indent( str.size() )\par
9748                                .width( CATCH_CONFIG_CONSOLE_WIDTH - 10 );\par
9749             out << str << wrapper << {\cf23 '\\n'};\par
9750         \}\par
9751         out << pluralise(tags.size(), {\cf22 "tag"}_sr) << {\cf22 "\\n\\n"} << std::flush;\par
9752     \}\par
9753 \par
9754     {\cf18 void} defaultListTests(std::ostream& out, ColourImpl* streamColour, std::vector<TestCaseHandle> {\cf17 const}& tests, {\cf18 bool} isFiltered, Verbosity verbosity) \{\par
9755         {\cf20 // We special case this to provide the equivalent of old}\par
9756         {\cf20 // `--list-test-names-only`, which could then be used by the}\par
9757         {\cf20 // `--input-file` option.}\par
9758         {\cf19 if} (verbosity == Verbosity::Quiet) \{\par
9759             listTestNamesOnly(out, tests);\par
9760             {\cf19 return};\par
9761         \}\par
9762 \par
9763         {\cf19 if} (isFiltered) \{\par
9764             out << {\cf22 "Matching test cases:\\n"};\par
9765         \} {\cf19 else} \{\par
9766             out << {\cf22 "All available test cases:\\n"};\par
9767         \}\par
9768 \par
9769         {\cf19 for} ({\cf17 auto} {\cf17 const}& test : tests) \{\par
9770             {\cf17 auto} {\cf17 const}& testCaseInfo = test.getTestCaseInfo();\par
9771             Colour::Code colour = testCaseInfo.isHidden()\par
9772                 ? Colour::SecondaryText\par
9773                 : Colour::None;\par
9774             {\cf17 auto} colourGuard = streamColour->guardColour( colour ).engage( out );\par
9775 \par
9776             out << TextFlow::Column(testCaseInfo.name).indent(2) << {\cf23 '\\n'};\par
9777             {\cf19 if} (verbosity >= Verbosity::High) \{\par
9778                 out << TextFlow::Column(Catch::Detail::stringify(testCaseInfo.lineInfo)).indent(4) << {\cf23 '\\n'};\par
9779             \}\par
9780             {\cf19 if} (!testCaseInfo.tags.empty() &&\par
9781                 verbosity > Verbosity::Quiet) \{\par
9782                 out << TextFlow::Column(testCaseInfo.tagsAsString()).indent(6) << {\cf23 '\\n'};\par
9783             \}\par
9784         \}\par
9785 \par
9786         {\cf19 if} (isFiltered) \{\par
9787             out << pluralise(tests.size(), {\cf22 "matching test case"}_sr);\par
9788         \} {\cf19 else} \{\par
9789             out << pluralise(tests.size(), {\cf22 "test case"}_sr);\par
9790         \}\par
9791         out << {\cf22 "\\n\\n"} << std::flush;\par
9792     \}\par
9793 \par
9794     {\cf17 namespace }\{\par
9795         {\cf17 class }SummaryColumn \{\par
9796         {\cf17 public}:\par
9797             SummaryColumn( std::string suffix, Colour::Code colour ):\par
9798                 m_suffix( CATCH_MOVE( suffix ) ), m_colour( colour ) \{\}\par
9799 \par
9800             SummaryColumn&& addRow( std::uint64_t count ) && \{\par
9801                 std::string row = std::to_string(count);\par
9802                 {\cf17 auto} {\cf17 const} new_width = std::max( m_width, row.size() );\par
9803                 {\cf19 if} ( new_width > m_width ) \{\par
9804                     {\cf19 for} ( {\cf17 auto}& oldRow : m_rows ) \{\par
9805                         oldRow.insert( 0, new_width - m_width, {\cf23 ' '} );\par
9806                     \}\par
9807                 \} {\cf19 else} \{\par
9808                     row.insert( 0, m_width - row.size(), {\cf23 ' '} );\par
9809                 \}\par
9810                 m_width = new_width;\par
9811                 m_rows.push_back( row );\par
9812                 {\cf19 return} std::move( *{\cf17 this} );\par
9813             \}\par
9814 \par
9815             std::string {\cf17 const}& getSuffix(){\cf17  const }\{ {\cf19 return} m_suffix; \}\par
9816             Colour::Code getColour(){\cf17  const }\{ {\cf19 return} m_colour; \}\par
9817             std::string {\cf17 const}& getRow( std::size_t index ){\cf17  const }\{\par
9818                 {\cf19 return} m_rows[index];\par
9819             \}\par
9820 \par
9821         {\cf17 private}:\par
9822             std::string m_suffix;\par
9823             Colour::Code m_colour;\par
9824             std::size_t m_width = 0;\par
9825             std::vector<std::string> m_rows;\par
9826         \};\par
9827 \par
9828         {\cf18 void} printSummaryRow( std::ostream& stream,\par
9829                               ColourImpl& colour,\par
9830                               StringRef label,\par
9831                               std::vector<SummaryColumn> {\cf17 const}& cols,\par
9832                               std::size_t row ) \{\par
9833             {\cf19 for} ( {\cf17 auto} {\cf17 const}& col : cols ) \{\par
9834                 {\cf17 auto} {\cf17 const}& value = col.getRow( row );\par
9835                 {\cf17 auto} {\cf17 const}& suffix = col.getSuffix();\par
9836                 {\cf19 if} ( suffix.empty() ) \{\par
9837                     stream << label << {\cf22 ": "};\par
9838                     {\cf19 if} ( value != {\cf22 "0"} ) \{\par
9839                         stream << value;\par
9840                     \} {\cf19 else} \{\par
9841                         stream << colour.guardColour( Colour::Warning )\par
9842                                << {\cf22 "- none -"};\par
9843                     \}\par
9844                 \} {\cf19 else} {\cf19 if} ( value != {\cf22 "0"} ) \{\par
9845                     stream << colour.guardColour( Colour::LightGrey ) << {\cf22 " | "}\par
9846                            << colour.guardColour( col.getColour() ) << value\par
9847                            << {\cf23 ' '} << suffix;\par
9848                 \}\par
9849             \}\par
9850             stream << {\cf23 '\\n'};\par
9851         \}\par
9852     \} {\cf20 // namespace}\par
9853 \par
9854     {\cf18 void} printTestRunTotals( std::ostream& stream,\par
9855                              ColourImpl& streamColour,\par
9856                              Totals {\cf17 const}& totals ) \{\par
9857         {\cf19 if} ( totals.testCases.total() == 0 ) \{\par
9858             stream << streamColour.guardColour( Colour::Warning )\par
9859                    << {\cf22 "No tests ran\\n"};\par
9860             {\cf19 return};\par
9861         \}\par
9862 \par
9863         {\cf19 if} ( totals.assertions.total() > 0 && totals.testCases.allPassed() ) \{\par
9864             stream << streamColour.guardColour( Colour::ResultSuccess )\par
9865                    << {\cf22 "All tests passed"};\par
9866             stream << {\cf22 " ("}\par
9867                    << pluralise( totals.assertions.passed, {\cf22 "assertion"}_sr )\par
9868                    << {\cf22 " in "}\par
9869                    << pluralise( totals.testCases.passed, {\cf22 "test case"}_sr )\par
9870                    << {\cf23 ')'} << {\cf23 '\\n'};\par
9871             {\cf19 return};\par
9872         \}\par
9873 \par
9874         std::vector<SummaryColumn> columns;\par
9875         {\cf20 // Don't include "skipped assertions" in total count}\par
9876         {\cf17 const} {\cf17 auto} totalAssertionCount =\par
9877             totals.assertions.total() - totals.assertions.skipped;\par
9878         columns.push_back( SummaryColumn( {\cf22 ""}, Colour::None )\par
9879                                .addRow( totals.testCases.total() )\par
9880                                .addRow( totalAssertionCount ) );\par
9881         columns.push_back( SummaryColumn( {\cf22 "passed"}, Colour::Success )\par
9882                                .addRow( totals.testCases.passed )\par
9883                                .addRow( totals.assertions.passed ) );\par
9884         columns.push_back( SummaryColumn( {\cf22 "failed"}, Colour::ResultError )\par
9885                                .addRow( totals.testCases.failed )\par
9886                                .addRow( totals.assertions.failed ) );\par
9887         columns.push_back( SummaryColumn( {\cf22 "skipped"}, Colour::Skip )\par
9888                                .addRow( totals.testCases.skipped )\par
9889                                {\cf20 // Don't print "skipped assertions"}\par
9890                                .addRow( 0 ) );\par
9891         columns.push_back(\par
9892             SummaryColumn( {\cf22 "failed as expected"}, Colour::ResultExpectedFailure )\par
9893                 .addRow( totals.testCases.failedButOk )\par
9894                 .addRow( totals.assertions.failedButOk ) );\par
9895         printSummaryRow( stream, streamColour, {\cf22 "test cases"}_sr, columns, 0 );\par
9896         printSummaryRow( stream, streamColour, {\cf22 "assertions"}_sr, columns, 1 );\par
9897     \}\par
9898 \par
9899 \} {\cf20 // namespace Catch}\par
9900 \par
9901 \par
9902 {\cf20 //}\par
9903 \par
9904 {\cf17 namespace }Catch \{\par
9905     {\cf17 namespace }\{\par
9906         {\cf18 void} writeSourceInfo( JsonObjectWriter& writer,\par
9907                               SourceLineInfo {\cf17 const}& sourceInfo ) \{\par
9908             {\cf17 auto} source_location_writer =\par
9909                 writer.write( {\cf22 "source-location"}_sr ).writeObject();\par
9910             source_location_writer.write( {\cf22 "filename"}_sr )\par
9911                 .write( sourceInfo.file );\par
9912             source_location_writer.write( {\cf22 "line"}_sr ).write( sourceInfo.line );\par
9913         \}\par
9914 \par
9915         {\cf18 void} writeTags( JsonArrayWriter writer, std::vector<Tag> {\cf17 const}& tags ) \{\par
9916             {\cf19 for} ( {\cf17 auto} {\cf17 const}& tag : tags ) \{\par
9917                 writer.write( tag.original );\par
9918             \}\par
9919         \}\par
9920 \par
9921         {\cf18 void} writeProperties( JsonArrayWriter writer,\par
9922                               TestCaseInfo {\cf17 const}& info ) \{\par
9923             {\cf19 if} ( info.isHidden() ) \{ writer.write( {\cf22 "is-hidden"}_sr ); \}\par
9924             {\cf19 if} ( info.okToFail() ) \{ writer.write( {\cf22 "ok-to-fail"}_sr ); \}\par
9925             {\cf19 if} ( info.expectedToFail() ) \{\par
9926                 writer.write( {\cf22 "expected-to-fail"}_sr );\par
9927             \}\par
9928             {\cf19 if} ( info.throws() ) \{ writer.write( {\cf22 "throws"}_sr ); \}\par
9929         \}\par
9930 \par
9931     \} {\cf20 // namespace}\par
9932 \par
9933     JsonReporter::JsonReporter( ReporterConfig&& config ):\par
9934         StreamingReporterBase\{ CATCH_MOVE( config ) \} \{\par
9935 \par
9936         m_preferences.shouldRedirectStdOut = {\cf17 true};\par
9937         {\cf20 // TBD: Do we want to report all assertions? XML reporter does}\par
9938         {\cf20 //      not, but for machine-parseable reporters I think the answer}\par
9939         {\cf20 //      should be yes.}\par
9940         m_preferences.shouldReportAllAssertions = {\cf17 true};\par
9941 \par
9942         m_objectWriters.emplace( m_stream );\par
9943         m_writers.emplace( Writer::Object );\par
9944         {\cf17 auto}& writer = m_objectWriters.top();\par
9945 \par
9946         writer.write( {\cf22 "version"}_sr ).write( 1 );\par
9947 \par
9948         \{\par
9949             {\cf17 auto} metadata_writer = writer.write( {\cf22 "metadata"}_sr ).writeObject();\par
9950             metadata_writer.write( {\cf22 "name"}_sr ).write( m_config->name() );\par
9951             metadata_writer.write( {\cf22 "rng-seed"}_sr ).write( m_config->rngSeed() );\par
9952             metadata_writer.write( {\cf22 "catch2-version"}_sr )\par
9953                 .write( libraryVersion() );\par
9954             {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
9955                 metadata_writer.write( {\cf22 "filters"}_sr )\par
9956                     .write( m_config->testSpec() );\par
9957             \}\par
9958         \}\par
9959     \}\par
9960 \par
9961     JsonReporter::~JsonReporter() \{\par
9962         endListing();\par
9963         {\cf20 // TODO: Ensure this closes the top level object, add asserts}\par
9964         assert( m_writers.size() == 1 && {\cf22 "Only the top level object should be open"} );\par
9965         assert( m_writers.top() == Writer::Object );\par
9966         endObject();\par
9967         m_stream << {\cf23 '\\n'} << std::flush;\par
9968         assert( m_writers.empty() );\par
9969     \}\par
9970 \par
9971     JsonArrayWriter& JsonReporter::startArray() \{\par
9972         m_arrayWriters.emplace( m_arrayWriters.top().writeArray() );\par
9973         m_writers.emplace( Writer::Array );\par
9974         {\cf19 return} m_arrayWriters.top();\par
9975     \}\par
9976     JsonArrayWriter& JsonReporter::startArray( StringRef key ) \{\par
9977         m_arrayWriters.emplace(\par
9978             m_objectWriters.top().write( key ).writeArray() );\par
9979         m_writers.emplace( Writer::Array );\par
9980         {\cf19 return} m_arrayWriters.top();\par
9981     \}\par
9982 \par
9983     JsonObjectWriter& JsonReporter::startObject() \{\par
9984         m_objectWriters.emplace( m_arrayWriters.top().writeObject() );\par
9985         m_writers.emplace( Writer::Object );\par
9986         {\cf19 return} m_objectWriters.top();\par
9987     \}\par
9988     JsonObjectWriter& JsonReporter::startObject( StringRef key ) \{\par
9989         m_objectWriters.emplace(\par
9990             m_objectWriters.top().write( key ).writeObject() );\par
9991         m_writers.emplace( Writer::Object );\par
9992         {\cf19 return} m_objectWriters.top();\par
9993     \}\par
9994 \par
9995     {\cf18 void} JsonReporter::endObject() \{\par
9996         assert( isInside( Writer::Object ) );\par
9997         m_objectWriters.pop();\par
9998         m_writers.pop();\par
9999     \}\par
10000     {\cf18 void} JsonReporter::endArray() \{\par
10001         assert( isInside( Writer::Array ) );\par
10002         m_arrayWriters.pop();\par
10003         m_writers.pop();\par
10004     \}\par
10005 \par
10006     {\cf18 bool} JsonReporter::isInside( Writer writer ) \{\par
10007         {\cf19 return} !m_writers.empty() && m_writers.top() == writer;\par
10008     \}\par
10009 \par
10010     {\cf18 void} JsonReporter::startListing() \{\par
10011         {\cf19 if} ( !m_startedListing ) \{ startObject( {\cf22 "listings"}_sr ); \}\par
10012         m_startedListing = {\cf17 true};\par
10013     \}\par
10014     {\cf18 void} JsonReporter::endListing() \{\par
10015         {\cf19 if} ( m_startedListing ) \{ endObject(); \}\par
10016         m_startedListing = {\cf17 false};\par
10017     \}\par
10018 \par
10019     std::string JsonReporter::getDescription() \{\par
10020         {\cf19 return} {\cf22 "Outputs listings as JSON. Test listing is Work-in-Progress!"};\par
10021     \}\par
10022 \par
10023     {\cf18 void} JsonReporter::testRunStarting( TestRunInfo {\cf17 const}& runInfo ) \{\par
10024         StreamingReporterBase::testRunStarting( runInfo );\par
10025         endListing();\par
10026 \par
10027         assert( isInside( Writer::Object ) );\par
10028         startObject( {\cf22 "test-run"}_sr );\par
10029         startArray( {\cf22 "test-cases"}_sr );\par
10030     \}\par
10031 \par
10032      {\cf17 static} {\cf18 void} writeCounts( JsonObjectWriter&& writer, Counts {\cf17 const}& counts ) \{\par
10033         writer.write( {\cf22 "passed"}_sr ).write( counts.passed );\par
10034         writer.write( {\cf22 "failed"}_sr ).write( counts.failed );\par
10035         writer.write( {\cf22 "fail-but-ok"}_sr ).write( counts.failedButOk );\par
10036         writer.write( {\cf22 "skipped"}_sr ).write( counts.skipped );\par
10037     \}\par
10038 \par
10039     {\cf18 void} JsonReporter::testRunEnded(TestRunStats {\cf17 const}& runStats) \{\par
10040         assert( isInside( Writer::Array ) );\par
10041         {\cf20 // End "test-cases"}\par
10042         endArray();\par
10043 \par
10044         \{\par
10045             {\cf17 auto} totals =\par
10046                 m_objectWriters.top().write( {\cf22 "totals"}_sr ).writeObject();\par
10047             writeCounts( totals.write( {\cf22 "assertions"}_sr ).writeObject(),\par
10048                          runStats.totals.assertions );\par
10049             writeCounts( totals.write( {\cf22 "test-cases"}_sr ).writeObject(),\par
10050                          runStats.totals.testCases );\par
10051         \}\par
10052 \par
10053         {\cf20 // End the "test-run" object}\par
10054         endObject();\par
10055     \}\par
10056 \par
10057     {\cf18 void} JsonReporter::testCaseStarting( TestCaseInfo {\cf17 const}& tcInfo ) \{\par
10058         StreamingReporterBase::testCaseStarting( tcInfo );\par
10059 \par
10060         assert( isInside( Writer::Array ) &&\par
10061                 {\cf22 "We should be in the 'test-cases' array"} );\par
10062         startObject();\par
10063         {\cf20 // "test-info" prelude}\par
10064         \{\par
10065             {\cf17 auto} testInfo =\par
10066                 m_objectWriters.top().write( {\cf22 "test-info"}_sr ).writeObject();\par
10067             {\cf20 // TODO: handle testName vs className!!}\par
10068             testInfo.write( {\cf22 "name"}_sr ).write( tcInfo.name );\par
10069             writeSourceInfo(testInfo, tcInfo.lineInfo);\par
10070             writeTags( testInfo.write( {\cf22 "tags"}_sr ).writeArray(), tcInfo.tags );\par
10071             writeProperties( testInfo.write( {\cf22 "properties"}_sr ).writeArray(),\par
10072                              tcInfo );\par
10073         \}\par
10074 \par
10075 \par
10076         {\cf20 // Start the array for individual test runs (testCasePartial pairs)}\par
10077         startArray( {\cf22 "runs"}_sr );\par
10078     \}\par
10079 \par
10080     {\cf18 void} JsonReporter::testCaseEnded( TestCaseStats {\cf17 const}& tcStats ) \{\par
10081         StreamingReporterBase::testCaseEnded( tcStats );\par
10082 \par
10083         {\cf20 // We need to close the 'runs' array before finishing the test case}\par
10084         assert( isInside( Writer::Array ) );\par
10085         endArray();\par
10086 \par
10087         \{\par
10088             {\cf17 auto} totals =\par
10089                 m_objectWriters.top().write( {\cf22 "totals"}_sr ).writeObject();\par
10090             writeCounts( totals.write( {\cf22 "assertions"}_sr ).writeObject(),\par
10091                          tcStats.totals.assertions );\par
10092             {\cf20 // We do not write the test case totals, because there will always be just one test case here.}\par
10093             {\cf20 // TODO: overall "result" -> success, skip, fail here? Or in partial result?}\par
10094         \}\par
10095         {\cf20 // We do not write out stderr/stdout, because we instead wrote those out in partial runs}\par
10096 \par
10097         {\cf20 // TODO: aborting?}\par
10098 \par
10099         {\cf20 // And we also close this test case's object}\par
10100         assert( isInside( Writer::Object ) );\par
10101         endObject();\par
10102     \}\par
10103 \par
10104     {\cf18 void} JsonReporter::testCasePartialStarting( TestCaseInfo {\cf17 const}& {\cf20 /*tcInfo*/},\par
10105                                                 uint64_t index ) \{\par
10106         startObject();\par
10107         m_objectWriters.top().write( {\cf22 "run-idx"}_sr ).write( index );\par
10108         startArray( {\cf22 "path"}_sr );\par
10109         {\cf20 // TODO: we want to delay most of the printing to the 'root' section}\par
10110         {\cf20 // TODO: childSection key name?}\par
10111     \}\par
10112 \par
10113     {\cf18 void} JsonReporter::testCasePartialEnded( TestCaseStats {\cf17 const}& tcStats,\par
10114                                              uint64_t {\cf20 /*index*/} ) \{\par
10115         {\cf20 // Fixme: the top level section handles this.}\par
10117         endArray();\par
10118         {\cf19 if} ( !tcStats.stdOut.empty() ) \{\par
10119             m_objectWriters.top()\par
10120                 .write( {\cf22 "captured-stdout"}_sr )\par
10121                 .write( tcStats.stdOut );\par
10122         \}\par
10123         {\cf19 if} ( !tcStats.stdErr.empty() ) \{\par
10124             m_objectWriters.top()\par
10125                 .write( {\cf22 "captured-stderr"}_sr )\par
10126                 .write( tcStats.stdErr );\par
10127         \}\par
10128         \{\par
10129             {\cf17 auto} totals =\par
10130                 m_objectWriters.top().write( {\cf22 "totals"}_sr ).writeObject();\par
10131             writeCounts( totals.write( {\cf22 "assertions"}_sr ).writeObject(),\par
10132                          tcStats.totals.assertions );\par
10133             {\cf20 // We do not write the test case totals, because there will}\par
10134             {\cf20 // always be just one test case here.}\par
10135             {\cf20 // TODO: overall "result" -> success, skip, fail here? Or in}\par
10136             {\cf20 // partial result?}\par
10137         \}\par
10138         {\cf20 // TODO: aborting?}\par
10139         {\cf20 // run object}\par
10140         endObject();\par
10141     \}\par
10142 \par
10143     {\cf18 void} JsonReporter::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
10144         assert( isInside( Writer::Array ) &&\par
10145                 {\cf22 "Section should always start inside an object"} );\par
10146         {\cf20 // We want to nest top level sections, even though it shares name}\par
10147         {\cf20 // and source loc with the TEST_CASE}\par
10148         {\cf17 auto}& sectionObject = startObject();\par
10149         sectionObject.write( {\cf22 "kind"}_sr ).write( {\cf22 "section"}_sr );\par
10150         sectionObject.write( {\cf22 "name"}_sr ).write( sectionInfo.name );\par
10151         writeSourceInfo( m_objectWriters.top(), sectionInfo.lineInfo );\par
10152 \par
10153 \par
10154         {\cf20 // TBD: Do we want to create this event lazily? It would become}\par
10155         {\cf20 //      rather complex, but we could do it, and it would look}\par
10156         {\cf20 //      better for empty sections. OTOH, empty sections should}\par
10157         {\cf20 //      be rare.}\par
10158         startArray( {\cf22 "path"}_sr );\par
10159     \}\par
10160     {\cf18 void} JsonReporter::sectionEnded( SectionStats {\cf17 const}& {\cf20 /*sectionStats */}) \{\par
10161         {\cf20 // End the subpath array}\par
10162         endArray();\par
10163         {\cf20 // TODO: metadata}\par
10164         {\cf20 // TODO: what info do we have here?}\par
10165 \par
10166         {\cf20 // End the section object}\par
10167         endObject();\par
10168     \}\par
10169 \par
10170     {\cf18 void} JsonReporter::assertionStarting( AssertionInfo {\cf17 const}& {\cf20 /*assertionInfo*/} ) \{\}\par
10171     {\cf18 void} JsonReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
10172         {\cf20 // TODO: There is lot of different things to handle here, but}\par
10173         {\cf20 //       we can fill it in later, after we show that the basic}\par
10174         {\cf20 //       outline and streaming reporter impl works well enough.}\par
10175         {\cf20 //if ( !m_config->includeSuccessfulResults()}\par
10176         {\cf20 //    && assertionStats.assertionResult.isOk() ) \{}\par
10177         {\cf20 //    return;}\par
10178         {\cf20 //\}}\par
10179         assert( isInside( Writer::Array ) );\par
10180         {\cf17 auto} assertionObject = m_arrayWriters.top().writeObject();\par
10181 \par
10182         assertionObject.write( {\cf22 "kind"}_sr ).write( {\cf22 "assertion"}_sr );\par
10183         writeSourceInfo( assertionObject,\par
10184                          assertionStats.assertionResult.getSourceInfo() );\par
10185         assertionObject.write( {\cf22 "status"}_sr )\par
10186             .write( assertionStats.assertionResult.isOk() );\par
10187         {\cf20 // TODO: handling of result.}\par
10188         {\cf20 // TODO: messages}\par
10189         {\cf20 // TODO: totals?}\par
10190     \}\par
10191 \par
10192 \par
10193     {\cf18 void} JsonReporter::benchmarkPreparing( StringRef name ) \{ (void)name; \}\par
10194     {\cf18 void} JsonReporter::benchmarkStarting( BenchmarkInfo {\cf17 const}& ) \{\}\par
10195     {\cf18 void} JsonReporter::benchmarkEnded( BenchmarkStats<> {\cf17 const}& ) \{\}\par
10196     {\cf18 void} JsonReporter::benchmarkFailed( StringRef error ) \{ (void)error; \}\par
10197 \par
10198     {\cf18 void} JsonReporter::listReporters(\par
10199         std::vector<ReporterDescription> {\cf17 const}& descriptions ) \{\par
10200         startListing();\par
10201 \par
10202         {\cf17 auto} writer =\par
10203             m_objectWriters.top().write( {\cf22 "reporters"}_sr ).writeArray();\par
10204         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
10205             {\cf17 auto} desc_writer = writer.writeObject();\par
10206             desc_writer.write( {\cf22 "name"}_sr ).write( desc.name );\par
10207             desc_writer.write( {\cf22 "description"}_sr ).write( desc.description );\par
10208         \}\par
10209     \}\par
10210     {\cf18 void} JsonReporter::listListeners(\par
10211         std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
10212         startListing();\par
10213 \par
10214         {\cf17 auto} writer =\par
10215             m_objectWriters.top().write( {\cf22 "listeners"}_sr ).writeArray();\par
10216 \par
10217         {\cf19 for} ( {\cf17 auto} {\cf17 const}& desc : descriptions ) \{\par
10218             {\cf17 auto} desc_writer = writer.writeObject();\par
10219             desc_writer.write( {\cf22 "name"}_sr ).write( desc.name );\par
10220             desc_writer.write( {\cf22 "description"}_sr ).write( desc.description );\par
10221         \}\par
10222     \}\par
10223     {\cf18 void} JsonReporter::listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) \{\par
10224         startListing();\par
10225 \par
10226         {\cf17 auto} writer = m_objectWriters.top().write( {\cf22 "tests"}_sr ).writeArray();\par
10227 \par
10228         {\cf19 for} ( {\cf17 auto} {\cf17 const}& test : tests ) \{\par
10229             {\cf17 auto} desc_writer = writer.writeObject();\par
10230             {\cf17 auto} {\cf17 const}& info = test.getTestCaseInfo();\par
10231 \par
10232             desc_writer.write( {\cf22 "name"}_sr ).write( info.name );\par
10233             desc_writer.write( {\cf22 "class-name"}_sr ).write( info.className );\par
10234             \{\par
10235                 {\cf17 auto} tag_writer = desc_writer.write( {\cf22 "tags"}_sr ).writeArray();\par
10236                 {\cf19 for} ( {\cf17 auto} {\cf17 const}& tag : info.tags ) \{\par
10237                     tag_writer.write( tag.original );\par
10238                 \}\par
10239             \}\par
10240             writeSourceInfo( desc_writer, info.lineInfo );\par
10241         \}\par
10242     \}\par
10243     {\cf18 void} JsonReporter::listTags( std::vector<TagInfo> {\cf17 const}& tags ) \{\par
10244         startListing();\par
10245 \par
10246         {\cf17 auto} writer = m_objectWriters.top().write( {\cf22 "tags"}_sr ).writeArray();\par
10247         {\cf19 for} ( {\cf17 auto} {\cf17 const}& tag : tags ) \{\par
10248             {\cf17 auto} tag_writer = writer.writeObject();\par
10249             \{\par
10250                 {\cf17 auto} aliases_writer =\par
10251                     tag_writer.write( {\cf22 "aliases"}_sr ).writeArray();\par
10252                 {\cf19 for} ( {\cf17 auto} alias : tag.spellings ) \{\par
10253                     aliases_writer.write( alias );\par
10254                 \}\par
10255             \}\par
10256             tag_writer.write( {\cf22 "count"}_sr ).write( tag.count );\par
10257         \}\par
10258     \}\par
10259 \} {\cf20 // namespace Catch}\par
10260 \par
10261 \par
10262 \par
10263 \par
10264 {\cf21 #include <cassert>}\par
10265 {\cf21 #include <ctime>}\par
10266 {\cf21 #include <algorithm>}\par
10267 {\cf21 #include <iomanip>}\par
10268 \par
10269 {\cf17 namespace }Catch \{\par
10270 \par
10271     {\cf17 namespace }\{\par
10272         std::string getCurrentTimestamp() \{\par
10273             time_t rawtime;\par
10274             std::time(&rawtime);\par
10275 \par
10276             std::tm timeInfo = \{\};\par
10277 {\cf21 #if defined (_MSC_VER) || defined (__MINGW32__)}\par
10278             gmtime_s(&timeInfo, &rawtime);\par
10279 {\cf21 #elif defined (CATCH_PLATFORM_PLAYSTATION)}\par
10280             gmtime_s(&rawtime, &timeInfo);\par
10281 {\cf21 #elif defined (__IAR_SYSTEMS_ICC__)}\par
10282             timeInfo = *std::gmtime(&rawtime);\par
10283 {\cf21 #else}\par
10284             gmtime_r(&rawtime, &timeInfo);\par
10285 {\cf21 #endif}\par
10286 \par
10287             {\cf17 auto} {\cf17 const} timeStampSize = {\cf17 sizeof}({\cf22 "2017-01-16T17:06:45Z"});\par
10288             {\cf18 char} timeStamp[timeStampSize];\par
10289             {\cf17 const} {\cf18 char} * {\cf17 const} fmt = {\cf22 "%Y-%m-%dT%H:%M:%SZ"};\par
10290 \par
10291             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\par
10292 \par
10293             {\cf19 return} std::string(timeStamp, timeStampSize - 1);\par
10294         \}\par
10295 \par
10296         std::string fileNameTag(std::vector<Tag> {\cf17 const}& tags) \{\par
10297             {\cf17 auto} it = std::find_if(begin(tags),\par
10298                                    end(tags),\par
10299                                    [] (Tag {\cf17 const}& tag) \{\par
10300                                        {\cf19 return} tag.original.size() > 0\par
10301                                            && tag.original[0] == {\cf23 '#'}; \});\par
10302             {\cf19 if} (it != tags.end()) \{\par
10303                 {\cf19 return} {\cf17 static_cast<}std::string{\cf17 >}(\par
10304                     it->original.substr(1, it->original.size() - 1)\par
10305                 );\par
10306             \}\par
10307             {\cf19 return} std::string();\par
10308         \}\par
10309 \par
10310         {\cf20 // Formats the duration in seconds to 3 decimal places.}\par
10311         {\cf20 // This is done because some genius defined Maven Surefire schema}\par
10312         {\cf20 // in a way that only accepts 3 decimal places, and tools like}\par
10313         {\cf20 // Jenkins use that schema for validation JUnit reporter output.}\par
10314         std::string formatDuration( {\cf18 double} seconds ) \{\par
10315             ReusableStringStream rss;\par
10316             rss << std::fixed << std::setprecision( 3 ) << seconds;\par
10317             {\cf19 return} rss.str();\par
10318         \}\par
10319 \par
10320         {\cf17 static} {\cf18 void} normalizeNamespaceMarkers(std::string& str) \{\par
10321             std::size_t pos = str.find( {\cf22 "::"} );\par
10322             {\cf19 while} ( pos != std::string::npos ) \{\par
10323                 str.replace( pos, 2, {\cf22 "."} );\par
10324                 pos += 1;\par
10325                 pos = str.find( {\cf22 "::"}, pos );\par
10326             \}\par
10327         \}\par
10328 \par
10329     \} {\cf20 // anonymous namespace}\par
10330 \par
10331     JunitReporter::JunitReporter( ReporterConfig&& _config )\par
10332         :   CumulativeReporterBase( CATCH_MOVE(_config) ),\par
10333             xml( m_stream )\par
10334         \{\par
10335             m_preferences.shouldRedirectStdOut = {\cf17 true};\par
10336             m_preferences.shouldReportAllAssertions = {\cf17 true};\par
10337             m_shouldStoreSuccesfulAssertions = {\cf17 false};\par
10338         \}\par
10339 \par
10340     std::string JunitReporter::getDescription() \{\par
10341         {\cf19 return} {\cf22 "Reports test results in an XML format that looks like Ant's junitreport target"};\par
10342     \}\par
10343 \par
10344     {\cf18 void} JunitReporter::testRunStarting( TestRunInfo {\cf17 const}& runInfo )  \{\par
10345         CumulativeReporterBase::testRunStarting( runInfo );\par
10346         xml.startElement( {\cf22 "testsuites"} );\par
10347         suiteTimer.start();\par
10348         stdOutForSuite.clear();\par
10349         stdErrForSuite.clear();\par
10350         unexpectedExceptions = 0;\par
10351     \}\par
10352 \par
10353     {\cf18 void} JunitReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testCaseInfo ) \{\par
10354         m_okToFail = testCaseInfo.okToFail();\par
10355     \}\par
10356 \par
10357     {\cf18 void} JunitReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
10358         {\cf19 if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )\par
10359             unexpectedExceptions++;\par
10360         CumulativeReporterBase::assertionEnded( assertionStats );\par
10361     \}\par
10362 \par
10363     {\cf18 void} JunitReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
10364         stdOutForSuite += testCaseStats.stdOut;\par
10365         stdErrForSuite += testCaseStats.stdErr;\par
10366         CumulativeReporterBase::testCaseEnded( testCaseStats );\par
10367     \}\par
10368 \par
10369     {\cf18 void} JunitReporter::testRunEndedCumulative() \{\par
10370         {\cf17 const} {\cf17 auto} suiteTime = suiteTimer.getElapsedSeconds();\par
10371         writeRun( *m_testRun, suiteTime );\par
10372         xml.endElement();\par
10373     \}\par
10374 \par
10375     {\cf18 void} JunitReporter::writeRun( TestRunNode {\cf17 const}& testRunNode, {\cf18 double} suiteTime ) \{\par
10376         XmlWriter::ScopedElement e = xml.scopedElement( {\cf22 "testsuite"} );\par
10377 \par
10378         TestRunStats {\cf17 const}& stats = testRunNode.value;\par
10379         xml.writeAttribute( {\cf22 "name"}_sr, stats.runInfo.name );\par
10380         xml.writeAttribute( {\cf22 "errors"}_sr, unexpectedExceptions );\par
10381         xml.writeAttribute( {\cf22 "failures"}_sr, stats.totals.assertions.failed-unexpectedExceptions );\par
10382         xml.writeAttribute( {\cf22 "skipped"}_sr, stats.totals.assertions.skipped );\par
10383         xml.writeAttribute( {\cf22 "tests"}_sr, stats.totals.assertions.total() );\par
10384         xml.writeAttribute( {\cf22 "hostname"}_sr, {\cf22 "tbd"}_sr ); {\cf20 // !TBD}\par
10385         {\cf19 if}( m_config->showDurations() == ShowDurations::Never )\par
10386             xml.writeAttribute( {\cf22 "time"}_sr, {\cf22 ""}_sr );\par
10387         {\cf19 else}\par
10388             xml.writeAttribute( {\cf22 "time"}_sr, formatDuration( suiteTime ) );\par
10389         xml.writeAttribute( {\cf22 "timestamp"}_sr, getCurrentTimestamp() );\par
10390 \par
10391         {\cf20 // Write properties}\par
10392         \{\par
10393             {\cf17 auto} properties = xml.scopedElement({\cf22 "properties"});\par
10394             xml.scopedElement({\cf22 "property"})\par
10395                 .writeAttribute({\cf22 "name"}_sr, {\cf22 "random-seed"}_sr)\par
10396                 .writeAttribute({\cf22 "value"}_sr, m_config->rngSeed());\par
10397             {\cf19 if} (m_config->testSpec().hasFilters()) \{\par
10398                 xml.scopedElement({\cf22 "property"})\par
10399                     .writeAttribute({\cf22 "name"}_sr, {\cf22 "filters"}_sr)\par
10400                     .writeAttribute({\cf22 "value"}_sr, m_config->testSpec());\par
10401             \}\par
10402         \}\par
10403 \par
10404         {\cf20 // Write test cases}\par
10405         {\cf19 for}( {\cf17 auto} {\cf17 const}& child : testRunNode.children )\par
10406             writeTestCase( *child );\par
10407 \par
10408         xml.scopedElement( {\cf22 "system-out"} ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );\par
10409         xml.scopedElement( {\cf22 "system-err"} ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );\par
10410     \}\par
10411 \par
10412     {\cf18 void} JunitReporter::writeTestCase( TestCaseNode {\cf17 const}& testCaseNode ) \{\par
10413         TestCaseStats {\cf17 const}& stats = testCaseNode.value;\par
10414 \par
10415         {\cf20 // All test cases have exactly one section - which represents the}\par
10416         {\cf20 // test case itself. That section may have 0-n nested sections}\par
10417         assert( testCaseNode.children.size() == 1 );\par
10418         SectionNode {\cf17 const}& rootSection = *testCaseNode.children.front();\par
10419 \par
10420         std::string className =\par
10421             {\cf17 static_cast<}std::string{\cf17 >}( stats.testInfo->className );\par
10422 \par
10423         {\cf19 if}( className.empty() ) \{\par
10424             className = fileNameTag(stats.testInfo->tags);\par
10425             {\cf19 if} ( className.empty() ) \{\par
10426                 className = {\cf22 "global"};\par
10427             \}\par
10428         \}\par
10429 \par
10430         {\cf19 if} ( !m_config->name().empty() )\par
10431             className = {\cf17 static_cast<}std::string{\cf17 >}(m_config->name()) + {\cf23 '.'} + className;\par
10432 \par
10433         normalizeNamespaceMarkers(className);\par
10434 \par
10435         writeSection( className, {\cf22 ""}, rootSection, stats.testInfo->okToFail() );\par
10436     \}\par
10437 \par
10438     {\cf18 void} JunitReporter::writeSection( std::string {\cf17 const}& className,\par
10439                                       std::string {\cf17 const}& rootName,\par
10440                                       SectionNode {\cf17 const}& sectionNode,\par
10441                                       {\cf18 bool} testOkToFail) \{\par
10442         std::string name = trim( sectionNode.stats.sectionInfo.name );\par
10443         {\cf19 if}( !rootName.empty() )\par
10444             name = rootName + {\cf23 '/'} + name;\par
10445 \par
10446         {\cf19 if}( sectionNode.hasAnyAssertions()\par
10447            || !sectionNode.stdOut.empty()\par
10448            || !sectionNode.stdErr.empty() ) \{\par
10449             XmlWriter::ScopedElement e = xml.scopedElement( {\cf22 "testcase"} );\par
10450             {\cf19 if}( className.empty() ) \{\par
10451                 xml.writeAttribute( {\cf22 "classname"}_sr, name );\par
10452                 xml.writeAttribute( {\cf22 "name"}_sr, {\cf22 "root"}_sr );\par
10453             \}\par
10454             {\cf19 else} \{\par
10455                 xml.writeAttribute( {\cf22 "classname"}_sr, className );\par
10456                 xml.writeAttribute( {\cf22 "name"}_sr, name );\par
10457             \}\par
10458             xml.writeAttribute( {\cf22 "time"}_sr, formatDuration( sectionNode.stats.durationInSeconds ) );\par
10459             {\cf20 // This is not ideal, but it should be enough to mimic gtest's}\par
10460             {\cf20 // junit output.}\par
10461             {\cf20 // Ideally the JUnit reporter would also handle `skipTest`}\par
10462             {\cf20 // events and write those out appropriately.}\par
10463             xml.writeAttribute( {\cf22 "status"}_sr, {\cf22 "run"}_sr );\par
10464 \par
10465             {\cf19 if} (sectionNode.stats.assertions.failedButOk) \{\par
10466                 xml.scopedElement({\cf22 "skipped"})\par
10467                     .writeAttribute({\cf22 "message"}, {\cf22 "TEST_CASE tagged with !mayfail"});\par
10468             \}\par
10469 \par
10470             writeAssertions( sectionNode );\par
10471 \par
10472 \par
10473             {\cf19 if}( !sectionNode.stdOut.empty() )\par
10474                 xml.scopedElement( {\cf22 "system-out"} ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );\par
10475             {\cf19 if}( !sectionNode.stdErr.empty() )\par
10476                 xml.scopedElement( {\cf22 "system-err"} ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );\par
10477         \}\par
10478         {\cf19 for}( {\cf17 auto} {\cf17 const}& childNode : sectionNode.childSections )\par
10479             {\cf19 if}( className.empty() )\par
10480                 writeSection( name, {\cf22 ""}, *childNode, testOkToFail );\par
10481             {\cf19 else}\par
10482                 writeSection( className, name, *childNode, testOkToFail );\par
10483     \}\par
10484 \par
10485     {\cf18 void} JunitReporter::writeAssertions( SectionNode {\cf17 const}& sectionNode ) \{\par
10486         {\cf19 for} ({\cf17 auto} {\cf17 const}& assertionOrBenchmark : sectionNode.assertionsAndBenchmarks) \{\par
10487             {\cf19 if} (assertionOrBenchmark.isAssertion()) \{\par
10488                 writeAssertion(assertionOrBenchmark.asAssertion());\par
10489             \}\par
10490         \}\par
10491     \}\par
10492 \par
10493     {\cf18 void} JunitReporter::writeAssertion( AssertionStats {\cf17 const}& stats ) \{\par
10494         AssertionResult {\cf17 const}& result = stats.assertionResult;\par
10495         {\cf19 if} ( !result.isOk() ||\par
10496              result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10497             std::string elementName;\par
10498             {\cf19 switch}( result.getResultType() ) \{\par
10499                 {\cf19 case} ResultWas::ThrewException:\par
10500                 {\cf19 case} ResultWas::FatalErrorCondition:\par
10501                     elementName = {\cf22 "error"};\par
10502                     {\cf19 break};\par
10503                 {\cf19 case} ResultWas::ExplicitFailure:\par
10504                 {\cf19 case} ResultWas::ExpressionFailed:\par
10505                 {\cf19 case} ResultWas::DidntThrowException:\par
10506                     elementName = {\cf22 "failure"};\par
10507                     {\cf19 break};\par
10508                 {\cf19 case} ResultWas::ExplicitSkip:\par
10509                     elementName = {\cf22 "skipped"};\par
10510                     {\cf19 break};\par
10511                 {\cf20 // We should never see these here:}\par
10512                 {\cf19 case} ResultWas::Info:\par
10513                 {\cf19 case} ResultWas::Warning:\par
10514                 {\cf19 case} ResultWas::Ok:\par
10515                 {\cf19 case} ResultWas::Unknown:\par
10516                 {\cf19 case} ResultWas::FailureBit:\par
10517                 {\cf19 case} ResultWas::Exception:\par
10518                     elementName = {\cf22 "internalError"};\par
10519                     {\cf19 break};\par
10520             \}\par
10521 \par
10522             XmlWriter::ScopedElement e = xml.scopedElement( elementName );\par
10523 \par
10524             xml.writeAttribute( {\cf22 "message"}_sr, result.getExpression() );\par
10525             xml.writeAttribute( {\cf22 "type"}_sr, result.getTestMacroName() );\par
10526 \par
10527             ReusableStringStream rss;\par
10528             {\cf19 if} ( result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10529                 rss << {\cf22 "SKIPPED\\n"};\par
10530             \} {\cf19 else} \{\par
10531                 rss << {\cf22 "FAILED"} << {\cf22 ":\\n"};\par
10532                 {\cf19 if} (result.hasExpression()) \{\par
10533                     rss << {\cf22 "  "};\par
10534                     rss << result.getExpressionInMacro();\par
10535                     rss << {\cf23 '\\n'};\par
10536                 \}\par
10537                 {\cf19 if} (result.hasExpandedExpression()) \{\par
10538                     rss << {\cf22 "with expansion:\\n"};\par
10539                     rss << TextFlow::Column(result.getExpandedExpression()).indent(2) << {\cf23 '\\n'};\par
10540                 \}\par
10541             \}\par
10542 \par
10543             {\cf19 if}( result.hasMessage() )\par
10544                 rss << result.getMessage() << {\cf23 '\\n'};\par
10545             {\cf19 for}( {\cf17 auto} {\cf17 const}& msg : stats.infoMessages )\par
10546                 {\cf19 if}( msg.type == ResultWas::Info )\par
10547                     rss << msg.message << {\cf23 '\\n'};\par
10548 \par
10549             rss << {\cf22 "at "} << result.getSourceInfo();\par
10550             xml.writeText( rss.str(), XmlFormatting::Newline );\par
10551         \}\par
10552     \}\par
10553 \par
10554 \} {\cf20 // end namespace Catch}\par
10555 \par
10556 \par
10557 \par
10558 \par
10559 {\cf21 #include <ostream>}\par
10560 \par
10561 {\cf17 namespace }Catch \{\par
10562     {\cf18 void} MultiReporter::updatePreferences(IEventListener {\cf17 const}& reporterish) \{\par
10563         m_preferences.shouldRedirectStdOut |=\par
10564             reporterish.getPreferences().shouldRedirectStdOut;\par
10565         m_preferences.shouldReportAllAssertions |=\par
10566             reporterish.getPreferences().shouldReportAllAssertions;\par
10567     \}\par
10568 \par
10569     {\cf18 void} MultiReporter::addListener( IEventListenerPtr&& listener ) \{\par
10570         updatePreferences(*listener);\par
10571         m_reporterLikes.insert(m_reporterLikes.begin() + m_insertedListeners, CATCH_MOVE(listener) );\par
10572         ++m_insertedListeners;\par
10573     \}\par
10574 \par
10575     {\cf18 void} MultiReporter::addReporter( IEventListenerPtr&& reporter ) \{\par
10576         updatePreferences(*reporter);\par
10577 \par
10578         {\cf20 // We will need to output the captured stdout if there are reporters}\par
10579         {\cf20 // that do not want it captured.}\par
10580         {\cf20 // We do not consider listeners, because it is generally assumed that}\par
10581         {\cf20 // listeners are output-transparent, even though they can ask for stdout}\par
10582         {\cf20 // capture to do something with it.}\par
10583         m_haveNoncapturingReporters |= !reporter->getPreferences().shouldRedirectStdOut;\par
10584 \par
10585         {\cf20 // Reporters can always be placed to the back without breaking the}\par
10586         {\cf20 // reporting order}\par
10587         m_reporterLikes.push_back( CATCH_MOVE( reporter ) );\par
10588     \}\par
10589 \par
10590     {\cf18 void} MultiReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
10591         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10592             reporterish->noMatchingTestCases( unmatchedSpec );\par
10593         \}\par
10594     \}\par
10595 \par
10596     {\cf18 void} MultiReporter::fatalErrorEncountered( StringRef error ) \{\par
10597         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10598             reporterish->fatalErrorEncountered( error );\par
10599         \}\par
10600     \}\par
10601 \par
10602     {\cf18 void} MultiReporter::reportInvalidTestSpec( StringRef arg ) \{\par
10603         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10604             reporterish->reportInvalidTestSpec( arg );\par
10605         \}\par
10606     \}\par
10607 \par
10608     {\cf18 void} MultiReporter::benchmarkPreparing( StringRef name ) \{\par
10609         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10610             reporterish->benchmarkPreparing(name);\par
10611         \}\par
10612     \}\par
10613     {\cf18 void} MultiReporter::benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) \{\par
10614         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10615             reporterish->benchmarkStarting( benchmarkInfo );\par
10616         \}\par
10617     \}\par
10618     {\cf18 void} MultiReporter::benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) \{\par
10619         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10620             reporterish->benchmarkEnded( benchmarkStats );\par
10621         \}\par
10622     \}\par
10623 \par
10624     {\cf18 void} MultiReporter::benchmarkFailed( StringRef error ) \{\par
10625         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10626             reporterish->benchmarkFailed(error);\par
10627         \}\par
10628     \}\par
10629 \par
10630     {\cf18 void} MultiReporter::testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) \{\par
10631         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10632             reporterish->testRunStarting( testRunInfo );\par
10633         \}\par
10634     \}\par
10635 \par
10636     {\cf18 void} MultiReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) \{\par
10637         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10638             reporterish->testCaseStarting( testInfo );\par
10639         \}\par
10640     \}\par
10641 \par
10642     {\cf18 void}\par
10643     MultiReporter::testCasePartialStarting( TestCaseInfo {\cf17 const}& testInfo,\par
10644                                                 uint64_t partNumber ) \{\par
10645         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10646             reporterish->testCasePartialStarting( testInfo, partNumber );\par
10647         \}\par
10648     \}\par
10649 \par
10650     {\cf18 void} MultiReporter::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
10651         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10652             reporterish->sectionStarting( sectionInfo );\par
10653         \}\par
10654     \}\par
10655 \par
10656     {\cf18 void} MultiReporter::assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) \{\par
10657         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10658             reporterish->assertionStarting( assertionInfo );\par
10659         \}\par
10660     \}\par
10661 \par
10662     {\cf18 void} MultiReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
10663         {\cf17 const} {\cf18 bool} reportByDefault =\par
10664             assertionStats.assertionResult.getResultType() != ResultWas::Ok ||\par
10665             m_config->includeSuccessfulResults();\par
10666 \par
10667         {\cf19 for} ( {\cf17 auto} & reporterish : m_reporterLikes ) \{\par
10668             {\cf19 if} ( reportByDefault ||\par
10669                  reporterish->getPreferences().shouldReportAllAssertions ) \{\par
10670                     reporterish->assertionEnded( assertionStats );\par
10671             \}\par
10672         \}\par
10673     \}\par
10674 \par
10675     {\cf18 void} MultiReporter::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
10676         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10677             reporterish->sectionEnded( sectionStats );\par
10678         \}\par
10679     \}\par
10680 \par
10681     {\cf18 void} MultiReporter::testCasePartialEnded( TestCaseStats {\cf17 const}& testStats,\par
10682                                                   uint64_t partNumber ) \{\par
10683         {\cf19 if} ( m_preferences.shouldRedirectStdOut &&\par
10684              m_haveNoncapturingReporters ) \{\par
10685             {\cf19 if} ( !testStats.stdOut.empty() ) \{\par
10686                 Catch::cout() << testStats.stdOut << std::flush;\par
10687             \}\par
10688             {\cf19 if} ( !testStats.stdErr.empty() ) \{\par
10689                 Catch::cerr() << testStats.stdErr << std::flush;\par
10690             \}\par
10691         \}\par
10692 \par
10693         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10694             reporterish->testCasePartialEnded( testStats, partNumber );\par
10695         \}\par
10696     \}\par
10697 \par
10698     {\cf18 void} MultiReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
10699         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10700             reporterish->testCaseEnded( testCaseStats );\par
10701         \}\par
10702     \}\par
10703 \par
10704     {\cf18 void} MultiReporter::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
10705         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10706             reporterish->testRunEnded( testRunStats );\par
10707         \}\par
10708     \}\par
10709 \par
10710 \par
10711     {\cf18 void} MultiReporter::skipTest( TestCaseInfo {\cf17 const}& testInfo ) \{\par
10712         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10713             reporterish->skipTest( testInfo );\par
10714         \}\par
10715     \}\par
10716 \par
10717     {\cf18 void} MultiReporter::listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) \{\par
10718         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10719             reporterish->listReporters(descriptions);\par
10720         \}\par
10721     \}\par
10722 \par
10723     {\cf18 void} MultiReporter::listListeners(\par
10724         std::vector<ListenerDescription> {\cf17 const}& descriptions ) \{\par
10725         {\cf19 for} ( {\cf17 auto}& reporterish : m_reporterLikes ) \{\par
10726             reporterish->listListeners( descriptions );\par
10727         \}\par
10728     \}\par
10729 \par
10730     {\cf18 void} MultiReporter::listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
10731         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10732             reporterish->listTests(tests);\par
10733         \}\par
10734     \}\par
10735 \par
10736     {\cf18 void} MultiReporter::listTags(std::vector<TagInfo> {\cf17 const}& tags) \{\par
10737         {\cf19 for} ({\cf17 auto}& reporterish : m_reporterLikes) \{\par
10738             reporterish->listTags(tags);\par
10739         \}\par
10740     \}\par
10741 \par
10742 \} {\cf20 // end namespace Catch}\par
10743 \par
10744 \par
10745 \par
10746 \par
10747 \par
10748 {\cf17 namespace }Catch \{\par
10749     {\cf17 namespace }Detail \{\par
10750 \par
10751         {\cf18 void} registerReporterImpl( std::string {\cf17 const}& name,\par
10752                                    IReporterFactoryPtr reporterPtr ) \{\par
10753             CATCH_TRY \{\par
10754                 getMutableRegistryHub().registerReporter(\par
10755                     name, CATCH_MOVE( reporterPtr ) );\par
10756             \}\par
10757             CATCH_CATCH_ALL \{\par
10758                 {\cf20 // Do not throw when constructing global objects, instead}\par
10759                 {\cf20 // register the exception to be processed later}\par
10760                 getMutableRegistryHub().registerStartupException();\par
10761             \}\par
10762         \}\par
10763 \par
10764         {\cf18 void} registerListenerImpl( Detail::unique_ptr<EventListenerFactory> listenerFactory ) \{\par
10765             getMutableRegistryHub().registerListener( CATCH_MOVE(listenerFactory) );\par
10766         \}\par
10767 \par
10768 \par
10769     \} {\cf20 // namespace Detail}\par
10770 \} {\cf20 // namespace Catch}\par
10771 \par
10772 \par
10773 \par
10774 \par
10775 {\cf21 #include <map>}\par
10776 \par
10777 {\cf17 namespace }Catch \{\par
10778 \par
10779     {\cf17 namespace }\{\par
10780         std::string createMetadataString(IConfig {\cf17 const}& config) \{\par
10781             ReusableStringStream sstr;\par
10782             {\cf19 if} ( config.testSpec().hasFilters() ) \{\par
10783                 sstr << {\cf22 "filters='"}\par
10784                          << config.testSpec()\par
10785                          << {\cf22 "' "};\par
10786             \}\par
10787             sstr << {\cf22 "rng-seed="} << config.rngSeed();\par
10788             {\cf19 return} sstr.str();\par
10789         \}\par
10790     \}\par
10791 \par
10792     {\cf18 void} SonarQubeReporter::testRunStarting(TestRunInfo {\cf17 const}& testRunInfo) \{\par
10793         CumulativeReporterBase::testRunStarting(testRunInfo);\par
10794 \par
10795         xml.writeComment( createMetadataString( *m_config ) );\par
10796         xml.startElement({\cf22 "testExecutions"});\par
10797         xml.writeAttribute({\cf22 "version"}_sr, {\cf23 '1'});\par
10798     \}\par
10799 \par
10800     {\cf18 void} SonarQubeReporter::writeRun( TestRunNode {\cf17 const}& runNode ) \{\par
10801         std::map<StringRef, std::vector<TestCaseNode const*>> testsPerFile;\par
10802 \par
10803         {\cf19 for} ( {\cf17 auto} {\cf17 const}& child : runNode.children ) \{\par
10804             testsPerFile[child->value.testInfo->lineInfo.file].push_back(\par
10805                 child.get() );\par
10806         \}\par
10807 \par
10808         {\cf19 for} ( {\cf17 auto} {\cf17 const}& kv : testsPerFile ) \{\par
10809             writeTestFile( kv.first, kv.second );\par
10810         \}\par
10811     \}\par
10812 \par
10813     {\cf18 void} SonarQubeReporter::writeTestFile(StringRef filename, std::vector<TestCaseNode const*> {\cf17 const}& testCaseNodes) \{\par
10814         XmlWriter::ScopedElement e = xml.scopedElement({\cf22 "file"});\par
10815         xml.writeAttribute({\cf22 "path"}_sr, filename);\par
10816 \par
10817         {\cf19 for} ({\cf17 auto} {\cf17 const}& child : testCaseNodes)\par
10818             writeTestCase(*child);\par
10819     \}\par
10820 \par
10821     {\cf18 void} SonarQubeReporter::writeTestCase(TestCaseNode {\cf17 const}& testCaseNode) \{\par
10822         {\cf20 // All test cases have exactly one section - which represents the}\par
10823         {\cf20 // test case itself. That section may have 0-n nested sections}\par
10824         assert(testCaseNode.children.size() == 1);\par
10825         SectionNode {\cf17 const}& rootSection = *testCaseNode.children.front();\par
10826         writeSection({\cf22 ""}, rootSection, testCaseNode.value.testInfo->okToFail());\par
10827     \}\par
10828 \par
10829     {\cf18 void} SonarQubeReporter::writeSection(std::string {\cf17 const}& rootName, SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail) \{\par
10830         std::string name = trim(sectionNode.stats.sectionInfo.name);\par
10831         {\cf19 if} (!rootName.empty())\par
10832             name = rootName + {\cf23 '/'} + name;\par
10833 \par
10834         {\cf19 if} ( sectionNode.hasAnyAssertions()\par
10835             || !sectionNode.stdOut.empty()\par
10836             ||  !sectionNode.stdErr.empty() ) \{\par
10837             XmlWriter::ScopedElement e = xml.scopedElement({\cf22 "testCase"});\par
10838             xml.writeAttribute({\cf22 "name"}_sr, name);\par
10839             xml.writeAttribute({\cf22 "duration"}_sr, {\cf17 static_cast<}{\cf18 long}{\cf17 >}(sectionNode.stats.durationInSeconds * 1000));\par
10840 \par
10841             writeAssertions(sectionNode, okToFail);\par
10842         \}\par
10843 \par
10844         {\cf19 for} ({\cf17 auto} {\cf17 const}& childNode : sectionNode.childSections)\par
10845             writeSection(name, *childNode, okToFail);\par
10846     \}\par
10847 \par
10848     {\cf18 void} SonarQubeReporter::writeAssertions(SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail) \{\par
10849         {\cf19 for} ({\cf17 auto} {\cf17 const}& assertionOrBenchmark : sectionNode.assertionsAndBenchmarks) \{\par
10850             {\cf19 if} (assertionOrBenchmark.isAssertion()) \{\par
10851                 writeAssertion(assertionOrBenchmark.asAssertion(), okToFail);\par
10852             \}\par
10853         \}\par
10854     \}\par
10855 \par
10856     {\cf18 void} SonarQubeReporter::writeAssertion(AssertionStats {\cf17 const}& stats, {\cf18 bool} okToFail) \{\par
10857         AssertionResult {\cf17 const}& result = stats.assertionResult;\par
10858         {\cf19 if} ( !result.isOk() ||\par
10859              result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10860             std::string elementName;\par
10861             {\cf19 if} (okToFail) \{\par
10862                 elementName = {\cf22 "skipped"};\par
10863             \} {\cf19 else} \{\par
10864                 {\cf19 switch} (result.getResultType()) \{\par
10865                 {\cf19 case} ResultWas::ThrewException:\par
10866                 {\cf19 case} ResultWas::FatalErrorCondition:\par
10867                     elementName = {\cf22 "error"};\par
10868                     {\cf19 break};\par
10869                 {\cf19 case} ResultWas::ExplicitFailure:\par
10870                 {\cf19 case} ResultWas::ExpressionFailed:\par
10871                 {\cf19 case} ResultWas::DidntThrowException:\par
10872                     elementName = {\cf22 "failure"};\par
10873                     {\cf19 break};\par
10874                 {\cf19 case} ResultWas::ExplicitSkip:\par
10875                     elementName = {\cf22 "skipped"};\par
10876                     {\cf19 break};\par
10877                     {\cf20 // We should never see these here:}\par
10878                 {\cf19 case} ResultWas::Info:\par
10879                 {\cf19 case} ResultWas::Warning:\par
10880                 {\cf19 case} ResultWas::Ok:\par
10881                 {\cf19 case} ResultWas::Unknown:\par
10882                 {\cf19 case} ResultWas::FailureBit:\par
10883                 {\cf19 case} ResultWas::Exception:\par
10884                     elementName = {\cf22 "internalError"};\par
10885                     {\cf19 break};\par
10886                 \}\par
10887             \}\par
10888 \par
10889             XmlWriter::ScopedElement e = xml.scopedElement(elementName);\par
10890 \par
10891             ReusableStringStream messageRss;\par
10892             messageRss << result.getTestMacroName() << {\cf23 '('} << result.getExpression() << {\cf23 ')'};\par
10893             xml.writeAttribute({\cf22 "message"}_sr, messageRss.str());\par
10894 \par
10895             ReusableStringStream textRss;\par
10896             {\cf19 if} ( result.getResultType() == ResultWas::ExplicitSkip ) \{\par
10897                 textRss << {\cf22 "SKIPPED\\n"};\par
10898             \} {\cf19 else} \{\par
10899                 textRss << {\cf22 "FAILED:\\n"};\par
10900                 {\cf19 if} (result.hasExpression()) \{\par
10901                     textRss << {\cf23 '\\t'} << result.getExpressionInMacro() << {\cf23 '\\n'};\par
10902                 \}\par
10903                 {\cf19 if} (result.hasExpandedExpression()) \{\par
10904                     textRss << {\cf22 "with expansion:\\n\\t"} << result.getExpandedExpression() << {\cf23 '\\n'};\par
10905                 \}\par
10906             \}\par
10907 \par
10908             {\cf19 if} (result.hasMessage())\par
10909                 textRss << result.getMessage() << {\cf23 '\\n'};\par
10910 \par
10911             {\cf19 for} ({\cf17 auto} {\cf17 const}& msg : stats.infoMessages)\par
10912                 {\cf19 if} (msg.type == ResultWas::Info)\par
10913                     textRss << msg.message << {\cf23 '\\n'};\par
10914 \par
10915             textRss << {\cf22 "at "} << result.getSourceInfo();\par
10916             xml.writeText(textRss.str(), XmlFormatting::Newline);\par
10917         \}\par
10918     \}\par
10919 \par
10920 \} {\cf20 // end namespace Catch}\par
10921 \par
10922 \par
10923 \par
10924 {\cf17 namespace }Catch \{\par
10925 \par
10926     StreamingReporterBase::~StreamingReporterBase() = {\cf19 default};\par
10927 \par
10928     {\cf18 void}\par
10929     StreamingReporterBase::testRunStarting( TestRunInfo {\cf17 const}& _testRunInfo ) \{\par
10930         currentTestRunInfo = _testRunInfo;\par
10931     \}\par
10932 \par
10933     {\cf18 void} StreamingReporterBase::testRunEnded( TestRunStats {\cf17 const}& ) \{\par
10934         currentTestCaseInfo = {\cf17 nullptr};\par
10935     \}\par
10936 \par
10937 \} {\cf20 // end namespace Catch}\par
10938 \par
10939 \par
10940 \par
10941 {\cf21 #include <algorithm>}\par
10942 {\cf21 #include <ostream>}\par
10943 \par
10944 {\cf17 namespace }Catch \{\par
10945 \par
10946     {\cf17 namespace }\{\par
10947         {\cf20 // Yes, this has to be outside the class and namespaced by naming.}\par
10948         {\cf20 // Making older compiler happy is hard.}\par
10949         {\cf17 static} {\cf17 constexpr} StringRef tapFailedString = {\cf22 "not ok"}_sr;\par
10950         {\cf17 static} {\cf17 constexpr} StringRef tapPassedString = {\cf22 "ok"}_sr;\par
10951         {\cf17 static} {\cf17 constexpr} Colour::Code tapDimColour = Colour::FileName;\par
10952 \par
10953         {\cf17 class }TapAssertionPrinter \{\par
10954         {\cf17 public}:\par
10955             TapAssertionPrinter& operator= (TapAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
10956             TapAssertionPrinter(TapAssertionPrinter {\cf17 const}&) = {\cf17 delete};\par
10957             TapAssertionPrinter(std::ostream& _stream, AssertionStats {\cf17 const}& _stats, std::size_t _counter, ColourImpl* colour_)\par
10958                 : stream(_stream)\par
10959                 , result(_stats.assertionResult)\par
10960                 , messages(_stats.infoMessages)\par
10961                 , itMessage(_stats.infoMessages.begin())\par
10962                 , printInfoMessages(true)\par
10963                 , counter(_counter)\par
10964                 , colourImpl( colour_ ) \{\}\par
10965 \par
10966             {\cf18 void} print() \{\par
10967                 itMessage = messages.begin();\par
10968 \par
10969                 {\cf19 switch} (result.getResultType()) \{\par
10970                 {\cf19 case} ResultWas::Ok:\par
10971                     printResultType(tapPassedString);\par
10972                     printOriginalExpression();\par
10973                     printReconstructedExpression();\par
10974                     {\cf19 if} (!result.hasExpression())\par
10975                         printRemainingMessages(Colour::None);\par
10976                     {\cf19 else}\par
10977                         printRemainingMessages();\par
10978                     {\cf19 break};\par
10979                 {\cf19 case} ResultWas::ExpressionFailed:\par
10980                     {\cf19 if} (result.isOk()) \{\par
10981                         printResultType(tapPassedString);\par
10982                     \} {\cf19 else} \{\par
10983                         printResultType(tapFailedString);\par
10984                     \}\par
10985                     printOriginalExpression();\par
10986                     printReconstructedExpression();\par
10987                     {\cf19 if} (result.isOk()) \{\par
10988                         printIssue({\cf22 " # TODO"});\par
10989                     \}\par
10990                     printRemainingMessages();\par
10991                     {\cf19 break};\par
10992                 {\cf19 case} ResultWas::ThrewException:\par
10993                     printResultType(tapFailedString);\par
10994                     printIssue({\cf22 "unexpected exception with message:"}_sr);\par
10995                     printMessage();\par
10996                     printExpressionWas();\par
10997                     printRemainingMessages();\par
10998                     {\cf19 break};\par
10999                 {\cf19 case} ResultWas::FatalErrorCondition:\par
11000                     printResultType(tapFailedString);\par
11001                     printIssue({\cf22 "fatal error condition with message:"}_sr);\par
11002                     printMessage();\par
11003                     printExpressionWas();\par
11004                     printRemainingMessages();\par
11005                     {\cf19 break};\par
11006                 {\cf19 case} ResultWas::DidntThrowException:\par
11007                     printResultType(tapFailedString);\par
11008                     printIssue({\cf22 "expected exception, got none"}_sr);\par
11009                     printExpressionWas();\par
11010                     printRemainingMessages();\par
11011                     {\cf19 break};\par
11012                 {\cf19 case} ResultWas::Info:\par
11013                     printResultType({\cf22 "info"}_sr);\par
11014                     printMessage();\par
11015                     printRemainingMessages();\par
11016                     {\cf19 break};\par
11017                 {\cf19 case} ResultWas::Warning:\par
11018                     printResultType({\cf22 "warning"}_sr);\par
11019                     printMessage();\par
11020                     printRemainingMessages();\par
11021                     {\cf19 break};\par
11022                 {\cf19 case} ResultWas::ExplicitFailure:\par
11023                     printResultType(tapFailedString);\par
11024                     printIssue({\cf22 "explicitly"}_sr);\par
11025                     printRemainingMessages(Colour::None);\par
11026                     {\cf19 break};\par
11027                 {\cf19 case} ResultWas::ExplicitSkip:\par
11028                     printResultType(tapPassedString);\par
11029                     printIssue({\cf22 " # SKIP"}_sr);\par
11030                     printMessage();\par
11031                     printRemainingMessages();\par
11032                     {\cf19 break};\par
11033                     {\cf20 // These cases are here to prevent compiler warnings}\par
11034                 {\cf19 case} ResultWas::Unknown:\par
11035                 {\cf19 case} ResultWas::FailureBit:\par
11036                 {\cf19 case} ResultWas::Exception:\par
11037                     printResultType({\cf22 "** internal error **"}_sr);\par
11038                     {\cf19 break};\par
11039                 \}\par
11040             \}\par
11041 \par
11042         {\cf17 private}:\par
11043             {\cf18 void} printResultType(StringRef passOrFail){\cf17  const }\{\par
11044                 {\cf19 if} (!passOrFail.empty()) \{\par
11045                     stream << passOrFail << {\cf23 ' '} << counter << {\cf22 " -"};\par
11046                 \}\par
11047             \}\par
11048 \par
11049             {\cf18 void} printIssue(StringRef issue){\cf17  const }\{\par
11050                 stream << {\cf23 ' '} << issue;\par
11051             \}\par
11052 \par
11053             {\cf18 void} printExpressionWas() \{\par
11054                 {\cf19 if} (result.hasExpression()) \{\par
11055                     stream << {\cf23 ';'};\par
11056                     stream << colourImpl->guardColour( tapDimColour )\par
11057                            << {\cf22 " expression was:"};\par
11058                     printOriginalExpression();\par
11059                 \}\par
11060             \}\par
11061 \par
11062             {\cf18 void} printOriginalExpression(){\cf17  const }\{\par
11063                 {\cf19 if} (result.hasExpression()) \{\par
11064                     stream << {\cf23 ' '} << result.getExpression();\par
11065                 \}\par
11066             \}\par
11067 \par
11068             {\cf18 void} printReconstructedExpression(){\cf17  const }\{\par
11069                 {\cf19 if} (result.hasExpandedExpression()) \{\par
11070                     stream << colourImpl->guardColour( tapDimColour ) << {\cf22 " for: "};\par
11071 \par
11072                     std::string expr = result.getExpandedExpression();\par
11073                     std::replace(expr.begin(), expr.end(), {\cf23 '\\n'}, {\cf23 ' '});\par
11074                     stream << expr;\par
11075                 \}\par
11076             \}\par
11077 \par
11078             {\cf18 void} printMessage() \{\par
11079                 {\cf19 if} (itMessage != messages.end()) \{\par
11080                     stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
11081                     ++itMessage;\par
11082                 \}\par
11083             \}\par
11084 \par
11085             {\cf18 void} printRemainingMessages(Colour::Code colour = tapDimColour) \{\par
11086                 {\cf19 if} (itMessage == messages.end()) \{\par
11087                     {\cf19 return};\par
11088                 \}\par
11089 \par
11090                 {\cf20 // using messages.end() directly (or auto) yields compilation error:}\par
11091                 std::vector<MessageInfo>::const_iterator itEnd = messages.end();\par
11092                 {\cf17 const} std::size_t N = {\cf17 static_cast<}std::size_t{\cf17 >}(itEnd - itMessage);\par
11093 \par
11094                 stream << colourImpl->guardColour( colour ) << {\cf22 " with "}\par
11095                        << pluralise( N, {\cf22 "message"}_sr ) << {\cf23 ':'};\par
11096 \par
11097                 {\cf19 for} (; itMessage != itEnd; ) \{\par
11098                     {\cf20 // If this assertion is a warning ignore any INFO messages}\par
11099                     {\cf19 if} (printInfoMessages || itMessage->type != ResultWas::Info) \{\par
11100                         stream << {\cf22 " '"} << itMessage->message << {\cf23 '\\''};\par
11101                         {\cf19 if} (++itMessage != itEnd) \{\par
11102                             stream << colourImpl->guardColour(tapDimColour) << {\cf22 " and"};\par
11103                         \}\par
11104                     \}\par
11105                 \}\par
11106             \}\par
11107 \par
11108         {\cf17 private}:\par
11109             std::ostream& stream;\par
11110             AssertionResult {\cf17 const}& result;\par
11111             std::vector<MessageInfo> {\cf17 const}& messages;\par
11112             std::vector<MessageInfo>::const_iterator itMessage;\par
11113             {\cf18 bool} printInfoMessages;\par
11114             std::size_t counter;\par
11115             ColourImpl* colourImpl;\par
11116         \};\par
11117 \par
11118     \} {\cf20 // End anonymous namespace}\par
11119 \par
11120     {\cf18 void} TAPReporter::testRunStarting( TestRunInfo {\cf17 const}& ) \{\par
11121         {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
11122             m_stream << {\cf22 "# filters: "} << m_config->testSpec() << {\cf23 '\\n'};\par
11123         \}\par
11124         m_stream << {\cf22 "# rng-seed: "} << m_config->rngSeed() << {\cf23 '\\n'};\par
11125     \}\par
11126 \par
11127     {\cf18 void} TAPReporter::noMatchingTestCases( StringRef unmatchedSpec ) \{\par
11128         m_stream << {\cf22 "# No test cases matched '"} << unmatchedSpec << {\cf22 "'\\n"};\par
11129     \}\par
11130 \par
11131     {\cf18 void} TAPReporter::assertionEnded(AssertionStats {\cf17 const}& _assertionStats) \{\par
11132         ++counter;\par
11133 \par
11134         m_stream << {\cf22 "# "} << currentTestCaseInfo->name << {\cf23 '\\n'};\par
11135         TapAssertionPrinter printer(m_stream, _assertionStats, counter, m_colour.get());\par
11136         printer.print();\par
11137 \par
11138         m_stream << {\cf23 '\\n'} << std::flush;\par
11139     \}\par
11140 \par
11141     {\cf18 void} TAPReporter::testRunEnded(TestRunStats {\cf17 const}& _testRunStats) \{\par
11142         m_stream << {\cf22 "1.."} << _testRunStats.totals.assertions.total();\par
11143         {\cf19 if} (_testRunStats.totals.testCases.total() == 0) \{\par
11144             m_stream << {\cf22 " # Skipped: No tests ran."};\par
11145         \}\par
11146         m_stream << {\cf22 "\\n\\n"} << std::flush;\par
11147         StreamingReporterBase::testRunEnded(_testRunStats);\par
11148     \}\par
11149 \par
11150 \par
11151 \par
11152 \par
11153 \} {\cf20 // end namespace Catch}\par
11154 \par
11155 \par
11156 \par
11157 \par
11158 {\cf21 #include <cassert>}\par
11159 {\cf21 #include <ostream>}\par
11160 \par
11161 {\cf17 namespace }Catch \{\par
11162 \par
11163     {\cf17 namespace }\{\par
11164         {\cf20 // if string has a : in first line will set indent to follow it on}\par
11165         {\cf20 // subsequent lines}\par
11166         {\cf18 void} printHeaderString(std::ostream& os, std::string {\cf17 const}& _string, std::size_t indent = 0) \{\par
11167             std::size_t i = _string.find({\cf22 ": "});\par
11168             {\cf19 if} (i != std::string::npos)\par
11169                 i += 2;\par
11170             {\cf19 else}\par
11171                 i = 0;\par
11172             os << TextFlow::Column(_string)\par
11173                   .indent(indent + i)\par
11174                   .initialIndent(indent) << {\cf23 '\\n'};\par
11175         \}\par
11176 \par
11177         std::string escape(StringRef str) \{\par
11178             std::string escaped = {\cf17 static_cast<}std::string{\cf17 >}(str);\par
11179             replaceInPlace(escaped, {\cf22 "|"}, {\cf22 "||"});\par
11180             replaceInPlace(escaped, {\cf22 "'"}, {\cf22 "|'"});\par
11181             replaceInPlace(escaped, {\cf22 "\\n"}, {\cf22 "|n"});\par
11182             replaceInPlace(escaped, {\cf22 "\\r"}, {\cf22 "|r"});\par
11183             replaceInPlace(escaped, {\cf22 "["}, {\cf22 "|["});\par
11184             replaceInPlace(escaped, {\cf22 "]"}, {\cf22 "|]"});\par
11185             {\cf19 return} escaped;\par
11186         \}\par
11187     \} {\cf20 // end anonymous namespace}\par
11188 \par
11189 \par
11190     TeamCityReporter::~TeamCityReporter() = {\cf19 default};\par
11191 \par
11192     {\cf18 void} TeamCityReporter::testRunStarting( TestRunInfo {\cf17 const}& runInfo ) \{\par
11193         m_stream << {\cf22 "##teamcity[testSuiteStarted name='"} << escape( runInfo.name )\par
11194                << {\cf22 "']\\n"};\par
11195     \}\par
11196 \par
11197     {\cf18 void} TeamCityReporter::testRunEnded( TestRunStats {\cf17 const}& runStats ) \{\par
11198         m_stream << {\cf22 "##teamcity[testSuiteFinished name='"}\par
11199                << escape( runStats.runInfo.name ) << {\cf22 "']\\n"};\par
11200     \}\par
11201 \par
11202     {\cf18 void} TeamCityReporter::assertionEnded(AssertionStats {\cf17 const}& assertionStats) \{\par
11203         AssertionResult {\cf17 const}& result = assertionStats.assertionResult;\par
11204         {\cf19 if} ( !result.isOk() ||\par
11205              result.getResultType() == ResultWas::ExplicitSkip ) \{\par
11206 \par
11207             ReusableStringStream msg;\par
11208             {\cf19 if} (!m_headerPrintedForThisSection)\par
11209                 printSectionHeader(msg.get());\par
11210             m_headerPrintedForThisSection = {\cf17 true};\par
11211 \par
11212             msg << result.getSourceInfo() << {\cf23 '\\n'};\par
11213 \par
11214             {\cf19 switch} (result.getResultType()) \{\par
11215             {\cf19 case} ResultWas::ExpressionFailed:\par
11216                 msg << {\cf22 "expression failed"};\par
11217                 {\cf19 break};\par
11218             {\cf19 case} ResultWas::ThrewException:\par
11219                 msg << {\cf22 "unexpected exception"};\par
11220                 {\cf19 break};\par
11221             {\cf19 case} ResultWas::FatalErrorCondition:\par
11222                 msg << {\cf22 "fatal error condition"};\par
11223                 {\cf19 break};\par
11224             {\cf19 case} ResultWas::DidntThrowException:\par
11225                 msg << {\cf22 "no exception was thrown where one was expected"};\par
11226                 {\cf19 break};\par
11227             {\cf19 case} ResultWas::ExplicitFailure:\par
11228                 msg << {\cf22 "explicit failure"};\par
11229                 {\cf19 break};\par
11230             {\cf19 case} ResultWas::ExplicitSkip:\par
11231                 msg << {\cf22 "explicit skip"};\par
11232                 {\cf19 break};\par
11233 \par
11234                 {\cf20 // We shouldn't get here because of the isOk() test}\par
11235             {\cf19 case} ResultWas::Ok:\par
11236             {\cf19 case} ResultWas::Info:\par
11237             {\cf19 case} ResultWas::Warning:\par
11238                 CATCH_ERROR({\cf22 "Internal error in TeamCity reporter"});\par
11239                 {\cf20 // These cases are here to prevent compiler warnings}\par
11240             {\cf19 case} ResultWas::Unknown:\par
11241             {\cf19 case} ResultWas::FailureBit:\par
11242             {\cf19 case} ResultWas::Exception:\par
11243                 CATCH_ERROR({\cf22 "Not implemented"});\par
11244             \}\par
11245             {\cf19 if} (assertionStats.infoMessages.size() == 1)\par
11246                 msg << {\cf22 " with message:"};\par
11247             {\cf19 if} (assertionStats.infoMessages.size() > 1)\par
11248                 msg << {\cf22 " with messages:"};\par
11249             {\cf19 for} ({\cf17 auto} {\cf17 const}& messageInfo : assertionStats.infoMessages)\par
11250                 msg << {\cf22 "\\n  \\""} << messageInfo.message << {\cf23 '"'};\par
11251 \par
11252 \par
11253             {\cf19 if} (result.hasExpression()) \{\par
11254                 msg <<\par
11255                     {\cf22 "\\n  "} << result.getExpressionInMacro() << {\cf22 "\\n"}\par
11256                     {\cf22 "with expansion:\\n"}\par
11257                     {\cf22 "  "} << result.getExpandedExpression() << {\cf23 '\\n'};\par
11258             \}\par
11259 \par
11260             {\cf19 if} ( result.getResultType() == ResultWas::ExplicitSkip ) \{\par
11261                 m_stream << {\cf22 "##teamcity[testIgnored"};\par
11262             \} {\cf19 else} {\cf19 if} ( currentTestCaseInfo->okToFail() ) \{\par
11263                 msg << {\cf22 "- failure ignore as test marked as 'ok to fail'\\n"};\par
11264                 m_stream << {\cf22 "##teamcity[testIgnored"};\par
11265             \} {\cf19 else} \{\par
11266                 m_stream << {\cf22 "##teamcity[testFailed"};\par
11267             \}\par
11268             m_stream << {\cf22 " name='"} << escape( currentTestCaseInfo->name ) << {\cf23 '\\''}\par
11269                      << {\cf22 " message='"} << escape( msg.str() ) << {\cf23 '\\''} << {\cf22 "]\\n"};\par
11270         \}\par
11271         m_stream.flush();\par
11272     \}\par
11273 \par
11274     {\cf18 void} TeamCityReporter::testCaseStarting(TestCaseInfo {\cf17 const}& testInfo) \{\par
11275         m_testTimer.start();\par
11276         StreamingReporterBase::testCaseStarting(testInfo);\par
11277         m_stream << {\cf22 "##teamcity[testStarted name='"}\par
11278             << escape(testInfo.name) << {\cf22 "']\\n"};\par
11279         m_stream.flush();\par
11280     \}\par
11281 \par
11282     {\cf18 void} TeamCityReporter::testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) \{\par
11283         StreamingReporterBase::testCaseEnded(testCaseStats);\par
11284         {\cf17 auto} {\cf17 const}& testCaseInfo = *testCaseStats.testInfo;\par
11285         {\cf19 if} (!testCaseStats.stdOut.empty())\par
11286             m_stream << {\cf22 "##teamcity[testStdOut name='"}\par
11287             << escape(testCaseInfo.name)\par
11288             << {\cf22 "' out='"} << escape(testCaseStats.stdOut) << {\cf22 "']\\n"};\par
11289         {\cf19 if} (!testCaseStats.stdErr.empty())\par
11290             m_stream << {\cf22 "##teamcity[testStdErr name='"}\par
11291             << escape(testCaseInfo.name)\par
11292             << {\cf22 "' out='"} << escape(testCaseStats.stdErr) << {\cf22 "']\\n"};\par
11293         m_stream << {\cf22 "##teamcity[testFinished name='"}\par
11294             << escape(testCaseInfo.name) << {\cf22 "' duration='"}\par
11295             << m_testTimer.getElapsedMilliseconds() << {\cf22 "']\\n"};\par
11296         m_stream.flush();\par
11297     \}\par
11298 \par
11299     {\cf18 void} TeamCityReporter::printSectionHeader(std::ostream& os) \{\par
11300         assert(!m_sectionStack.empty());\par
11301 \par
11302         {\cf19 if} (m_sectionStack.size() > 1) \{\par
11303             os << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
11304 \par
11305             std::vector<SectionInfo>::const_iterator\par
11306                 it = m_sectionStack.begin() + 1, {\cf20 // Skip first section (test case)}\par
11307                 itEnd = m_sectionStack.end();\par
11308             {\cf19 for} (; it != itEnd; ++it)\par
11309                 printHeaderString(os, it->name);\par
11310             os << lineOfChars({\cf23 '-'}) << {\cf23 '\\n'};\par
11311         \}\par
11312 \par
11313         SourceLineInfo lineInfo = m_sectionStack.front().lineInfo;\par
11314 \par
11315         os << lineInfo << {\cf23 '\\n'};\par
11316         os << lineOfChars({\cf23 '.'}) << {\cf22 "\\n\\n"};\par
11317     \}\par
11318 \par
11319 \} {\cf20 // end namespace Catch}\par
11320 \par
11321 \par
11322 \par
11323 \par
11324 {\cf21 #if defined(_MSC_VER)}\par
11325 {\cf21 #pragma warning(push)}\par
11326 {\cf21 #pragma warning(disable:4061) }{\cf20 // Not all labels are EXPLICITLY handled in switch}\par
11327                               {\cf20 // Note that 4062 (not all labels are handled}\par
11328                               {\cf20 // and default is missing) is enabled}\par
11329 {\cf21 #endif}\par
11330 \par
11331 {\cf17 namespace }Catch \{\par
11332     XmlReporter::XmlReporter( ReporterConfig&& _config )\par
11333     :   StreamingReporterBase( CATCH_MOVE(_config) ),\par
11334         m_xml(m_stream)\par
11335     \{\par
11336         m_preferences.shouldRedirectStdOut = {\cf17 true};\par
11337         m_preferences.shouldReportAllAssertions = {\cf17 true};\par
11338     \}\par
11339 \par
11340     XmlReporter::~XmlReporter() = {\cf19 default};\par
11341 \par
11342     std::string XmlReporter::getDescription() \{\par
11343         {\cf19 return} {\cf22 "Reports test results as an XML document"};\par
11344     \}\par
11345 \par
11346     std::string XmlReporter::getStylesheetRef(){\cf17  const }\{\par
11347         {\cf19 return} std::string();\par
11348     \}\par
11349 \par
11350     {\cf18 void} XmlReporter::writeSourceInfo( SourceLineInfo {\cf17 const}& sourceInfo ) \{\par
11351         m_xml\par
11352             .writeAttribute( {\cf22 "filename"}_sr, sourceInfo.file )\par
11353             .writeAttribute( {\cf22 "line"}_sr, sourceInfo.line );\par
11354     \}\par
11355 \par
11356     {\cf18 void} XmlReporter::testRunStarting( TestRunInfo {\cf17 const}& testInfo ) \{\par
11357         StreamingReporterBase::testRunStarting( testInfo );\par
11358         std::string stylesheetRef = getStylesheetRef();\par
11359         {\cf19 if}( !stylesheetRef.empty() )\par
11360             m_xml.writeStylesheetRef( stylesheetRef );\par
11361         m_xml.startElement({\cf22 "Catch2TestRun"})\par
11362              .writeAttribute({\cf22 "name"}_sr, m_config->name())\par
11363              .writeAttribute({\cf22 "rng-seed"}_sr, m_config->rngSeed())\par
11364              .writeAttribute({\cf22 "xml-format-version"}_sr, 3)\par
11365              .writeAttribute({\cf22 "catch2-version"}_sr, libraryVersion());\par
11366         {\cf19 if} ( m_config->testSpec().hasFilters() ) \{\par
11367             m_xml.writeAttribute( {\cf22 "filters"}_sr, m_config->testSpec() );\par
11368         \}\par
11369     \}\par
11370 \par
11371     {\cf18 void} XmlReporter::testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) \{\par
11372         StreamingReporterBase::testCaseStarting(testInfo);\par
11373         m_xml.startElement( {\cf22 "TestCase"} )\par
11374             .writeAttribute( {\cf22 "name"}_sr, trim( StringRef(testInfo.name) ) )\par
11375             .writeAttribute( {\cf22 "tags"}_sr, testInfo.tagsAsString() );\par
11376 \par
11377         writeSourceInfo( testInfo.lineInfo );\par
11378 \par
11379         {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
11380             m_testCaseTimer.start();\par
11381         m_xml.ensureTagClosed();\par
11382     \}\par
11383 \par
11384     {\cf18 void} XmlReporter::sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) \{\par
11385         StreamingReporterBase::sectionStarting( sectionInfo );\par
11386         {\cf19 if}( m_sectionDepth++ > 0 ) \{\par
11387             m_xml.startElement( {\cf22 "Section"} )\par
11388                 .writeAttribute( {\cf22 "name"}_sr, trim( StringRef(sectionInfo.name) ) );\par
11389             writeSourceInfo( sectionInfo.lineInfo );\par
11390             m_xml.ensureTagClosed();\par
11391         \}\par
11392     \}\par
11393 \par
11394     {\cf18 void} XmlReporter::assertionStarting( AssertionInfo {\cf17 const}& ) \{ \}\par
11395 \par
11396     {\cf18 void} XmlReporter::assertionEnded( AssertionStats {\cf17 const}& assertionStats ) \{\par
11397 \par
11398         AssertionResult {\cf17 const}& result = assertionStats.assertionResult;\par
11399 \par
11400         {\cf18 bool} includeResults = m_config->includeSuccessfulResults() || !result.isOk();\par
11401 \par
11402         {\cf19 if}( includeResults || result.getResultType() == ResultWas::Warning ) \{\par
11403             {\cf20 // Print any info messages in <Info> tags.}\par
11404             {\cf19 for}( {\cf17 auto} {\cf17 const}& msg : assertionStats.infoMessages ) \{\par
11405                 {\cf19 if}( msg.type == ResultWas::Info && includeResults ) \{\par
11406                     {\cf17 auto} t = m_xml.scopedElement( {\cf22 "Info"} );\par
11407                     writeSourceInfo( msg.lineInfo );\par
11408                     t.writeText( msg.message );\par
11409                 \} {\cf19 else} {\cf19 if} ( msg.type == ResultWas::Warning ) \{\par
11410                     {\cf17 auto} t = m_xml.scopedElement( {\cf22 "Warning"} );\par
11411                     writeSourceInfo( msg.lineInfo );\par
11412                     t.writeText( msg.message );\par
11413                 \}\par
11414             \}\par
11415         \}\par
11416 \par
11417         {\cf20 // Drop out if result was successful but we're not printing them.}\par
11418         {\cf19 if} ( !includeResults && result.getResultType() != ResultWas::Warning &&\par
11419              result.getResultType() != ResultWas::ExplicitSkip ) \{\par
11420             {\cf19 return};\par
11421         \}\par
11422 \par
11423         {\cf20 // Print the expression if there is one.}\par
11424         {\cf19 if}( result.hasExpression() ) \{\par
11425             m_xml.startElement( {\cf22 "Expression"} )\par
11426                 .writeAttribute( {\cf22 "success"}_sr, result.succeeded() )\par
11427                 .writeAttribute( {\cf22 "type"}_sr, result.getTestMacroName() );\par
11428 \par
11429             writeSourceInfo( result.getSourceInfo() );\par
11430 \par
11431             m_xml.scopedElement( {\cf22 "Original"} )\par
11432                 .writeText( result.getExpression() );\par
11433             m_xml.scopedElement( {\cf22 "Expanded"} )\par
11434                 .writeText( result.getExpandedExpression() );\par
11435         \}\par
11436 \par
11437         {\cf20 // And... Print a result applicable to each result type.}\par
11438         {\cf19 switch}( result.getResultType() ) \{\par
11439             {\cf19 case} ResultWas::ThrewException:\par
11440                 m_xml.startElement( {\cf22 "Exception"} );\par
11441                 writeSourceInfo( result.getSourceInfo() );\par
11442                 m_xml.writeText( result.getMessage() );\par
11443                 m_xml.endElement();\par
11444                 {\cf19 break};\par
11445             {\cf19 case} ResultWas::FatalErrorCondition:\par
11446                 m_xml.startElement( {\cf22 "FatalErrorCondition"} );\par
11447                 writeSourceInfo( result.getSourceInfo() );\par
11448                 m_xml.writeText( result.getMessage() );\par
11449                 m_xml.endElement();\par
11450                 {\cf19 break};\par
11451             {\cf19 case} ResultWas::Info:\par
11452                 m_xml.scopedElement( {\cf22 "Info"} )\par
11453                      .writeText( result.getMessage() );\par
11454                 {\cf19 break};\par
11455             {\cf19 case} ResultWas::Warning:\par
11456                 {\cf20 // Warning will already have been written}\par
11457                 {\cf19 break};\par
11458             {\cf19 case} ResultWas::ExplicitFailure:\par
11459                 m_xml.startElement( {\cf22 "Failure"} );\par
11460                 writeSourceInfo( result.getSourceInfo() );\par
11461                 m_xml.writeText( result.getMessage() );\par
11462                 m_xml.endElement();\par
11463                 {\cf19 break};\par
11464             {\cf19 case} ResultWas::ExplicitSkip:\par
11465                 m_xml.startElement( {\cf22 "Skip"} );\par
11466                 writeSourceInfo( result.getSourceInfo() );\par
11467                 m_xml.writeText( result.getMessage() );\par
11468                 m_xml.endElement();\par
11469                 {\cf19 break};\par
11470             {\cf19 default}:\par
11471                 {\cf19 break};\par
11472         \}\par
11473 \par
11474         {\cf19 if}( result.hasExpression() )\par
11475             m_xml.endElement();\par
11476     \}\par
11477 \par
11478     {\cf18 void} XmlReporter::sectionEnded( SectionStats {\cf17 const}& sectionStats ) \{\par
11479         StreamingReporterBase::sectionEnded( sectionStats );\par
11480         {\cf19 if} ( --m_sectionDepth > 0 ) \{\par
11481             \{\par
11482                 XmlWriter::ScopedElement e = m_xml.scopedElement( {\cf22 "OverallResults"} );\par
11483                 e.writeAttribute( {\cf22 "successes"}_sr, sectionStats.assertions.passed );\par
11484                 e.writeAttribute( {\cf22 "failures"}_sr, sectionStats.assertions.failed );\par
11485                 e.writeAttribute( {\cf22 "expectedFailures"}_sr, sectionStats.assertions.failedButOk );\par
11486                 e.writeAttribute( {\cf22 "skipped"}_sr, sectionStats.assertions.skipped > 0 );\par
11487 \par
11488                 {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
11489                     e.writeAttribute( {\cf22 "durationInSeconds"}_sr, sectionStats.durationInSeconds );\par
11490             \}\par
11491             {\cf20 // Ends assertion tag}\par
11492             m_xml.endElement();\par
11493         \}\par
11494     \}\par
11495 \par
11496     {\cf18 void} XmlReporter::testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) \{\par
11497         StreamingReporterBase::testCaseEnded( testCaseStats );\par
11498         XmlWriter::ScopedElement e = m_xml.scopedElement( {\cf22 "OverallResult"} );\par
11499         e.writeAttribute( {\cf22 "success"}_sr, testCaseStats.totals.assertions.allOk() );\par
11500         e.writeAttribute( {\cf22 "skips"}_sr, testCaseStats.totals.assertions.skipped );\par
11501 \par
11502         {\cf19 if} ( m_config->showDurations() == ShowDurations::Always )\par
11503             e.writeAttribute( {\cf22 "durationInSeconds"}_sr, m_testCaseTimer.getElapsedSeconds() );\par
11504         {\cf19 if}( !testCaseStats.stdOut.empty() )\par
11505             m_xml.scopedElement( {\cf22 "StdOut"} ).writeText( trim( StringRef(testCaseStats.stdOut) ), XmlFormatting::Newline );\par
11506         {\cf19 if}( !testCaseStats.stdErr.empty() )\par
11507             m_xml.scopedElement( {\cf22 "StdErr"} ).writeText( trim( StringRef(testCaseStats.stdErr) ), XmlFormatting::Newline );\par
11508 \par
11509         m_xml.endElement();\par
11510     \}\par
11511 \par
11512     {\cf18 void} XmlReporter::testRunEnded( TestRunStats {\cf17 const}& testRunStats ) \{\par
11513         StreamingReporterBase::testRunEnded( testRunStats );\par
11514         m_xml.scopedElement( {\cf22 "OverallResults"} )\par
11515             .writeAttribute( {\cf22 "successes"}_sr, testRunStats.totals.assertions.passed )\par
11516             .writeAttribute( {\cf22 "failures"}_sr, testRunStats.totals.assertions.failed )\par
11517             .writeAttribute( {\cf22 "expectedFailures"}_sr, testRunStats.totals.assertions.failedButOk )\par
11518             .writeAttribute( {\cf22 "skips"}_sr, testRunStats.totals.assertions.skipped );\par
11519         m_xml.scopedElement( {\cf22 "OverallResultsCases"})\par
11520             .writeAttribute( {\cf22 "successes"}_sr, testRunStats.totals.testCases.passed )\par
11521             .writeAttribute( {\cf22 "failures"}_sr, testRunStats.totals.testCases.failed )\par
11522             .writeAttribute( {\cf22 "expectedFailures"}_sr, testRunStats.totals.testCases.failedButOk )\par
11523             .writeAttribute( {\cf22 "skips"}_sr, testRunStats.totals.testCases.skipped );\par
11524         m_xml.endElement();\par
11525     \}\par
11526 \par
11527     {\cf18 void} XmlReporter::benchmarkPreparing( StringRef name ) \{\par
11528         m_xml.startElement({\cf22 "BenchmarkResults"})\par
11529              .writeAttribute({\cf22 "name"}_sr, name);\par
11530     \}\par
11531 \par
11532     {\cf18 void} XmlReporter::benchmarkStarting(BenchmarkInfo {\cf17 const} &info) \{\par
11533         m_xml.writeAttribute({\cf22 "samples"}_sr, info.samples)\par
11534             .writeAttribute({\cf22 "resamples"}_sr, info.resamples)\par
11535             .writeAttribute({\cf22 "iterations"}_sr, info.iterations)\par
11536             .writeAttribute({\cf22 "clockResolution"}_sr, info.clockResolution)\par
11537             .writeAttribute({\cf22 "estimatedDuration"}_sr, info.estimatedDuration)\par
11538             .writeComment({\cf22 "All values in nano seconds"}_sr);\par
11539     \}\par
11540 \par
11541     {\cf18 void} XmlReporter::benchmarkEnded(BenchmarkStats<> {\cf17 const}& benchmarkStats) \{\par
11542         m_xml.scopedElement({\cf22 "mean"})\par
11543             .writeAttribute({\cf22 "value"}_sr, benchmarkStats.mean.point.count())\par
11544             .writeAttribute({\cf22 "lowerBound"}_sr, benchmarkStats.mean.lower_bound.count())\par
11545             .writeAttribute({\cf22 "upperBound"}_sr, benchmarkStats.mean.upper_bound.count())\par
11546             .writeAttribute({\cf22 "ci"}_sr, benchmarkStats.mean.confidence_interval);\par
11547         m_xml.scopedElement({\cf22 "standardDeviation"})\par
11548             .writeAttribute({\cf22 "value"}_sr, benchmarkStats.standardDeviation.point.count())\par
11549             .writeAttribute({\cf22 "lowerBound"}_sr, benchmarkStats.standardDeviation.lower_bound.count())\par
11550             .writeAttribute({\cf22 "upperBound"}_sr, benchmarkStats.standardDeviation.upper_bound.count())\par
11551             .writeAttribute({\cf22 "ci"}_sr, benchmarkStats.standardDeviation.confidence_interval);\par
11552         m_xml.scopedElement({\cf22 "outliers"})\par
11553             .writeAttribute({\cf22 "variance"}_sr, benchmarkStats.outlierVariance)\par
11554             .writeAttribute({\cf22 "lowMild"}_sr, benchmarkStats.outliers.low_mild)\par
11555             .writeAttribute({\cf22 "lowSevere"}_sr, benchmarkStats.outliers.low_severe)\par
11556             .writeAttribute({\cf22 "highMild"}_sr, benchmarkStats.outliers.high_mild)\par
11557             .writeAttribute({\cf22 "highSevere"}_sr, benchmarkStats.outliers.high_severe);\par
11558         m_xml.endElement();\par
11559     \}\par
11560 \par
11561     {\cf18 void} XmlReporter::benchmarkFailed(StringRef error) \{\par
11562         m_xml.scopedElement({\cf22 "failed"}).\par
11563             writeAttribute({\cf22 "message"}_sr, error);\par
11564         m_xml.endElement();\par
11565     \}\par
11566 \par
11567     {\cf18 void} XmlReporter::listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) \{\par
11568         {\cf17 auto} outerTag = m_xml.scopedElement({\cf22 "AvailableReporters"});\par
11569         {\cf19 for} ({\cf17 auto} {\cf17 const}& reporter : descriptions) \{\par
11570             {\cf17 auto} inner = m_xml.scopedElement({\cf22 "Reporter"});\par
11571             m_xml.startElement({\cf22 "Name"}, XmlFormatting::Indent)\par
11572                  .writeText(reporter.name, XmlFormatting::None)\par
11573                  .endElement(XmlFormatting::Newline);\par
11574             m_xml.startElement({\cf22 "Description"}, XmlFormatting::Indent)\par
11575                  .writeText(reporter.description, XmlFormatting::None)\par
11576                  .endElement(XmlFormatting::Newline);\par
11577         \}\par
11578     \}\par
11579 \par
11580     {\cf18 void} XmlReporter::listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) \{\par
11581         {\cf17 auto} outerTag = m_xml.scopedElement( {\cf22 "RegisteredListeners"} );\par
11582         {\cf19 for} ( {\cf17 auto} {\cf17 const}& listener : descriptions ) \{\par
11583             {\cf17 auto} inner = m_xml.scopedElement( {\cf22 "Listener"} );\par
11584             m_xml.startElement( {\cf22 "Name"}, XmlFormatting::Indent )\par
11585                 .writeText( listener.name, XmlFormatting::None )\par
11586                 .endElement( XmlFormatting::Newline );\par
11587             m_xml.startElement( {\cf22 "Description"}, XmlFormatting::Indent )\par
11588                 .writeText( listener.description, XmlFormatting::None )\par
11589                 .endElement( XmlFormatting::Newline );\par
11590         \}\par
11591     \}\par
11592 \par
11593     {\cf18 void} XmlReporter::listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) \{\par
11594         {\cf17 auto} outerTag = m_xml.scopedElement({\cf22 "MatchingTests"});\par
11595         {\cf19 for} ({\cf17 auto} {\cf17 const}& test : tests) \{\par
11596             {\cf17 auto} innerTag = m_xml.scopedElement({\cf22 "TestCase"});\par
11597             {\cf17 auto} {\cf17 const}& testInfo = test.getTestCaseInfo();\par
11598             m_xml.startElement({\cf22 "Name"}, XmlFormatting::Indent)\par
11599                  .writeText(testInfo.name, XmlFormatting::None)\par
11600                  .endElement(XmlFormatting::Newline);\par
11601             m_xml.startElement({\cf22 "ClassName"}, XmlFormatting::Indent)\par
11602                  .writeText(testInfo.className, XmlFormatting::None)\par
11603                  .endElement(XmlFormatting::Newline);\par
11604             m_xml.startElement({\cf22 "Tags"}, XmlFormatting::Indent)\par
11605                  .writeText(testInfo.tagsAsString(), XmlFormatting::None)\par
11606                  .endElement(XmlFormatting::Newline);\par
11607 \par
11608             {\cf17 auto} sourceTag = m_xml.scopedElement({\cf22 "SourceInfo"});\par
11609             m_xml.startElement({\cf22 "File"}, XmlFormatting::Indent)\par
11610                  .writeText(testInfo.lineInfo.file, XmlFormatting::None)\par
11611                  .endElement(XmlFormatting::Newline);\par
11612             m_xml.startElement({\cf22 "Line"}, XmlFormatting::Indent)\par
11613                  .writeText(std::to_string(testInfo.lineInfo.line), XmlFormatting::None)\par
11614                  .endElement(XmlFormatting::Newline);\par
11615         \}\par
11616     \}\par
11617 \par
11618     {\cf18 void} XmlReporter::listTags(std::vector<TagInfo> {\cf17 const}& tags) \{\par
11619         {\cf17 auto} outerTag = m_xml.scopedElement({\cf22 "TagsFromMatchingTests"});\par
11620         {\cf19 for} ({\cf17 auto} {\cf17 const}& tag : tags) \{\par
11621             {\cf17 auto} innerTag = m_xml.scopedElement({\cf22 "Tag"});\par
11622             m_xml.startElement({\cf22 "Count"}, XmlFormatting::Indent)\par
11623                  .writeText(std::to_string(tag.count), XmlFormatting::None)\par
11624                  .endElement(XmlFormatting::Newline);\par
11625             {\cf17 auto} aliasTag = m_xml.scopedElement({\cf22 "Aliases"});\par
11626             {\cf19 for} ({\cf17 auto} {\cf17 const}& alias : tag.spellings) \{\par
11627                 m_xml.startElement({\cf22 "Alias"}, XmlFormatting::Indent)\par
11628                      .writeText(alias, XmlFormatting::None)\par
11629                      .endElement(XmlFormatting::Newline);\par
11630             \}\par
11631         \}\par
11632     \}\par
11633 \par
11634 \} {\cf20 // end namespace Catch}\par
11635 \par
11636 {\cf21 #if defined(_MSC_VER)}\par
11637 {\cf21 #pragma warning(pop)}\par
11638 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo test/catch_amalgamated.hpp\par \pard\plain 
{\tc\tcl2 \v test/catch_amalgamated.hpp}
{\xe \v test/catch_amalgamated.hpp}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <type_traits>}\par
{\f2 #include <string>}\par
{\f2 #include <chrono>}\par
{\f2 #include <cstddef>}\par
{\f2 #include <iosfwd>}\par
{\f2 #include <cassert>}\par
{\f2 #include <cstring>}\par
{\f2 #include <vector>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <cmath>}\par
{\f2 #include <exception>}\par
{\f2 #include <ostream>}\par
{\f2 #include <ctime>}\par
{\f2 #include <ratio>}\par
{\f2 #include <cstdint>}\par
{\f2 #include <map>}\par
{\f2 #include <memory>}\par
{\f2 #include <sstream>}\par
{\f2 #include <tuple>}\par
{\f2 #include <climits>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Context}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::TestFailureException}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that an assertion macro failed. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::TestSkipException}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to signal that the remainder of a test should be skipped. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::StringRef}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ResultWas}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ResultDisposition}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Detail::unique_ptr< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IResultCapture}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Detail::NonCopyable}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deriving classes become noncopyable and nonmovable. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::WarnAbout}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::WaitForKeypress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IConfig}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IMutableRegistryHub}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Estimate< Type >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::OutlierClassification}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::BenchmarkInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::BenchmarkStats< Dummy >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::EnvironmentEstimate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Environment}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::true_given< typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::is_callable_tester}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::is_callable< Fun(Args...)>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::ChronometerConcept}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::ChronometerModel< Clock >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Chronometer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::is_related< T, U >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::BenchmarkFunction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::repeater< Fun >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::CompleteType< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::CompleteType< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::CompleteType< void >::type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::CompleteInvoker< Result >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::CompleteInvoker< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Timing< Result >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::ExecutionPlan}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::bootstrap_analysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::SampleAnalysis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Benchmark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Benchmark::Detail::ObjectStorage< T, Destruct >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ReusableStringStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::make_void<... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::EnumInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IMutableEnumValuesRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch_global_namespace_dummy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Detail::IsStreamInsertable< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::string >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::wstring >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< wchar_t const * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< wchar_t * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< signed char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned char[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned int >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned long long >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< bool >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< signed char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< unsigned char >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::nullptr_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< float >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< double >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< T * >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< R C::* >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::is_range_impl< T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::is_range_impl< T, void_t< decltype(begin(std::declval< T >()))> >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::is_range< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< R, std::enable_if_t< is_range< R >::value &&!::Catch::Detail::IsStreamInsertable< R >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< T[SZ]>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ratio_string< Ratio >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ratio_string< std::atto >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ratio_string< std::femto >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ratio_string< std::pico >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ratio_string< std::nano >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ratio_string< std::micro >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ratio_string< std::milli >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::chrono::duration< Value, Ratio > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::chrono::duration< Value, std::ratio< 1 > > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::chrono::duration< Value, std::ratio< 60 > > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::chrono::duration< Value, std::ratio< 3600 > > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::chrono::time_point< Clock, Duration > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< std::chrono::time_point< std::chrono::system_clock, Duration > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Approx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringMaker< Catch::Approx >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SourceLineInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::AssertionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::LazyExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::AssertionResultData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::AssertionResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::WildcardPattern}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::TestSpec}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::TestSpec::FilterMatch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Optional< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ReporterSpec}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ProcessedReporterSpec}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ConfigData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Config}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StreamEndStop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::MessageInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::MessageStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::MessageBuilder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ScopedMessage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Capturer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Counts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Totals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SectionInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SectionEndInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::accept_many_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::fake_arg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::is_unary_function< F, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::is_unary_function< F, Catch::Detail::void_t< decltype(std::declval< F >()(fake_arg())) > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::UnaryLambdaTraits< L >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(Args...) const >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::UnaryLambdaTraits< ReturnT(ClassT::*)(ArgT) const >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::Token}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::TokenStream}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::ResultBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::ResultValueBase< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::ResultValueBase< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::BasicResult< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::ParseState}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::HelpColumns}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundValueRefBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundFlagRefBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundValueRef< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundValueRef< std::vector< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundFlagRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::LambdaInvoker< ReturnType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::LambdaInvoker< void >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundLambda< L >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundManyLambda< L >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Detail::BoundFlagLambda< L >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::ParserBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::ComposableParserImpl< DerivedT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Detail::ParserRefImpl< DerivedT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Arg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Opt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::ExeName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Clara::Args}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Clara::Help}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Session}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::TagAlias}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::RegistrarForTagAliases}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::conjunction<... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::conjunction< B1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::conjunction< B1, Bn... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::disjunction<... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::disjunction< B1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::disjunction< B1, Bn... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Detail::negation< B >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::capture_by_value< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::always_false< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ITransientExpression}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::BinaryExpr< LhsT, RhsT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::UnaryExpr< LhsT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ExprLhs< LhsT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Decomposer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::AssertionReaction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::AssertionHandler}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Timer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Section}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ITestInvoker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::TestInvokerAsMethod< C >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::NameAndTags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::AutoReg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Tag}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::TestCaseInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::TestCaseHandle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IExceptionTranslator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IExceptionTranslatorRegistry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::ExceptionTranslatorRegistrar}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Version}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::GeneratorException}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::GeneratorUntypedBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::IGeneratorTracker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::IGenerator< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::GeneratorWrapper< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::SingleValueGenerator< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::FixedValuesGenerator< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::Generators< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Generators::as< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::TakeGenerator< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::FilterGenerator< T, Predicate >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::RepeatGenerator< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::MapGenerator< T, U, Func >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::Generators::ChunkGenerator< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::SimplePcg32}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Benchmark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Generators}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b mpl_}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Benchmark::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::literals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Clara}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Clara::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Generators::Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ALL_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_BENCHMARK_ALL_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_BENCHMARK_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_PLATFORM_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_CONFIG_GETENV}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_POSIX_SIGNALS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_GETENV}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_CPP11_TO_STRING}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_DISABLE_EXCEPTIONS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_GLOBAL_NEXTAFTER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_START_WARNINGS_SUPPRESSION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_IGNORE_BUT_WARN}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TRY}\~ {\b if} ((true))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CATCH_ALL}\~ {\b if} ((false))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CATCH_ANON}(type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_EXPORT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONTEXT_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_MOVE}(...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replacement for std::move with better compile time performance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_FORWARD}(...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replacement for std::forward with better compile time performance. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_UNIQUE_NAME_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_COUNTER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_CONFIG_COUNTER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_COUNTER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_UNIQUE_NAME_LINE2}(name,  line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_UNIQUE_NAME_LINE}(name,  line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_UNIQUE_NAME}(name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_STRINGREF_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RESULT_TYPE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_UNIQUE_PTR_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CLOCK_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERFACES_CONFIG_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_NONCOPYABLE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_BENCHMARK_STATS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ESTIMATE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ENVIRONMENT_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_EXECUTION_PLAN_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CHRONOMETER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_OPTIMIZER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_META_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REPEAT_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_MEASURE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_COMPLETE_INVOKE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TIMING_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_STATS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ANALYSE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_GET_1_ARG}(arg1,  arg2, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_GET_2_ARG}(arg1,  arg2, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_BENCHMARK}(BenchmarkName,  name,  benchmarkIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_BENCHMARK_ADVANCED}(BenchmarkName,  name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BENCHMARK}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BENCHMARK_ADVANCED}(name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONSTRUCTOR_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_APPROX_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TOSTRING_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_WCHAR_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_WCHAR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VOID_TYPE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REGISTER_ENUM}(enumName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REGISTER_ENUM}(enumName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ASSERTION_INFO_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_LINEINFO}\~     {\b ::Catch::SourceLineInfo}( __FILE__, static_cast<std::size_t>( __LINE__ ) )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ASSERTION_RESULT_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_LAZY_EXPR_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEST_SPEC_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_WILDCARD_PATTERN_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CASE_SENSITIVE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_OPTIONAL_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_GET_RANDOM_SEED_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_MESSAGE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_STREAM_END_STOP_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_MESSAGE_INFO_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_MSG}(macroName,  messageType,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_CAPTURE}(varName,  macroName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_INFO}(macroName,  log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_UNSCOPED_INFO}(macroName,  log)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INFO}(msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNSCOPED_INFO}(msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WARN}(msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CAPTURE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_SECTION_INFO_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TOTALS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_SESSION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_COMMANDLINE_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CLARA_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TAG_ALIAS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REGISTER_TAG_ALIAS}(alias,  spec)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEST_MACROS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_ASSERTION_HANDLER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_DECOMPOSER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_COMPARE_TRAITS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_DEFINE_COMPARABLE_TRAIT}(id,  op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_LOGICAL_TRAITS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR}(id,  op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR}(id,  op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR}(op)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_STRINGIFY}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_CATCH}(capturer)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REACT}(handler)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEST}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_IF}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_ELSE}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NO_THROW}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_THROWS}(macroName,  resultDisposition, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_THROWS_AS}(macroName,  exceptionType,  resultDisposition,  expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_THROWS_STR_MATCHES}(macroName,  resultDisposition,  matcher, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_SECTION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TIMER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_SECTION}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DYNAMIC_SECTION}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEST_REGISTRY_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_EXPAND1}(param)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_EXPAND2}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEF}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NOINTERNAL_CATCH_DEF}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TESTCASE2}(TestName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TESTCASE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEST_CASE_METHOD2}(TestName,  ClassName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEST_CASE_METHOD}(ClassName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_METHOD_AS_TEST_CASE}(QualifiedMethod, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REGISTER_TESTCASE}(Function, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_FALSE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_THROWS}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_THROWS_AS}(expr,  exceptionType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REQUIRE_NOTHROW}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_FALSE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECKED_IF}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECKED_ELSE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_NOFAIL}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_THROWS}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_THROWS_AS}(expr,  exceptionType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHECK_NOTHROW}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_CASE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEST_CASE_METHOD}(className, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b METHOD_AS_TEST_CASE}(method, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REGISTER_TEST_CASE}(Function, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SECTION}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DYNAMIC_SECTION}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAIL}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAIL_CHECK}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SUCCEED}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SKIP}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STATIC_REQUIRE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STATIC_REQUIRE_FALSE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STATIC_CHECK}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STATIC_CHECK_FALSE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SCENARIO}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SCENARIO_METHOD}(className, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GIVEN}(desc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AND_GIVEN}(desc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WHEN}(desc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AND_WHEN}(desc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THEN}(desc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AND_THEN}(desc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_PREPROCESSOR_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RECURSION_LEVEL0}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RECURSION_LEVEL1}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RECURSION_LEVEL2}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RECURSION_LEVEL3}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RECURSION_LEVEL4}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RECURSION_LEVEL5}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RECURSE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_END}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_OUT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_EMPTY}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_DEFER}(id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_GET_END2}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_GET_END1}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_GET_END}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_NEXT0}(test,  next, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_NEXT1}(test,  next)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_NEXT}(test,  next)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST0}(f,  {\b x},  peek, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST1}(f,  {\b x},  peek, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST2}(f,  {\b x},  peek, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST0_UD}(f,  userdata,  {\b x},  peek, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST1_UD}(f,  userdata,  {\b x},  peek, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST2_UD}(f,  userdata,  {\b x},  peek, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST_UD}(f,  userdata, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_REC_LIST}(f, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_STRINGIZE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_STRINGIZE2}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS}(param)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_MAKE_NAMESPACE2}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_MAKE_NAMESPACE}(name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_MAKE_TYPE_LIST2}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_MAKE_TYPE_LIST}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_1_ARG}(_0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_2_ARG}(_0,  _1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_3_ARG}(_0,  _1,  _2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_4_ARG}(_0,  _1,  _2,  _3)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_5_ARG}(_0,  _1,  _2,  _3,  _4)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_6_ARG}(_0,  _1,  _2,  _3,  _4,  _5)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_7_ARG}(_0,  _1,  _2,  _3,  _4,  _5,  _6)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_8_ARG}(_0,  _1,  _2,  _3,  _4,  _5,  _6,  _7)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_9_ARG}(_0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_10_ARG}(_0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_11_ARG}(_0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_VA_NARGS_IMPL}(_0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10,  N, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TYPE_GEN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_1}(signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST0}(TestName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST1}(TestName,  signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST_X}(TestName,  signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST0}(TestName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST1}(TestName,  signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST_X}(TestName,  signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_REGISTER0}(TestFunc,  signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_REGISTER}(TestFunc,  signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_REGISTER_METHOD0}(TestName,  signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_REGISTER_METHOD}(TestName,  signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0}(TestName,  ClassName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1}(TestName,  ClassName,  signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X}(TestName,  ClassName,  signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0}(TestName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1}(TestName,  signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X}(TestName,  signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_GEN}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD}(TestName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD}(TestName,  ClassName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_REG_METHOD_GEN}(TestName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_NTTP_REG_GEN}(TestFunc, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DEFINE_SIG_TEST}(TestName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_DECLARE_SIG_TEST}(TestName, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_REMOVE_PARENS_GEN}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_TEST_CASE_2}(TestName,  TestFunc,  Name,  Tags,  Signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_TEST_CASE}(Name,  Tags, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG}(Name,  Tags,  Signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2}(TestName,  TestFuncName,  Name,  Tags,  Signature,  TmplTypes,  TypesList)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE}(Name,  Tags, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG}(Name,  Tags,  Signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2}(TestName,  TestFunc,  Name,  Tags,  TmplList)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE}(Name,  Tags,  TmplList)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2}(TestNameClass,  TestName,  ClassName,  Name,  Tags,  Signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD}(ClassName,  Name,  Tags, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG}(ClassName,  Name,  Tags,  Signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2}(TestNameClass,  TestName,  ClassName,  Name,  Tags,  Signature,  TmplTypes,  TypesList)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD}(ClassName,  Name,  Tags, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG}(ClassName,  Name,  Tags,  Signature, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2}(TestNameClass,  TestName,  ClassName,  Name,  Tags,  TmplList)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD}(ClassName,  Name,  Tags,  TmplList)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_TEST_CASE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_TEST_CASE_SIG}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_TEST_CASE_METHOD}(className, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_TEST_CASE_METHOD_SIG}(className, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_PRODUCT_TEST_CASE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_PRODUCT_TEST_CASE_SIG}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_PRODUCT_TEST_CASE_METHOD}(className, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG}(className, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_LIST_TEST_CASE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMPLATE_LIST_TEST_CASE_METHOD}(className, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TEST_CASE_INFO_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION2}(translatorName,  signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INTERNAL_CATCH_TRANSLATE_EXCEPTION}(signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_TRANSLATE_EXCEPTION}(signature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_MACROS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_MAJOR}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_MINOR}\~ 6\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_VERSION_PATCH}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_GENERATORS_ALL_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_GENERATORS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_INTERNAL_GENERATOR_STRINGIZE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GENERATE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GENERATE_COPY}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GENERATE_REF}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_GENERATORS_RANDOM_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SizedUnsignedTypeHelper}(TYPE)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CarryBits}({\b x})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Benchmark::IDuration} = std::chrono::nanoseconds\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Benchmark::FDuration} = std::chrono::duration<double, std::nano>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > using {\b Catch::Benchmark::TimePoint} = typename Clock::time_point\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Benchmark::default_clock} = std::chrono::steady_clock\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Generators::GeneratorBasePtr} = {\b Catch::Detail::unique_ptr}<{\b GeneratorUntypedBase}>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::IReporterFactoryPtr} = {\b Detail::unique_ptr}<IReporterFactory>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func , typename... U> using {\b Catch::FunctionReturnType} = std::remove_reference_t<std::remove_cv_t<std::result_of_t<Func(U...)>>>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b Catch::Benchmark::Detail::CompleteType_t} = typename {\b CompleteType}<T>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func , typename... Args> using {\b Catch::Benchmark::TimingOf} = {\b Timing}<{\b Detail::CompleteType_t}<{\b FunctionReturnType}<Func, Args...>>>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > using {\b Catch::Benchmark::Detail::run_for_at_least_argument_t} = std::conditional_t<{\b is_callable}<Fun({\b Chronometer})>{\b ::value}, {\b Chronometer}, int>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Benchmark::Detail::sample} = std::vector<double>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b Catch::Benchmark::storage_for} = {\b Detail::ObjectStorage}<T, true>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b Catch::Benchmark::destructable_object} = {\b Detail::ObjectStorage}<T, false>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Ts> using {\b Catch::Detail::void_t} = typename {\b make_void}<Ts...>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Clara::Detail::Result} = {\b BasicResult}<void>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Clara::Detail::ParserResult} = {\b BasicResult}<{\b ParseResultType}>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::Clara::Detail::InternalParseResult} = {\b BasicResult}<{\b ParseState}>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b Catch::Detail::RemoveCVRef_t} = std::remove_cv_t<std::remove_reference_t<T>>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::exceptionTranslateFunction} = std::string(*)()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::ExceptionTranslators} = std::vector<{\b Detail::unique_ptr}<{\b IExceptionTranslator} const>>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b Catch::Generators::GeneratorPtr} = {\b Catch::Detail::unique_ptr}<{\b IGenerator}<T>>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Verbosity} \{ {\b Catch::Quiet} = 0
, {\b Catch::Normal}
, {\b Catch::High}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::ShowDurations} \{ {\b Catch::DefaultForReporter}
, {\b Catch::Always}
, {\b Catch::Never}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::TestRunOrder} \{ {\b Catch::Declared}
, {\b Catch::LexicographicallySorted}
, {\b Catch::Randomized}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::ColourMode} : std::uint8_t \{ {\b Catch::PlatformDefault}
, {\b Catch::ANSI}
, {\b Catch::Win32}
, {\b Catch::None}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::CaseSensitive} \{ {\b Catch::Yes}
, {\b Catch::No}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::GenerateFrom} \{ {\b Catch::Time}
, {\b Catch::RandomDevice}
, {\b Catch::Default}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Clara::ParseResultType} \{ {\b Catch::Clara::Matched}
, {\b Catch::Clara::NoMatch}
, {\b Catch::Clara::ShortCircuitAll}
, {\b Catch::Clara::ShortCircuitSame}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Clara::Detail::TokenType} \{ {\b Catch::Clara::Detail::Option}
, {\b Catch::Clara::Detail::Argument}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Clara::Detail::ResultType} \{ {\b Catch::Clara::Detail::Ok}
, {\b Catch::Clara::Detail::LogicError}
, {\b Catch::Clara::Detail::RuntimeError}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Denotes type of a parsing result. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Clara::Detail::Optionality} \{ {\b Catch::Clara::Detail::Optional}
, {\b Catch::Clara::Detail::Required}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::TestCaseProperties} : uint8_t \{ {\b Catch::None} = 0
, {\b Catch::IsHidden} = 1 << 1
, {\b Catch::ShouldFail} = 1 << 2
, {\b Catch::MayFail} = 1 << 3
, {\b Catch::Throws} = 1 << 4
, {\b Catch::NonPortable} = 1 << 5
, {\b Catch::Benchmark} = 1 << 6
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} & {\b Catch::getCurrentMutableContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} const & {\b Catch::getCurrentContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanUpContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SimplePcg32} & {\b Catch::sharedRng} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_test_failure_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_test_skip_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::operator""_sr} (char const *rawChars, std::size_t size) noexcept -> {\b StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator""_catch_sr} (char const *rawChars, std::size_t size) noexcept -> {\b Catch::StringRef}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isOk} ({\b ResultWas::OfType} resultType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isJustInfo} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b Catch::operator|} ({\b ResultDisposition::Flags} lhs, {\b ResultDisposition::Flags} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldContinueOnFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isFalseTest} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldSuppressFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Args> {\b unique_ptr}< T > {\b Catch::Detail::make_unique} (Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IResultCapture} & {\b Catch::getResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRegistryHub} const & {\b Catch::getRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IMutableRegistryHub} & {\b Catch::getMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::translateActiveException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > void {\b Catch::Benchmark::deoptimize_value} (T &&{\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fn , typename... Args> auto {\b Catch::Benchmark::invoke_deoptimized} (Fn &&fn, Args &&... args) -> std::enable_if_t<!std::is_same< void, decltype(fn(args...))>{\b ::value} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun > {\b repeater}< std::decay_t< Fun > > {\b Catch::Benchmark::Detail::repeat} (Fun &&fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun , typename... Args> {\b CompleteType_t}< {\b FunctionReturnType}< Fun, Args... > > {\b Catch::Benchmark::Detail::complete_invoke} (Fun &&fun, Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Fun > {\b Detail::CompleteType_t}< {\b FunctionReturnType}< Fun > > {\b Catch::Benchmark::user_code} (Fun &&fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun , typename... Args> {\b TimingOf}< Fun, Args... > {\b Catch::Benchmark::Detail::measure} (Fun &&fun, Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, int > {\b Catch::Benchmark::Detail::measure_one} (Fun &&fun, int iters, std::false_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, {\b Chronometer} > {\b Catch::Benchmark::Detail::measure_one} (Fun &&fun, int iters, std::true_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Benchmark::Detail::throw_optimized_away_error} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock , typename Fun > {\b TimingOf}< Fun, {\b run_for_at_least_argument_t}< Clock, Fun > > {\b Catch::Benchmark::Detail::run_for_at_least} ({\b IDuration} how_long, const int initial_iterations, Fun &&fun)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::weighted_average_quantile} (int k, int q, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OutlierClassification} {\b Catch::Benchmark::Detail::classify_outliers} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::mean} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::normal_cdf} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::erfc_inv} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::normal_quantile} (double {\b p})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< double > {\b Catch::Benchmark::Detail::bootstrap} (double confidence_level, double *first, double *last, {\b sample} const &resample, double(*estimator)(double const *, double const *))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bootstrap_analysis} {\b Catch::Benchmark::Detail::analyse_samples} (double confidence_level, unsigned int n_resamples, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > std::vector< double > {\b Catch::Benchmark::Detail::resolution} (int k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > int {\b Catch::Benchmark::Detail::warmup} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > {\b EnvironmentEstimate} {\b Catch::Benchmark::Detail::estimate_clock_resolution} (int iterations)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > {\b EnvironmentEstimate} {\b Catch::Benchmark::Detail::estimate_clock_cost} ({\b FDuration} {\b resolution})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Clock > {\b Environment} {\b Catch::Benchmark::Detail::measure_environment} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SampleAnalysis} {\b Catch::Benchmark::Detail::analyse} (const {\b IConfig} &cfg, {\b FDuration} *first, {\b FDuration} *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &, {\b Catch_global_namespace_dummy})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b Catch::Detail::catch_strnlen} (const char *str, std::size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::convertIntoString} ({\b StringRef} string, bool escapeInvisibles)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases `string in quotes, and optionally escapes invisibles. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::convertIntoString} ({\b StringRef} string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases {\f2 string}  in quotes, and escapes invisibles if user requested it via CLI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::rawMemoryToString} (const void *object, std::size_t size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b Catch::Detail::rawMemoryToString} (const T &object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename E > std::string {\b Catch::Detail::convertUnknownEnumToString} (E e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if_t< !std::is_enum< T >{\b ::value} &&!std::is_base_of< std::exception, T >{\b ::value}, std::string > {\b Catch::Detail::convertUnstreamable} (T const &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if_t< !std::is_enum< T >{\b ::value} &&std::is_base_of< std::exception, T >{\b ::value}, std::string > {\b Catch::Detail::convertUnstreamable} (T const &ex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::enable_if_t< std::is_enum< T >{\b ::value}, std::string > {\b Catch::Detail::convertUnstreamable} (T const &{\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > std::string {\b Catch::Detail::stringify} (const T &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator , typename Sentinel  = InputIterator> std::string {\b Catch::Detail::rangeToString} (InputIterator first, Sentinel last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Range > std::string {\b Catch::rangeToString} (Range const &range)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Allocator > std::string {\b Catch::rangeToString} (std::vector< bool, Allocator > const &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b Catch::literals::operator""_a} (long double val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b Catch::literals::operator""_a} (unsigned long long val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::generateRandomSeed} ({\b GenerateFrom} from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b Catch::Detail::splitReporterSpec} ({\b StringRef} reporterSpec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits the reporter spec into reporter name and kv-pair options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ColourMode} > {\b Catch::Detail::stringToColourMode} ({\b StringRef} colourMode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ReporterSpec} > {\b Catch::parseReporterSpec} ({\b StringRef} reporterSpec)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::getSeed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns Catch2's current RNG seed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b ParserResult} {\b Catch::Clara::Detail::convertInto} (std::string const &source, T &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b Catch::Clara::Detail::convertInto} (std::string const &source, std::string &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b Catch::Clara::Detail::convertInto} (std::string const &source, bool &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ArgType , typename L > auto {\b Catch::Clara::Detail::invokeLambda} (L const &lambda, std::string const &arg) -> {\b ParserResult}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clara::Parser} {\b Catch::makeCommandLineParser} ({\b ConfigData} &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::formatReconstructedExpression} (std::ostream &os, std::string const &lhs, {\b StringRef} op, std::string const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExceptionMatchExpr} ({\b AssertionHandler} &handler, std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b ITestInvoker} > {\b Catch::makeTestInvoker} (void(*testAsFunction)())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > {\b Detail::unique_ptr}< {\b ITestInvoker} > {\b Catch::makeTestInvoker} (void(C::*testAsMethod)())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b TestCaseInfo} > {\b Catch::makeTestCaseInfo} ({\b StringRef} _className, {\b NameAndTags} const &nameAndTags, {\b SourceLineInfo} const &_lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Detail::registerTranslatorImpl} ({\b Detail::unique_ptr}< {\b IExceptionTranslator} > &&translator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Version} const & {\b Catch::libraryVersion} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Generators::Detail::throw_generator_exception} (char const *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws {\b GeneratorException} with the provided message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename DecayedT  = std::decay_t<T>> {\b GeneratorWrapper}< DecayedT > {\b Catch::Generators::value} (T &&value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< T > {\b Catch::Generators::values} (std::initializer_list< T > values)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Ts> {\b GeneratorWrapper}< std::tuple< std::decay_t< Ts >... > > {\b Catch::Generators::table} (std::initializer_list< std::tuple< std::decay_t< Ts >... > > tuples)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Gs> auto {\b Catch::Generators::makeGenerators} ({\b GeneratorWrapper}< T > &&generator, Gs &&... moreGenerators) -> {\b Generators}< T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > auto {\b Catch::Generators::makeGenerators} ({\b GeneratorWrapper}< T > &&generator) -> {\b Generators}< T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Gs> auto {\b Catch::Generators::makeGenerators} (T &&val, Gs &&... moreGenerators) -> {\b Generators}< std::decay_t< T > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , typename... Gs> auto {\b Catch::Generators::makeGenerators} ({\b as}< T >, U &&val, Gs &&... moreGenerators) -> {\b Generators}< T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b Catch::Generators::acquireGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} const &lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b Catch::Generators::createGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} lineInfo, {\b GeneratorBasePtr} &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename L > auto {\b Catch::Generators::generate} ({\b StringRef} generatorName, {\b SourceLineInfo} const &lineInfo, L const &generatorExpression) -> typename decltype(generatorExpression())::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< T > {\b Catch::Generators::take} (size_t target, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Predicate > {\b GeneratorWrapper}< T > {\b Catch::Generators::filter} (Predicate &&pred, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< T > {\b Catch::Generators::repeat} (size_t repeats, {\b GeneratorWrapper}< T > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Func , typename U , typename T  = FunctionReturnType<Func, U>> {\b GeneratorWrapper}< T > {\b Catch::Generators::map} (Func &&function, {\b GeneratorWrapper}< U > &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b GeneratorWrapper}< std::vector< T > > {\b Catch::Generators::chunk} (size_t size, {\b GeneratorWrapper}< T > &&generator)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::warmup_iterations} = 10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::warmup_time} = std::chrono::milliseconds(100)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::minimum_ticks} = 1000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::warmup_seed} = 10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::clock_resolution_estimation_time} = std::chrono::milliseconds(500)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::clock_cost_estimation_time_limit} = std::chrono::seconds(1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::clock_cost_estimation_tick_limit} = 100000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::clock_cost_estimation_time} = std::chrono::milliseconds(10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b Catch::Benchmark::Detail::clock_cost_estimation_iterations} = 10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b StringRef} {\b Catch::Detail::unprintableString} = "\{?\}"_sr\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b accept_many_t} {\b Catch::Clara::accept_many} \{\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a convenience header for Catch2. It includes {\b all}  of Catch2 headers.\par
Generally the Catch2 users should use specific includes they need, but this header can be used instead for ease-of-experimentation, or just plain convenience, at the cost of (significantly) increased compilation times.\par
When a new header is added to either the top level folder, or to the corresponding internal subfolder, it should be added here. Headers added to the various subparts (e.g. matchers, generators, etc...), should go their respective catch-all headers.\par
This is a convenience header for Catch2's benchmarking. It includes {\b all}  of Catch2 headers related to benchmarking.\par
Generally the Catch2 users should use specific includes they need, but this header can be used instead for ease-of-experimentation, or just plain convenience, at the cost of (significantly) increased compilation times.\par
When a new header is added to either the {\f2 benchmark}  folder, or to the corresponding internal (detail) subfolder, it should be added here.\par
Wrapper for the CONFIG configuration option\par
When generating internal unique names, there are two options. Either we mix in the current line number, or mix in an incrementing number. We prefer the latter, using {\f2 __COUNTER__} , but users might want to use the former.\par
Wrapper for the WCHAR configuration option\par
We want to support platforms that do not provide {\f2 wchar_t} , so we sometimes have to disable providing wchar_t overloads through Catch2, e.g. the StringMaker specialization for {\f2 std::wstring} .\par
Wrapper for the CATCH_CONFIG_PREFIX_MESSAGES configuration option\par
CATCH_CONFIG_PREFIX_ALL can be used to avoid clashes with other macros by prepending CATCH_. This may not be desirable if the only clashes are with logger macros such as INFO and WARN. In this cases CATCH_CONFIG_PREFIX_MESSAGES can be used to only prefix a small subset of relevant macros.\par
Why does decomposing look the way it does:\par
Conceptually, decomposing is simple. We change {\f2 REQUIRE( a == b )}  into {\f2 Decomposer\{\} <= a == b} , so that {\f2 Decomposer\{\} <= a}  is evaluated first, and our custom operator is used for {\f2 a == b} , because {\f2 a}  is transformed into {\f2 ExprLhs<T&>}  and then into {\f2 BinaryExpr<T&, U&>} .\par
In practice, decomposing ends up a mess, because we have to support various fun things.\par
1) Types that are only comparable with literal 0, and they do this by comparing against a magic type with pointer constructor and deleted other constructors. Example: {\f2 REQUIRE((a <=> b) == 0)}  in libstdc++\par
2) Types that are only comparable with literal 0, and they do this by comparing against a magic type with consteval integer constructor. Example: {\f2 REQUIRE((a <=> b) == 0)}  in current MSVC STL.\par
3) Types that have no linkage, and so we cannot form a reference to them. Example: some implementations of traits.\par
4) Starting with C++20, when the compiler sees {\f2 a == b} , it also uses {\f2 b == a}  when constructing the overload set. For us this means that when the compiler handles {\f2 ExprLhs<T> == b} , it also tries to resolve the overload set for {\f2 b == ExprLhs<T>} .\par
To accomodate these use cases, decomposer ended up rather complex.\par
1) These types are handled by adding SFINAE overloads to our comparison operators, checking whether {\f2 T == U}  are comparable with the given operator, and if not, whether T (or U) are comparable with literal 0. If yes, the overload compares T (or U) with 0 literal inline in the definition.\par
Note that for extra correctness, we check that the other type is either an {\f2 int}  (literal 0 is captured as {\f2 int}  by templates), or a {\f2 long}  (some platforms use 0L for {\f2 NULL}  and we want to support that for pointer comparisons).\par
2) For these types, {\f2 is_foo_comparable<T, int>}  is true, but letting them fall into the overload that actually does {\f2 T == int}  causes compilation error. Handling them requires that the decomposition is {\f2 constexpr} , so that P2564R3 applies and the {\f2 consteval}  from their accompanying magic type is propagated through the {\f2 constexpr}  call stack.\par
However this is not enough to handle these types automatically, because our default is to capture types by reference, to avoid runtime copies. While these references cannot become dangling, they outlive the constexpr context and thus the default capture path cannot be actually constexpr.\par
The solution is to capture these types by value, by explicitly specializing {\f2 {\b Catch::capture_by_value}}  for them. Catch2 provides specialization for {\f2 std::foo_ordering} s, but users can specialize the trait for their own types as well.\par
3) If a type has no linkage, we also cannot capture it by reference. The solution is once again to capture them by value. We handle the common cases by using {\f2 std::is_arithmetic}  as the default for {\f2 {\b Catch::capture_by_value}} , but that is only a some-effort heuristic. But as with 2), users can specialize {\f2 capture_by_value}  for their own types as needed.\par
4) To support C++20 and make the SFINAE on our decomposing operators work, the SFINAE has to happen in return type, rather than in a template type. This is due to our use of logical type traits ({\f2 conjunction} /{\f2 disjunction} /{\f2 negation} ), that we use to workaround an issue in older (9-) versions of GCC. I still blame C++20 for this, because without the comparison order switching, the logical traits could still be used in template type.\par
There are also other side concerns, e.g. supporting both {\f2 {\b REQUIRE(a)}}  and {\f2 REQUIRE(a == b)} , or making {\f2 REQUIRE_THAT(a, IsEqual(b))}  slot nicely into the same expression handling logic, but these are rather straightforward and add only a bit of complexity (e.g. common base class for decomposed expressions).\par
Wrapper for the STATIC_ANALYSIS_SUPPORT configuration option\par
Some of Catch2's macros can be defined differently to work better with static analysis tools, like clang-tidy or coverity. Currently the main use case is to show that {\f2 SECTION} s are executed exclusively, and not all in one run of a {\f2 TEST_CASE} .\par
This is a convenience header for Catch2's Generator support. It includes {\b all}  of Catch2 headers related to generators.\par
Generally the Catch2 users should use specific includes they need, but this header can be used instead for ease-of-experimentation, or just plain convenience, at the cost of (significantly) increased compilation times.\par
When a new header is added to either the {\f2 generators}  folder, or to the corresponding internal subfolder, it should be added here. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v AND_GIVEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:AND_GIVEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AND_GIVEN( desc)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DYNAMIC_SECTION( {\cf22 "And given: "} << desc )\par
}
}
{\xe \v AND_THEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:AND_THEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AND_THEN( desc)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DYNAMIC_SECTION( {\cf22 "      And: "} << desc )\par
}
}
{\xe \v AND_WHEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:AND_WHEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AND_WHEN( desc)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DYNAMIC_SECTION( {\cf22 " And when: "} << desc )\par
}
}
{\xe \v BENCHMARK\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:BENCHMARK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BENCHMARK( ...)}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2199 {\cf21 #define BENCHMARK(...) \\}\par
2200 {\cf21     INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))}\par
}
}
{\xe \v BENCHMARK_ADVANCED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:BENCHMARK_ADVANCED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BENCHMARK_ADVANCED( name)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2201 {\cf21 #define BENCHMARK_ADVANCED(name) \\}\par
2202 {\cf21     INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)}\par
}
}
{\xe \v CAPTURE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CAPTURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CAPTURE( ...)}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), {\cf22 "CAPTURE"}, __VA_ARGS__ )\par
}
}
{\xe \v CarryBits\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CarryBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CarryBits( {\b x})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( x >> 32 )\par
}
}
{\xe \v CATCH_ALL_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ALL_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ALL_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_ANALYSE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ANALYSE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ANALYSE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_APPROX_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_APPROX_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_APPROX_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_ASSERTION_HANDLER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ASSERTION_HANDLER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ASSERTION_HANDLER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_ASSERTION_INFO_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ASSERTION_INFO_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ASSERTION_INFO_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_ASSERTION_RESULT_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ASSERTION_RESULT_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ASSERTION_RESULT_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_BENCHMARK_ALL_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_BENCHMARK_ALL_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_BENCHMARK_ALL_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_BENCHMARK_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_BENCHMARK_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_BENCHMARK_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_BENCHMARK_STATS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_BENCHMARK_STATS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_BENCHMARK_STATS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CASE_SENSITIVE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CASE_SENSITIVE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CASE_SENSITIVE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CATCH_ALL\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CATCH_ALL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CATCH_ALL\~ {\b if} ((false))}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CATCH_ANON\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CATCH_ANON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CATCH_ANON( type)}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 if} (({\cf17 false}))\par
}
}
{\xe \v CATCH_CHRONOMETER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CHRONOMETER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CHRONOMETER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CLARA_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CLARA_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CLARA_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CLOCK_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CLOCK_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CLOCK_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_COMMANDLINE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_COMMANDLINE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_COMMANDLINE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_COMPARE_TRAITS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_COMPARE_TRAITS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_COMPARE_TRAITS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_COMPLETE_INVOKE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_COMPLETE_INVOKE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_COMPLETE_INVOKE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_COUNTER\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_COUNTER}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_COUNTER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_COUNTER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_COUNTER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_CPP11_TO_STRING\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_CPP11_TO_STRING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_CPP11_TO_STRING}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_DISABLE_EXCEPTIONS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_DISABLE_EXCEPTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_DISABLE_EXCEPTIONS}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_GETENV\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_GETENV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_GETENV}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_GLOBAL_NEXTAFTER\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_GLOBAL_NEXTAFTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_GLOBAL_NEXTAFTER}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_POSIX_SIGNALS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_POSIX_SIGNALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_POSIX_SIGNALS}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_WCHAR\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_WCHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_WCHAR}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONFIG_WCHAR_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONFIG_WCHAR_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_WCHAR_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONSTRUCTOR_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONSTRUCTOR_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONSTRUCTOR_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_CONTEXT_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_CONTEXT_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONTEXT_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_DECOMPOSER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_DECOMPOSER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_DECOMPOSER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_DEFER\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_DEFER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_DEFER( id)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 id} CATCH_EMPTY()\par
}
}
{\xe \v CATCH_DEFINE_COMPARABLE_TRAIT\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_DEFINE_COMPARABLE_TRAIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_DEFINE_COMPARABLE_TRAIT( id,  op)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template} <{\cf17 typename}, {\cf17 typename}, {\cf17 typename} = {\cf18 void}>                            \\\par
    {\cf17 struct }is_##id##_comparable : std::false_type \{\};                         \\\par
    {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>                                         \\\par
    {\cf17 struct }is_##id##_comparable<                                              \\\par
        T,                                                                    \\\par
        U,                                                                    \\\par
        void_t<decltype( std::declval<T>() op std::declval<U>() )>>           \\\par
        : std::true_type \{\};                                                  \\\par
    {\cf17 template} <{\cf17 typename}, {\cf17 typename} = {\cf18 void}>                                      \\\par
    {\cf17 struct }is_##id##_0_comparable : std::false_type \{\};                       \\\par
    {\cf17 template} <{\cf17 typename} T>                                                     \\\par
    {\cf17 struct }is_##id##_0_comparable<T,                                          \\\par
                                  void_t<decltype( std::declval<T>() op 0 )>> \\\par
        : std::true_type \{\};\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5072 {\cf21 #define CATCH_DEFINE_COMPARABLE_TRAIT( id, op )                               \\}\par
5073 {\cf21     template <typename, typename, typename = void>                            \\}\par
5074 {\cf21     struct is_##id##_comparable : std::false_type \{\};                         \\}\par
5075 {\cf21     template <typename T, typename U>                                         \\}\par
5076 {\cf21     struct is_##id##_comparable<                                              \\}\par
5077 {\cf21         T,                                                                    \\}\par
5078 {\cf21         U,                                                                    \\}\par
5079 {\cf21         void_t<decltype( std::declval<T>() op std::declval<U>() )>>           \\}\par
5080 {\cf21         : std::true_type \{\};                                                  \\}\par
5081 {\cf21     template <typename, typename = void>                                      \\}\par
5082 {\cf21     struct is_##id##_0_comparable : std::false_type \{\};                       \\}\par
5083 {\cf21     template <typename T>                                                     \\}\par
5084 {\cf21     struct is_##id##_0_comparable<T,                                          \\}\par
5085 {\cf21                                   void_t<decltype( std::declval<T>() op 0 )>> \\}\par
5086 {\cf21         : std::true_type \{\};}\par
}
}
{\xe \v CATCH_EMPTY\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_EMPTY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_EMPTY()}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_ENVIRONMENT_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ENVIRONMENT_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ENVIRONMENT_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_ESTIMATE_CLOCK_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_ESTIMATE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_ESTIMATE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_ESTIMATE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_EXECUTION_PLAN_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_EXECUTION_PLAN_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_EXECUTION_PLAN_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_EXPORT\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_EXPORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_EXPORT}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_FORWARD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_FORWARD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_FORWARD( ...)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 static_cast<}decltype(__VA_ARGS__)&&{\cf17 >}(__VA_ARGS__)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replacement for std::forward with better compile time performance. }}\par
}
{\xe \v CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_GENERATORS_ALL_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_GENERATORS_ALL_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_GENERATORS_ALL_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_GENERATORS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_GENERATORS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_GENERATORS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_GENERATORS_RANDOM_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_GENERATORS_RANDOM_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_GENERATORS_RANDOM_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_GET_RANDOM_SEED_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_GET_RANDOM_SEED_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_GET_RANDOM_SEED_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERFACES_CAPTURE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERFACES_CONFIG_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERFACES_CONFIG_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERFACES_CONFIG_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_CONFIG_COUNTER\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_CONFIG_COUNTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_CONFIG_COUNTER}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_CONFIG_GETENV\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_CONFIG_GETENV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_CONFIG_GETENV}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_CONFIG_POSIX_SIGNALS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( id,  op)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5470 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( id, op )         \\}\par
5471 {\cf21     template <typename RhsT>                                                   \\}\par
5472 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5473 {\cf21         -> std::enable_if_t<                                                   \\}\par
5474 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5475 {\cf21                                 Detail::negation<capture_by_value<             \\}\par
5476 {\cf21                                     Detail::RemoveCVRef_t<RhsT>>>>::value,     \\}\par
5477 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5478 {\cf21         return \{                                                               \\}\par
5479 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5480 {\cf21     \}                                                                          \\}\par
5481 {\cf21     template <typename RhsT>                                                   \\}\par
5482 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5483 {\cf21         -> std::enable_if_t<                                                   \\}\par
5484 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5485 {\cf21                                 capture_by_value<RhsT>>::value,                \\}\par
5486 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5487 {\cf21         return \{                                                               \\}\par
5488 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5489 {\cf21     \}                                                                          \\}\par
5490 {\cf21     template <typename RhsT>                                                   \\}\par
5491 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5492 {\cf21         -> std::enable_if_t<                                                   \\}\par
5493 {\cf21             Detail::conjunction<                                               \\}\par
5494 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5495 {\cf21                 Detail::is_##id##_0_comparable<LhsT>,                          \\}\par
5496 {\cf21                 std::is_same<RhsT, int>>::value,                               \\}\par
5497 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5498 {\cf21         if ( rhs != 0 ) \{ throw_test_failure_exception(); \}                    \\}\par
5499 {\cf21         return \{                                                               \\}\par
5500 {\cf21             static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs \};   \\}\par
5501 {\cf21     \}                                                                          \\}\par
5502 {\cf21     template <typename RhsT>                                                   \\}\par
5503 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5504 {\cf21         -> std::enable_if_t<                                                   \\}\par
5505 {\cf21             Detail::conjunction<                                               \\}\par
5506 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5507 {\cf21                 Detail::is_##id##_0_comparable<RhsT>,                          \\}\par
5508 {\cf21                 std::is_same<LhsT, int>>::value,                               \\}\par
5509 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5510 {\cf21         if ( lhs.m_lhs != 0 ) \{ throw_test_failure_exception(); \}              \\}\par
5511 {\cf21         return \{ static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs \};    \\}\par
5512 {\cf21     \}}\par
}
}
{\xe \v CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( id,  op)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5416 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( id, op )           \\}\par
5417 {\cf21     template <typename RhsT>                                                   \\}\par
5418 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5419 {\cf21         -> std::enable_if_t<                                                   \\}\par
5420 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5421 {\cf21                                 Detail::negation<capture_by_value<             \\}\par
5422 {\cf21                                     Detail::RemoveCVRef_t<RhsT>>>>::value,     \\}\par
5423 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5424 {\cf21         return \{                                                               \\}\par
5425 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5426 {\cf21     \}                                                                          \\}\par
5427 {\cf21     template <typename RhsT>                                                   \\}\par
5428 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5429 {\cf21         -> std::enable_if_t<                                                   \\}\par
5430 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5431 {\cf21                                 capture_by_value<RhsT>>::value,                \\}\par
5432 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5433 {\cf21         return \{                                                               \\}\par
5434 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5435 {\cf21     \}                                                                          \\}\par
5436 {\cf21     template <typename RhsT>                                                   \\}\par
5437 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5438 {\cf21         -> std::enable_if_t<                                                   \\}\par
5439 {\cf21             Detail::conjunction<                                               \\}\par
5440 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5441 {\cf21                 Detail::is_eq_0_comparable<LhsT>,                              \\}\par
5442 {\cf21               }{\cf20 /* We allow long because we want `ptr op NULL` to be accepted */}{\cf21  \\}\par
5443 {\cf21                 Detail::disjunction<std::is_same<RhsT, int>,                   \\}\par
5444 {\cf21                                     std::is_same<RhsT, long>>>::value,         \\}\par
5445 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5446 {\cf21         if ( rhs != 0 ) \{ throw_test_failure_exception(); \}                    \\}\par
5447 {\cf21         return \{                                                               \\}\par
5448 {\cf21             static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs \};   \\}\par
5449 {\cf21     \}                                                                          \\}\par
5450 {\cf21     template <typename RhsT>                                                   \\}\par
5451 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5452 {\cf21         -> std::enable_if_t<                                                   \\}\par
5453 {\cf21             Detail::conjunction<                                               \\}\par
5454 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5455 {\cf21                 Detail::is_eq_0_comparable<RhsT>,                              \\}\par
5456 {\cf21               }{\cf20 /* We allow long because we want `ptr op NULL` to be accepted */}{\cf21  \\}\par
5457 {\cf21                 Detail::disjunction<std::is_same<LhsT, int>,                   \\}\par
5458 {\cf21                                     std::is_same<LhsT, long>>>::value,         \\}\par
5459 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5460 {\cf21         if ( lhs.m_lhs != 0 ) \{ throw_test_failure_exception(); \}              \\}\par
5461 {\cf21         return \{ static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs \};    \\}\par
5462 {\cf21     \}}\par
}
}
{\xe \v CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR( op)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template} <{\cf17 typename} RhsT>                                                   \\\par
    {\cf17 constexpr} {\cf17 friend} {\cf17 auto} {\cf17 operator} op( ExprLhs&& lhs, RhsT&& rhs )             \\\par
        -> std::enable_if_t<                                                   \\\par
            !capture_by_value<Detail::RemoveCVRef_t<RhsT>>::value,             \\\par
            BinaryExpr<LhsT, RhsT const&>> \{                                   \\\par
        {\cf19 return} \{                                                               \\\par
            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\\par
    \}                                                                          \\\par
    {\cf17 template} <{\cf17 typename} RhsT>                                                   \\\par
    {\cf17 constexpr} {\cf17 friend} {\cf17 auto} {\cf17 operator} op( ExprLhs&& lhs, RhsT rhs )               \\\par
        -> std::enable_if_t<capture_by_value<RhsT>::value,                     \\\par
                            BinaryExpr<LhsT, RhsT>> \{                          \\\par
        {\cf19 return} \{                                                               \\\par
            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\\par
    \}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5522 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR( op )                        \\}\par
5523 {\cf21     template <typename RhsT>                                                   \\}\par
5524 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5525 {\cf21         -> std::enable_if_t<                                                   \\}\par
5526 {\cf21             !capture_by_value<Detail::RemoveCVRef_t<RhsT>>::value,             \\}\par
5527 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5528 {\cf21         return \{                                                               \\}\par
5529 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5530 {\cf21     \}                                                                          \\}\par
5531 {\cf21     template <typename RhsT>                                                   \\}\par
5532 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5533 {\cf21         -> std::enable_if_t<capture_by_value<RhsT>::value,                     \\}\par
5534 {\cf21                             BinaryExpr<LhsT, RhsT>> \{                          \\}\par
5535 {\cf21         return \{                                                               \\}\par
5536 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5537 {\cf21     \}}\par
}
}
{\xe \v CATCH_INTERNAL_GENERATOR_STRINGIZE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_GENERATOR_STRINGIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_GENERATOR_STRINGIZE( ...)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL(__VA_ARGS__)\par
}
}
{\xe \v CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL( ...)}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #__VA_ARGS__##_catch_sr}\par
}
}
{\xe \v CATCH_INTERNAL_IGNORE_BUT_WARN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_IGNORE_BUT_WARN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_IGNORE_BUT_WARN( ...)}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_LINEINFO\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_LINEINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_LINEINFO\~     {\b ::Catch::SourceLineInfo}( __FILE__, static_cast<std::size_t>( __LINE__ ) )}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3244 {\cf21 #define CATCH_INTERNAL_LINEINFO \\}\par
3245 {\cf21     ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )}\par
}
}
{\xe \v CATCH_INTERNAL_START_WARNINGS_SUPPRESSION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_START_WARNINGS_SUPPRESSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_STRINGIFY\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_STRINGIFY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_STRINGIFY( ...)}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #__VA_ARGS__##_catch_sr}\par
}
}
{\xe \v CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_LAZY_EXPR_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_LAZY_EXPR_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_LAZY_EXPR_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_LOGICAL_TRAITS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_LOGICAL_TRAITS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_LOGICAL_TRAITS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_MEASURE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_MEASURE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_MEASURE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_MESSAGE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_MESSAGE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_MESSAGE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_MESSAGE_INFO_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_MESSAGE_INFO_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_MESSAGE_INFO_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_META_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_META_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_META_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_MOVE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_MOVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_MOVE( ...)}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 static_cast<}std::remove_reference_t<decltype(__VA_ARGS__){\cf17 >}&&>(__VA_ARGS__)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replacement for std::move with better compile time performance. }}\par
}
{\xe \v CATCH_MOVE_AND_FORWARD_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_NONCOPYABLE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_NONCOPYABLE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_NONCOPYABLE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_OPTIMIZER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_OPTIMIZER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_OPTIMIZER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_OPTIONAL_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_OPTIONAL_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_OPTIONAL_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_PLATFORM_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_PLATFORM_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_PLATFORM_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_PREPROCESSOR_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_PREPROCESSOR_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_PREPROCESSOR_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_REC_END\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_END( ...)}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_REC_GET_END\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_GET_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_GET_END( ...)}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_REC_GET_END1\par
}
}
{\xe \v CATCH_REC_GET_END1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_GET_END1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_GET_END1( ...)}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_REC_GET_END2\par
}
}
{\xe \v CATCH_REC_GET_END2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_GET_END2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_GET_END2()}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0, CATCH_REC_END\par
}
}
{\xe \v CATCH_REC_LIST\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST( f,  ...)}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))\par
}
}
{\xe \v CATCH_REC_LIST0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST0( f,  {\b x},  peek,  ...)}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )\par
}
}
{\xe \v CATCH_REC_LIST0_UD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST0_UD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST0_UD( f,  userdata,  {\b x},  peek,  ...)}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )\par
}
}
{\xe \v CATCH_REC_LIST1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST1( f,  {\b x},  peek,  ...)}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )\par
}
}
{\xe \v CATCH_REC_LIST1_UD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST1_UD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST1_UD( f,  userdata,  {\b x},  peek,  ...)}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )\par
}
}
{\xe \v CATCH_REC_LIST2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST2( f,  {\b x},  peek,  ...)}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )\par
}
}
{\xe \v CATCH_REC_LIST2_UD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST2_UD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST2_UD( f,  userdata,  {\b x},  peek,  ...)}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )\par
}
}
{\xe \v CATCH_REC_LIST_UD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_LIST_UD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_LIST_UD( f,  userdata,  ...)}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))\par
}
}
{\xe \v CATCH_REC_NEXT\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_NEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_NEXT( test,  next)}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)\par
}
}
{\xe \v CATCH_REC_NEXT0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_NEXT0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_NEXT0( test,  next,  ...)}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid next CATCH_REC_OUT\par
}
}
{\xe \v CATCH_REC_NEXT1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_NEXT1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_NEXT1( test,  next)}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)\par
}
}
{\xe \v CATCH_REC_OUT\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REC_OUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REC_OUT}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_RECURSE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RECURSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RECURSE( ...)}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSION_LEVEL5(__VA_ARGS__)\par
}
}
{\xe \v CATCH_RECURSION_LEVEL0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RECURSION_LEVEL0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RECURSION_LEVEL0( ...)}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __VA_ARGS__\par
}
}
{\xe \v CATCH_RECURSION_LEVEL1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RECURSION_LEVEL1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RECURSION_LEVEL1( ...)}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))\par
}
}
{\xe \v CATCH_RECURSION_LEVEL2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RECURSION_LEVEL2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RECURSION_LEVEL2( ...)}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))\par
}
}
{\xe \v CATCH_RECURSION_LEVEL3\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RECURSION_LEVEL3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RECURSION_LEVEL3( ...)}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))\par
}
}
{\xe \v CATCH_RECURSION_LEVEL4\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RECURSION_LEVEL4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RECURSION_LEVEL4( ...)}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))\par
}
}
{\xe \v CATCH_RECURSION_LEVEL5\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RECURSION_LEVEL5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RECURSION_LEVEL5( ...)}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))\par
}
}
{\xe \v CATCH_REGISTER_ENUM\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REGISTER_ENUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REGISTER_ENUM( enumName,  ...)}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )\par
}
}
{\xe \v CATCH_REGISTER_TAG_ALIAS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REGISTER_TAG_ALIAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REGISTER_TAG_ALIAS( alias,  spec)}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
    namespace\{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); \} \\\par
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5000 {\cf21 #define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \\}\par
5001 {\cf21     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5002 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
5003 {\cf21     namespace\{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); \} \\}\par
5004 {\cf21     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
}
}
{\xe \v CATCH_REPEAT_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REPEAT_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REPEAT_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_RESULT_TYPE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RESULT_TYPE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RESULT_TYPE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_SECTION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_SECTION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_SECTION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_SECTION_INFO_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_SECTION_INFO_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_SECTION_INFO_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_SESSION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_SESSION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_SESSION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_SOURCE_LINE_INFO_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_STATS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_STATS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_STATS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_STREAM_END_STOP_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_STREAM_END_STOP_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_STREAM_END_STOP_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_STRINGREF_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_STRINGREF_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_STRINGREF_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TAG_ALIAS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TAG_ALIAS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TAG_ALIAS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEST_CASE_INFO_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEST_CASE_INFO_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEST_CASE_INFO_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEST_MACRO_IMPL_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEST_MACROS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEST_MACROS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEST_MACROS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEST_REGISTRY_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEST_REGISTRY_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEST_REGISTRY_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TEST_SPEC_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TEST_SPEC_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TEST_SPEC_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TIMER_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TIMER_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TIMER_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TIMING_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TIMING_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TIMING_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TOSTRING_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TOSTRING_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TOSTRING_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TOTALS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TOTALS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TOTALS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TRANSLATE_EXCEPTION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TRANSLATE_EXCEPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TRANSLATE_EXCEPTION( signature)}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )\par
}
}
{\xe \v CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_TRY\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_TRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_TRY\~ {\b if} ((true))}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_UNIQUE_NAME_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_UNIQUE_NAME_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_UNIQUE_NAME_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_UNIQUE_PTR_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_UNIQUE_PTR_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_UNIQUE_PTR_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_VERSION_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_MACROS_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_VERSION_MACROS_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_MACROS_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_MAJOR\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_VERSION_MAJOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_MAJOR\~ 3}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_MINOR\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_VERSION_MINOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_MINOR\~ 6}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VERSION_PATCH\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_VERSION_PATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VERSION_PATCH\~ 0}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_VOID_TYPE_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_VOID_TYPE_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_VOID_TYPE_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CATCH_WILDCARD_PATTERN_HPP_INCLUDED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CATCH_WILDCARD_PATTERN_HPP_INCLUDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_WILDCARD_PATTERN_HPP_INCLUDED}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CHECK\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK( ...)}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEST( {\cf22 "CHECK"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
}
}
{\xe \v CHECK_FALSE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECK_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_FALSE( ...)}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEST( {\cf22 "CHECK_FALSE"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\par
}
}
{\xe \v CHECK_NOFAIL\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECK_NOFAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_NOFAIL( ...)}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEST( {\cf22 "CHECK_NOFAIL"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\par
}
}
{\xe \v CHECK_NOTHROW\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECK_NOTHROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_NOTHROW( ...)}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_NO_THROW( {\cf22 "CHECK_NOTHROW"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
}
}
{\xe \v CHECK_THROWS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECK_THROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_THROWS( ...)}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_THROWS( {\cf22 "CHECK_THROWS"}, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
}
}
{\xe \v CHECK_THROWS_AS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECK_THROWS_AS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECK_THROWS_AS( expr,  exceptionType)}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_THROWS_AS( {\cf22 "CHECK_THROWS_AS"}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )\par
}
}
{\xe \v CHECKED_ELSE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECKED_ELSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECKED_ELSE( ...)}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_ELSE( {\cf22 "CHECKED_ELSE"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\par
}
}
{\xe \v CHECKED_IF\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:CHECKED_IF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHECKED_IF( ...)}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_IF( {\cf22 "CHECKED_IF"}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )\par
}
}
{\xe \v DYNAMIC_SECTION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:DYNAMIC_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DYNAMIC_SECTION( ...)}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )\par
}
}
{\xe \v FAIL\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAIL( ...)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_MSG( {\cf22 "FAIL"}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
}
}
{\xe \v FAIL_CHECK\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:FAIL_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAIL_CHECK( ...)}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_MSG( {\cf22 "FAIL_CHECK"}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
}
}
{\xe \v GENERATE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:GENERATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GENERATE( ...)}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\\par
                                 CATCH_INTERNAL_LINEINFO, \\\par
                                 [ ]\{ {\cf17 using namespace }Catch::Generators; {\cf19 return} makeGenerators( __VA_ARGS__ ); \} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7624 {\cf21 #define GENERATE( ... ) \\}\par
7625 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7626 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7627 {\cf21                                  [ ]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
}
}
{\xe \v GENERATE_COPY\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:GENERATE_COPY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GENERATE_COPY( ...)}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\\par
                                 CATCH_INTERNAL_LINEINFO, \\\par
                                 [=]\{ {\cf17 using namespace }Catch::Generators; {\cf19 return} makeGenerators( __VA_ARGS__ ); \} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7628 {\cf21 #define GENERATE_COPY( ... ) \\}\par
7629 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7630 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7631 {\cf21                                  [=]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
}
}
{\xe \v GENERATE_REF\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:GENERATE_REF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GENERATE_REF( ...)}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\\par
                                 CATCH_INTERNAL_LINEINFO, \\\par
                                 [&]\{ {\cf17 using namespace }Catch::Generators; {\cf19 return} makeGenerators( __VA_ARGS__ ); \} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7632 {\cf21 #define GENERATE_REF( ... ) \\}\par
7633 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7634 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7635 {\cf21                                  [&]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
}
}
{\xe \v GIVEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:GIVEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GIVEN( desc)}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DYNAMIC_SECTION( {\cf22 "    Given: "} << desc )\par
}
}
{\xe \v INFO\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INFO( msg)}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_INFO( {\cf22 "INFO"}, msg )\par
}
}
{\xe \v INTERNAL_CATCH_BENCHMARK\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_BENCHMARK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_BENCHMARK( BenchmarkName,  name,  benchmarkIndex)}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 if}( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\\par
        BenchmarkName = [&]({\cf18 int} benchmarkIndex)\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2182 {\cf21 #define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\\}\par
2183 {\cf21     if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\}\par
2184 {\cf21         BenchmarkName = [&](int benchmarkIndex)}\par
}
}
{\xe \v INTERNAL_CATCH_BENCHMARK_ADVANCED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_BENCHMARK_ADVANCED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_BENCHMARK_ADVANCED( BenchmarkName,  name)}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 if}( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\\par
        BenchmarkName = [&]\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 2186 {\cf21 #define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\\}\par
2187 {\cf21     if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\}\par
2188 {\cf21         BenchmarkName = [&]}\par
}
}
{\xe \v INTERNAL_CATCH_CAPTURE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_CAPTURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_CAPTURE( varName,  macroName,  ...)}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     Catch::Capturer varName( macroName##_catch_sr,        \\\par
                             CATCH_INTERNAL_LINEINFO,     \\\par
                             Catch::ResultWas::Info,      \\\par
                             #__VA_ARGS__##_catch_sr );   \\\par
    varName.captureValues( 0, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4036 {\cf21 #define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \\}\par
4037 {\cf21     Catch::Capturer varName( macroName##_catch_sr,        \\}\par
4038 {\cf21                              CATCH_INTERNAL_LINEINFO,     \\}\par
4039 {\cf21                              Catch::ResultWas::Info,      \\}\par
4040 {\cf21                              #__VA_ARGS__##_catch_sr );   \\}\par
4041 {\cf21     varName.captureValues( 0, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_CATCH\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_CATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_CATCH( capturer)}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST( TestName,  ...)}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL( {\cf22 "dummy"}, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST0( TestName)}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST1( TestName,  signature)}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf17 static} {\cf18 void} TestName()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6491 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\\}\par
6492 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6493 {\cf21     static void TestName()}\par
}
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD( TestName,  ClassName,  ...)}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL( {\cf22 "dummy"}, __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0( TestName,  ClassName)}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1( TestName,  ClassName,  signature)}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<{\cf17 typename} TestType> \\\par
    {\cf17 struct }TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> \{ \\\par
        {\cf18 void} test();\\\par
    \}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6535 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\\}\par
6536 {\cf21     template<typename TestType> \\}\par
6537 {\cf21     struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> \{ \\}\par
6538 {\cf21         void test();\\}\par
6539 {\cf21     \}}\par
}
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X( TestName,  ClassName,  signature,  ...)}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\par
    {\cf17 struct }TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> \{ \\\par
        {\cf18 void} test();\\\par
    \}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6541 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\\}\par
6542 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\}\par
6543 {\cf21     struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> \{ \\}\par
6544 {\cf21         void test();\\}\par
6545 {\cf21     \}}\par
}
}
{\xe \v INTERNAL_CATCH_DECLARE_SIG_TEST_X\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DECLARE_SIG_TEST_X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DECLARE_SIG_TEST_X( TestName,  signature,  ...)}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf17 static} {\cf18 void} TestName()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6494 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\\}\par
6495 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6496 {\cf21     static void TestName()}\par
}
}
{\xe \v INTERNAL_CATCH_DEF\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEF( ...)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DEF __VA_ARGS__\par
}
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST( TestName,  ...)}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL( {\cf22 "dummy"}, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST0( TestName)}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST1( TestName,  signature)}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf17 static} {\cf18 void} TestName()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6499 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\\}\par
6500 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6501 {\cf21     static void TestName()}\par
}
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD( TestName,  ...)}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL( {\cf22 "dummy"}, __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0( TestName)}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1( TestName,  signature)}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<{\cf17 typename} TestType> \\\par
    {\cf18 void} INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6548 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\\}\par
6549 {\cf21     template<typename TestType> \\}\par
6550 {\cf21     void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()}\par
}
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X( TestName,  signature,  ...)}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\\par
    {\cf18 void} INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6551 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\\}\par
6552 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\}\par
6553 {\cf21     void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()}\par
}
}
{\xe \v INTERNAL_CATCH_DEFINE_SIG_TEST_X\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DEFINE_SIG_TEST_X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DEFINE_SIG_TEST_X( TestName,  signature,  ...)}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf17 static} {\cf18 void} TestName()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6502 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\\}\par
6503 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6504 {\cf21     static void TestName()}\par
}
}
{\xe \v INTERNAL_CATCH_DYNAMIC_SECTION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_DYNAMIC_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_DYNAMIC_SECTION( ...)}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                     \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS              \\\par
        if ( Catch::Section {\cf17 const}& INTERNAL_CATCH_UNIQUE_NAME(        \\\par
                 catch_internal_Section ) =                           \\\par
                 Catch::SectionInfo(                                  \\\par
                     CATCH_INTERNAL_LINEINFO,                         \\\par
                     ( Catch::ReusableStringStream() << __VA_ARGS__ ) \\\par
                         .str() ) )                                   \\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5888 {\cf21 #    define INTERNAL_CATCH_DYNAMIC_SECTION( ... )                     \\}\par
5889 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                     \\}\par
5890 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS              \\}\par
5891 {\cf21         if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(        \\}\par
5892 {\cf21                  catch_internal_Section ) =                           \\}\par
5893 {\cf21                  Catch::SectionInfo(                                  \\}\par
5894 {\cf21                      CATCH_INTERNAL_LINEINFO,                         \\}\par
5895 {\cf21                      ( Catch::ReusableStringStream() << __VA_ARGS__ ) \\}\par
5896 {\cf21                          .str() ) )                                   \\}\par
5897 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
}
}
{\xe \v INTERNAL_CATCH_ELSE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_ELSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_ELSE( macroName,  resultDisposition,  ...)}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\\par
    if( !Catch::getResultCapture().lastAssertionPassed() )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5707 {\cf21 #define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \\}\par
5708 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
5709 {\cf21     if( !Catch::getResultCapture().lastAssertionPassed() )}\par
}
}
{\xe \v INTERNAL_CATCH_EXPAND1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_EXPAND1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_EXPAND1( param)}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_EXPAND2( param )\par
}
}
{\xe \v INTERNAL_CATCH_EXPAND2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_EXPAND2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_EXPAND2( ...)}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_NO##__VA_ARGS__\par
}
}
{\xe \v INTERNAL_CATCH_GET_1_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_GET_1_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_GET_1_ARG( arg1,  arg2,  ...)}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid arg1\par
}
}
{\xe \v INTERNAL_CATCH_GET_2_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_GET_2_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_GET_2_ARG( arg1,  arg2,  ...)}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid arg2\par
}
}
{\xe \v INTERNAL_CATCH_IF\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_IF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_IF( macroName,  resultDisposition,  ...)}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\\par
    if( Catch::getResultCapture().lastAssertionPassed() )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5702 {\cf21 #define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \\}\par
5703 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
5704 {\cf21     if( Catch::getResultCapture().lastAssertionPassed() )}\par
}
}
{\xe \v INTERNAL_CATCH_INFO\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_INFO( macroName,  log)}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 const} Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4044 {\cf21 #define INTERNAL_CATCH_INFO( macroName, log ) \\}\par
4045 {\cf21     const Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )}\par
}
}
{\xe \v INTERNAL_CATCH_MAKE_NAMESPACE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_MAKE_NAMESPACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_MAKE_NAMESPACE( name)}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_MAKE_NAMESPACE2(name)\par
}
}
{\xe \v INTERNAL_CATCH_MAKE_NAMESPACE2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_MAKE_NAMESPACE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_MAKE_NAMESPACE2( ...)}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ns_##__VA_ARGS__\par
}
}
{\xe \v INTERNAL_CATCH_MAKE_TYPE_LIST\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_MAKE_TYPE_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_MAKE_TYPE_LIST( ...)}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))\par
}
}
{\xe \v INTERNAL_CATCH_MAKE_TYPE_LIST2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_MAKE_TYPE_LIST2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_MAKE_TYPE_LIST2( ...)}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 decltype}(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())\par
}
}
{\xe \v INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES( ...)}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6425 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\\}\par
6426 {\cf21     CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)}\par
}
}
{\xe \v INTERNAL_CATCH_METHOD_AS_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_METHOD_AS_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod,  ...)}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
        namespace \{                                                           \\\par
        {\cf17 const} Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\\par
            Catch::makeTestInvoker( &QualifiedMethod ),                   \\\par
            CATCH_INTERNAL_LINEINFO,                                      \\\par
            {\cf22 "&"} #QualifiedMethod##_catch_sr,                              \\\par
            Catch::NameAndTags\{ __VA_ARGS__ \} );                          \\\par
    \} {\cf20 /* NOLINT */} \\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6106 {\cf21     #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\}\par
6107 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6108 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6109 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6110 {\cf21         namespace \{                                                           \\}\par
6111 {\cf21         const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\}\par
6112 {\cf21             Catch::makeTestInvoker( &QualifiedMethod ),                   \\}\par
6113 {\cf21             CATCH_INTERNAL_LINEINFO,                                      \\}\par
6114 {\cf21             "&" #QualifiedMethod##_catch_sr,                              \\}\par
6115 {\cf21             Catch::NameAndTags\{ __VA_ARGS__ \} );                          \\}\par
6116 {\cf21     \} }{\cf20 /* NOLINT */}{\cf21  \\}\par
6117 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
}
}
{\xe \v INTERNAL_CATCH_MSG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_MSG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_MSG( macroName,  messageType,  resultDisposition,  ...)}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \\\par
        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4028 {\cf21 #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \\}\par
4029 {\cf21     do \{ \\}\par
4030 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \\}\par
4031 {\cf21         catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \\}\par
4032 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
4033 {\cf21     \} while( false )}\par
}
}
{\xe \v INTERNAL_CATCH_NO_THROW\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NO_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NO_THROW( macroName,  resultDisposition,  ...)}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\par
        {\cf19 try} \{ \\\par
            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
            CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\par
            static_cast<void>(__VA_ARGS__); \\\par
            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\\par
        \} \\\par
        catch( ... ) \{ \\\par
            catchAssertionHandler.handleUnexpectedInflightException(); \\\par
        \} \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5712 {\cf21 #define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \\}\par
5713 {\cf21     do \{ \\}\par
5714 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
5715 {\cf21         try \{ \\}\par
5716 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5717 {\cf21             CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5718 {\cf21             static_cast<void>(__VA_ARGS__); \\}\par
5719 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5720 {\cf21             catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\}\par
5721 {\cf21         \} \\}\par
5722 {\cf21         catch( ... ) \{ \\}\par
5723 {\cf21             catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
5724 {\cf21         \} \\}\par
5725 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5726 {\cf21     \} while( false )}\par
}
}
{\xe \v INTERNAL_CATCH_NOINTERNAL_CATCH_DEF\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NOINTERNAL_CATCH_DEF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_NTTP_0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_0}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_NTTP_1\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_1( signature,  ...)}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 struct }Nttp\{\};\\\par
    {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf17 constexpr} {\cf17 auto} get_wrapper() noexcept -> Nttp<__VA_ARGS__> \{ {\cf19 return} \{\}; \} \\\par
    {\cf17 template}<{\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 class}...> {\cf17 struct }NttpTemplateTypeList\{\};\\\par
    {\cf17 template}<{\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 class}...Cs>\\\par
    {\cf17 constexpr} {\cf17 auto} get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> \{ {\cf19 return} \{\}; \} \\\par
    \\\par
    {\cf17 template}< {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 class }Container, {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 class }List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf17 struct }rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> \{ {\cf17 using }type = TypeList<Container<__VA_ARGS__>>; \};\\\par
    {\cf17 template}< {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 class }Container, {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 class }List, INTERNAL_CATCH_REMOVE_PARENS(signature), {\cf17 typename}...Elements>\\\par
    {\cf17 struct }rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> \{ {\cf17 using }type = {\cf17 typename} append<TypeList<Container<__VA_ARGS__>>, {\cf17 typename} rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; \};\\\par
    {\cf17 template}<{\cf17 template} <{\cf17 typename}...> {\cf17 class }Final, {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)> {\cf17 class}...Containers, {\cf17 typename}...Types>\\\par
    {\cf17 struct }create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> \{ {\cf17 using }type = {\cf17 typename} append<Final<>, {\cf17 typename} rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; \};\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6475 {\cf21 #define INTERNAL_CATCH_NTTP_1(signature, ...)\\}\par
6476 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp\{\};\\}\par
6477 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6478 {\cf21     constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> \{ return \{\}; \} \\}\par
6479 {\cf21     template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...> struct NttpTemplateTypeList\{\};\\}\par
6480 {\cf21     template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Cs>\\}\par
6481 {\cf21     constexpr auto get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> \{ return \{\}; \} \\}\par
6482 {\cf21     \\}\par
6483 {\cf21     template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6484 {\cf21     struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> \{ using type = TypeList<Container<__VA_ARGS__>>; \};\\}\par
6485 {\cf21     template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\\}\par
6486 {\cf21     struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> \{ using type = typename append<TypeList<Container<__VA_ARGS__>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; \};\\}\par
6487 {\cf21     template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\\}\par
6488 {\cf21     struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; \};}\par
}
}
{\xe \v INTERNAL_CATCH_NTTP_GEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_GEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_GEN( ...)}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)\par
}
}
{\xe \v INTERNAL_CATCH_NTTP_REG_GEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_REG_GEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_REG_GEN( TestFunc,  ...)}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL( {\cf22 "dummy"}, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_NTTP_REG_METHOD_GEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_REG_METHOD_GEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN( TestName,  ...)}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL( {\cf22 "dummy"}, __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_NTTP_REGISTER\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_REGISTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_REGISTER( TestFunc,  signature,  ...)}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf18 void} reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\\par
    \{\\\par
        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\par
    \}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6513 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\\}\par
6514 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6515 {\cf21     void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\}\par
6516 {\cf21     \{\\}\par
6517 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\}\par
6518 {\cf21     \}}\par
}
}
{\xe \v INTERNAL_CATCH_NTTP_REGISTER0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_REGISTER0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_REGISTER0( TestFunc,  signature)}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<{\cf17 typename} Type>\\\par
    {\cf18 void} reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\\par
    \{\\\par
        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\\par
    \}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6506 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\\}\par
6507 {\cf21     template<typename Type>\\}\par
6508 {\cf21     void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\}\par
6509 {\cf21     \{\\}\par
6510 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\}\par
6511 {\cf21     \}}\par
}
}
{\xe \v INTERNAL_CATCH_NTTP_REGISTER_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_REGISTER_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_REGISTER_METHOD( TestName,  signature,  ...)}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\\par
    {\cf18 void} reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\par
    \{\\\par
        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\par
    \}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6527 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\\}\par
6528 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6529 {\cf21     void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\}\par
6530 {\cf21     \{\\}\par
6531 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\}\par
6532 {\cf21     \}}\par
}
}
{\xe \v INTERNAL_CATCH_NTTP_REGISTER_METHOD0\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_NTTP_REGISTER_METHOD0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0( TestName,  signature,  ...)}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<{\cf17 typename} Type>\\\par
    {\cf18 void} reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\\par
    \{\\\par
        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\\par
    \}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6520 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\\}\par
6521 {\cf21     template<typename Type>\\}\par
6522 {\cf21     void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\}\par
6523 {\cf21     \{\\}\par
6524 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\}\par
6525 {\cf21     \}}\par
}
}
{\xe \v INTERNAL_CATCH_REACT\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REACT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REACT( handler)}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid handler.complete();\par
}
}
{\xe \v INTERNAL_CATCH_REGISTER_ENUM\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REGISTER_ENUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REGISTER_ENUM( enumName,  ...)}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 namespace }Catch \{ \\\par
    {\cf17 template}<> {\cf17 struct }StringMaker<enumName> \{ \\\par
        {\cf17 static} std::string convert( enumName value ) \{ \\\par
            {\cf17 static} {\cf17 const} {\cf17 auto}& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, \{ __VA_ARGS__ \} ); \\\par
            {\cf19 return} {\cf17 static_cast<}std::string{\cf17 >}(enumInfo.lookup( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( value ) )); \\\par
        \} \\\par
    \}; \\\par
\}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 3077 {\cf21 #define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \\}\par
3078 {\cf21 namespace Catch \{ \\}\par
3079 {\cf21     template<> struct StringMaker<enumName> \{ \\}\par
3080 {\cf21         static std::string convert( enumName value ) \{ \\}\par
3081 {\cf21             static const auto& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, \{ __VA_ARGS__ \} ); \\}\par
3082 {\cf21             return static_cast<std::string>(enumInfo.lookup( static_cast<int>( value ) )); \\}\par
3083 {\cf21         \} \\}\par
3084 {\cf21     \}; \\}\par
3085 {\cf21 \}}\par
}
}
{\xe \v INTERNAL_CATCH_REGISTER_TESTCASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REGISTER_TESTCASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REGISTER_TESTCASE( Function,  ...)}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         {\cf19 do} \{ \\\par
            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
            CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
            CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); {\cf20 /* NOLINT */} \\\par
            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
        \} {\cf19 while}({\cf17 false})\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6121 {\cf21     #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \\}\par
6122 {\cf21         do \{ \\}\par
6123 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6124 {\cf21             CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6125 {\cf21             CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6126 {\cf21             Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
6127 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6128 {\cf21         \} while(false)}\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS( ...)}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     INTERNAL_CATCH_EXPAND1( INTERNAL_CATCH_DEF __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5973 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS( ... ) \\}\par
5974 {\cf21     INTERNAL_CATCH_EXPAND1( INTERNAL_CATCH_DEF __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_10_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_10_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG( _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9)}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_11_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_11_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG( _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10)}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_1_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_1_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG( _0)}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_2_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_2_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG( _0,  _1)}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_3_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_3_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG( _0,  _1,  _2)}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_4_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_4_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG( _0,  _1,  _2,  _3)}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_5_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_5_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG( _0,  _1,  _2,  _3,  _4)}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_6_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_6_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG( _0,  _1,  _2,  _3,  _4,  _5)}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_7_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_7_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG( _0,  _1,  _2,  _3,  _4,  _5,  _6)}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_8_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_8_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG( _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7)}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_9_ARG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_9_ARG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG( _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8)}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)\par
}
}
{\xe \v INTERNAL_CATCH_REMOVE_PARENS_GEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_REMOVE_PARENS_GEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_REMOVE_PARENS_GEN( ...)}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_SECTION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_SECTION( ...)}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                         \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                  \\\par
        if ( Catch::Section {\cf17 const}& INTERNAL_CATCH_UNIQUE_NAME(            \\\par
                 catch_internal_Section ) =                               \\\par
                 Catch::Section( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5880 {\cf21 #    define INTERNAL_CATCH_SECTION( ... )                                 \\}\par
5881 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                         \\}\par
5882 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                  \\}\par
5883 {\cf21         if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(            \\}\par
5884 {\cf21                  catch_internal_Section ) =                               \\}\par
5885 {\cf21                  Catch::Section( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \\}\par
5886 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
}
}
{\xe \v INTERNAL_CATCH_STRINGIZE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_STRINGIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_STRINGIZE( ...)}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)\par
}
}
{\xe \v INTERNAL_CATCH_STRINGIZE2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_STRINGIZE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_STRINGIZE2( ...)}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf21 #__VA_ARGS__}\par
}
}
{\xe \v INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS( param)}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( Name,  Tags,  TmplList)}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, TmplList )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6760 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \\}\par
6761 {\cf21         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, TmplList )}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( TestName,  TestFunc,  Name,  Tags,  TmplList)}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\\par
        template<typename TestType> {\cf17 static} {\cf18 void} TestFunc();       \\\par
        {\cf17 namespace }\{\\\par
        {\cf17 namespace }INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\\par
        INTERNAL_CATCH_TYPE_GEN\\\par
        template<{\cf17 typename}... Types>                               \\\par
        {\cf17 struct }TestName \{                                         \\\par
            {\cf18 void} reg_tests() \{                                          \\\par
                {\cf18 size_t} index = 0;                                    \\\par
                {\cf17 using }expander = {\cf18 size_t}[];                           \\\par
                (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name {\cf22 " - "} INTERNAL_CATCH_STRINGIZE(TmplList) {\cf22 " - "} + std::to_string(index), Tags \} ), index++)... \};{\cf20 /* NOLINT */}\\\par
            \}                                                     \\\par
        \};\\\par
        {\cf17 static} {\cf18 int} INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{ \\\par
                {\cf17 using }TestInit = {\cf17 typename} convert<TestName, TmplList>::type; \\\par
                TestInit t;                                           \\\par
                t.reg_tests();                                        \\\par
                {\cf19 return} 0;                                             \\\par
            \}();                                                      \\\par
        \}\}\\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \\\par
        template<typename TestType>                                   \\\par
        {\cf17 static} {\cf18 void} TestFunc()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6731 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\\}\par
6732 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6733 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6734 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6735 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6736 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6737 {\cf21         template<typename TestType> static void TestFunc();       \\}\par
6738 {\cf21         namespace \{\\}\par
6739 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\}\par
6740 {\cf21         INTERNAL_CATCH_TYPE_GEN\\}\par
6741 {\cf21         template<typename... Types>                               \\}\par
6742 {\cf21         struct TestName \{                                         \\}\par
6743 {\cf21             void reg_tests() \{                                          \\}\par
6744 {\cf21                 size_t index = 0;                                    \\}\par
6745 {\cf21                 using expander = size_t[];                           \\}\par
6746 {\cf21                 (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21 \\}\par
6747 {\cf21             \}                                                     \\}\par
6748 {\cf21         \};\\}\par
6749 {\cf21         static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{ \\}\par
6750 {\cf21                 using TestInit = typename convert<TestName, TmplList>::type; \\}\par
6751 {\cf21                 TestInit t;                                           \\}\par
6752 {\cf21                 t.reg_tests();                                        \\}\par
6753 {\cf21                 return 0;                                             \\}\par
6754 {\cf21             \}();                                                      \\}\par
6755 {\cf21         \}\}\\}\par
6756 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \\}\par
6757 {\cf21         template<typename TestType>                                   \\}\par
6758 {\cf21         static void TestFunc()}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( ClassName,  Name,  Tags,  TmplList)}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, TmplList )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6895 {\cf21 #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \\}\par
6896 {\cf21         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, TmplList )}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass,  TestName,  ClassName,  Name,  Tags,  TmplList)}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\\par
        template<typename TestType> \\\par
        {\cf17 struct }TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) \{ \\\par
            {\cf18 void} test();\\\par
        \};\\\par
        {\cf17 namespace }\{\\\par
        {\cf17 namespace }INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\\par
            INTERNAL_CATCH_TYPE_GEN\\\par
            template<{\cf17 typename}...Types>\\\par
            {\cf17 struct }TestNameClass\{\\\par
                {\cf18 void} reg_tests()\{\\\par
                    {\cf18 size_t} index = 0;\\\par
                    {\cf17 using }expander = {\cf18 size_t}[];\\\par
                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName##_catch_sr, Catch::NameAndTags\{ Name {\cf22 " - "} INTERNAL_CATCH_STRINGIZE(TmplList) {\cf22 " - "} + std::to_string(index), Tags \} ), index++)... \};{\cf20 /* NOLINT */} \\\par
                \}\\\par
            \};\\\par
            {\cf17 static} {\cf18 int} INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\\par
                {\cf17 using }TestInit = {\cf17 typename} convert<TestNameClass, TmplList>::type;\\\par
                TestInit t;\\\par
                t.reg_tests();\\\par
                {\cf19 return} 0;\\\par
            \}(); \\\par
        \}\}\\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
        template<typename TestType> \\\par
        {\cf18 void} TestName<TestType>::test()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6863 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \\}\par
6864 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6865 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6866 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6867 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6868 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6869 {\cf21         template<typename TestType> \\}\par
6870 {\cf21         struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) \{ \\}\par
6871 {\cf21             void test();\\}\par
6872 {\cf21         \};\\}\par
6873 {\cf21         namespace \{\\}\par
6874 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\}\par
6875 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6876 {\cf21             template<typename...Types>\\}\par
6877 {\cf21             struct TestNameClass\{\\}\par
6878 {\cf21                 void reg_tests()\{\\}\par
6879 {\cf21                     size_t index = 0;\\}\par
6880 {\cf21                     using expander = size_t[];\\}\par
6881 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName##_catch_sr, Catch::NameAndTags\{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6882 {\cf21                 \}\\}\par
6883 {\cf21             \};\\}\par
6884 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6885 {\cf21                 using TestInit = typename convert<TestNameClass, TmplList>::type;\\}\par
6886 {\cf21                 TestInit t;\\}\par
6887 {\cf21                 t.reg_tests();\\}\par
6888 {\cf21                 return 0;\\}\par
6889 {\cf21             \}(); \\}\par
6890 {\cf21         \}\}\\}\par
6891 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6892 {\cf21         template<typename TestType> \\}\par
6893 {\cf21         void TestName<TestType>::test()}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( Name,  Tags,  ...)}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, {\cf17 typename} T,__VA_ARGS__)\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6716 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\}\par
6717 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename T,__VA_ARGS__)}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( TestName,  TestFuncName,  Name,  Tags,  Signature,  TmplTypes,  TypesList)}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6680 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\}\par
6681 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \\}\par
6682 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\}\par
6683 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\}\par
6684 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS       \\}\par
6685 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6686 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6687 {\cf21         template<typename TestType> static void TestFuncName();       \\}\par
6688 {\cf21         namespace \{\\}\par
6689 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) \{                                     \\}\par
6690 {\cf21             INTERNAL_CATCH_TYPE_GEN                                                  \\}\par
6691 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\}\par
6692 {\cf21             template<typename... Types>                               \\}\par
6693 {\cf21             struct TestName \{                                         \\}\par
6694 {\cf21                 void reg_tests() \{                                          \\}\par
6695 {\cf21                     size_t index = 0;                                    \\}\par
6696 {\cf21                     using expander = size_t[];                           \\}\par
6697 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))\};\\}\par
6698 {\cf21                     constexpr char const* types_list[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))\};\\}\par
6699 {\cf21                     constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\\}\par
6700 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21 \\}\par
6701 {\cf21                 \}                                                     \\}\par
6702 {\cf21             \};                                                        \\}\par
6703 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{ \\}\par
6704 {\cf21                 using TestInit = typename create<TestName, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type; \\}\par
6705 {\cf21                 TestInit t;                                           \\}\par
6706 {\cf21                 t.reg_tests();                                        \\}\par
6707 {\cf21                 return 0;                                             \\}\par
6708 {\cf21             \}();                                                      \\}\par
6709 {\cf21         \}                                                             \\}\par
6710 {\cf21         \}                                                             \\}\par
6711 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \\}\par
6712 {\cf21         template<typename TestType>                                   \\}\par
6713 {\cf21         static void TestFuncName()}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName,  Name,  Tags,  ...)}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, {\cf17 typename} T, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6848 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\}\par
6849 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( TestNameClass,  TestName,  ClassName,  Name,  Tags,  Signature,  TmplTypes,  TypesList)}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6810 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\}\par
6811 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6812 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6813 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6814 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6815 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6816 {\cf21         template<typename TestType> \\}\par
6817 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) \{ \\}\par
6818 {\cf21                 void test();\\}\par
6819 {\cf21             \};\\}\par
6820 {\cf21         namespace \{\\}\par
6821 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) \{\\}\par
6822 {\cf21             INTERNAL_CATCH_TYPE_GEN                  \\}\par
6823 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6824 {\cf21             template<typename...Types>\\}\par
6825 {\cf21             struct TestNameClass\{\\}\par
6826 {\cf21                 void reg_tests()\{\\}\par
6827 {\cf21                     std::size_t index = 0;\\}\par
6828 {\cf21                     using expander = std::size_t[];\\}\par
6829 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))\};\\}\par
6830 {\cf21                     constexpr char const* types_list[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))\};\\}\par
6831 {\cf21                     constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\\}\par
6832 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6833 {\cf21                 \}\\}\par
6834 {\cf21             \};\\}\par
6835 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6836 {\cf21                 using TestInit = typename create<TestNameClass, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type;\\}\par
6837 {\cf21                 TestInit t;\\}\par
6838 {\cf21                 t.reg_tests();\\}\par
6839 {\cf21                 return 0;\\}\par
6840 {\cf21             \}(); \\}\par
6841 {\cf21         \}\\}\par
6842 {\cf21         \}\\}\par
6843 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6844 {\cf21         template<typename TestType> \\}\par
6845 {\cf21         void TestName<TestType>::test()}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName,  Name,  Tags,  Signature,  ...)}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6856 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\}\par
6857 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( Name,  Tags,  Signature,  ...)}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__)\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6724 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\}\par
6725 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__)}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_TEST_CASE( Name,  Tags,  ...)}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, {\cf17 typename} TestType, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6665 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\}\par
6666 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_TEST_CASE_2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_TEST_CASE_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( TestName,  TestFunc,  Name,  Tags,  Signature,  ...)}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\\par
        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\par
        {\cf17 namespace }\{\\\par
        {\cf17 namespace }INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\\par
            INTERNAL_CATCH_TYPE_GEN\\\par
            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\par
            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\par
            {\cf17 template}<{\cf17 typename}...Types> \\\par
            {\cf17 struct }TestName\{\\\par
                TestName()\{\\\par
                    {\cf18 size_t} index = 0;                                    \\\par
                    {\cf17 constexpr} {\cf18 char} {\cf17 const}* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\}; {\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}\\\par
                    {\cf17 using }expander = {\cf18 size_t}[]; {\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}\\\par
                    (void)expander\{(reg_test(Types\{\}, Catch::NameAndTags\{ Name {\cf22 " - "} + std::string(tmpl_types[index]), Tags \} ), index++)... \};{\cf20 /* NOLINT */} \\\par
                \}\\\par
            \};\\\par
            {\cf17 static} {\cf17 const} {\cf18 int} INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\\par
            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\par
            {\cf19 return} 0;\\\par
        \}();\\\par
        \}\\\par
        \}\\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6633 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\}\par
6634 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6635 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6636 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6637 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6638 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6639 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6640 {\cf21         INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6641 {\cf21         namespace \{\\}\par
6642 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\}\par
6643 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6644 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6645 {\cf21             INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6646 {\cf21             template<typename...Types> \\}\par
6647 {\cf21             struct TestName\{\\}\par
6648 {\cf21                 TestName()\{\\}\par
6649 {\cf21                     size_t index = 0;                                    \\}\par
6650 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\}; }{\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}{\cf21 \\}\par
6651 {\cf21                     using expander = size_t[]; }{\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}{\cf21 \\}\par
6652 {\cf21                     (void)expander\{(reg_test(Types\{\}, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index]), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6653 {\cf21                 \}\\}\par
6654 {\cf21             \};\\}\par
6655 {\cf21             static const int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6656 {\cf21             TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\}\par
6657 {\cf21             return 0;\\}\par
6658 {\cf21         \}();\\}\par
6659 {\cf21         \}\\}\par
6660 {\cf21         \}\\}\par
6661 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6662 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName,  Name,  Tags,  ...)}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, {\cf17 typename} T, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6795 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\}\par
6796 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass,  TestName,  ClassName,  Name,  Tags,  Signature,  ...)}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
        namespace \{\\\par
        {\cf17 namespace }INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\\par
            INTERNAL_CATCH_TYPE_GEN\\\par
            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\par
            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\\par
            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\\par
            {\cf17 template}<{\cf17 typename}...Types> \\\par
            {\cf17 struct }TestNameClass\{\\\par
                TestNameClass()\{\\\par
                    {\cf18 size_t} index = 0;                                    \\\par
                    {\cf17 constexpr} {\cf18 char} {\cf17 const}* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\};\\\par
                    {\cf17 using }expander = {\cf18 size_t}[];\\\par
                    (void)expander\{(reg_test(Types\{\}, #ClassName, Catch::NameAndTags\{ Name {\cf22 " - "} + std::string(tmpl_types[index]), Tags \} ), index++)... \};{\cf20 /* NOLINT */} \\\par
                \}\\\par
            \};\\\par
            {\cf17 static} {\cf18 int} INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\\par
                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\\par
                {\cf19 return} 0;\\\par
        \}();\\\par
        \}\\\par
        \}\\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6764 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\}\par
6765 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6766 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6767 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6768 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6769 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6770 {\cf21         namespace \{\\}\par
6771 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\}\par
6772 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6773 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6774 {\cf21             INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6775 {\cf21             INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6776 {\cf21             template<typename...Types> \\}\par
6777 {\cf21             struct TestNameClass\{\\}\par
6778 {\cf21                 TestNameClass()\{\\}\par
6779 {\cf21                     size_t index = 0;                                    \\}\par
6780 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\};\\}\par
6781 {\cf21                     using expander = size_t[];\\}\par
6782 {\cf21                     (void)expander\{(reg_test(Types\{\}, #ClassName, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index]), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6783 {\cf21                 \}\\}\par
6784 {\cf21             \};\\}\par
6785 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6786 {\cf21                 TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\}\par
6787 {\cf21                 return 0;\\}\par
6788 {\cf21         \}();\\}\par
6789 {\cf21         \}\\}\par
6790 {\cf21         \}\\}\par
6791 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6792 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName,  Name,  Tags,  Signature,  ...)}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6803 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\}\par
6804 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( Name,  Tags,  Signature,  ...)}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6673 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\}\par
6674 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TEST\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEST( macroName,  resultDisposition,  ...)}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ {\cf20 /* NOLINT(bugprone-infinite-loop) */} \\\par
        {\cf20 /* The expression should not be evaluated, but warnings should hopefully be checked */} \\\par
        CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\\par
        INTERNAL_CATCH_TRY \{ \\\par
            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\\par
            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); {\cf20 /* NOLINT(bugprone-chained-comparison) */} \\\par
            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
        \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( ({\cf18 void})0, ({\cf17 false}) && {\cf17 static_cast<}{\cf17 const }{\cf18 bool}&{\cf17 >}( !!(__VA_ARGS__) ) )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5686 {\cf21 #define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \\}\par
5687 {\cf21     do \{ }{\cf20 /* NOLINT(bugprone-infinite-loop) */}{\cf21  \\}\par
5688 {\cf21         }{\cf20 /* The expression should not be evaluated, but warnings should hopefully be checked */}{\cf21  \\}\par
5689 {\cf21         CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \\}\par
5690 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
5691 {\cf21         INTERNAL_CATCH_TRY \{ \\}\par
5692 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5693 {\cf21             CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
5694 {\cf21             catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); }{\cf20 /* NOLINT(bugprone-chained-comparison) */}{\cf21  \\}\par
5695 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5696 {\cf21         \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\}\par
5697 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5698 {\cf21     \} while( (void)0, (false) && static_cast<const bool&>( !!(__VA_ARGS__) ) ) }{\cf20 // the expression here is never evaluated at runtime but it forces the compiler to give it a look}\par
}
}
{\xe \v INTERNAL_CATCH_TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName,  ...)}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), ClassName, __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6101 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \\}\par
6102 {\cf21         INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), ClassName, __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TEST_CASE_METHOD2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TEST_CASE_METHOD2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName,  ClassName,  ...)}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
        namespace\{ \\\par
            {\cf17 struct }TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) \{ \\\par
                {\cf18 void} test(); \\\par
            \}; \\\par
            {\cf17 const} Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\\par
            Catch::makeTestInvoker( &TestName::test ),                    \\\par
            CATCH_INTERNAL_LINEINFO,                                      \\\par
{\cf21             #ClassName##_catch_sr,                                        \\}\par
{\cf21             Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
{\cf21         \} \\}\par
{\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
{\cf21         void TestName::test()}\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6085 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\}\par
6086 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6087 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6088 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6089 {\cf21         namespace\{ \\}\par
6090 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) \{ \\}\par
6091 {\cf21                 void test(); \\}\par
6092 {\cf21             \}; \\}\par
6093 {\cf21             const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\}\par
6094 {\cf21             Catch::makeTestInvoker( &TestName::test ),                    \\}\par
6095 {\cf21             CATCH_INTERNAL_LINEINFO,                                      \\}\par
6096 {\cf21             #ClassName##_catch_sr,                                        \\}\par
6097 {\cf21             Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
6098 {\cf21         \} \\}\par
6099 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6100 {\cf21         void TestName::test()}\par
}
}
{\xe \v INTERNAL_CATCH_TESTCASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TESTCASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TESTCASE( ...)}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__ )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6046 {\cf21     #define INTERNAL_CATCH_TESTCASE( ... ) \\}\par
6047 {\cf21         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__ )}\par
}
}
{\xe \v INTERNAL_CATCH_TESTCASE2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TESTCASE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TESTCASE2( TestName,  ...)}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         {\cf17 static} {\cf18 void} TestName(); \\\par
        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\\par
        namespace\{ {\cf17 const} Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); \} {\cf20 /* NOLINT */} \\\par
        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
        static {\cf18 void} TestName()\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6038 {\cf21     #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \\}\par
6039 {\cf21         static void TestName(); \\}\par
6040 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6041 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6042 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6043 {\cf21         namespace\{ const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); \} }{\cf20 /* NOLINT */}{\cf21  \\}\par
6044 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6045 {\cf21         static void TestName()}\par
}
}
{\xe \v INTERNAL_CATCH_THROWS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_THROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_THROWS( macroName,  resultDisposition,  ...)}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\\par
        if( catchAssertionHandler.allowThrows() ) \\\par
            {\cf19 try} \{ \\\par
                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
                CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\\par
                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\par
                static_cast<void>(__VA_ARGS__); \\\par
                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
            \} \\\par
            catch( ... ) \{ \\\par
                catchAssertionHandler.handleExceptionThrownAsExpected(); \\\par
            \} \\\par
        else \\\par
            catchAssertionHandler.handleThrowingCallSkipped(); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5729 {\cf21 #define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \\}\par
5730 {\cf21     do \{ \\}\par
5731 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\}\par
5732 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5733 {\cf21             try \{ \\}\par
5734 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5735 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5736 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5737 {\cf21                 static_cast<void>(__VA_ARGS__); \\}\par
5738 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5739 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5740 {\cf21             \} \\}\par
5741 {\cf21             catch( ... ) \{ \\}\par
5742 {\cf21                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\}\par
5743 {\cf21             \} \\}\par
5744 {\cf21         else \\}\par
5745 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5746 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5747 {\cf21     \} while( false )}\par
}
}
{\xe \v INTERNAL_CATCH_THROWS_AS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_THROWS_AS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_THROWS_AS( macroName,  exceptionType,  resultDisposition,  expr)}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) {\cf22 ", "} CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\\par
        if( catchAssertionHandler.allowThrows() ) \\\par
            {\cf19 try} \{ \\\par
                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
                CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\\par
                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\par
                static_cast<void>(expr); \\\par
                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
            \} \\\par
            catch( exceptionType {\cf17 const}& ) \{ \\\par
                catchAssertionHandler.handleExceptionThrownAsExpected(); \\\par
            \} \\\par
            catch( ... ) \{ \\\par
                catchAssertionHandler.handleUnexpectedInflightException(); \\\par
            \} \\\par
        else \\\par
            catchAssertionHandler.handleThrowingCallSkipped(); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5750 {\cf21 #define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \\}\par
5751 {\cf21     do \{ \\}\par
5752 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\}\par
5753 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5754 {\cf21             try \{ \\}\par
5755 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5756 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5757 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5758 {\cf21                 static_cast<void>(expr); \\}\par
5759 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5760 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5761 {\cf21             \} \\}\par
5762 {\cf21             catch( exceptionType const& ) \{ \\}\par
5763 {\cf21                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\}\par
5764 {\cf21             \} \\}\par
5765 {\cf21             catch( ... ) \{ \\}\par
5766 {\cf21                 catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
5767 {\cf21             \} \\}\par
5768 {\cf21         else \\}\par
5769 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5770 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5771 {\cf21     \} while( false )}\par
}
}
{\xe \v INTERNAL_CATCH_THROWS_STR_MATCHES\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_THROWS_STR_MATCHES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName,  resultDisposition,  matcher,  ...)}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) {\cf22 ", "} CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\\par
        if( catchAssertionHandler.allowThrows() ) \\\par
            {\cf19 try} \{ \\\par
                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
                CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\\par
                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\\par
                static_cast<void>(__VA_ARGS__); \\\par
                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\\par
            \} \\\par
            catch( ... ) \{ \\\par
                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher ); \\\par
            \} \\\par
        else \\\par
            catchAssertionHandler.handleThrowingCallSkipped(); \\\par
        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\\par
    \} {\cf19 while}( {\cf17 false} )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 5777 {\cf21 #define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \\}\par
5778 {\cf21     do \{ \\}\par
5779 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\}\par
5780 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5781 {\cf21             try \{ \\}\par
5782 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5783 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5784 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5785 {\cf21                 static_cast<void>(__VA_ARGS__); \\}\par
5786 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5787 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5788 {\cf21             \} \\}\par
5789 {\cf21             catch( ... ) \{ \\}\par
5790 {\cf21                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher ); \\}\par
5791 {\cf21             \} \\}\par
5792 {\cf21         else \\}\par
5793 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5794 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5795 {\cf21     \} while( false )}\par
}
}
{\xe \v INTERNAL_CATCH_TRANSLATE_EXCEPTION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TRANSLATE_EXCEPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature)}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )\par
}
}
{\xe \v INTERNAL_CATCH_TRANSLATE_EXCEPTION2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TRANSLATE_EXCEPTION2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName,  signature)}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 static} std::string translatorName( signature ); \\\par
    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\\par
    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\\par
    namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); \} \\\par
    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\\par
    static std::string translatorName( signature )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 7209 {\cf21 #define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \\}\par
7210 {\cf21     static std::string translatorName( signature ); \\}\par
7211 {\cf21     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
7212 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
7213 {\cf21     namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); \} \\}\par
7214 {\cf21     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
7215 {\cf21     static std::string translatorName( signature )}\par
}
}
{\xe \v INTERNAL_CATCH_TRY\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TRY}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERNAL_CATCH_TYPE_GEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_TYPE_GEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_TYPE_GEN}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 6442 {\cf21 #define INTERNAL_CATCH_TYPE_GEN\\}\par
6443 {\cf21     template<typename...> struct TypeList \{\};\\}\par
6444 {\cf21     template<typename...Ts>\\}\par
6445 {\cf21     constexpr auto get_wrapper() noexcept -> TypeList<Ts...> \{ return \{\}; \}\\}\par
6446 {\cf21     template<template<typename...> class...> struct TemplateTypeList\{\};\\}\par
6447 {\cf21     template<template<typename...> class...Cs>\\}\par
6448 {\cf21     constexpr auto get_wrapper() noexcept -> TemplateTypeList<Cs...> \{ return \{\}; \}\\}\par
6449 {\cf21     template<typename...>\\}\par
6450 {\cf21     struct append;\\}\par
6451 {\cf21     template<typename...>\\}\par
6452 {\cf21     struct rewrap;\\}\par
6453 {\cf21     template<template<typename...> class, typename...>\\}\par
6454 {\cf21     struct create;\\}\par
6455 {\cf21     template<template<typename...> class, typename>\\}\par
6456 {\cf21     struct convert;\\}\par
6457 {\cf21     \\}\par
6458 {\cf21     template<typename T> \\}\par
6459 {\cf21     struct append<T> \{ using type = T; \};\\}\par
6460 {\cf21     template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\}\par
6461 {\cf21     struct append<L1<E1...>, L2<E2...>, Rest...> \{ using type = typename append<L1<E1...,E2...>, Rest...>::type; \};\\}\par
6462 {\cf21     template< template<typename...> class L1, typename...E1, typename...Rest>\\}\par
6463 {\cf21     struct append<L1<E1...>, TypeList<mpl_::na>, Rest...> \{ using type = L1<E1...>; \};\\}\par
6464 {\cf21     \\}\par
6465 {\cf21     template< template<typename...> class Container, template<typename...> class List, typename...elems>\\}\par
6466 {\cf21     struct rewrap<TemplateTypeList<Container>, List<elems...>> \{ using type = TypeList<Container<elems...>>; \};\\}\par
6467 {\cf21     template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\\}\par
6468 {\cf21     struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> \{ using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; \};\\}\par
6469 {\cf21     \\}\par
6470 {\cf21     template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\}\par
6471 {\cf21     struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; \};\\}\par
6472 {\cf21     template<template <typename...> class Final, template <typename...> class List, typename...Ts>\\}\par
6473 {\cf21     struct convert<Final, List<Ts...>> \{ using type = typename append<Final<>,TypeList<Ts>...>::type; \};}\par
}
}
{\xe \v INTERNAL_CATCH_UNIQUE_NAME\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_UNIQUE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_UNIQUE_NAME( name)}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )\par
}
}
{\xe \v INTERNAL_CATCH_UNIQUE_NAME_LINE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_UNIQUE_NAME_LINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name,  line)}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )\par
}
}
{\xe \v INTERNAL_CATCH_UNIQUE_NAME_LINE2\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_UNIQUE_NAME_LINE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name,  line)}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid name##line\par
}
}
{\xe \v INTERNAL_CATCH_UNSCOPED_INFO\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_UNSCOPED_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_UNSCOPED_INFO( macroName,  log)}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )\par
}
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4048 {\cf21 #define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \\}\par
4049 {\cf21     Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )}\par
}
}
{\xe \v INTERNAL_CATCH_VA_NARGS_IMPL\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:INTERNAL_CATCH_VA_NARGS_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INTERNAL_CATCH_VA_NARGS_IMPL( _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10,  N,  ...)}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid N\par
}
}
{\xe \v METHOD_AS_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:METHOD_AS_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define METHOD_AS_TEST_CASE( method,  ...)}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )\par
}
}
{\xe \v REGISTER_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:REGISTER_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REGISTER_TEST_CASE( Function,  ...)}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )\par
}
}
{\xe \v REQUIRE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:REQUIRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE( ...)}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEST( {\cf22 "REQUIRE"}, Catch::ResultDisposition::Normal, __VA_ARGS__  )\par
}
}
{\xe \v REQUIRE_FALSE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:REQUIRE_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_FALSE( ...)}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEST( {\cf22 "REQUIRE_FALSE"}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )\par
}
}
{\xe \v REQUIRE_NOTHROW\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:REQUIRE_NOTHROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_NOTHROW( ...)}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_NO_THROW( {\cf22 "REQUIRE_NOTHROW"}, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
}
}
{\xe \v REQUIRE_THROWS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:REQUIRE_THROWS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_THROWS( ...)}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_THROWS( {\cf22 "REQUIRE_THROWS"}, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
}
}
{\xe \v REQUIRE_THROWS_AS\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:REQUIRE_THROWS_AS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REQUIRE_THROWS_AS( expr,  exceptionType)}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_THROWS_AS( {\cf22 "REQUIRE_THROWS_AS"}, exceptionType, Catch::ResultDisposition::Normal, expr )\par
}
}
{\xe \v SCENARIO\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:SCENARIO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SCENARIO( ...)}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid TEST_CASE( {\cf22 "Scenario: "} __VA_ARGS__ )\par
}
}
{\xe \v SCENARIO_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:SCENARIO_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SCENARIO_METHOD( className,  ...)}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEST_CASE_METHOD( className, {\cf22 "Scenario: "} __VA_ARGS__ )\par
}
}
{\xe \v SECTION\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:SECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SECTION( ...)}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_SECTION( __VA_ARGS__ )\par
}
}
{\xe \v SizedUnsignedTypeHelper\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:SizedUnsignedTypeHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SizedUnsignedTypeHelper( TYPE)}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template} <>                                \\\par
    {\cf17 struct }SizedUnsignedType<sizeof( TYPE )> \{ \\\par
        {\cf17 using }type = TYPE;                     \\\par
    \}\par
}
}
{\xe \v SKIP\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:SKIP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SKIP( ...)}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_MSG( {\cf22 "SKIP"}, Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )\par
}
}
{\xe \v STATIC_CHECK\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:STATIC_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STATIC_CHECK( ...)}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 static_assert}(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )\par
}
}
{\xe \v STATIC_CHECK_FALSE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:STATIC_CHECK_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STATIC_CHECK_FALSE( ...)}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 static_assert}( !(__VA_ARGS__), {\cf22 "!("} #__VA_ARGS__ {\cf22 ")"} ); SUCCEED( {\cf22 "!("} #__VA_ARGS__ {\cf22 ")"} )\par
}
}
{\xe \v STATIC_REQUIRE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:STATIC_REQUIRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STATIC_REQUIRE( ...)}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 static_assert}(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )\par
}
}
{\xe \v STATIC_REQUIRE_FALSE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:STATIC_REQUIRE_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STATIC_REQUIRE_FALSE( ...)}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 static_assert}( !(__VA_ARGS__), {\cf22 "!("} #__VA_ARGS__ {\cf22 ")"} ); SUCCEED( {\cf22 "!("} #__VA_ARGS__ {\cf22 ")"} )\par
}
}
{\xe \v SUCCEED\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:SUCCEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SUCCEED( ...)}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_MSG( {\cf22 "SUCCEED"}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_LIST_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_LIST_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_LIST_TEST_CASE( ...)}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)\par
}
}
{\xe \v TEMPLATE_LIST_TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_LIST_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_LIST_TEST_CASE_METHOD( className,  ...)}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_PRODUCT_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_PRODUCT_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_PRODUCT_TEST_CASE( ...)}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_PRODUCT_TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_PRODUCT_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className,  ...)}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className,  ...)}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_PRODUCT_TEST_CASE_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_PRODUCT_TEST_CASE_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ...)}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_TEST_CASE( ...)}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_TEST_CASE_METHOD( className,  ...)}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_TEST_CASE_METHOD_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_TEST_CASE_METHOD_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_TEST_CASE_METHOD_SIG( className,  ...)}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )\par
}
}
{\xe \v TEMPLATE_TEST_CASE_SIG\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEMPLATE_TEST_CASE_SIG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMPLATE_TEST_CASE_SIG( ...)}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )\par
}
}
{\xe \v TEST_CASE\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_CASE( ...)}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )\par
}
}
{\xe \v TEST_CASE_METHOD\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:TEST_CASE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEST_CASE_METHOD( className,  ...)}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )\par
}
}
{\xe \v THEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:THEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THEN( desc)}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DYNAMIC_SECTION( {\cf22 "     Then: "} << desc )\par
}
}
{\xe \v UNSCOPED_INFO\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:UNSCOPED_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNSCOPED_INFO( msg)}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_UNSCOPED_INFO( {\cf22 "UNSCOPED_INFO"}, msg )\par
}
}
{\xe \v WARN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:WARN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WARN( msg)}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_MSG( {\cf22 "WARN"}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )\par
}
}
{\xe \v WHEN\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:WHEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WHEN( desc)}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid INTERNAL_CATCH_DYNAMIC_SECTION( {\cf22 "     When: "} << desc )\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v operator""_catch_sr\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:operator""_catch_sr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
auto operator""_catch_sr (char const * rawChars, std::size_t size) -> {\b Catch::StringRef} {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 787                                                                                                        \{\par
788     {\cf19 return} Catch::StringRef( rawChars, size );\par
789 \}\par
}
}
{\xe \v operator<<\:catch_amalgamated.hpp}
{\xe \v catch_amalgamated.hpp\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & operator<< (std::ostream & , {\b Catch_global_namespace_dummy} )}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
catch_amalgamated.hpp\par \pard\plain 
{\tc\tcl2 \v test/catch_amalgamated.hpp}
{\xe \v test/catch_amalgamated.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Ir para a documenta\'E7\'E3o desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //              Copyright Catch2 Authors}\par
3 {\cf20 // Distributed under the Boost Software License, Version 1.0.}\par
4 {\cf20 //   (See accompanying file LICENSE.txt or copy at}\par
5 {\cf20 //        https://www.boost.org/LICENSE_1_0.txt)}\par
6 \par
7 {\cf20 // SPDX-License-Identifier: BSL-1.0}\par
8 \par
9 {\cf20 //  Catch v3.6.0}\par
10 {\cf20 //  Generated: 2024-05-05 20:53:27.071502}\par
11 {\cf20 //  ----------------------------------------------------------}\par
12 {\cf20 //  This file is an amalgamation of multiple different files.}\par
13 {\cf20 //  You probably shouldn't edit it directly.}\par
14 {\cf20 //  ----------------------------------------------------------}\par
15 {\cf21 #ifndef CATCH_AMALGAMATED_HPP_INCLUDED}\par
16 {\cf21 #define CATCH_AMALGAMATED_HPP_INCLUDED}\par
17 \par
18 \par
33 {\cf21 #ifndef CATCH_ALL_HPP_INCLUDED}\par
34 {\cf21 #define CATCH_ALL_HPP_INCLUDED}\par
35 \par
36 \par
37 \par
51 {\cf21 #ifndef CATCH_BENCHMARK_ALL_HPP_INCLUDED}\par
52 {\cf21 #define CATCH_BENCHMARK_ALL_HPP_INCLUDED}\par
53 \par
54 \par
55 \par
56 {\cf20 // Adapted from donated nonius code.}\par
57 \par
58 {\cf21 #ifndef CATCH_BENCHMARK_HPP_INCLUDED}\par
59 {\cf21 #define CATCH_BENCHMARK_HPP_INCLUDED}\par
60 \par
61 \par
62 \par
63 {\cf21 #ifndef CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}\par
64 {\cf21 #define CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}\par
65 \par
66 {\cf20 // Detect a number of compiler features - by compiler}\par
67 {\cf20 // The following features are defined:}\par
68 {\cf20 //}\par
69 {\cf20 // CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?}\par
70 {\cf20 // CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?}\par
71 {\cf20 // CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?}\par
72 {\cf20 // ****************}\par
73 {\cf20 // Note to maintainers: if new toggles are added please document them}\par
74 {\cf20 // in configuration.md, too}\par
75 {\cf20 // ****************}\par
76 \par
77 {\cf20 // In general each macro has a _NO_<feature name> form}\par
78 {\cf20 // (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.}\par
79 {\cf20 // Many features, at point of detection, define an _INTERNAL_ macro, so they}\par
80 {\cf20 // can be combined, en-mass, with the _NO_ forms later.}\par
81 \par
82 \par
83 \par
84 {\cf21 #ifndef CATCH_PLATFORM_HPP_INCLUDED}\par
85 {\cf21 #define CATCH_PLATFORM_HPP_INCLUDED}\par
86 \par
87 {\cf20 // See e.g.:}\par
88 {\cf20 // https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-18.1/TargetConditionals.h.auto.html}\par
89 {\cf21 #ifdef __APPLE__}\par
90 {\cf21 #  ifndef __has_extension}\par
91 {\cf21 #    define __has_extension(x) 0}\par
92 {\cf21 #  endif}\par
93 {\cf21 #  include <TargetConditionals.h>}\par
94 {\cf21 #  if (defined(TARGET_OS_OSX) && TARGET_OS_OSX == 1) || \\}\par
95 {\cf21       (defined(TARGET_OS_MAC) && TARGET_OS_MAC == 1)}\par
96 {\cf21 #    define CATCH_PLATFORM_MAC}\par
97 {\cf21 #  elif (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE == 1)}\par
98 {\cf21 #    define CATCH_PLATFORM_IPHONE}\par
99 {\cf21 #  endif}\par
100 \par
101 {\cf21 #elif defined(linux) || defined(__linux) || defined(__linux__)}\par
102 {\cf21 #  define CATCH_PLATFORM_LINUX}\par
103 \par
104 {\cf21 #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)}\par
105 {\cf21 #  define CATCH_PLATFORM_WINDOWS}\par
106 \par
107 {\cf21 #  if defined( WINAPI_FAMILY ) && ( WINAPI_FAMILY == WINAPI_FAMILY_APP )}\par
108 {\cf21 #      define CATCH_PLATFORM_WINDOWS_UWP}\par
109 {\cf21 #  endif}\par
110 \par
111 {\cf21 #elif defined(__ORBIS__) || defined(__PROSPERO__)}\par
112 {\cf21 #  define CATCH_PLATFORM_PLAYSTATION}\par
113 \par
114 {\cf21 #endif}\par
115 \par
116 {\cf21 #endif }{\cf20 // CATCH_PLATFORM_HPP_INCLUDED}\par
117 \par
118 {\cf21 #ifdef __cplusplus}\par
119 \par
120 {\cf21 #  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)}\par
121 {\cf21 #    define CATCH_CPP17_OR_GREATER}\par
122 {\cf21 #  endif}\par
123 \par
124 {\cf21 #  if (__cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)}\par
125 {\cf21 #    define CATCH_CPP20_OR_GREATER}\par
126 {\cf21 #  endif}\par
127 \par
128 {\cf21 #endif}\par
129 \par
130 {\cf20 // Only GCC compiler should be used in this block, so other compilers trying to}\par
131 {\cf20 // mask themselves as GCC should be ignored.}\par
132 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && !defined(__CUDACC__) && !defined(__LCC__) && !defined(__NVCOMPILER)}\par
133 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "GCC diagnostic push" )}\par
134 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "GCC diagnostic pop" )}\par
135 \par
136 {\cf20 // This only works on GCC 9+. so we have to also add a global suppression of Wparentheses}\par
137 {\cf20 // for older versions of GCC.}\par
138 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
139 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wparentheses\\"" )}\par
140 \par
141 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
142 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wunused-result\\"" )}\par
143 \par
144 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
145 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wunused-variable\\"" )}\par
146 \par
147 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
148 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wuseless-cast\\"" )}\par
149 \par
150 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS \\}\par
151 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wshadow\\"" )}\par
152 \par
153 {\cf21 #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)}\par
154 \par
155 {\cf21 #endif}\par
156 \par
157 {\cf21 #if defined(__NVCOMPILER)}\par
158 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "diag push" )}\par
159 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "diag pop" )}\par
160 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "diag_suppress declared_but_not_referenced" )}\par
161 {\cf21 #endif}\par
162 \par
163 {\cf21 #if defined(__CUDACC__) && !defined(__clang__)}\par
164 {\cf21 #  ifdef __NVCC_DIAG_PRAGMA_SUPPORT__}\par
165 {\cf20 // New pragmas introduced in CUDA 11.5+}\par
166 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "nv_diagnostic push" )}\par
167 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "nv_diagnostic pop" )}\par
168 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "nv_diag_suppress 177" )}\par
169 {\cf21 #  else}\par
170 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "diag_suppress 177" )}\par
171 {\cf21 #  endif}\par
172 {\cf21 #endif}\par
173 \par
174 {\cf20 // clang-cl defines _MSC_VER as well as __clang__, which could cause the}\par
175 {\cf20 // start/stop internal suppression macros to be double defined.}\par
176 {\cf21 #if defined(__clang__) && !defined(_MSC_VER)}\par
177 \par
178 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "clang diagnostic push" )}\par
179 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "clang diagnostic pop" )}\par
180 \par
181 {\cf21 #endif }{\cf20 // __clang__ && !_MSC_VER}\par
182 \par
183 {\cf21 #if defined(__clang__)}\par
184 \par
185 {\cf20 // As of this writing, IBM XL's implementation of __builtin_constant_p has a bug}\par
186 {\cf20 // which results in calls to destructors being emitted for each temporary,}\par
187 {\cf20 // without a matching initialization. In practice, this can result in something}\par
188 {\cf20 // like `std::string::~string` being called on an uninitialized value.}\par
189 {\cf20 //}\par
190 {\cf20 // For example, this code will likely segfault under IBM XL:}\par
191 {\cf20 // ```}\par
192 {\cf20 // REQUIRE(std::string("12") + "34" == "1234")}\par
193 {\cf20 // ```}\par
194 {\cf20 //}\par
195 {\cf20 // Similarly, NVHPC's implementation of `__builtin_constant_p` has a bug which}\par
196 {\cf20 // results in calls to the immediately evaluated lambda expressions to be}\par
197 {\cf20 // reported as unevaluated lambdas.}\par
198 {\cf20 // https://developer.nvidia.com/nvidia_bug/3321845.}\par
199 {\cf20 //}\par
200 {\cf20 // Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.}\par
201 {\cf21 #  if !defined(__ibmxl__) && !defined(__CUDACC__) && !defined( __NVCOMPILER )}\par
202 {\cf21 #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) }{\cf20 /* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */}{\cf21 }\par
203 {\cf21 #  endif}\par
204 \par
205 \par
206 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
207 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wexit-time-destructors\\"" ) \\}\par
208 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wglobal-constructors\\"")}\par
209 \par
210 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
211 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wparentheses\\"" )}\par
212 \par
213 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
214 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wunused-variable\\"" )}\par
215 \par
216 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
217 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wgnu-zero-variadic-macro-arguments\\"" )}\par
218 \par
219 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
220 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wunused-template\\"" )}\par
221 \par
222 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
223 {\cf21         _Pragma( "clang diagnostic ignored \\"-Wcomma\\"" )}\par
224 \par
225 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS \\}\par
226 {\cf21         _Pragma( "clang diagnostic ignored \\"-Wshadow\\"" )}\par
227 \par
228 {\cf21 #endif }{\cf20 // __clang__}\par
229 \par
230 \par
232 {\cf20 // We know some environments not to support full POSIX signals}\par
233 {\cf21 #if defined( CATCH_PLATFORM_WINDOWS ) ||                                       \\}\par
234 {\cf21     defined( CATCH_PLATFORM_PLAYSTATION ) ||                                   \\}\par
235 {\cf21     defined( __CYGWIN__ ) ||                                                   \\}\par
236 {\cf21     defined( __QNX__ ) ||                                                      \\}\par
237 {\cf21     defined( __EMSCRIPTEN__ ) ||                                               \\}\par
238 {\cf21     defined( __DJGPP__ ) ||                                                    \\}\par
239 {\cf21     defined( __OS400__ )}\par
240 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS}\par
241 {\cf21 #else}\par
242 {\cf21 #    define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}\par
243 {\cf21 #endif}\par
244 \par
246 {\cf20 // Assume that some platforms do not support getenv.}\par
247 {\cf21 #if defined( CATCH_PLATFORM_WINDOWS_UWP ) ||                                   \\}\par
248 {\cf21     defined( CATCH_PLATFORM_PLAYSTATION ) ||                                   \\}\par
249 {\cf21     defined( _GAMING_XBOX )}\par
250 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_GETENV}\par
251 {\cf21 #else}\par
252 {\cf21 #    define CATCH_INTERNAL_CONFIG_GETENV}\par
253 {\cf21 #endif}\par
254 \par
256 {\cf20 // Android somehow still does not support std::to_string}\par
257 {\cf21 #if defined(__ANDROID__)}\par
258 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING}\par
259 {\cf21 #endif}\par
260 \par
262 {\cf20 // Not all Windows environments support SEH properly}\par
263 {\cf21 #if defined(__MINGW32__)}\par
264 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH}\par
265 {\cf21 #endif}\par
266 \par
268 {\cf20 // PS4}\par
269 {\cf21 #if defined(__ORBIS__)}\par
270 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE}\par
271 {\cf21 #endif}\par
272 \par
274 {\cf20 // Cygwin}\par
275 {\cf21 #ifdef __CYGWIN__}\par
276 \par
277 {\cf20 // Required for some versions of Cygwin to declare gettimeofday}\par
278 {\cf20 // see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin}\par
279 {\cf21 #   define _BSD_SOURCE}\par
280 {\cf20 // some versions of cygwin (most) do not support std::to_string. Use the libstd check.}\par
281 {\cf20 // https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813}\par
282 {\cf21 # if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \\}\par
283 {\cf21            && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))}\par
284 \par
285 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING}\par
286 \par
287 {\cf21 # endif}\par
288 {\cf21 #endif }{\cf20 // __CYGWIN__}\par
289 \par
291 {\cf20 // Visual C++}\par
292 {\cf21 #if defined(_MSC_VER)}\par
293 \par
294 {\cf20 // We want to defer to nvcc-specific warning suppression if we are compiled}\par
295 {\cf20 // with nvcc masquerading for MSVC.}\par
296 {\cf21 #    if !defined( __CUDACC__ )}\par
297 {\cf21 #        define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
298 {\cf21             __pragma( warning( push ) )}\par
299 {\cf21 #        define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
300 {\cf21             __pragma( warning( pop ) )}\par
301 {\cf21 #    endif}\par
302 \par
303 {\cf20 // Universal Windows platform does not support SEH}\par
304 {\cf20 // Or console colours (or console at all...)}\par
305 {\cf21 #  if defined(CATCH_PLATFORM_WINDOWS_UWP)}\par
306 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32}\par
307 {\cf21 #  else}\par
308 {\cf21 #    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH}\par
309 {\cf21 #  endif}\par
310 \par
311 {\cf20 // MSVC traditional preprocessor needs some workaround for __VA_ARGS__}\par
312 {\cf20 // _MSVC_TRADITIONAL == 0 means new conformant preprocessor}\par
313 {\cf20 // _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor}\par
314 {\cf21 #  if !defined(__clang__) }{\cf20 // Handle Clang masquerading for msvc}\par
315 {\cf21 #    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)}\par
316 {\cf21 #      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
317 {\cf21 #    endif }{\cf20 // MSVC_TRADITIONAL}\par
318 {\cf21 #  endif }{\cf20 // __clang__}\par
319 \par
320 {\cf21 #endif }{\cf20 // _MSC_VER}\par
321 \par
322 {\cf21 #if defined(_REENTRANT) || defined(_MSC_VER)}\par
323 {\cf20 // Enable async processing, as -pthread is specified or no additional linking is required}\par
324 {\cf21 # define CATCH_INTERNAL_CONFIG_USE_ASYNC}\par
325 {\cf21 #endif }{\cf20 // _MSC_VER}\par
326 \par
328 {\cf20 // Check if we are compiled with -fno-exceptions or equivalent}\par
329 {\cf21 #if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)}\par
330 {\cf21 #  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED}\par
331 {\cf21 #endif}\par
332 \par
333 \par
335 {\cf20 // Embarcadero C++Build}\par
336 {\cf21 #if defined(__BORLANDC__)}\par
337 {\cf21     #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN}\par
338 {\cf21 #endif}\par
339 \par
341 \par
342 {\cf20 // RTX is a special version of Windows that is real time.}\par
343 {\cf20 // This means that it is detected as Windows, but does not provide}\par
344 {\cf20 // the same set of capabilities as real Windows does.}\par
345 {\cf21 #if defined(UNDER_RTSS) || defined(RTX64_BUILD)}\par
346 {\cf21     #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH}\par
347 {\cf21     #define CATCH_INTERNAL_CONFIG_NO_ASYNC}\par
348 {\cf21     #define CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32}\par
349 {\cf21 #endif}\par
350 \par
351 {\cf21 #if !defined(_GLIBCXX_USE_C99_MATH_TR1)}\par
352 {\cf21 #define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER}\par
353 {\cf21 #endif}\par
354 \par
355 {\cf20 // Various stdlib support checks that require __has_include}\par
356 {\cf21 #if defined(__has_include)}\par
357   {\cf20 // Check if string_view is available and usable}\par
358 {\cf21   #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)}\par
359 {\cf21   #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW}\par
360 {\cf21   #endif}\par
361 \par
362   {\cf20 // Check if optional is available and usable}\par
363 {\cf21   #  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)}\par
364 {\cf21   #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL}\par
365 {\cf21   #  endif }{\cf20 // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)}\par
366 \par
367   {\cf20 // Check if byte is available and usable}\par
368 {\cf21   #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)}\par
369 {\cf21   #    include <cstddef>}\par
370 {\cf21   #    if defined(__cpp_lib_byte) && (__cpp_lib_byte > 0)}\par
371 {\cf21   #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE}\par
372 {\cf21   #    endif}\par
373 {\cf21   #  endif }{\cf20 // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)}\par
374 \par
375   {\cf20 // Check if variant is available and usable}\par
376 {\cf21   #  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)}\par
377 {\cf21   #    if defined(__clang__) && (__clang_major__ < 8)}\par
378          {\cf20 // work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852}\par
379          {\cf20 // fix should be in clang 8, workaround in libstdc++ 8.2}\par
380 {\cf21   #      include <ciso646>}\par
381 {\cf21   #      if defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)}\par
382 {\cf21   #        define CATCH_CONFIG_NO_CPP17_VARIANT}\par
383 {\cf21   #      else}\par
384 {\cf21   #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT}\par
385 {\cf21   #      endif }{\cf20 // defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)}\par
386 {\cf21   #    else}\par
387 {\cf21   #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT}\par
388 {\cf21   #    endif }{\cf20 // defined(__clang__) && (__clang_major__ < 8)}\par
389 {\cf21   #  endif }{\cf20 // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)}\par
390 {\cf21 #endif }{\cf20 // defined(__has_include)}\par
391 \par
392 \par
393 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH) && !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)}\par
394 {\cf21 #   define CATCH_CONFIG_WINDOWS_SEH}\par
395 {\cf21 #endif}\par
396 {\cf20 // This is set by default, because we assume that unix compilers are posix-signal-compatible by default.}\par
397 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)}\par
398 {\cf21 #   define CATCH_CONFIG_POSIX_SIGNALS}\par
399 {\cf21 #endif}\par
400 \par
401 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_GETENV) && !defined(CATCH_INTERNAL_CONFIG_NO_GETENV) && !defined(CATCH_CONFIG_NO_GETENV) && !defined(CATCH_CONFIG_GETENV)}\par
402 {\cf21 #   define CATCH_CONFIG_GETENV}\par
403 {\cf21 #endif}\par
404 \par
405 {\cf21 #if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_CPP11_TO_STRING)}\par
406 {\cf21 #    define CATCH_CONFIG_CPP11_TO_STRING}\par
407 {\cf21 #endif}\par
408 \par
409 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_CPP17_OPTIONAL)}\par
410 {\cf21 #  define CATCH_CONFIG_CPP17_OPTIONAL}\par
411 {\cf21 #endif}\par
412 \par
413 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)}\par
414 {\cf21 #  define CATCH_CONFIG_CPP17_STRING_VIEW}\par
415 {\cf21 #endif}\par
416 \par
417 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) && !defined(CATCH_CONFIG_NO_CPP17_VARIANT) && !defined(CATCH_CONFIG_CPP17_VARIANT)}\par
418 {\cf21 #  define CATCH_CONFIG_CPP17_VARIANT}\par
419 {\cf21 #endif}\par
420 \par
421 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) && !defined(CATCH_CONFIG_NO_CPP17_BYTE) && !defined(CATCH_CONFIG_CPP17_BYTE)}\par
422 {\cf21 #  define CATCH_CONFIG_CPP17_BYTE}\par
423 {\cf21 #endif}\par
424 \par
425 \par
426 {\cf21 #if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)}\par
427 {\cf21 #  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE}\par
428 {\cf21 #endif}\par
429 \par
430 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) && !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NEW_CAPTURE)}\par
431 {\cf21 #  define CATCH_CONFIG_NEW_CAPTURE}\par
432 {\cf21 #endif}\par
433 \par
434 {\cf21 #if !defined( CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED ) && \\}\par
435 {\cf21     !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS ) &&          \\}\par
436 {\cf21     !defined( CATCH_CONFIG_NO_DISABLE_EXCEPTIONS )}\par
437 {\cf21 #  define CATCH_CONFIG_DISABLE_EXCEPTIONS}\par
438 {\cf21 #endif}\par
439 \par
440 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_POLYFILL_ISNAN)}\par
441 {\cf21 #  define CATCH_CONFIG_POLYFILL_ISNAN}\par
442 {\cf21 #endif}\par
443 \par
444 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  && !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) && !defined(CATCH_CONFIG_NO_USE_ASYNC) && !defined(CATCH_CONFIG_USE_ASYNC)}\par
445 {\cf21 #  define CATCH_CONFIG_USE_ASYNC}\par
446 {\cf21 #endif}\par
447 \par
448 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)}\par
449 {\cf21 #  define CATCH_CONFIG_GLOBAL_NEXTAFTER}\par
450 {\cf21 #endif}\par
451 \par
452 \par
453 {\cf20 // Even if we do not think the compiler has that warning, we still have}\par
454 {\cf20 // to provide a macro that can be used by the code.}\par
455 {\cf21 #if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)}\par
456 {\cf21 #   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION}\par
457 {\cf21 #endif}\par
458 {\cf21 #if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)}\par
459 {\cf21 #   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
460 {\cf21 #endif}\par
461 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)}\par
462 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}\par
463 {\cf21 #endif}\par
464 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)}\par
465 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}\par
466 {\cf21 #endif}\par
467 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT)}\par
468 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT}\par
469 {\cf21 #endif}\par
470 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS)}\par
471 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS}\par
472 {\cf21 #endif}\par
473 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS)}\par
474 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS}\par
475 {\cf21 #endif}\par
476 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)}\par
477 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS}\par
478 {\cf21 #endif}\par
479 {\cf21 #if !defined( CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS )}\par
480 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}\par
481 {\cf21 #endif}\par
482 {\cf21 #if !defined( CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS )}\par
483 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS}\par
484 {\cf21 #endif}\par
485 {\cf21 #if !defined( CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS )}\par
486 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS}\par
487 {\cf21 #endif}\par
488 \par
489 \par
490 {\cf20 // The goal of this macro is to avoid evaluation of the arguments, but}\par
491 {\cf20 // still have the compiler warn on problems inside...}\par
492 {\cf21 #if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)}\par
493 {\cf21 #   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)}\par
494 {\cf21 #endif}\par
495 \par
496 {\cf21 #if defined(__APPLE__) && defined(__apple_build_version__) && (__clang_major__ < 10)}\par
497 {\cf21 #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}\par
498 {\cf21 #elif defined(__clang__) && (__clang_major__ < 5)}\par
499 {\cf21 #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}\par
500 {\cf21 #endif}\par
501 \par
502 \par
503 {\cf21 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
504 {\cf21 #define CATCH_TRY if ((true))}\par
505 {\cf21 #define CATCH_CATCH_ALL if ((false))}\par
506 {\cf21 #define CATCH_CATCH_ANON(type) if ((false))}\par
507 {\cf21 #else}\par
508 {\cf21 #define CATCH_TRY try}\par
509 {\cf21 #define CATCH_CATCH_ALL catch (...)}\par
510 {\cf21 #define CATCH_CATCH_ANON(type) catch (type)}\par
511 {\cf21 #endif}\par
512 \par
513 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)}\par
514 {\cf21 #define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
515 {\cf21 #endif}\par
516 \par
517 {\cf21 #if defined( CATCH_PLATFORM_WINDOWS ) &&       \\}\par
518 {\cf21     !defined( CATCH_CONFIG_COLOUR_WIN32 ) && \\}\par
519 {\cf21     !defined( CATCH_CONFIG_NO_COLOUR_WIN32 ) && \\}\par
520 {\cf21     !defined( CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32 )}\par
521 {\cf21 #    define CATCH_CONFIG_COLOUR_WIN32}\par
522 {\cf21 #endif}\par
523 \par
524 {\cf21 #if defined( CATCH_CONFIG_SHARED_LIBRARY ) && defined( _MSC_VER ) && \\}\par
525 {\cf21     !defined( CATCH_CONFIG_STATIC )}\par
526 {\cf21 #    ifdef Catch2_EXPORTS}\par
527 {\cf21 #        define CATCH_EXPORT }{\cf20 //__declspec( dllexport ) // not needed}\par
528 {\cf21 #    else}\par
529 {\cf21 #        define CATCH_EXPORT __declspec( dllimport )}\par
530 {\cf21 #    endif}\par
531 {\cf21 #else}\par
532 {\cf21 #    define CATCH_EXPORT}\par
533 {\cf21 #endif}\par
534 \par
535 {\cf21 #endif }{\cf20 // CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}\par
536 \par
537 \par
538 {\cf21 #ifndef CATCH_CONTEXT_HPP_INCLUDED}\par
539 {\cf21 #define CATCH_CONTEXT_HPP_INCLUDED}\par
540 \par
541 \par
542 {\cf17 namespace }Catch \{\par
543 \par
544     {\cf17 class }IResultCapture;\par
545     {\cf17 class }IConfig;\par
546 \par
547     {\cf17 class }Context \{\par
548         IConfig {\cf17 const}* m_config = {\cf17 nullptr};\par
549         IResultCapture* m_resultCapture = {\cf17 nullptr};\par
550 \par
551         CATCH_EXPORT {\cf17 static} Context* currentContext;\par
552         {\cf17 friend} Context& getCurrentMutableContext();\par
553         {\cf17 friend} Context {\cf17 const}& getCurrentContext();\par
554         {\cf17 static} {\cf18 void} createContext();\par
555         {\cf17 friend} {\cf18 void} cleanUpContext();\par
556 \par
557     {\cf17 public}:\par
558         IResultCapture* getResultCapture(){\cf17  const }\{ {\cf19 return} m_resultCapture; \}\par
559         IConfig {\cf17 const}* getConfig(){\cf17  const }\{ {\cf19 return} m_config; \}\par
560         {\cf18 void} setResultCapture( IResultCapture* resultCapture );\par
561         {\cf18 void} setConfig( IConfig {\cf17 const}* config );\par
562     \};\par
563 \par
564     Context& getCurrentMutableContext();\par
565 \par
566     {\cf17 inline} Context {\cf17 const}& getCurrentContext() \{\par
567         {\cf20 // We duplicate the logic from `getCurrentMutableContext` here,}\par
568         {\cf20 // to avoid paying the call overhead in debug mode.}\par
569         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
570         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
571         {\cf19 return} *Context::currentContext;\par
572     \}\par
573 \par
574     {\cf18 void} cleanUpContext();\par
575 \par
576     {\cf17 class }SimplePcg32;\par
577     SimplePcg32& sharedRng();\par
578 \}\par
579 \par
580 {\cf21 #endif }{\cf20 // CATCH_CONTEXT_HPP_INCLUDED}\par
581 \par
582 \par
583 {\cf21 #ifndef CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}\par
584 {\cf21 #define CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}\par
585 \par
586 {\cf21 #include <type_traits>}\par
587 \par
589 {\cf21 #define CATCH_MOVE(...) static_cast<std::remove_reference_t<decltype(__VA_ARGS__)>&&>(__VA_ARGS__)}\par
590 \par
592 {\cf21 #define CATCH_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)}\par
593 \par
594 {\cf21 #endif }{\cf20 // CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}\par
595 \par
596 \par
597 {\cf21 #ifndef CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}\par
598 {\cf21 #define CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}\par
599 \par
600 {\cf17 namespace }Catch \{\par
601 \par
603     {\cf17 struct }TestFailureException\{\};\par
605     {\cf17 struct }TestSkipException \{\};\par
606 \par
612     [[noreturn]] {\cf18 void} throw_test_failure_exception();\par
613 \par
619     [[noreturn]] {\cf18 void} throw_test_skip_exception();\par
620 \par
621 \} {\cf20 // namespace Catch}\par
622 \par
623 {\cf21 #endif }{\cf20 // CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}\par
624 \par
625 \par
626 {\cf21 #ifndef CATCH_UNIQUE_NAME_HPP_INCLUDED}\par
627 {\cf21 #define CATCH_UNIQUE_NAME_HPP_INCLUDED}\par
628 \par
629 \par
630 \par
631 \par
641 {\cf21 #ifndef CATCH_CONFIG_COUNTER_HPP_INCLUDED}\par
642 {\cf21 #define CATCH_CONFIG_COUNTER_HPP_INCLUDED}\par
643 \par
644 \par
645 {\cf21 #if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )}\par
646 {\cf21     #define CATCH_INTERNAL_CONFIG_COUNTER}\par
647 {\cf21 #endif}\par
648 \par
649 {\cf21 #if defined( CATCH_INTERNAL_CONFIG_COUNTER ) && \\}\par
650 {\cf21     !defined( CATCH_CONFIG_NO_COUNTER ) && \\}\par
651 {\cf21     !defined( CATCH_CONFIG_COUNTER )}\par
652 {\cf21 #    define CATCH_CONFIG_COUNTER}\par
653 {\cf21 #endif}\par
654 \par
655 \par
656 {\cf21 #endif }{\cf20 // CATCH_CONFIG_COUNTER_HPP_INCLUDED}\par
657 {\cf21 #define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line}\par
658 {\cf21 #define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )}\par
659 {\cf21 #ifdef CATCH_CONFIG_COUNTER}\par
660 {\cf21 #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )}\par
661 {\cf21 #else}\par
662 {\cf21 #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )}\par
663 {\cf21 #endif}\par
664 \par
665 {\cf21 #endif }{\cf20 // CATCH_UNIQUE_NAME_HPP_INCLUDED}\par
666 \par
667 \par
668 {\cf21 #ifndef CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}\par
669 {\cf21 #define CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}\par
670 \par
671 {\cf21 #include <string>}\par
672 {\cf21 #include <chrono>}\par
673 \par
674 \par
675 \par
676 {\cf21 #ifndef CATCH_STRINGREF_HPP_INCLUDED}\par
677 {\cf21 #define CATCH_STRINGREF_HPP_INCLUDED}\par
678 \par
679 {\cf21 #include <cstddef>}\par
680 {\cf21 #include <string>}\par
681 {\cf21 #include <iosfwd>}\par
682 {\cf21 #include <cassert>}\par
683 \par
684 {\cf21 #include <cstring>}\par
685 \par
686 {\cf17 namespace }Catch \{\par
687 \par
691     {\cf17 class }StringRef \{\par
692     {\cf17 public}:\par
693         {\cf17 using }size_type = std::size_t;\par
694         {\cf17 using }const_iterator = {\cf17 const} {\cf18 char}*;\par
695 \par
696         {\cf17 static} {\cf17 constexpr} size_type npos\{ {\cf17 static_cast<}size_type{\cf17 >}( -1 ) \};\par
697 \par
698     {\cf17 private}:\par
699         {\cf17 static} {\cf17 constexpr} {\cf18 char} {\cf17 const}* {\cf17 const} s_empty = {\cf22 ""};\par
700 \par
701         {\cf18 char} {\cf17 const}* m_start = s_empty;\par
702         size_type m_size = 0;\par
703 \par
704     {\cf17 public}: {\cf20 // construction}\par
705         {\cf17 constexpr} StringRef() noexcept = default;\par
706 \par
707         StringRef( {\cf18 char} const* rawChars ) noexcept;\par
708 \par
709         constexpr StringRef( {\cf18 char} const* rawChars, size_type size ) noexcept\par
710         :   m_start( rawChars ),\par
711             m_size( size )\par
712         \{\}\par
713 \par
714         StringRef( std::string {\cf17 const}& stdString ) noexcept\par
715         :   m_start( stdString.c_str() ),\par
716             m_size( stdString.size() )\par
717         \{\}\par
718 \par
719         {\cf17 explicit} {\cf17 operator} std::string(){\cf17  const }\{\par
720             {\cf19 return} std::string(m_start, m_size);\par
721         \}\par
722 \par
723     {\cf17 public}: {\cf20 // operators}\par
724         {\cf17 auto} operator == ( StringRef other ) {\cf17 const} {\cf17 noexcept} -> {\cf18 bool} \{\par
725             {\cf19 return} m_size == other.m_size\par
726                 && (std::memcmp( m_start, other.m_start, m_size ) == 0);\par
727         \}\par
728         {\cf17 auto} operator != (StringRef other) {\cf17 const} {\cf17 noexcept} -> {\cf18 bool} \{\par
729             {\cf19 return} !(*{\cf17 this} == other);\par
730         \}\par
731 \par
732         {\cf17 constexpr} {\cf17 auto} operator[] ( size_type index ) {\cf17 const} {\cf17 noexcept} -> {\cf18 char} \{\par
733             assert(index < m_size);\par
734             {\cf19 return} m_start[index];\par
735         \}\par
736 \par
737         {\cf18 bool} operator<(StringRef rhs) {\cf17 const} {\cf17 noexcept};\par
738 \par
739     {\cf17 public}: {\cf20 // named queries}\par
740         {\cf17 constexpr} {\cf17 auto} empty() const noexcept -> {\cf18 bool} \{\par
741             {\cf19 return} m_size == 0;\par
742         \}\par
743         {\cf17 constexpr} {\cf17 auto} size() const noexcept -> size_type \{\par
744             {\cf19 return} m_size;\par
745         \}\par
746 \par
747         {\cf20 // Returns a substring of [start, start + length).}\par
748         {\cf20 // If start + length > size(), then the substring is [start, size()).}\par
749         {\cf20 // If start > size(), then the substring is empty.}\par
750         {\cf17 constexpr} StringRef substr(size_type start, size_type length) {\cf17 const} {\cf17 noexcept} \{\par
751             {\cf19 if} (start < m_size) \{\par
752                 {\cf17 const} {\cf17 auto} shortened_size = m_size - start;\par
753                 {\cf19 return} StringRef(m_start + start, (shortened_size < length) ? shortened_size : length);\par
754             \} {\cf19 else} \{\par
755                 {\cf19 return} StringRef();\par
756             \}\par
757         \}\par
758 \par
759         {\cf20 // Returns the current start pointer. May not be null-terminated.}\par
760         {\cf17 constexpr} {\cf18 char} {\cf17 const}* data() const noexcept \{\par
761             {\cf19 return} m_start;\par
762         \}\par
763 \par
764         {\cf17 constexpr} const_iterator begin(){\cf17  const }\{ {\cf19 return} m_start; \}\par
765         {\cf17 constexpr} const_iterator end(){\cf17  const }\{ {\cf19 return} m_start + m_size; \}\par
766 \par
767 \par
768         {\cf17 friend} std::string& operator += (std::string& lhs, StringRef rhs);\par
769         {\cf17 friend} std::ostream& operator << (std::ostream& os, StringRef str);\par
770         {\cf17 friend} std::string operator+(StringRef lhs, StringRef rhs);\par
771 \par
778         {\cf18 int} compare( StringRef rhs ) {\cf17 const};\par
779     \};\par
780 \par
781 \par
782     {\cf17 constexpr} {\cf17 auto} {\cf17 operator} {\cf22 ""}_sr( {\cf18 char} {\cf17 const}* rawChars, std::size_t size ) {\cf17 noexcept} -> StringRef \{\par
783         {\cf19 return} StringRef( rawChars, size );\par
784     \}\par
785 \} {\cf20 // namespace Catch}\par
786 \par
787 {\cf17 constexpr} {\cf17 auto} {\cf17 operator} {\cf22 ""}_catch_sr( {\cf18 char} {\cf17 const}* rawChars, std::size_t size ) {\cf17 noexcept} -> Catch::StringRef \{\par
788     {\cf19 return} Catch::StringRef( rawChars, size );\par
789 \}\par
790 \par
791 {\cf21 #endif }{\cf20 // CATCH_STRINGREF_HPP_INCLUDED}\par
792 \par
793 \par
794 {\cf21 #ifndef CATCH_RESULT_TYPE_HPP_INCLUDED}\par
795 {\cf21 #define CATCH_RESULT_TYPE_HPP_INCLUDED}\par
796 \par
797 {\cf17 namespace }Catch \{\par
798 \par
799     {\cf20 // ResultWas::OfType enum}\par
800     {\cf17 struct }ResultWas \{ {\cf17 enum} OfType \{\par
801         Unknown = -1,\par
802         Ok = 0,\par
803         Info = 1,\par
804         Warning = 2,\par
805         {\cf20 // TODO: Should explicit skip be considered "not OK" (cf. isOk)? I.e., should it have the failure bit?}\par
806         ExplicitSkip = 4,\par
807 \par
808         FailureBit = 0x10,\par
809 \par
810         ExpressionFailed = FailureBit | 1,\par
811         ExplicitFailure = FailureBit | 2,\par
812 \par
813         Exception = 0x100 | FailureBit,\par
814 \par
815         ThrewException = Exception | 1,\par
816         DidntThrowException = Exception | 2,\par
817 \par
818         FatalErrorCondition = 0x200 | FailureBit\par
819 \par
820     \}; \};\par
821 \par
822     {\cf18 bool} isOk( ResultWas::OfType resultType );\par
823     {\cf18 bool} isJustInfo( {\cf18 int} flags );\par
824 \par
825 \par
826     {\cf20 // ResultDisposition::Flags enum}\par
827     {\cf17 struct }ResultDisposition \{ {\cf17 enum} Flags \{\par
828         Normal = 0x01,\par
829 \par
830         ContinueOnFailure = 0x02,   {\cf20 // Failures fail test, but execution continues}\par
831         FalseTest = 0x04,           {\cf20 // Prefix expression with !}\par
832         SuppressFail = 0x08         {\cf20 // Failures are reported but do not fail the test}\par
833     \}; \};\par
834 \par
835     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );\par
836 \par
837     {\cf18 bool} shouldContinueOnFailure( {\cf18 int} flags );\par
838     {\cf17 inline} {\cf18 bool} isFalseTest( {\cf18 int} flags ) \{ {\cf19 return} ( flags & ResultDisposition::FalseTest ) != 0; \}\par
839     {\cf18 bool} shouldSuppressFailure( {\cf18 int} flags );\par
840 \par
841 \} {\cf20 // end namespace Catch}\par
842 \par
843 {\cf21 #endif }{\cf20 // CATCH_RESULT_TYPE_HPP_INCLUDED}\par
844 \par
845 \par
846 {\cf21 #ifndef CATCH_UNIQUE_PTR_HPP_INCLUDED}\par
847 {\cf21 #define CATCH_UNIQUE_PTR_HPP_INCLUDED}\par
848 \par
849 {\cf21 #include <cassert>}\par
850 {\cf21 #include <type_traits>}\par
851 \par
852 \par
853 {\cf17 namespace }Catch \{\par
854 {\cf17 namespace }Detail \{\par
860     {\cf17 template} <{\cf17 typename} T>\par
861     {\cf17 class }unique_ptr \{\par
862         T* m_ptr;\par
863     {\cf17 public}:\par
864         {\cf17 constexpr} unique_ptr(std::nullptr_t = {\cf17 nullptr}):\par
865             m_ptr\{\}\par
866         \{\}\par
867         {\cf17 explicit} {\cf17 constexpr} unique_ptr(T* ptr):\par
868             m_ptr(ptr)\par
869         \{\}\par
870 \par
871         template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>\par
872         unique_ptr(unique_ptr<U>&& from):\par
873             m_ptr(from.release())\par
874         \{\}\par
875 \par
876         template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>\par
877         unique_ptr& operator=(unique_ptr<U>&& from) \{\par
878             reset(from.release());\par
879 \par
880             {\cf19 return} *{\cf17 this};\par
881         \}\par
882 \par
883         unique_ptr(unique_ptr {\cf17 const}&) = {\cf17 delete};\par
884         unique_ptr& operator=(unique_ptr {\cf17 const}&) = {\cf17 delete};\par
885 \par
886         unique_ptr(unique_ptr&& rhs) {\cf17 noexcept}:\par
887             m_ptr(rhs.m_ptr) \{\par
888             rhs.m_ptr = {\cf17 nullptr};\par
889         \}\par
890         unique_ptr& operator=(unique_ptr&& rhs) {\cf17 noexcept} \{\par
891             reset(rhs.release());\par
892 \par
893             {\cf19 return} *{\cf17 this};\par
894         \}\par
895 \par
896         ~unique_ptr() \{\par
897             {\cf17 delete} m_ptr;\par
898         \}\par
899 \par
900         T& operator*() \{\par
901             assert(m_ptr);\par
902             {\cf19 return} *m_ptr;\par
903         \}\par
904         T {\cf17 const}& operator*(){\cf17  const }\{\par
905             assert(m_ptr);\par
906             {\cf19 return} *m_ptr;\par
907         \}\par
908         T* operator->() noexcept \{\par
909             assert(m_ptr);\par
910             {\cf19 return} m_ptr;\par
911         \}\par
912         T {\cf17 const}* operator->() const noexcept \{\par
913             assert(m_ptr);\par
914             {\cf19 return} m_ptr;\par
915         \}\par
916 \par
917         T* get() \{ {\cf19 return} m_ptr; \}\par
918         T {\cf17 const}* get(){\cf17  const }\{ {\cf19 return} m_ptr; \}\par
919 \par
920         {\cf18 void} reset(T* ptr = {\cf17 nullptr}) \{\par
921             {\cf17 delete} m_ptr;\par
922             m_ptr = ptr;\par
923         \}\par
924 \par
925         T* release() \{\par
926             {\cf17 auto} temp = m_ptr;\par
927             m_ptr = {\cf17 nullptr};\par
928             {\cf19 return} temp;\par
929         \}\par
930 \par
931         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
932             {\cf19 return} m_ptr;\par
933         \}\par
934 \par
935         {\cf17 friend} {\cf18 void} swap(unique_ptr& lhs, unique_ptr& rhs) \{\par
936             {\cf17 auto} temp = lhs.m_ptr;\par
937             lhs.m_ptr = rhs.m_ptr;\par
938             rhs.m_ptr = temp;\par
939         \}\par
940     \};\par
941 \par
943     {\cf17 template} <{\cf17 typename} T>\par
944     {\cf17 class }unique_ptr<T[]>;\par
945 \par
946     {\cf17 template} <{\cf17 typename} T, {\cf17 typename}... Args>\par
947     unique_ptr<T> make_unique(Args&&... args) \{\par
948         {\cf19 return} unique_ptr<T>({\cf17 new} T(CATCH_FORWARD(args)...));\par
949     \}\par
950 \par
951 \par
952 \} {\cf20 // end namespace Detail}\par
953 \} {\cf20 // end namespace Catch}\par
954 \par
955 {\cf21 #endif }{\cf20 // CATCH_UNIQUE_PTR_HPP_INCLUDED}\par
956 \par
957 \par
958 {\cf21 #ifndef CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}\par
959 {\cf21 #define CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}\par
960 \par
961 \par
962 \par
963 {\cf20 // Adapted from donated nonius code.}\par
964 \par
965 {\cf21 #ifndef CATCH_CLOCK_HPP_INCLUDED}\par
966 {\cf21 #define CATCH_CLOCK_HPP_INCLUDED}\par
967 \par
968 {\cf21 #include <chrono>}\par
969 \par
970 {\cf17 namespace }Catch \{\par
971     {\cf17 namespace }Benchmark \{\par
972         {\cf17 using }IDuration = std::chrono::nanoseconds;\par
973         {\cf17 using }FDuration = std::chrono::duration<double, std::nano>;\par
974 \par
975         {\cf17 template} <{\cf17 typename} Clock>\par
976         {\cf17 using }TimePoint = {\cf17 typename} Clock::time_point;\par
977 \par
978         {\cf17 using }default_clock = std::chrono::steady_clock;\par
979     \} {\cf20 // namespace Benchmark}\par
980 \} {\cf20 // namespace Catch}\par
981 \par
982 {\cf21 #endif }{\cf20 // CATCH_CLOCK_HPP_INCLUDED}\par
983 \par
984 {\cf17 namespace }Catch \{\par
985 \par
986     {\cf20 // We cannot forward declare the type with default template argument}\par
987     {\cf20 // multiple times, so it is split out into a separate header so that}\par
988     {\cf20 // we can prevent multiple declarations in dependees}\par
989     {\cf17 template} <{\cf17 typename} Duration = Benchmark::FDuration>\par
990     {\cf17 struct }BenchmarkStats;\par
991 \par
992 \} {\cf20 // end namespace Catch}\par
993 \par
994 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}\par
995 \par
996 {\cf17 namespace }Catch \{\par
997 \par
998     {\cf17 class }AssertionResult;\par
999     {\cf17 struct }AssertionInfo;\par
1000     {\cf17 struct }SectionInfo;\par
1001     {\cf17 struct }SectionEndInfo;\par
1002     {\cf17 struct }MessageInfo;\par
1003     {\cf17 struct }MessageBuilder;\par
1004     {\cf17 struct }Counts;\par
1005     {\cf17 struct }AssertionReaction;\par
1006     {\cf17 struct }SourceLineInfo;\par
1007 \par
1008     {\cf17 class }ITransientExpression;\par
1009     {\cf17 class }IGeneratorTracker;\par
1010 \par
1011     {\cf17 struct }BenchmarkInfo;\par
1012 \par
1013     {\cf17 namespace }Generators \{\par
1014         {\cf17 class }GeneratorUntypedBase;\par
1015         {\cf17 using }GeneratorBasePtr = Catch::Detail::unique_ptr<GeneratorUntypedBase>;\par
1016     \}\par
1017 \par
1018 \par
1019     {\cf17 class }IResultCapture \{\par
1020     {\cf17 public}:\par
1021         {\cf17 virtual} ~IResultCapture();\par
1022 \par
1023         {\cf17 virtual} {\cf18 void} notifyAssertionStarted( AssertionInfo {\cf17 const}& info ) = 0;\par
1024         {\cf17 virtual} {\cf18 bool} sectionStarted( StringRef sectionName,\par
1025                                      SourceLineInfo {\cf17 const}& sectionLineInfo,\par
1026                                      Counts& assertions ) = 0;\par
1027         {\cf17 virtual} {\cf18 void} sectionEnded( SectionEndInfo&& endInfo ) = 0;\par
1028         {\cf17 virtual} {\cf18 void} sectionEndedEarly( SectionEndInfo&& endInfo ) = 0;\par
1029 \par
1030         {\cf17 virtual} IGeneratorTracker*\par
1031         acquireGeneratorTracker( StringRef generatorName,\par
1032                                  SourceLineInfo {\cf17 const}& lineInfo ) = 0;\par
1033         {\cf17 virtual} IGeneratorTracker*\par
1034         createGeneratorTracker( StringRef generatorName,\par
1035                                 SourceLineInfo lineInfo,\par
1036                                 Generators::GeneratorBasePtr&& generator ) = 0;\par
1037 \par
1038         {\cf17 virtual} {\cf18 void} benchmarkPreparing( StringRef name ) = 0;\par
1039         {\cf17 virtual} {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) = 0;\par
1040         {\cf17 virtual} {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& stats ) = 0;\par
1041         {\cf17 virtual} {\cf18 void} benchmarkFailed( StringRef error ) = 0;\par
1042 \par
1043         {\cf17 virtual} {\cf18 void} pushScopedMessage( MessageInfo {\cf17 const}& message ) = 0;\par
1044         {\cf17 virtual} {\cf18 void} popScopedMessage( MessageInfo {\cf17 const}& message ) = 0;\par
1045 \par
1046         {\cf17 virtual} {\cf18 void} emplaceUnscopedMessage( MessageBuilder&& builder ) = 0;\par
1047 \par
1048         {\cf17 virtual} {\cf18 void} handleFatalErrorCondition( StringRef message ) = 0;\par
1049 \par
1050         {\cf17 virtual} {\cf18 void} handleExpr\par
1051                 (   AssertionInfo {\cf17 const}& info,\par
1052                     ITransientExpression {\cf17 const}& expr,\par
1053                     AssertionReaction& reaction ) = 0;\par
1054         {\cf17 virtual} {\cf18 void} handleMessage\par
1055                 (   AssertionInfo {\cf17 const}& info,\par
1056                     ResultWas::OfType resultType,\par
1057                     StringRef message,\par
1058                     AssertionReaction& reaction ) = 0;\par
1059         {\cf17 virtual} {\cf18 void} handleUnexpectedExceptionNotThrown\par
1060                 (   AssertionInfo {\cf17 const}& info,\par
1061                     AssertionReaction& reaction ) = 0;\par
1062         {\cf17 virtual} {\cf18 void} handleUnexpectedInflightException\par
1063                 (   AssertionInfo {\cf17 const}& info,\par
1064                     std::string&& message,\par
1065                     AssertionReaction& reaction ) = 0;\par
1066         {\cf17 virtual} {\cf18 void} handleIncomplete\par
1067                 (   AssertionInfo {\cf17 const}& info ) = 0;\par
1068         {\cf17 virtual} {\cf18 void} handleNonExpr\par
1069                 (   AssertionInfo {\cf17 const} &info,\par
1070                     ResultWas::OfType resultType,\par
1071                     AssertionReaction &reaction ) = 0;\par
1072 \par
1073 \par
1074 \par
1075         {\cf17 virtual} {\cf18 bool} lastAssertionPassed() = 0;\par
1076         {\cf17 virtual} {\cf18 void} assertionPassed() = 0;\par
1077 \par
1078         {\cf20 // Deprecated, do not use:}\par
1079         {\cf17 virtual} std::string getCurrentTestName() {\cf17 const} = 0;\par
1080         {\cf17 virtual} {\cf17 const} AssertionResult* getLastResult() {\cf17 const} = 0;\par
1081         {\cf17 virtual} {\cf18 void} exceptionEarlyReported() = 0;\par
1082     \};\par
1083 \par
1084     IResultCapture& getResultCapture();\par
1085 \}\par
1086 \par
1087 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}\par
1088 \par
1089 \par
1090 {\cf21 #ifndef CATCH_INTERFACES_CONFIG_HPP_INCLUDED}\par
1091 {\cf21 #define CATCH_INTERFACES_CONFIG_HPP_INCLUDED}\par
1092 \par
1093 \par
1094 \par
1095 {\cf21 #ifndef CATCH_NONCOPYABLE_HPP_INCLUDED}\par
1096 {\cf21 #define CATCH_NONCOPYABLE_HPP_INCLUDED}\par
1097 \par
1098 {\cf17 namespace }Catch \{\par
1099     {\cf17 namespace }Detail \{\par
1100 \par
1102         {\cf17 class }NonCopyable \{\par
1103             NonCopyable( NonCopyable {\cf17 const}& ) = {\cf17 delete};\par
1104             NonCopyable( NonCopyable&& ) = {\cf17 delete};\par
1105             NonCopyable& operator=( NonCopyable {\cf17 const}& ) = {\cf17 delete};\par
1106             NonCopyable& operator=( NonCopyable&& ) = {\cf17 delete};\par
1107 \par
1108         {\cf17 protected}:\par
1109             NonCopyable() noexcept = default;\par
1110         \};\par
1111 \par
1112     \} {\cf20 // namespace Detail}\par
1113 \} {\cf20 // namespace Catch}\par
1114 \par
1115 {\cf21 #endif }{\cf20 // CATCH_NONCOPYABLE_HPP_INCLUDED}\par
1116 \par
1117 {\cf21 #include <chrono>}\par
1118 {\cf21 #include <iosfwd>}\par
1119 {\cf21 #include <string>}\par
1120 {\cf21 #include <vector>}\par
1121 \par
1122 {\cf17 namespace }Catch \{\par
1123 \par
1124     {\cf17 enum class} Verbosity \{\par
1125         Quiet = 0,\par
1126         Normal,\par
1127         High\par
1128     \};\par
1129 \par
1130     {\cf17 struct }WarnAbout \{ {\cf17 enum} What \{\par
1131         Nothing = 0x00,\par
1133         NoAssertions = 0x01,\par
1135         UnmatchedTestSpec = 0x02,\par
1136     \}; \};\par
1137 \par
1138     {\cf17 enum class} ShowDurations \{\par
1139         DefaultForReporter,\par
1140         Always,\par
1141         Never\par
1142     \};\par
1143     {\cf17 enum class} TestRunOrder \{\par
1144         Declared,\par
1145         LexicographicallySorted,\par
1146         Randomized\par
1147     \};\par
1148     {\cf17 enum class} ColourMode : std::uint8_t \{\par
1150         PlatformDefault,\par
1152         ANSI,\par
1154         Win32,\par
1156         None\par
1157     \};\par
1158     {\cf17 struct }WaitForKeypress \{ {\cf17 enum} When \{\par
1159         Never,\par
1160         BeforeStart = 1,\par
1161         BeforeExit = 2,\par
1162         BeforeStartAndExit = BeforeStart | BeforeExit\par
1163     \}; \};\par
1164 \par
1165     {\cf17 class }TestSpec;\par
1166     {\cf17 class }IStream;\par
1167 \par
1168     {\cf17 class }IConfig : {\cf17 public} Detail::NonCopyable \{\par
1169     {\cf17 public}:\par
1170         {\cf17 virtual} ~IConfig();\par
1171 \par
1172         {\cf17 virtual} {\cf18 bool} allowThrows() {\cf17 const} = 0;\par
1173         {\cf17 virtual} StringRef name() {\cf17 const} = 0;\par
1174         {\cf17 virtual} {\cf18 bool} includeSuccessfulResults() {\cf17 const} = 0;\par
1175         {\cf17 virtual} {\cf18 bool} shouldDebugBreak() {\cf17 const} = 0;\par
1176         {\cf17 virtual} {\cf18 bool} warnAboutMissingAssertions() {\cf17 const} = 0;\par
1177         {\cf17 virtual} {\cf18 bool} warnAboutUnmatchedTestSpecs() {\cf17 const} = 0;\par
1178         {\cf17 virtual} {\cf18 bool} zeroTestsCountAsSuccess() {\cf17 const} = 0;\par
1179         {\cf17 virtual} {\cf18 int} abortAfter() {\cf17 const} = 0;\par
1180         {\cf17 virtual} {\cf18 bool} showInvisibles() {\cf17 const} = 0;\par
1181         {\cf17 virtual} ShowDurations showDurations() {\cf17 const} = 0;\par
1182         {\cf17 virtual} {\cf18 double} minDuration() {\cf17 const} = 0;\par
1183         {\cf17 virtual} TestSpec {\cf17 const}& testSpec() {\cf17 const} = 0;\par
1184         {\cf17 virtual} {\cf18 bool} hasTestFilters() {\cf17 const} = 0;\par
1185         {\cf17 virtual} std::vector<std::string> {\cf17 const}& getTestsOrTags() {\cf17 const} = 0;\par
1186         {\cf17 virtual} TestRunOrder runOrder() {\cf17 const} = 0;\par
1187         {\cf17 virtual} uint32_t rngSeed() {\cf17 const} = 0;\par
1188         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} shardCount() {\cf17 const} = 0;\par
1189         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} shardIndex() {\cf17 const} = 0;\par
1190         {\cf17 virtual} ColourMode defaultColourMode() {\cf17 const} = 0;\par
1191         {\cf17 virtual} std::vector<std::string> {\cf17 const}& getSectionsToRun() {\cf17 const} = 0;\par
1192         {\cf17 virtual} Verbosity verbosity() {\cf17 const} = 0;\par
1193 \par
1194         {\cf17 virtual} {\cf18 bool} skipBenchmarks() {\cf17 const} = 0;\par
1195         {\cf17 virtual} {\cf18 bool} benchmarkNoAnalysis() {\cf17 const} = 0;\par
1196         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} benchmarkSamples() {\cf17 const} = 0;\par
1197         {\cf17 virtual} {\cf18 double} benchmarkConfidenceInterval() {\cf17 const} = 0;\par
1198         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} benchmarkResamples() {\cf17 const} = 0;\par
1199         {\cf17 virtual} std::chrono::milliseconds benchmarkWarmupTime() {\cf17 const} = 0;\par
1200     \};\par
1201 \}\par
1202 \par
1203 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_CONFIG_HPP_INCLUDED}\par
1204 \par
1205 \par
1206 {\cf21 #ifndef CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}\par
1207 {\cf21 #define CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}\par
1208 \par
1209 \par
1210 {\cf21 #include <string>}\par
1211 \par
1212 {\cf17 namespace }Catch \{\par
1213 \par
1214     {\cf17 class }TestCaseHandle;\par
1215     {\cf17 struct }TestCaseInfo;\par
1216     {\cf17 class }ITestCaseRegistry;\par
1217     {\cf17 class }IExceptionTranslatorRegistry;\par
1218     {\cf17 class }IExceptionTranslator;\par
1219     {\cf17 class }ReporterRegistry;\par
1220     {\cf17 class }IReporterFactory;\par
1221     {\cf17 class }ITagAliasRegistry;\par
1222     {\cf17 class }ITestInvoker;\par
1223     {\cf17 class }IMutableEnumValuesRegistry;\par
1224     {\cf17 struct }SourceLineInfo;\par
1225 \par
1226     {\cf17 class }StartupExceptionRegistry;\par
1227     {\cf17 class }EventListenerFactory;\par
1228 \par
1229     {\cf17 using }IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;\par
1230 \par
1231     {\cf17 class }IRegistryHub \{\par
1232     {\cf17 public}:\par
1233         {\cf17 virtual} ~IRegistryHub(); {\cf20 // = default}\par
1234 \par
1235         {\cf17 virtual} ReporterRegistry {\cf17 const}& getReporterRegistry() {\cf17 const} = 0;\par
1236         {\cf17 virtual} ITestCaseRegistry {\cf17 const}& getTestCaseRegistry() {\cf17 const} = 0;\par
1237         {\cf17 virtual} ITagAliasRegistry {\cf17 const}& getTagAliasRegistry() {\cf17 const} = 0;\par
1238         {\cf17 virtual} IExceptionTranslatorRegistry {\cf17 const}& getExceptionTranslatorRegistry() {\cf17 const} = 0;\par
1239 \par
1240 \par
1241         {\cf17 virtual} StartupExceptionRegistry {\cf17 const}& getStartupExceptionRegistry() {\cf17 const} = 0;\par
1242     \};\par
1243 \par
1244     {\cf17 class }IMutableRegistryHub \{\par
1245     {\cf17 public}:\par
1246         {\cf17 virtual} ~IMutableRegistryHub(); {\cf20 // = default}\par
1247         {\cf17 virtual} {\cf18 void} registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr factory ) = 0;\par
1248         {\cf17 virtual} {\cf18 void} registerListener( Detail::unique_ptr<EventListenerFactory> factory ) = 0;\par
1249         {\cf17 virtual} {\cf18 void} registerTest(Detail::unique_ptr<TestCaseInfo>&& testInfo, Detail::unique_ptr<ITestInvoker>&& invoker) = 0;\par
1250         {\cf17 virtual} {\cf18 void} registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator ) = 0;\par
1251         {\cf17 virtual} {\cf18 void} registerTagAlias( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ) = 0;\par
1252         {\cf17 virtual} {\cf18 void} registerStartupException() noexcept = 0;\par
1253         virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;\par
1254     \};\par
1255 \par
1256     IRegistryHub const& getRegistryHub();\par
1257     IMutableRegistryHub& getMutableRegistryHub();\par
1258     {\cf18 void} cleanUp();\par
1259     std::{\cf18 string} translateActiveException();\par
1260 \par
1261 \}\par
1262 \par
1263 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}\par
1264 \par
1265 \par
1266 {\cf21 #ifndef CATCH_BENCHMARK_STATS_HPP_INCLUDED}\par
1267 {\cf21 #define CATCH_BENCHMARK_STATS_HPP_INCLUDED}\par
1268 \par
1269 \par
1270 \par
1271 {\cf20 // Adapted from donated nonius code.}\par
1272 \par
1273 {\cf21 #ifndef CATCH_ESTIMATE_HPP_INCLUDED}\par
1274 {\cf21 #define CATCH_ESTIMATE_HPP_INCLUDED}\par
1275 \par
1276 {\cf17 namespace }Catch \{\par
1277     {\cf17 namespace }Benchmark \{\par
1278         {\cf17 template} <{\cf17 typename} Type>\par
1279         {\cf17 struct }Estimate \{\par
1280             Type point;\par
1281             Type lower_bound;\par
1282             Type upper_bound;\par
1283             {\cf18 double} confidence_interval;\par
1284         \};\par
1285     \} {\cf20 // namespace Benchmark}\par
1286 \} {\cf20 // namespace Catch}\par
1287 \par
1288 {\cf21 #endif }{\cf20 // CATCH_ESTIMATE_HPP_INCLUDED}\par
1289 \par
1290 \par
1291 {\cf20 // Adapted from donated nonius code.}\par
1292 \par
1293 {\cf21 #ifndef CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED}\par
1294 {\cf21 #define CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED}\par
1295 \par
1296 {\cf17 namespace }Catch \{\par
1297     {\cf17 namespace }Benchmark \{\par
1298         {\cf17 struct }OutlierClassification \{\par
1299             {\cf18 int} samples_seen = 0;\par
1300             {\cf18 int} low_severe = 0;     {\cf20 // more than 3 times IQR below Q1}\par
1301             {\cf18 int} low_mild = 0;       {\cf20 // 1.5 to 3 times IQR below Q1}\par
1302             {\cf18 int} high_mild = 0;      {\cf20 // 1.5 to 3 times IQR above Q3}\par
1303             {\cf18 int} high_severe = 0;    {\cf20 // more than 3 times IQR above Q3}\par
1304 \par
1305             {\cf18 int} total(){\cf17  const }\{\par
1306                 {\cf19 return} low_severe + low_mild + high_mild + high_severe;\par
1307             \}\par
1308         \};\par
1309     \} {\cf20 // namespace Benchmark}\par
1310 \} {\cf20 // namespace Catch}\par
1311 \par
1312 {\cf21 #endif }{\cf20 // CATCH_OUTLIERS_CLASSIFICATION_HPP_INCLUDED}\par
1313 {\cf20 // The fwd decl & default specialization needs to be seen by VS2017 before}\par
1314 {\cf20 // BenchmarkStats itself, or VS2017 will report compilation error.}\par
1315 \par
1316 {\cf21 #include <string>}\par
1317 {\cf21 #include <vector>}\par
1318 \par
1319 {\cf17 namespace }Catch \{\par
1320 \par
1321     {\cf17 struct }BenchmarkInfo \{\par
1322         std::string name;\par
1323         {\cf18 double} estimatedDuration;\par
1324         {\cf18 int} iterations;\par
1325         {\cf18 unsigned} {\cf18 int} samples;\par
1326         {\cf18 unsigned} {\cf18 int} resamples;\par
1327         {\cf18 double} clockResolution;\par
1328         {\cf18 double} clockCost;\par
1329     \};\par
1330 \par
1331     {\cf20 // We need to keep template parameter for backwards compatibility,}\par
1332     {\cf20 // but we also do not want to use the template paraneter.}\par
1333     {\cf17 template} <{\cf17 class} Dummy>\par
1334     {\cf17 struct }BenchmarkStats \{\par
1335         BenchmarkInfo info;\par
1336 \par
1337         std::vector<Benchmark::FDuration> samples;\par
1338         Benchmark::Estimate<Benchmark::FDuration> mean;\par
1339         Benchmark::Estimate<Benchmark::FDuration> standardDeviation;\par
1340         Benchmark::OutlierClassification outliers;\par
1341         {\cf18 double} outlierVariance;\par
1342     \};\par
1343 \par
1344 \par
1345 \} {\cf20 // end namespace Catch}\par
1346 \par
1347 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_STATS_HPP_INCLUDED}\par
1348 \par
1349 \par
1350 {\cf20 // Adapted from donated nonius code.}\par
1351 \par
1352 {\cf21 #ifndef CATCH_ENVIRONMENT_HPP_INCLUDED}\par
1353 {\cf21 #define CATCH_ENVIRONMENT_HPP_INCLUDED}\par
1354 \par
1355 \par
1356 {\cf17 namespace }Catch \{\par
1357     {\cf17 namespace }Benchmark \{\par
1358         {\cf17 struct }EnvironmentEstimate \{\par
1359             FDuration mean;\par
1360             OutlierClassification outliers;\par
1361         \};\par
1362         {\cf17 struct }Environment \{\par
1363             EnvironmentEstimate clock_resolution;\par
1364             EnvironmentEstimate clock_cost;\par
1365         \};\par
1366     \} {\cf20 // namespace Benchmark}\par
1367 \} {\cf20 // namespace Catch}\par
1368 \par
1369 {\cf21 #endif }{\cf20 // CATCH_ENVIRONMENT_HPP_INCLUDED}\par
1370 \par
1371 \par
1372 {\cf20 // Adapted from donated nonius code.}\par
1373 \par
1374 {\cf21 #ifndef CATCH_EXECUTION_PLAN_HPP_INCLUDED}\par
1375 {\cf21 #define CATCH_EXECUTION_PLAN_HPP_INCLUDED}\par
1376 \par
1377 \par
1378 \par
1379 {\cf20 // Adapted from donated nonius code.}\par
1380 \par
1381 {\cf21 #ifndef CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}\par
1382 {\cf21 #define CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}\par
1383 \par
1384 \par
1385 \par
1386 {\cf20 // Adapted from donated nonius code.}\par
1387 \par
1388 {\cf21 #ifndef CATCH_CHRONOMETER_HPP_INCLUDED}\par
1389 {\cf21 #define CATCH_CHRONOMETER_HPP_INCLUDED}\par
1390 \par
1391 \par
1392 \par
1393 {\cf20 // Adapted from donated nonius code.}\par
1394 \par
1395 {\cf21 #ifndef CATCH_OPTIMIZER_HPP_INCLUDED}\par
1396 {\cf21 #define CATCH_OPTIMIZER_HPP_INCLUDED}\par
1397 \par
1398 {\cf21 #if defined(_MSC_VER) || defined(__IAR_SYSTEMS_ICC__)}\par
1399 {\cf21 #   include <atomic>} {\cf20 // atomic_thread_fence}\par
1400 {\cf21 #endif}\par
1401 \par
1402 \par
1403 {\cf21 #include <type_traits>}\par
1404 \par
1405 {\cf17 namespace }Catch \{\par
1406     {\cf17 namespace }Benchmark \{\par
1407 {\cf21 #if defined(__GNUC__) || defined(__clang__)}\par
1408         {\cf17 template} <{\cf17 typename} T>\par
1409         {\cf17 inline} {\cf18 void} keep_memory(T* p) \{\par
1410             {\cf17 asm} {\cf17 volatile}({\cf22 ""} : : {\cf22 "g"}(p) : {\cf22 "memory"});\par
1411         \}\par
1412         {\cf17 inline} {\cf18 void} keep_memory() \{\par
1413             {\cf17 asm} {\cf17 volatile}({\cf22 ""} : : : {\cf22 "memory"});\par
1414         \}\par
1415 \par
1416         {\cf17 namespace }Detail \{\par
1417             {\cf17 inline} {\cf18 void} optimizer_barrier() \{ keep_memory(); \}\par
1418         \} {\cf20 // namespace Detail}\par
1419 {\cf21 #elif defined(_MSC_VER) || defined(__IAR_SYSTEMS_ICC__)}\par
1420 \par
1421 {\cf21 #if defined(_MSVC_VER)}\par
1422 {\cf21 #pragma optimize("", off)}\par
1423 {\cf21 #elif defined(__IAR_SYSTEMS_ICC__)}\par
1424 {\cf20 // For IAR the pragma only affects the following function}\par
1425 {\cf21 #pragma optimize=disable}\par
1426 {\cf21 #endif}\par
1427         {\cf17 template} <{\cf17 typename} T>\par
1428         {\cf17 inline} {\cf18 void} keep_memory(T* p) \{\par
1429             {\cf20 // thanks @milleniumbug}\par
1430             *{\cf17 reinterpret_cast<}{\cf18 char} volatile*{\cf17 >}(p) = *{\cf17 reinterpret_cast<}{\cf18 char} {\cf17 const }volatile*{\cf17 >}(p);\par
1431         \}\par
1432         {\cf20 // TODO equivalent keep_memory()}\par
1433 {\cf21 #if defined(_MSVC_VER)}\par
1434 {\cf21 #pragma optimize("", on)}\par
1435 {\cf21 #endif}\par
1436 \par
1437         {\cf17 namespace }Detail \{\par
1438             {\cf17 inline} {\cf18 void} optimizer_barrier() \{\par
1439                 std::atomic_thread_fence(std::memory_order_seq_cst);\par
1440             \}\par
1441         \} {\cf20 // namespace Detail}\par
1442 \par
1443 {\cf21 #endif}\par
1444 \par
1445         {\cf17 template} <{\cf17 typename} T>\par
1446         {\cf17 inline} {\cf18 void} deoptimize_value(T&& x) \{\par
1447             keep_memory(&x);\par
1448         \}\par
1449 \par
1450         {\cf17 template} <{\cf17 typename} Fn, {\cf17 typename}... Args>\par
1451         {\cf17 inline} {\cf17 auto} invoke_deoptimized(Fn&& fn, Args&&... args) -> std::enable_if_t<!std::is_same<void, {\cf17 decltype}(fn(args...))>::value> \{\par
1452             deoptimize_value(CATCH_FORWARD(fn) (CATCH_FORWARD(args)...));\par
1453         \}\par
1454 \par
1455         {\cf17 template} <{\cf17 typename} Fn, {\cf17 typename}... Args>\par
1456         {\cf17 inline} {\cf17 auto} invoke_deoptimized(Fn&& fn, Args&&... args) -> std::enable_if_t<std::is_same<void, {\cf17 decltype}(fn(args...))>::value> \{\par
1457             CATCH_FORWARD((fn)) (CATCH_FORWARD(args)...);\par
1458         \}\par
1459     \} {\cf20 // namespace Benchmark}\par
1460 \} {\cf20 // namespace Catch}\par
1461 \par
1462 {\cf21 #endif }{\cf20 // CATCH_OPTIMIZER_HPP_INCLUDED}\par
1463 \par
1464 \par
1465 {\cf21 #ifndef CATCH_META_HPP_INCLUDED}\par
1466 {\cf21 #define CATCH_META_HPP_INCLUDED}\par
1467 \par
1468 {\cf21 #include <type_traits>}\par
1469 \par
1470 {\cf17 namespace }Catch \{\par
1471     {\cf17 template} <{\cf17 typename}>\par
1472     {\cf17 struct }true_given : std::true_type \{\};\par
1473 \par
1474     {\cf17 struct }is_callable_tester \{\par
1475         {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1476         {\cf17 static} true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> test({\cf18 int});\par
1477         {\cf17 template} <{\cf17 typename}...>\par
1478         {\cf17 static} std::false_type test(...);\par
1479     \};\par
1480 \par
1481     {\cf17 template} <{\cf17 typename} T>\par
1482     {\cf17 struct }is_callable;\par
1483 \par
1484     {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1485     {\cf17 struct }is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) \{\};\par
1486 \par
1487 \par
1488 {\cf21 #if defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703}\par
1489     {\cf20 // std::result_of is deprecated in C++17 and removed in C++20. Hence, it is}\par
1490     {\cf20 // replaced with std::invoke_result here.}\par
1491     {\cf17 template} <{\cf17 typename} Func, {\cf17 typename}... U>\par
1492     {\cf17 using }FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U...>>>;\par
1493 {\cf21 #else}\par
1494     {\cf17 template} <{\cf17 typename} Func, {\cf17 typename}... U>\par
1495     {\cf17 using }FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::result_of_t<Func(U...)>>>;\par
1496 {\cf21 #endif}\par
1497 \par
1498 \} {\cf20 // namespace Catch}\par
1499 \par
1500 {\cf17 namespace }mpl_\{\par
1501     {\cf17 struct }na;\par
1502 \}\par
1503 \par
1504 {\cf21 #endif }{\cf20 // CATCH_META_HPP_INCLUDED}\par
1505 \par
1506 {\cf17 namespace }Catch \{\par
1507     {\cf17 namespace }Benchmark \{\par
1508         {\cf17 namespace }Detail \{\par
1509             {\cf17 struct }ChronometerConcept \{\par
1510                 {\cf17 virtual} {\cf18 void} start() = 0;\par
1511                 {\cf17 virtual} {\cf18 void} finish() = 0;\par
1512                 {\cf17 virtual} ~ChronometerConcept(); {\cf20 // = default;}\par
1513 \par
1514                 ChronometerConcept() = {\cf19 default};\par
1515                 ChronometerConcept(ChronometerConcept {\cf17 const}&) = {\cf19 default};\par
1516                 ChronometerConcept& operator=(ChronometerConcept {\cf17 const}&) = {\cf19 default};\par
1517             \};\par
1518             {\cf17 template} <{\cf17 typename} Clock>\par
1519             {\cf17 struct }ChronometerModel final : {\cf17 public} ChronometerConcept \{\par
1520                 {\cf18 void} start(){\cf17  override }\{ started = Clock::now(); \}\par
1521                 {\cf18 void} finish(){\cf17  override }\{ finished = Clock::now(); \}\par
1522 \par
1523                 IDuration elapsed(){\cf17  const }\{\par
1524                     {\cf19 return} std::chrono::duration_cast<std::chrono::nanoseconds>(\par
1525                         finished - started );\par
1526                 \}\par
1527 \par
1528                 TimePoint<Clock> started;\par
1529                 TimePoint<Clock> finished;\par
1530             \};\par
1531         \} {\cf20 // namespace Detail}\par
1532 \par
1533         {\cf17 struct }Chronometer \{\par
1534         {\cf17 public}:\par
1535             {\cf17 template} <{\cf17 typename} Fun>\par
1536             {\cf18 void} measure(Fun&& fun) \{ measure(CATCH_FORWARD(fun), is_callable<Fun({\cf18 int})>()); \}\par
1537 \par
1538             {\cf18 int} runs(){\cf17  const }\{ {\cf19 return} repeats; \}\par
1539 \par
1540             Chronometer(Detail::ChronometerConcept& meter, {\cf18 int} repeats_)\par
1541                 : impl(&meter)\par
1542                 , repeats(repeats_) \{\}\par
1543 \par
1544         {\cf17 private}:\par
1545             {\cf17 template} <{\cf17 typename} Fun>\par
1546             {\cf18 void} measure(Fun&& fun, std::false_type) \{\par
1547                 measure([&fun]({\cf18 int}) \{ {\cf19 return} fun(); \}, std::true_type());\par
1548             \}\par
1549 \par
1550             {\cf17 template} <{\cf17 typename} Fun>\par
1551             {\cf18 void} measure(Fun&& fun, std::true_type) \{\par
1552                 Detail::optimizer_barrier();\par
1553                 impl->start();\par
1554                 {\cf19 for} ({\cf18 int} i = 0; i < repeats; ++i) invoke_deoptimized(fun, i);\par
1555                 impl->finish();\par
1556                 Detail::optimizer_barrier();\par
1557             \}\par
1558 \par
1559             Detail::ChronometerConcept* impl;\par
1560             {\cf18 int} repeats;\par
1561         \};\par
1562     \} {\cf20 // namespace Benchmark}\par
1563 \} {\cf20 // namespace Catch}\par
1564 \par
1565 {\cf21 #endif }{\cf20 // CATCH_CHRONOMETER_HPP_INCLUDED}\par
1566 \par
1567 {\cf21 #include <type_traits>}\par
1568 \par
1569 {\cf17 namespace }Catch \{\par
1570     {\cf17 namespace }Benchmark \{\par
1571         {\cf17 namespace }Detail \{\par
1572             {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
1573             {\cf17 struct }is_related\par
1574                 : std::is_same<std::decay_t<T>, std::decay_t<U>> \{\};\par
1575 \par
1583             {\cf17 struct }BenchmarkFunction \{\par
1584             {\cf17 private}:\par
1585                 {\cf17 struct }callable \{\par
1586                     {\cf17 virtual} {\cf18 void} call(Chronometer meter) {\cf17 const} = 0;\par
1587                     {\cf17 virtual} Catch::Detail::unique_ptr<callable> clone() {\cf17 const} = 0;\par
1588                     {\cf17 virtual} ~callable(); {\cf20 // = default;}\par
1589 \par
1590                     callable() = {\cf19 default};\par
1591                     callable(callable {\cf17 const}&) = {\cf19 default};\par
1592                     callable& operator=(callable {\cf17 const}&) = {\cf19 default};\par
1593                 \};\par
1594                 {\cf17 template} <{\cf17 typename} Fun>\par
1595                 {\cf17 struct }model : {\cf17 public} callable \{\par
1596                     model(Fun&& fun_) : fun(CATCH_MOVE(fun_)) \{\}\par
1597                     model(Fun {\cf17 const}& fun_) : fun(fun_) \{\}\par
1598 \par
1599                     Catch::Detail::unique_ptr<callable> clone(){\cf17  const override }\{\par
1600                         {\cf19 return} Catch::Detail::make_unique<model<Fun>>( *this );\par
1601                     \}\par
1602 \par
1603                     {\cf18 void} call(Chronometer meter){\cf17  const override }\{\par
1604                         call(meter, is_callable<Fun(Chronometer)>());\par
1605                     \}\par
1606                     {\cf18 void} call(Chronometer meter, std::true_type){\cf17  const }\{\par
1607                         fun(meter);\par
1608                     \}\par
1609                     {\cf18 void} call(Chronometer meter, std::false_type){\cf17  const }\{\par
1610                         meter.measure(fun);\par
1611                     \}\par
1612 \par
1613                     Fun fun;\par
1614                 \};\par
1615 \par
1616                 {\cf17 struct }do_nothing \{ {\cf18 void} operator()(){\cf17  const }\{\} \};\par
1617 \par
1618                 {\cf17 template} <{\cf17 typename} T>\par
1619                 BenchmarkFunction(model<T>* c) : f(c) \{\}\par
1620 \par
1621             {\cf17 public}:\par
1622                 BenchmarkFunction()\par
1623                     : f(new model<do_nothing>\{ \{\} \}) \{\}\par
1624 \par
1625                 {\cf17 template} <{\cf17 typename} Fun,\par
1626                     std::enable_if_t<!is_related<Fun, BenchmarkFunction>::value, {\cf18 int}> = 0>\par
1627                     BenchmarkFunction(Fun&& fun)\par
1628                     : f(new model<std::decay_t<Fun>>(CATCH_FORWARD(fun))) \{\}\par
1629 \par
1630                 BenchmarkFunction( BenchmarkFunction&& that ) {\cf17 noexcept}:\par
1631                     f( CATCH_MOVE( that.f ) ) \{\}\par
1632 \par
1633                 BenchmarkFunction(BenchmarkFunction {\cf17 const}& that)\par
1634                     : f(that.f->clone()) \{\}\par
1635 \par
1636                 BenchmarkFunction&\par
1637                 operator=( BenchmarkFunction&& that ) {\cf17 noexcept} \{\par
1638                     f = CATCH_MOVE( that.f );\par
1639                     {\cf19 return} *{\cf17 this};\par
1640                 \}\par
1641 \par
1642                 BenchmarkFunction& operator=(BenchmarkFunction {\cf17 const}& that) \{\par
1643                     f = that.f->clone();\par
1644                     {\cf19 return} *{\cf17 this};\par
1645                 \}\par
1646 \par
1647                 {\cf18 void} operator()(Chronometer meter){\cf17  const }\{ f->call(meter); \}\par
1648 \par
1649             {\cf17 private}:\par
1650                 Catch::Detail::unique_ptr<callable> f;\par
1651             \};\par
1652         \} {\cf20 // namespace Detail}\par
1653     \} {\cf20 // namespace Benchmark}\par
1654 \} {\cf20 // namespace Catch}\par
1655 \par
1656 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}\par
1657 \par
1658 \par
1659 {\cf20 // Adapted from donated nonius code.}\par
1660 \par
1661 {\cf21 #ifndef CATCH_REPEAT_HPP_INCLUDED}\par
1662 {\cf21 #define CATCH_REPEAT_HPP_INCLUDED}\par
1663 \par
1664 {\cf21 #include <type_traits>}\par
1665 \par
1666 {\cf17 namespace }Catch \{\par
1667     {\cf17 namespace }Benchmark \{\par
1668         {\cf17 namespace }Detail \{\par
1669             {\cf17 template} <{\cf17 typename} Fun>\par
1670             {\cf17 struct }repeater \{\par
1671                 {\cf18 void} operator()({\cf18 int} k){\cf17  const }\{\par
1672                     {\cf19 for} ({\cf18 int} i = 0; i < k; ++i) \{\par
1673                         fun();\par
1674                     \}\par
1675                 \}\par
1676                 Fun fun;\par
1677             \};\par
1678             {\cf17 template} <{\cf17 typename} Fun>\par
1679             repeater<std::decay_t<Fun>> repeat(Fun&& fun) \{\par
1680                 {\cf19 return} \{ CATCH_FORWARD(fun) \};\par
1681             \}\par
1682         \} {\cf20 // namespace Detail}\par
1683     \} {\cf20 // namespace Benchmark}\par
1684 \} {\cf20 // namespace Catch}\par
1685 \par
1686 {\cf21 #endif }{\cf20 // CATCH_REPEAT_HPP_INCLUDED}\par
1687 \par
1688 \par
1689 {\cf20 // Adapted from donated nonius code.}\par
1690 \par
1691 {\cf21 #ifndef CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}\par
1692 {\cf21 #define CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}\par
1693 \par
1694 \par
1695 \par
1696 {\cf20 // Adapted from donated nonius code.}\par
1697 \par
1698 {\cf21 #ifndef CATCH_MEASURE_HPP_INCLUDED}\par
1699 {\cf21 #define CATCH_MEASURE_HPP_INCLUDED}\par
1700 \par
1701 \par
1702 \par
1703 {\cf20 // Adapted from donated nonius code.}\par
1704 \par
1705 {\cf21 #ifndef CATCH_COMPLETE_INVOKE_HPP_INCLUDED}\par
1706 {\cf21 #define CATCH_COMPLETE_INVOKE_HPP_INCLUDED}\par
1707 \par
1708 \par
1709 {\cf17 namespace }Catch \{\par
1710     {\cf17 namespace }Benchmark \{\par
1711         {\cf17 namespace }Detail \{\par
1712             {\cf17 template} <{\cf17 typename} T>\par
1713             {\cf17 struct }CompleteType \{ {\cf17 using }type = T; \};\par
1714             {\cf17 template} <>\par
1715             {\cf17 struct }CompleteType<void> \{ {\cf17 struct }type \{\}; \};\par
1716 \par
1717             {\cf17 template} <{\cf17 typename} T>\par
1718             {\cf17 using }CompleteType_t = {\cf17 typename} CompleteType<T>::type;\par
1719 \par
1720             {\cf17 template} <{\cf17 typename} Result>\par
1721             {\cf17 struct }CompleteInvoker \{\par
1722                 {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1723                 {\cf17 static} Result invoke(Fun&& fun, Args&&... args) \{\par
1724                     {\cf19 return} CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);\par
1725                 \}\par
1726             \};\par
1727             {\cf17 template} <>\par
1728             {\cf17 struct }CompleteInvoker<void> \{\par
1729                 {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1730                 {\cf17 static} CompleteType_t<void> invoke(Fun&& fun, Args&&... args) \{\par
1731                     CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);\par
1732                     {\cf19 return} \{\};\par
1733                 \}\par
1734             \};\par
1735 \par
1736             {\cf20 // invoke and not return void :(}\par
1737             {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1738             CompleteType_t<FunctionReturnType<Fun, Args...>> complete_invoke(Fun&& fun, Args&&... args) \{\par
1739                 {\cf19 return} CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(CATCH_FORWARD(fun), CATCH_FORWARD(args)...);\par
1740             \}\par
1741 \par
1742         \} {\cf20 // namespace Detail}\par
1743 \par
1744         {\cf17 template} <{\cf17 typename} Fun>\par
1745         Detail::CompleteType_t<FunctionReturnType<Fun>> user_code(Fun&& fun) \{\par
1746             {\cf19 return} Detail::complete_invoke(CATCH_FORWARD(fun));\par
1747         \}\par
1748     \} {\cf20 // namespace Benchmark}\par
1749 \} {\cf20 // namespace Catch}\par
1750 \par
1751 {\cf21 #endif }{\cf20 // CATCH_COMPLETE_INVOKE_HPP_INCLUDED}\par
1752 \par
1753 \par
1754 {\cf20 // Adapted from donated nonius code.}\par
1755 \par
1756 {\cf21 #ifndef CATCH_TIMING_HPP_INCLUDED}\par
1757 {\cf21 #define CATCH_TIMING_HPP_INCLUDED}\par
1758 \par
1759 \par
1760 {\cf21 #include <type_traits>}\par
1761 \par
1762 {\cf17 namespace }Catch \{\par
1763     {\cf17 namespace }Benchmark \{\par
1764         {\cf17 template} <{\cf17 typename} Result>\par
1765         {\cf17 struct }Timing \{\par
1766             IDuration elapsed;\par
1767             Result result;\par
1768             {\cf18 int} iterations;\par
1769         \};\par
1770         {\cf17 template} <{\cf17 typename} Func, {\cf17 typename}... Args>\par
1771         {\cf17 using }TimingOf = Timing<Detail::CompleteType_t<FunctionReturnType<Func, Args...>>>;\par
1772     \} {\cf20 // namespace Benchmark}\par
1773 \} {\cf20 // namespace Catch}\par
1774 \par
1775 {\cf21 #endif }{\cf20 // CATCH_TIMING_HPP_INCLUDED}\par
1776 \par
1777 {\cf17 namespace }Catch \{\par
1778     {\cf17 namespace }Benchmark \{\par
1779         {\cf17 namespace }Detail \{\par
1780             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun, {\cf17 typename}... Args>\par
1781             TimingOf<Fun, Args...> measure(Fun&& fun, Args&&... args) \{\par
1782                 {\cf17 auto} start = Clock::now();\par
1783                 {\cf17 auto}&& r = Detail::complete_invoke(fun, CATCH_FORWARD(args)...);\par
1784                 {\cf17 auto} end = Clock::now();\par
1785                 {\cf17 auto} delta = end - start;\par
1786                 {\cf19 return} \{ delta, CATCH_FORWARD(r), 1 \};\par
1787             \}\par
1788         \} {\cf20 // namespace Detail}\par
1789     \} {\cf20 // namespace Benchmark}\par
1790 \} {\cf20 // namespace Catch}\par
1791 \par
1792 {\cf21 #endif }{\cf20 // CATCH_MEASURE_HPP_INCLUDED}\par
1793 \par
1794 {\cf21 #include <type_traits>}\par
1795 \par
1796 {\cf17 namespace }Catch \{\par
1797     {\cf17 namespace }Benchmark \{\par
1798         {\cf17 namespace }Detail \{\par
1799             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1800             TimingOf<Fun, int> measure_one(Fun&& fun, {\cf18 int} iters, std::false_type) \{\par
1801                 {\cf19 return} Detail::measure<Clock>(fun, iters);\par
1802             \}\par
1803             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1804             TimingOf<Fun, Chronometer> measure_one(Fun&& fun, {\cf18 int} iters, std::true_type) \{\par
1805                 Detail::ChronometerModel<Clock> meter;\par
1806                 {\cf17 auto}&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));\par
1807 \par
1808                 {\cf19 return} \{ meter.elapsed(), CATCH_MOVE(result), iters \};\par
1809             \}\par
1810 \par
1811             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1812             {\cf17 using }run_for_at_least_argument_t = std::conditional_t<is_callable<Fun(Chronometer)>::value, Chronometer, {\cf18 int}>;\par
1813 \par
1814 \par
1815             [[noreturn]]\par
1816             {\cf18 void} throw_optimized_away_error();\par
1817 \par
1818             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1819             TimingOf<Fun, run_for_at_least_argument_t<Clock, Fun>>\par
1820                 run_for_at_least(IDuration how_long,\par
1821                                  {\cf17 const} {\cf18 int} initial_iterations,\par
1822                                  Fun&& fun) \{\par
1823                 {\cf17 auto} iters = initial_iterations;\par
1824                 {\cf19 while} (iters < (1 << 30)) \{\par
1825                     {\cf17 auto}&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());\par
1826 \par
1827                     {\cf19 if} (Timing.elapsed >= how_long) \{\par
1828                         {\cf19 return} \{ Timing.elapsed, CATCH_MOVE(Timing.result), iters \};\par
1829                     \}\par
1830                     iters *= 2;\par
1831                 \}\par
1832                 throw_optimized_away_error();\par
1833             \}\par
1834         \} {\cf20 // namespace Detail}\par
1835     \} {\cf20 // namespace Benchmark}\par
1836 \} {\cf20 // namespace Catch}\par
1837 \par
1838 {\cf21 #endif }{\cf20 // CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}\par
1839 \par
1840 {\cf21 #include <vector>}\par
1841 \par
1842 {\cf17 namespace }Catch \{\par
1843     {\cf17 namespace }Benchmark \{\par
1844         {\cf17 struct }ExecutionPlan \{\par
1845             {\cf18 int} iterations_per_sample;\par
1846             FDuration estimated_duration;\par
1847             Detail::BenchmarkFunction benchmark;\par
1848             FDuration warmup_time;\par
1849             {\cf18 int} warmup_iterations;\par
1850 \par
1851             {\cf17 template} <{\cf17 typename} Clock>\par
1852             std::vector<FDuration> run({\cf17 const} IConfig &cfg, Environment env){\cf17  const }\{\par
1853                 {\cf20 // warmup a bit}\par
1854                 Detail::run_for_at_least<Clock>(\par
1855                     std::chrono::duration_cast<IDuration>( warmup_time ),\par
1856                     warmup_iterations,\par
1857                     Detail::repeat( []() \{ {\cf19 return} Clock::now(); \} )\par
1858                 );\par
1859 \par
1860                 std::vector<FDuration> times;\par
1861                 {\cf17 const} {\cf17 auto} num_samples = cfg.benchmarkSamples();\par
1862                 times.reserve( num_samples );\par
1863                 {\cf19 for} ( {\cf18 size_t} i = 0; i < num_samples; ++i ) \{\par
1864                     Detail::ChronometerModel<Clock> model;\par
1865                     this->benchmark( Chronometer( model, iterations_per_sample ) );\par
1866                     {\cf17 auto} sample_time = model.elapsed() - env.clock_cost.mean;\par
1867                     {\cf19 if} ( sample_time < FDuration::zero() ) \{\par
1868                         sample_time = FDuration::zero();\par
1869                     \}\par
1870                     times.push_back(sample_time / iterations_per_sample);\par
1871                 \}\par
1872                 {\cf19 return} times;\par
1873             \}\par
1874         \};\par
1875     \} {\cf20 // namespace Benchmark}\par
1876 \} {\cf20 // namespace Catch}\par
1877 \par
1878 {\cf21 #endif }{\cf20 // CATCH_EXECUTION_PLAN_HPP_INCLUDED}\par
1879 \par
1880 \par
1881 {\cf20 // Adapted from donated nonius code.}\par
1882 \par
1883 {\cf21 #ifndef CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}\par
1884 {\cf21 #define CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}\par
1885 \par
1886 \par
1887 \par
1888 {\cf20 // Adapted from donated nonius code.}\par
1889 \par
1890 {\cf21 #ifndef CATCH_STATS_HPP_INCLUDED}\par
1891 {\cf21 #define CATCH_STATS_HPP_INCLUDED}\par
1892 \par
1893 \par
1894 {\cf21 #include <vector>}\par
1895 \par
1896 {\cf17 namespace }Catch \{\par
1897     {\cf17 namespace }Benchmark \{\par
1898         {\cf17 namespace }Detail \{\par
1899             {\cf17 using }sample = std::vector<double>;\par
1900 \par
1901             {\cf18 double} weighted_average_quantile( {\cf18 int} k,\par
1902                                               {\cf18 int} q,\par
1903                                               {\cf18 double}* first,\par
1904                                               {\cf18 double}* last );\par
1905 \par
1906             OutlierClassification\par
1907             classify_outliers( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last );\par
1908 \par
1909             {\cf18 double} mean( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last );\par
1910 \par
1911             {\cf18 double} normal_cdf( {\cf18 double} x );\par
1912 \par
1913             {\cf18 double} erfc_inv({\cf18 double} x);\par
1914 \par
1915             {\cf18 double} normal_quantile({\cf18 double} p);\par
1916 \par
1917             Estimate<double>\par
1918             bootstrap( {\cf18 double} confidence_level,\par
1919                        {\cf18 double}* first,\par
1920                        {\cf18 double}* last,\par
1921                        sample {\cf17 const}& resample,\par
1922                        {\cf18 double} ( *estimator )( {\cf18 double} {\cf17 const}*, {\cf18 double} {\cf17 const}* ) );\par
1923 \par
1924             {\cf17 struct }bootstrap_analysis \{\par
1925                 Estimate<double> mean;\par
1926                 Estimate<double> standard_deviation;\par
1927                 {\cf18 double} outlier_variance;\par
1928             \};\par
1929 \par
1930             bootstrap_analysis analyse_samples({\cf18 double} confidence_level,\par
1931                                                {\cf18 unsigned} {\cf18 int} n_resamples,\par
1932                                                {\cf18 double}* first,\par
1933                                                {\cf18 double}* last);\par
1934         \} {\cf20 // namespace Detail}\par
1935     \} {\cf20 // namespace Benchmark}\par
1936 \} {\cf20 // namespace Catch}\par
1937 \par
1938 {\cf21 #endif }{\cf20 // CATCH_STATS_HPP_INCLUDED}\par
1939 \par
1940 {\cf21 #include <algorithm>}\par
1941 {\cf21 #include <vector>}\par
1942 {\cf21 #include <cmath>}\par
1943 \par
1944 {\cf17 namespace }Catch \{\par
1945     {\cf17 namespace }Benchmark \{\par
1946         {\cf17 namespace }Detail \{\par
1947             {\cf17 template} <{\cf17 typename} Clock>\par
1948             std::vector<double> resolution({\cf18 int} k) \{\par
1949                 std::vector<TimePoint<Clock>> times;\par
1950                 times.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k + 1));\par
1951                 {\cf19 for} ( {\cf18 int} i = 0; i < k + 1; ++i ) \{\par
1952                     times.push_back( Clock::now() );\par
1953                 \}\par
1954 \par
1955                 std::vector<double> deltas;\par
1956                 deltas.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k));\par
1957                 {\cf19 for} ( {\cf18 size_t} idx = 1; idx < times.size(); ++idx ) \{\par
1958                     deltas.push_back( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(\par
1959                         ( times[idx] - times[idx - 1] ).count() ) );\par
1960                 \}\par
1961 \par
1962                 {\cf19 return} deltas;\par
1963             \}\par
1964 \par
1965             {\cf17 constexpr} {\cf17 auto} warmup_iterations = 10000;\par
1966             {\cf17 constexpr} {\cf17 auto} warmup_time = std::chrono::milliseconds(100);\par
1967             {\cf17 constexpr} {\cf17 auto} minimum_ticks = 1000;\par
1968             {\cf17 constexpr} {\cf17 auto} warmup_seed = 10000;\par
1969             {\cf17 constexpr} {\cf17 auto} clock_resolution_estimation_time = std::chrono::milliseconds(500);\par
1970             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_time_limit = std::chrono::seconds(1);\par
1971             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_tick_limit = 100000;\par
1972             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_time = std::chrono::milliseconds(10);\par
1973             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_iterations = 10000;\par
1974 \par
1975             {\cf17 template} <{\cf17 typename} Clock>\par
1976             {\cf18 int} warmup() \{\par
1977                 {\cf19 return} run_for_at_least<Clock>(warmup_time, warmup_seed, &resolution<Clock>)\par
1978                     .iterations;\par
1979             \}\par
1980             {\cf17 template} <{\cf17 typename} Clock>\par
1981             EnvironmentEstimate estimate_clock_resolution({\cf18 int} iterations) \{\par
1982                 {\cf17 auto} r = run_for_at_least<Clock>(clock_resolution_estimation_time, iterations, &resolution<Clock>)\par
1983                     .result;\par
1984                 {\cf19 return} \{\par
1985                     FDuration(mean(r.data(), r.data() + r.size())),\par
1986                     classify_outliers(r.data(), r.data() + r.size()),\par
1987                 \};\par
1988             \}\par
1989             {\cf17 template} <{\cf17 typename} Clock>\par
1990             EnvironmentEstimate estimate_clock_cost(FDuration resolution) \{\par
1991                 {\cf17 auto} time_limit = (std::min)(\par
1992                     resolution * clock_cost_estimation_tick_limit,\par
1993                     FDuration(clock_cost_estimation_time_limit));\par
1994                 {\cf17 auto} time_clock = []({\cf18 int} k) \{\par
1995                     {\cf19 return} Detail::measure<Clock>([k] \{\par
1996                         {\cf19 for} ({\cf18 int} i = 0; i < k; ++i) \{\par
1997                             {\cf17 volatile} {\cf17 auto} ignored = Clock::now();\par
1998                             (void)ignored;\par
1999                         \}\par
2000                     \}).elapsed;\par
2001                 \};\par
2002                 time_clock(1);\par
2003                 {\cf18 int} iters = clock_cost_estimation_iterations;\par
2004                 {\cf17 auto}&& r = run_for_at_least<Clock>(clock_cost_estimation_time, iters, time_clock);\par
2005                 std::vector<double> times;\par
2006                 {\cf18 int} nsamples = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::ceil(time_limit / r.elapsed));\par
2007                 times.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(nsamples));\par
2008                 {\cf19 for} ( {\cf18 int} s = 0; s < nsamples; ++s ) \{\par
2009                     times.push_back( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(\par
2010                         ( time_clock( r.iterations ) / r.iterations )\par
2011                             .count() ) );\par
2012                 \}\par
2013                 {\cf19 return} \{\par
2014                     FDuration(mean(times.data(), times.data() + times.size())),\par
2015                     classify_outliers(times.data(), times.data() + times.size()),\par
2016                 \};\par
2017             \}\par
2018 \par
2019             {\cf17 template} <{\cf17 typename} Clock>\par
2020             Environment measure_environment() \{\par
2021 {\cf21 #if defined(__clang__)}\par
2022 {\cf21 #    pragma clang diagnostic push}\par
2023 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
2024 {\cf21 #endif}\par
2025                 {\cf17 static} Catch::Detail::unique_ptr<Environment> env;\par
2026 {\cf21 #if defined(__clang__)}\par
2027 {\cf21 #    pragma clang diagnostic pop}\par
2028 {\cf21 #endif}\par
2029                 {\cf19 if} (env) \{\par
2030                     {\cf19 return} *env;\par
2031                 \}\par
2032 \par
2033                 {\cf17 auto} iters = Detail::warmup<Clock>();\par
2034                 {\cf17 auto} resolution = Detail::estimate_clock_resolution<Clock>(iters);\par
2035                 {\cf17 auto} cost = Detail::estimate_clock_cost<Clock>(resolution.mean);\par
2036 \par
2037                 env = Catch::Detail::make_unique<Environment>( Environment\{resolution, cost\} );\par
2038                 {\cf19 return} *env;\par
2039             \}\par
2040         \} {\cf20 // namespace Detail}\par
2041     \} {\cf20 // namespace Benchmark}\par
2042 \} {\cf20 // namespace Catch}\par
2043 \par
2044 {\cf21 #endif }{\cf20 // CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}\par
2045 \par
2046 \par
2047 {\cf20 // Adapted from donated nonius code.}\par
2048 \par
2049 {\cf21 #ifndef CATCH_ANALYSE_HPP_INCLUDED}\par
2050 {\cf21 #define CATCH_ANALYSE_HPP_INCLUDED}\par
2051 \par
2052 \par
2053 \par
2054 {\cf20 // Adapted from donated nonius code.}\par
2055 \par
2056 {\cf21 #ifndef CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}\par
2057 {\cf21 #define CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}\par
2058 \par
2059 \par
2060 {\cf21 #include <vector>}\par
2061 \par
2062 {\cf17 namespace }Catch \{\par
2063     {\cf17 namespace }Benchmark \{\par
2064         {\cf17 struct }SampleAnalysis \{\par
2065             std::vector<FDuration> samples;\par
2066             Estimate<FDuration> mean;\par
2067             Estimate<FDuration> standard_deviation;\par
2068             OutlierClassification outliers;\par
2069             {\cf18 double} outlier_variance;\par
2070         \};\par
2071     \} {\cf20 // namespace Benchmark}\par
2072 \} {\cf20 // namespace Catch}\par
2073 \par
2074 {\cf21 #endif }{\cf20 // CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}\par
2075 \par
2076 \par
2077 {\cf17 namespace }Catch \{\par
2078     {\cf17 class }IConfig;\par
2079 \par
2080     {\cf17 namespace }Benchmark \{\par
2081         {\cf17 namespace }Detail \{\par
2082             SampleAnalysis analyse({\cf17 const} IConfig &cfg, FDuration* first, FDuration* last);\par
2083         \} {\cf20 // namespace Detail}\par
2084     \} {\cf20 // namespace Benchmark}\par
2085 \} {\cf20 // namespace Catch}\par
2086 \par
2087 {\cf21 #endif }{\cf20 // CATCH_ANALYSE_HPP_INCLUDED}\par
2088 \par
2089 {\cf21 #include <algorithm>}\par
2090 {\cf21 #include <chrono>}\par
2091 {\cf21 #include <exception>}\par
2092 {\cf21 #include <string>}\par
2093 {\cf21 #include <cmath>}\par
2094 \par
2095 {\cf17 namespace }Catch \{\par
2096     {\cf17 namespace }Benchmark \{\par
2097         {\cf17 struct }Benchmark \{\par
2098             Benchmark(std::string&& benchmarkName)\par
2099                 : name(CATCH_MOVE(benchmarkName)) \{\}\par
2100 \par
2101             {\cf17 template} <{\cf17 class} FUN>\par
2102             Benchmark(std::string&& benchmarkName , FUN &&func)\par
2103                 : fun(CATCH_MOVE(func)), name(CATCH_MOVE(benchmarkName)) \{\}\par
2104 \par
2105             {\cf17 template} <{\cf17 typename} Clock>\par
2106             ExecutionPlan prepare({\cf17 const} IConfig &cfg, Environment env){\cf17  const }\{\par
2107                 {\cf17 auto} min_time = env.clock_resolution.mean * Detail::minimum_ticks;\par
2108                 {\cf17 auto} run_time = std::max(min_time, std::chrono::duration_cast<{\cf17 decltype}(min_time)>(cfg.benchmarkWarmupTime()));\par
2109                 {\cf17 auto}&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<IDuration>(run_time), 1, fun);\par
2110                 {\cf18 int} new_iters = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::ceil(min_time * test.iterations / test.elapsed));\par
2111                 {\cf19 return} \{ new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FDuration>(cfg.benchmarkWarmupTime()), Detail::warmup_iterations \};\par
2112             \}\par
2113 \par
2114             {\cf17 template} <{\cf17 typename} Clock = default_clock>\par
2115             {\cf18 void} run() \{\par
2116                 {\cf17 static_assert}( Clock::is_steady,\par
2117                                {\cf22 "Benchmarking clock should be steady"} );\par
2118                 {\cf17 auto} {\cf17 const}* cfg = getCurrentContext().getConfig();\par
2119 \par
2120                 {\cf17 auto} env = Detail::measure_environment<Clock>();\par
2121 \par
2122                 getResultCapture().benchmarkPreparing(name);\par
2123                 CATCH_TRY\{\par
2124                     {\cf17 auto} plan = user_code([&] \{\par
2125                         {\cf19 return} prepare<Clock>(*cfg, env);\par
2126                     \});\par
2127 \par
2128                     BenchmarkInfo info \{\par
2129                         CATCH_MOVE(name),\par
2130                         plan.estimated_duration.count(),\par
2131                         plan.iterations_per_sample,\par
2132                         cfg->benchmarkSamples(),\par
2133                         cfg->benchmarkResamples(),\par
2134                         env.clock_resolution.mean.count(),\par
2135                         env.clock_cost.mean.count()\par
2136                     \};\par
2137 \par
2138                     getResultCapture().benchmarkStarting(info);\par
2139 \par
2140                     {\cf17 auto} samples = user_code([&] \{\par
2141                         {\cf19 return} plan.template run<Clock>(*cfg, env);\par
2142                     \});\par
2143 \par
2144                     {\cf17 auto} analysis = Detail::analyse(*cfg, samples.data(), samples.data() + samples.size());\par
2145                     BenchmarkStats<> stats\{ CATCH_MOVE(info), CATCH_MOVE(analysis.samples), analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance \};\par
2146                     getResultCapture().benchmarkEnded(stats);\par
2147                 \} CATCH_CATCH_ANON (TestFailureException {\cf17 const}&) \{\par
2148                     getResultCapture().benchmarkFailed({\cf22 "Benchmark failed due to failed assertion"}_sr);\par
2149                 \} CATCH_CATCH_ALL\{\par
2150                     getResultCapture().benchmarkFailed(translateActiveException());\par
2151                     {\cf20 // We let the exception go further up so that the}\par
2152                     {\cf20 // test case is marked as failed.}\par
2153                     std::rethrow_exception(std::current_exception());\par
2154                 \}\par
2155             \}\par
2156 \par
2157             {\cf20 // sets lambda to be used in fun *and* executes benchmark!}\par
2158             template <typename Fun, std::enable_if_t<!Detail::is_related<Fun, Benchmark>::value, {\cf18 int}> = 0>\par
2159                 Benchmark & operator=(Fun func) \{\par
2160                 {\cf17 auto} {\cf17 const}* cfg = getCurrentContext().getConfig();\par
2161                 {\cf19 if} (!cfg->skipBenchmarks()) \{\par
2162                     fun = Detail::BenchmarkFunction(func);\par
2163                     run();\par
2164                 \}\par
2165                 {\cf19 return} *{\cf17 this};\par
2166             \}\par
2167 \par
2168             {\cf17 explicit} {\cf17 operator} bool() \{\par
2169                 {\cf19 return} {\cf17 true};\par
2170             \}\par
2171 \par
2172         {\cf17 private}:\par
2173             Detail::BenchmarkFunction fun;\par
2174             std::string name;\par
2175         \};\par
2176     \}\par
2177 \} {\cf20 // namespace Catch}\par
2178 \par
2179 {\cf21 #define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1}\par
2180 {\cf21 #define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2}\par
2181 \par
2182 {\cf21 #define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\\}\par
2183 {\cf21     if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\}\par
2184 {\cf21         BenchmarkName = [&](int benchmarkIndex)}\par
2185 \par
2186 {\cf21 #define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\\}\par
2187 {\cf21     if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\}\par
2188 {\cf21         BenchmarkName = [&]}\par
2189 \par
2190 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL)}\par
2191 \par
2192 {\cf21 #define CATCH_BENCHMARK(...) \\}\par
2193 {\cf21     INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))}\par
2194 {\cf21 #define CATCH_BENCHMARK_ADVANCED(name) \\}\par
2195 {\cf21     INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)}\par
2196 \par
2197 {\cf21 #else}\par
2198 \par
2199 {\cf21 #define BENCHMARK(...) \\}\par
2200 {\cf21     INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))}\par
2201 {\cf21 #define BENCHMARK_ADVANCED(name) \\}\par
2202 {\cf21     INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)}\par
2203 \par
2204 {\cf21 #endif}\par
2205 \par
2206 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_HPP_INCLUDED}\par
2207 \par
2208 \par
2209 {\cf20 // Adapted from donated nonius code.}\par
2210 \par
2211 {\cf21 #ifndef CATCH_CONSTRUCTOR_HPP_INCLUDED}\par
2212 {\cf21 #define CATCH_CONSTRUCTOR_HPP_INCLUDED}\par
2213 \par
2214 \par
2215 {\cf21 #include <type_traits>}\par
2216 \par
2217 {\cf17 namespace }Catch \{\par
2218     {\cf17 namespace }Benchmark \{\par
2219         {\cf17 namespace }Detail \{\par
2220             {\cf17 template} <{\cf17 typename} T, {\cf18 bool} Destruct>\par
2221             {\cf17 struct }ObjectStorage\par
2222             \{\par
2223                 ObjectStorage() = {\cf19 default};\par
2224 \par
2225                 ObjectStorage({\cf17 const} ObjectStorage& other)\par
2226                 \{\par
2227                     {\cf17 new}(&data) T(other.stored_object());\par
2228                 \}\par
2229 \par
2230                 ObjectStorage(ObjectStorage&& other)\par
2231                 \{\par
2232                     {\cf17 new}(data) T(CATCH_MOVE(other.stored_object()));\par
2233                 \}\par
2234 \par
2235                 ~ObjectStorage() \{ destruct_on_exit<T>(); \}\par
2236 \par
2237                 {\cf17 template} <{\cf17 typename}... Args>\par
2238                 {\cf18 void} construct(Args&&... args)\par
2239                 \{\par
2240                     {\cf17 new} (data) T(CATCH_FORWARD(args)...);\par
2241                 \}\par
2242 \par
2243                 {\cf17 template} <{\cf18 bool} AllowManualDestruction = !Destruct>\par
2244                 std::enable_if_t<AllowManualDestruction> destruct()\par
2245                 \{\par
2246                     stored_object().~T();\par
2247                 \}\par
2248 \par
2249             {\cf17 private}:\par
2250                 {\cf20 // If this is a constructor benchmark, destruct the underlying object}\par
2251                 {\cf17 template} <{\cf17 typename} U>\par
2252                 {\cf18 void} destruct_on_exit(std::enable_if_t<Destruct, U>* = {\cf17 nullptr}) \{ destruct<true>(); \}\par
2253                 {\cf20 // Otherwise, don't}\par
2254                 {\cf17 template} <{\cf17 typename} U>\par
2255                 {\cf18 void} destruct_on_exit(std::enable_if_t<!Destruct, U>* = {\cf17 nullptr}) \{ \}\par
2256 \par
2257 {\cf21 #if defined( __GNUC__ ) && __GNUC__ <= 6}\par
2258 {\cf21 #    pragma GCC diagnostic push}\par
2259 {\cf21 #    pragma GCC diagnostic ignored "-Wstrict-aliasing"}\par
2260 {\cf21 #endif}\par
2261                 T& stored_object() \{ {\cf19 return} *{\cf17 reinterpret_cast<}T*{\cf17 >}( data ); \}\par
2262 \par
2263                 T {\cf17 const}& stored_object(){\cf17  const }\{\par
2264                     {\cf19 return} *{\cf17 reinterpret_cast<}T const*{\cf17 >}( data );\par
2265                 \}\par
2266 {\cf21 #if defined( __GNUC__ ) && __GNUC__ <= 6}\par
2267 {\cf21 #    pragma GCC diagnostic pop}\par
2268 {\cf21 #endif}\par
2269 \par
2270                 {\cf17 alignas}( T ) {\cf18 unsigned} {\cf18 char} data[{\cf17 sizeof}( T )]\{\};\par
2271             \};\par
2272         \} {\cf20 // namespace Detail}\par
2273 \par
2274         {\cf17 template} <{\cf17 typename} T>\par
2275         {\cf17 using }storage_for = Detail::ObjectStorage<T, true>;\par
2276 \par
2277         {\cf17 template} <{\cf17 typename} T>\par
2278         {\cf17 using }destructable_object = Detail::ObjectStorage<T, false>;\par
2279     \} {\cf20 // namespace Benchmark}\par
2280 \} {\cf20 // namespace Catch}\par
2281 \par
2282 {\cf21 #endif }{\cf20 // CATCH_CONSTRUCTOR_HPP_INCLUDED}\par
2283 \par
2284 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_ALL_HPP_INCLUDED}\par
2285 \par
2286 \par
2287 {\cf21 #ifndef CATCH_APPROX_HPP_INCLUDED}\par
2288 {\cf21 #define CATCH_APPROX_HPP_INCLUDED}\par
2289 \par
2290 \par
2291 \par
2292 {\cf21 #ifndef CATCH_TOSTRING_HPP_INCLUDED}\par
2293 {\cf21 #define CATCH_TOSTRING_HPP_INCLUDED}\par
2294 \par
2295 \par
2296 {\cf21 #include <vector>}\par
2297 {\cf21 #include <cstddef>}\par
2298 {\cf21 #include <type_traits>}\par
2299 {\cf21 #include <string>}\par
2300 \par
2301 \par
2302 \par
2303 \par
2312 {\cf21 #ifndef CATCH_CONFIG_WCHAR_HPP_INCLUDED}\par
2313 {\cf21 #define CATCH_CONFIG_WCHAR_HPP_INCLUDED}\par
2314 \par
2315 \par
2316 {\cf20 // We assume that WCHAR should be enabled by default, and only disabled}\par
2317 {\cf20 // for a shortlist (so far only DJGPP) of compilers.}\par
2318 \par
2319 {\cf21 #if defined(__DJGPP__)}\par
2320 {\cf21 #  define CATCH_INTERNAL_CONFIG_NO_WCHAR}\par
2321 {\cf21 #endif }{\cf20 // __DJGPP__}\par
2322 \par
2323 {\cf21 #if !defined( CATCH_INTERNAL_CONFIG_NO_WCHAR ) && \\}\par
2324 {\cf21     !defined( CATCH_CONFIG_NO_WCHAR ) && \\}\par
2325 {\cf21     !defined( CATCH_CONFIG_WCHAR )}\par
2326 {\cf21 #    define CATCH_CONFIG_WCHAR}\par
2327 {\cf21 #endif}\par
2328 \par
2329 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WCHAR_HPP_INCLUDED}\par
2330 \par
2331 \par
2332 {\cf21 #ifndef CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}\par
2333 {\cf21 #define CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}\par
2334 \par
2335 \par
2336 {\cf21 #include <iosfwd>}\par
2337 {\cf21 #include <cstddef>}\par
2338 {\cf21 #include <ostream>}\par
2339 {\cf21 #include <string>}\par
2340 \par
2341 {\cf17 namespace }Catch \{\par
2342 \par
2343     {\cf17 class }ReusableStringStream : Detail::NonCopyable \{\par
2344         std::size_t m_index;\par
2345         std::ostream* m_oss;\par
2346     {\cf17 public}:\par
2347         ReusableStringStream();\par
2348         ~ReusableStringStream();\par
2349 \par
2351         std::string str() {\cf17 const};\par
2353         {\cf18 void} str(std::string {\cf17 const}& str);\par
2354 \par
2355 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
2356 {\cf21 #pragma GCC diagnostic push}\par
2357 {\cf20 // Old versions of GCC do not understand -Wnonnull-compare}\par
2358 {\cf21 #pragma GCC diagnostic ignored "-Wpragmas"}\par
2359 {\cf20 // Streaming a function pointer triggers Waddress and Wnonnull-compare}\par
2360 {\cf20 // on GCC, because it implicitly converts it to bool and then decides}\par
2361 {\cf20 // that the check it uses (a? true : false) is tautological and cannot}\par
2362 {\cf20 // be null...}\par
2363 {\cf21 #pragma GCC diagnostic ignored "-Waddress"}\par
2364 {\cf21 #pragma GCC diagnostic ignored "-Wnonnull-compare"}\par
2365 {\cf21 #endif}\par
2366 \par
2367         {\cf17 template}<{\cf17 typename} T>\par
2368         {\cf17 auto} operator << ( T {\cf17 const}& value ) -> ReusableStringStream& \{\par
2369             *m_oss << value;\par
2370             {\cf19 return} *{\cf17 this};\par
2371         \}\par
2372 \par
2373 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
2374 {\cf21 #pragma GCC diagnostic pop}\par
2375 {\cf21 #endif}\par
2376         {\cf17 auto} get() -> std::ostream& \{ {\cf19 return} *m_oss; \}\par
2377     \};\par
2378 \}\par
2379 \par
2380 {\cf21 #endif }{\cf20 // CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}\par
2381 \par
2382 \par
2383 {\cf21 #ifndef CATCH_VOID_TYPE_HPP_INCLUDED}\par
2384 {\cf21 #define CATCH_VOID_TYPE_HPP_INCLUDED}\par
2385 \par
2386 \par
2387 {\cf17 namespace }Catch \{\par
2388     {\cf17 namespace }Detail \{\par
2389 \par
2390         {\cf17 template} <{\cf17 typename}...>\par
2391         {\cf17 struct }make_void \{ {\cf17 using }type = void; \};\par
2392 \par
2393         {\cf17 template} <{\cf17 typename}... Ts>\par
2394         {\cf17 using }void_t = {\cf17 typename} make_void<Ts...>::type;\par
2395 \par
2396     \} {\cf20 // namespace Detail}\par
2397 \} {\cf20 // namespace Catch}\par
2398 \par
2399 \par
2400 {\cf21 #endif }{\cf20 // CATCH_VOID_TYPE_HPP_INCLUDED}\par
2401 \par
2402 \par
2403 {\cf21 #ifndef CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
2404 {\cf21 #define CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
2405 \par
2406 \par
2407 {\cf21 #include <vector>}\par
2408 \par
2409 {\cf17 namespace }Catch \{\par
2410 \par
2411     {\cf17 namespace }Detail \{\par
2412         {\cf17 struct }EnumInfo \{\par
2413             StringRef m_name;\par
2414             std::vector<std::pair<int, StringRef>> m_values;\par
2415 \par
2416             ~EnumInfo();\par
2417 \par
2418             StringRef lookup( {\cf18 int} value ) {\cf17 const};\par
2419         \};\par
2420     \} {\cf20 // namespace Detail}\par
2421 \par
2422     {\cf17 class }IMutableEnumValuesRegistry \{\par
2423     {\cf17 public}:\par
2424         {\cf17 virtual} ~IMutableEnumValuesRegistry(); {\cf20 // = default;}\par
2425 \par
2426         {\cf17 virtual} Detail::EnumInfo {\cf17 const}& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> {\cf17 const}& values ) = 0;\par
2427 \par
2428         {\cf17 template}<{\cf17 typename} E>\par
2429         Detail::EnumInfo {\cf17 const}& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) \{\par
2430             {\cf17 static_assert}({\cf17 sizeof}(int) >= {\cf17 sizeof}(E), {\cf22 "Cannot serialize enum to int"});\par
2431             std::vector<int> intValues;\par
2432             intValues.reserve( values.size() );\par
2433             {\cf19 for}( {\cf17 auto} enumValue : values )\par
2434                 intValues.push_back( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( enumValue ) );\par
2435             {\cf19 return} registerEnum( enumName, allEnums, intValues );\par
2436         \}\par
2437     \};\par
2438 \par
2439 \} {\cf20 // Catch}\par
2440 \par
2441 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
2442 \par
2443 {\cf21 #ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2444 {\cf21 #include <string_view>}\par
2445 {\cf21 #endif}\par
2446 \par
2447 {\cf21 #ifdef _MSC_VER}\par
2448 {\cf21 #pragma warning(push)}\par
2449 {\cf21 #pragma warning(disable:4180) }{\cf20 // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless}\par
2450 {\cf21 #endif}\par
2451 \par
2452 {\cf20 // We need a dummy global operator<< so we can bring it into Catch namespace later}\par
2453 {\cf17 struct }Catch_global_namespace_dummy\{\};\par
2454 std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);\par
2455 \par
2456 {\cf17 namespace }Catch \{\par
2457     {\cf20 // Bring in global namespace operator<< for ADL lookup in}\par
2458     {\cf20 // `IsStreamInsertable` below.}\par
2459     using ::operator<<;\par
2460 \par
2461     {\cf17 namespace }Detail \{\par
2462 \par
2463         {\cf17 inline} std::size_t catch_strnlen({\cf17 const} {\cf18 char} *str, std::size_t n) \{\par
2464             {\cf17 auto} ret = std::char_traits<char>::find(str, n, {\cf23 '\\0'});\par
2465             {\cf19 if} (ret != {\cf17 nullptr}) \{\par
2466                 {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(ret - str);\par
2467             \}\par
2468             {\cf19 return} n;\par
2469         \}\par
2470 \par
2471         {\cf17 constexpr} StringRef unprintableString = {\cf22 "\{?\}"}_sr;\par
2472 \par
2474         std::string convertIntoString( StringRef {\cf18 string}, {\cf18 bool} escapeInvisibles );\par
2475 \par
2478         std::string convertIntoString( StringRef {\cf18 string} );\par
2479 \par
2480         std::string rawMemoryToString( {\cf17 const} {\cf18 void} *{\cf18 object}, std::size_t size );\par
2481 \par
2482         {\cf17 template}<{\cf17 typename} T>\par
2483         std::string rawMemoryToString( {\cf17 const} T& {\cf18 object} ) \{\par
2484           {\cf19 return} rawMemoryToString( &{\cf18 object}, {\cf17 sizeof}({\cf18 object}) );\par
2485         \}\par
2486 \par
2487         {\cf17 template}<{\cf17 typename} T>\par
2488         {\cf17 class }IsStreamInsertable \{\par
2489             {\cf17 template}<{\cf17 typename} Stream, {\cf17 typename} U>\par
2490             {\cf17 static} {\cf17 auto} test({\cf18 int})\par
2491                 -> {\cf17 decltype}(std::declval<Stream&>() << std::declval<U>(), std::true_type());\par
2492 \par
2493             {\cf17 template}<{\cf17 typename}, {\cf17 typename}>\par
2494             {\cf17 static} {\cf17 auto} test(...)->std::false_type;\par
2495 \par
2496         {\cf17 public}:\par
2497             {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 decltype}(test<std::ostream, const T&>(0))::value;\par
2498         \};\par
2499 \par
2500         {\cf17 template}<{\cf17 typename} E>\par
2501         std::string convertUnknownEnumToString( E e );\par
2502 \par
2503         {\cf17 template}<{\cf17 typename} T>\par
2504         std::enable_if_t<\par
2505             !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,\par
2506         std::string> convertUnstreamable( T {\cf17 const}& ) \{\par
2507             {\cf19 return} std::string(Detail::unprintableString);\par
2508         \}\par
2509         {\cf17 template}<{\cf17 typename} T>\par
2510         std::enable_if_t<\par
2511             !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,\par
2512          std::string> convertUnstreamable(T {\cf17 const}& ex) \{\par
2513             {\cf19 return} ex.what();\par
2514         \}\par
2515 \par
2516 \par
2517         {\cf17 template}<{\cf17 typename} T>\par
2518         std::enable_if_t<\par
2519             std::is_enum<T>::value,\par
2520         std::string> convertUnstreamable( T {\cf17 const}& value ) \{\par
2521             {\cf19 return} convertUnknownEnumToString( value );\par
2522         \}\par
2523 \par
2524 {\cf21 #if defined(_MANAGED)}\par
2526         {\cf17 template}<{\cf17 typename} T>\par
2527         std::string clrReferenceToString( T^ ref ) \{\par
2528             {\cf19 if} (ref == {\cf17 nullptr})\par
2529                 {\cf19 return} std::string({\cf22 "null"});\par
2530             {\cf17 auto} bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());\par
2531             cli::pin_ptr<System::Byte> p = &bytes[0];\par
2532             {\cf19 return} std::string({\cf17 reinterpret_cast<}{\cf18 char} {\cf17 const }*{\cf17 >}(p), bytes->Length);\par
2533         \}\par
2534 {\cf21 #endif}\par
2535 \par
2536     \} {\cf20 // namespace Detail}\par
2537 \par
2538 \par
2539     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
2540     {\cf17 struct }StringMaker \{\par
2541         {\cf17 template} <{\cf17 typename} Fake = T>\par
2542         {\cf17 static}\par
2543         std::enable_if_t<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>\par
2544             convert({\cf17 const} Fake& value) \{\par
2545                 ReusableStringStream rss;\par
2546                 {\cf20 // NB: call using the function-like syntax to avoid ambiguity with}\par
2547                 {\cf20 // user-defined templated operator<< under clang.}\par
2548                 rss.operator<<(value);\par
2549                 {\cf19 return} rss.str();\par
2550         \}\par
2551 \par
2552         {\cf17 template} <{\cf17 typename} Fake = T>\par
2553         {\cf17 static}\par
2554         std::enable_if_t<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>\par
2555             convert( {\cf17 const} Fake& value ) \{\par
2556 {\cf21 #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)}\par
2557             {\cf19 return} Detail::convertUnstreamable(value);\par
2558 {\cf21 #else}\par
2559             {\cf19 return} CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\par
2560 {\cf21 #endif}\par
2561         \}\par
2562     \};\par
2563 \par
2564     {\cf17 namespace }Detail \{\par
2565 \par
2566         {\cf20 // This function dispatches all stringification requests inside of Catch.}\par
2567         {\cf20 // Should be preferably called fully qualified, like ::Catch::Detail::stringify}\par
2568         {\cf17 template} <{\cf17 typename} T>\par
2569         std::string stringify({\cf17 const} T& e) \{\par
2570             return ::Catch::StringMaker<std::remove_cv_t<std::remove_reference_t<T>>>::convert(e);\par
2571         \}\par
2572 \par
2573         {\cf17 template}<{\cf17 typename} E>\par
2574         std::string convertUnknownEnumToString( E e ) \{\par
2575             return ::Catch::Detail::stringify({\cf17 static_cast<}std::underlying_type_t<E>{\cf17 >}(e));\par
2576         \}\par
2577 \par
2578 {\cf21 #if defined(_MANAGED)}\par
2579         {\cf17 template} <{\cf17 typename} T>\par
2580         std::string stringify( T^ e ) \{\par
2581             return ::Catch::StringMaker<T^>::convert(e);\par
2582         \}\par
2583 {\cf21 #endif}\par
2584 \par
2585     \} {\cf20 // namespace Detail}\par
2586 \par
2587     {\cf20 // Some predefined specializations}\par
2588 \par
2589     {\cf17 template}<>\par
2590     {\cf17 struct }StringMaker<std::string> \{\par
2591         {\cf17 static} std::string convert({\cf17 const} std::string& str);\par
2592     \};\par
2593 \par
2594 {\cf21 #ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2595     {\cf17 template}<>\par
2596     {\cf17 struct }StringMaker<std::string_view> \{\par
2597         {\cf17 static} std::string convert(std::string_view str);\par
2598     \};\par
2599 {\cf21 #endif}\par
2600 \par
2601     {\cf17 template}<>\par
2602     {\cf17 struct }StringMaker<char const *> \{\par
2603         {\cf17 static} std::string convert({\cf18 char} {\cf17 const} * str);\par
2604     \};\par
2605     {\cf17 template}<>\par
2606     {\cf17 struct }StringMaker<char *> \{\par
2607         {\cf17 static} std::string convert({\cf18 char} * str);\par
2608     \};\par
2609 \par
2610 {\cf21 #if defined(CATCH_CONFIG_WCHAR)}\par
2611     {\cf17 template}<>\par
2612     {\cf17 struct }StringMaker<std::wstring> \{\par
2613         {\cf17 static} std::string convert({\cf17 const} std::wstring& wstr);\par
2614     \};\par
2615 \par
2616 {\cf21 # ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2617     {\cf17 template}<>\par
2618     {\cf17 struct }StringMaker<std::wstring_view> \{\par
2619         {\cf17 static} std::string convert(std::wstring_view str);\par
2620     \};\par
2621 {\cf21 # endif}\par
2622 \par
2623     {\cf17 template}<>\par
2624     {\cf17 struct }StringMaker<wchar_t const *> \{\par
2625         {\cf17 static} std::string convert({\cf18 wchar_t} {\cf17 const} * str);\par
2626     \};\par
2627     {\cf17 template}<>\par
2628     {\cf17 struct }StringMaker<wchar_t *> \{\par
2629         {\cf17 static} std::string convert({\cf18 wchar_t} * str);\par
2630     \};\par
2631 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WCHAR}\par
2632 \par
2633     {\cf17 template}<{\cf18 size_t} SZ>\par
2634     {\cf17 struct }StringMaker<char[SZ]> \{\par
2635         {\cf17 static} std::string convert({\cf18 char} {\cf17 const}* str) \{\par
2636             {\cf19 return} Detail::convertIntoString(\par
2637                 StringRef( str, Detail::catch_strnlen( str, SZ ) ) );\par
2638         \}\par
2639     \};\par
2640     {\cf17 template}<{\cf18 size_t} SZ>\par
2641     {\cf17 struct }StringMaker<signed char[SZ]> \{\par
2642         {\cf17 static} std::string convert({\cf18 signed} {\cf18 char} {\cf17 const}* str) \{\par
2643             {\cf17 auto} reinterpreted = {\cf17 reinterpret_cast<}{\cf18 char} const*{\cf17 >}(str);\par
2644             {\cf19 return} Detail::convertIntoString(\par
2645                 StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\par
2646         \}\par
2647     \};\par
2648     {\cf17 template}<{\cf18 size_t} SZ>\par
2649     {\cf17 struct }StringMaker<unsigned char[SZ]> \{\par
2650         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 char} {\cf17 const}* str) \{\par
2651             {\cf17 auto} reinterpreted = {\cf17 reinterpret_cast<}{\cf18 char} const*{\cf17 >}(str);\par
2652             {\cf19 return} Detail::convertIntoString(\par
2653                 StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\par
2654         \}\par
2655     \};\par
2656 \par
2657 {\cf21 #if defined(CATCH_CONFIG_CPP17_BYTE)}\par
2658     {\cf17 template}<>\par
2659     {\cf17 struct }StringMaker<std::byte> \{\par
2660         {\cf17 static} std::string convert(std::byte value);\par
2661     \};\par
2662 {\cf21 #endif }{\cf20 // defined(CATCH_CONFIG_CPP17_BYTE)}\par
2663     {\cf17 template}<>\par
2664     {\cf17 struct }StringMaker<int> \{\par
2665         {\cf17 static} std::string convert({\cf18 int} value);\par
2666     \};\par
2667     {\cf17 template}<>\par
2668     {\cf17 struct }StringMaker<long> \{\par
2669         {\cf17 static} std::string convert({\cf18 long} value);\par
2670     \};\par
2671     {\cf17 template}<>\par
2672     {\cf17 struct }StringMaker<long long> \{\par
2673         {\cf17 static} std::string convert({\cf18 long} {\cf18 long} value);\par
2674     \};\par
2675     {\cf17 template}<>\par
2676     {\cf17 struct }StringMaker<unsigned int> \{\par
2677         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 int} value);\par
2678     \};\par
2679     {\cf17 template}<>\par
2680     {\cf17 struct }StringMaker<unsigned long> \{\par
2681         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 long} value);\par
2682     \};\par
2683     {\cf17 template}<>\par
2684     {\cf17 struct }StringMaker<unsigned long long> \{\par
2685         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 long} {\cf18 long} value);\par
2686     \};\par
2687 \par
2688     {\cf17 template}<>\par
2689     {\cf17 struct }StringMaker<bool> \{\par
2690         {\cf17 static} std::string convert({\cf18 bool} b) \{\par
2691             {\cf17 using namespace }std::string_literals;\par
2692             {\cf19 return} b ? {\cf22 "true"}s : {\cf22 "false"}s;\par
2693         \}\par
2694     \};\par
2695 \par
2696     {\cf17 template}<>\par
2697     {\cf17 struct }StringMaker<char> \{\par
2698         {\cf17 static} std::string convert({\cf18 char} c);\par
2699     \};\par
2700     {\cf17 template}<>\par
2701     {\cf17 struct }StringMaker<signed char> \{\par
2702         {\cf17 static} std::string convert({\cf18 signed} {\cf18 char} value);\par
2703     \};\par
2704     {\cf17 template}<>\par
2705     {\cf17 struct }StringMaker<unsigned char> \{\par
2706         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 char} value);\par
2707     \};\par
2708 \par
2709     {\cf17 template}<>\par
2710     {\cf17 struct }StringMaker<std::nullptr_t> \{\par
2711         {\cf17 static} std::string convert(std::nullptr_t) \{\par
2712             {\cf17 using namespace }std::string_literals;\par
2713             {\cf19 return} {\cf22 "nullptr"}s;\par
2714         \}\par
2715     \};\par
2716 \par
2717     {\cf17 template}<>\par
2718     {\cf17 struct }StringMaker<float> \{\par
2719         {\cf17 static} std::string convert({\cf18 float} value);\par
2720         CATCH_EXPORT {\cf17 static} {\cf18 int} precision;\par
2721     \};\par
2722 \par
2723     {\cf17 template}<>\par
2724     {\cf17 struct }StringMaker<double> \{\par
2725         {\cf17 static} std::string convert({\cf18 double} value);\par
2726         CATCH_EXPORT {\cf17 static} {\cf18 int} precision;\par
2727     \};\par
2728 \par
2729     {\cf17 template} <{\cf17 typename} T>\par
2730     {\cf17 struct }StringMaker<T*> \{\par
2731         {\cf17 template} <{\cf17 typename} U>\par
2732         {\cf17 static} std::string convert(U* p) \{\par
2733             {\cf19 if} (p) \{\par
2734                 return ::Catch::Detail::rawMemoryToString(p);\par
2735             \} {\cf19 else} \{\par
2736                 {\cf19 return} {\cf22 "nullptr"};\par
2737             \}\par
2738         \}\par
2739     \};\par
2740 \par
2741     {\cf17 template} <{\cf17 typename} R, {\cf17 typename} C>\par
2742     {\cf17 struct }StringMaker<R C::*> \{\par
2743         {\cf17 static} std::string convert(R C::* p) \{\par
2744             {\cf19 if} (p) \{\par
2745                 return ::Catch::Detail::rawMemoryToString(p);\par
2746             \} {\cf19 else} \{\par
2747                 {\cf19 return} {\cf22 "nullptr"};\par
2748             \}\par
2749         \}\par
2750     \};\par
2751 \par
2752 {\cf21 #if defined(_MANAGED)}\par
2753     {\cf17 template} <{\cf17 typename} T>\par
2754     {\cf17 struct }StringMaker<T^> \{\par
2755         {\cf17 static} std::string convert( T^ ref ) \{\par
2756             return ::Catch::Detail::clrReferenceToString(ref);\par
2757         \}\par
2758     \};\par
2759 {\cf21 #endif}\par
2760 \par
2761     {\cf17 namespace }Detail \{\par
2762         {\cf17 template}<{\cf17 typename} InputIterator, {\cf17 typename} Sentinel = InputIterator>\par
2763         std::string rangeToString(InputIterator first, Sentinel last) \{\par
2764             ReusableStringStream rss;\par
2765             rss << {\cf22 "\{ "};\par
2766             {\cf19 if} (first != last) \{\par
2767                 rss << ::Catch::Detail::stringify(*first);\par
2768                 {\cf19 for} (++first; first != last; ++first)\par
2769                     rss << {\cf22 ", "} << ::Catch::Detail::stringify(*first);\par
2770             \}\par
2771             rss << {\cf22 " \}"};\par
2772             {\cf19 return} rss.str();\par
2773         \}\par
2774     \}\par
2775 \par
2776 \} {\cf20 // namespace Catch}\par
2777 \par
2779 {\cf20 // Separate std-lib types stringification, so it can be selectively enabled}\par
2780 {\cf20 // This means that we do not bring in their headers}\par
2781 \par
2782 {\cf21 #if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)}\par
2783 {\cf21 #  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER}\par
2784 {\cf21 #  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER}\par
2785 {\cf21 #  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER}\par
2786 {\cf21 #  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER}\par
2787 {\cf21 #endif}\par
2788 \par
2789 {\cf20 // Separate std::pair specialization}\par
2790 {\cf21 #if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)}\par
2791 {\cf21 #include <utility>}\par
2792 {\cf17 namespace }Catch \{\par
2793     {\cf17 template}<{\cf17 typename} T1, {\cf17 typename} T2>\par
2794     {\cf17 struct }StringMaker<std::pair<T1, T2> > \{\par
2795         {\cf17 static} std::string convert({\cf17 const} std::pair<T1, T2>& pair) \{\par
2796             ReusableStringStream rss;\par
2797             rss << {\cf22 "\{ "}\par
2798                 << ::Catch::Detail::stringify(pair.first)\par
2799                 << {\cf22 ", "}\par
2800                 << ::Catch::Detail::stringify(pair.second)\par
2801                 << {\cf22 " \}"};\par
2802             {\cf19 return} rss.str();\par
2803         \}\par
2804     \};\par
2805 \}\par
2806 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER}\par
2807 \par
2808 {\cf21 #if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_OPTIONAL)}\par
2809 {\cf21 #include <optional>}\par
2810 {\cf17 namespace }Catch \{\par
2811     {\cf17 template}<{\cf17 typename} T>\par
2812     {\cf17 struct }StringMaker<std::optional<T> > \{\par
2813         {\cf17 static} std::string convert({\cf17 const} std::optional<T>& optional) \{\par
2814             {\cf19 if} (optional.has_value()) \{\par
2815                 return ::Catch::Detail::stringify(*optional);\par
2816             \} {\cf19 else} \{\par
2817                 {\cf19 return} {\cf22 "\{ \}"};\par
2818             \}\par
2819         \}\par
2820     \};\par
2821     {\cf17 template} <>\par
2822     {\cf17 struct }StringMaker<std::nullopt_t> \{\par
2823         {\cf17 static} std::string convert({\cf17 const} std::nullopt_t&) \{\par
2824             {\cf19 return} {\cf22 "\{ \}"};\par
2825         \}\par
2826     \};\par
2827 \}\par
2828 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER}\par
2829 \par
2830 {\cf20 // Separate std::tuple specialization}\par
2831 {\cf21 #if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)}\par
2832 {\cf21 #include <tuple>}\par
2833 {\cf17 namespace }Catch \{\par
2834     {\cf17 namespace }Detail \{\par
2835         {\cf17 template}<\par
2836             {\cf17 typename} Tuple,\par
2837             std::size_t N = 0,\par
2838             {\cf18 bool} = (N < std::tuple_size<Tuple>::value)\par
2839             >\par
2840             {\cf17 struct} TupleElementPrinter \{\par
2841             {\cf17 static} {\cf18 void} print({\cf17 const} Tuple& tuple, std::ostream& os) \{\par
2842                 os << (N ? {\cf22 ", "} : {\cf22 " "})\par
2843                     << ::Catch::Detail::stringify(std::get<N>(tuple));\par
2844                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);\par
2845             \}\par
2846         \};\par
2847 \par
2848         {\cf17 template}<\par
2849             {\cf17 typename} Tuple,\par
2850             std::size_t N\par
2851         >\par
2852             {\cf17 struct }TupleElementPrinter<Tuple, N, false> \{\par
2853             {\cf17 static} {\cf18 void} print({\cf17 const} Tuple&, std::ostream&) \{\}\par
2854         \};\par
2855 \par
2856     \}\par
2857 \par
2858 \par
2859     {\cf17 template}<{\cf17 typename} ...Types>\par
2860     {\cf17 struct }StringMaker<std::tuple<Types...>> \{\par
2861         {\cf17 static} std::string convert({\cf17 const} std::tuple<Types...>& tuple) \{\par
2862             ReusableStringStream rss;\par
2863             rss << {\cf23 '\{'};\par
2864             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());\par
2865             rss << {\cf22 " \}"};\par
2866             {\cf19 return} rss.str();\par
2867         \}\par
2868     \};\par
2869 \}\par
2870 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER}\par
2871 \par
2872 {\cf21 #if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_VARIANT)}\par
2873 {\cf21 #include <variant>}\par
2874 {\cf17 namespace }Catch \{\par
2875     {\cf17 template}<>\par
2876     {\cf17 struct }StringMaker<std::monostate> \{\par
2877         {\cf17 static} std::string convert({\cf17 const} std::monostate&) \{\par
2878             {\cf19 return} {\cf22 "\{ \}"};\par
2879         \}\par
2880     \};\par
2881 \par
2882     {\cf17 template}<{\cf17 typename}... Elements>\par
2883     {\cf17 struct }StringMaker<std::variant<Elements...>> \{\par
2884         {\cf17 static} std::string convert({\cf17 const} std::variant<Elements...>& variant) \{\par
2885             {\cf19 if} (variant.valueless_by_exception()) \{\par
2886                 {\cf19 return} {\cf22 "\{valueless variant\}"};\par
2887             \} {\cf19 else} \{\par
2888                 {\cf19 return} std::visit(\par
2889                     []({\cf17 const} {\cf17 auto}& value) \{\par
2890                         return ::Catch::Detail::stringify(value);\par
2891                     \},\par
2892                     variant\par
2893                 );\par
2894             \}\par
2895         \}\par
2896     \};\par
2897 \}\par
2898 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER}\par
2899 \par
2900 {\cf17 namespace }Catch \{\par
2901     {\cf20 // Import begin/ end from std here}\par
2902     {\cf17 using }std::begin;\par
2903     {\cf17 using }std::end;\par
2904 \par
2905     {\cf17 namespace }Detail \{\par
2906         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
2907         {\cf17 struct }is_range_impl : std::false_type \{\};\par
2908 \par
2909         {\cf17 template} <{\cf17 typename} T>\par
2910         {\cf17 struct }is_range_impl<T, void_t<decltype(begin(std::declval<T>()))>> : std::true_type \{\};\par
2911     \} {\cf20 // namespace Detail}\par
2912 \par
2913     {\cf17 template} <{\cf17 typename} T>\par
2914     {\cf17 struct }is_range : Detail::is_range_impl<T> \{\};\par
2915 \par
2916 {\cf21 #if defined(_MANAGED) }{\cf20 // Managed types are never ranges}\par
2917     {\cf17 template} <{\cf17 typename} T>\par
2918     {\cf17 struct }is_range<T^> \{\par
2919         {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 false};\par
2920     \};\par
2921 {\cf21 #endif}\par
2922 \par
2923     {\cf17 template}<{\cf17 typename} Range>\par
2924     std::string rangeToString( Range {\cf17 const}& range ) \{\par
2925         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );\par
2926     \}\par
2927 \par
2928     {\cf20 // Handle vector<bool> specially}\par
2929     {\cf17 template}<{\cf17 typename} Allocator>\par
2930     std::string rangeToString( std::vector<bool, Allocator> {\cf17 const}& v ) \{\par
2931         ReusableStringStream rss;\par
2932         rss << {\cf22 "\{ "};\par
2933         {\cf18 bool} first = {\cf17 true};\par
2934         {\cf19 for}( {\cf18 bool} b : v ) \{\par
2935             {\cf19 if}( first )\par
2936                 first = {\cf17 false};\par
2937             {\cf19 else}\par
2938                 rss << {\cf22 ", "};\par
2939             rss << ::Catch::Detail::stringify( b );\par
2940         \}\par
2941         rss << {\cf22 " \}"};\par
2942         {\cf19 return} rss.str();\par
2943     \}\par
2944 \par
2945     {\cf17 template}<{\cf17 typename} R>\par
2946     {\cf17 struct }StringMaker<R, std::enable_if_t<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>> \{\par
2947         {\cf17 static} std::string convert( R {\cf17 const}& range ) \{\par
2948             {\cf19 return} rangeToString( range );\par
2949         \}\par
2950     \};\par
2951 \par
2952     {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} SZ>\par
2953     {\cf17 struct }StringMaker<T[SZ]> \{\par
2954         {\cf17 static} std::string convert(T {\cf17 const}(&arr)[SZ]) \{\par
2955             {\cf19 return} rangeToString(arr);\par
2956         \}\par
2957     \};\par
2958 \par
2959 \par
2960 \} {\cf20 // namespace Catch}\par
2961 \par
2962 {\cf20 // Separate std::chrono::duration specialization}\par
2963 {\cf21 #include <ctime>}\par
2964 {\cf21 #include <ratio>}\par
2965 {\cf21 #include <chrono>}\par
2966 \par
2967 \par
2968 {\cf17 namespace }Catch \{\par
2969 \par
2970 {\cf17 template} <{\cf17 class} Ratio>\par
2971 {\cf17 struct }ratio_string \{\par
2972     {\cf17 static} std::string symbol() \{\par
2973         Catch::ReusableStringStream rss;\par
2974         rss << {\cf23 '['} << Ratio::num << {\cf23 '/'}\par
2975             << Ratio::den << {\cf23 ']'};\par
2976         {\cf19 return} rss.str();\par
2977     \}\par
2978 \};\par
2979 \par
2980 {\cf17 template} <>\par
2981 {\cf17 struct }ratio_string<std::atto> \{\par
2982     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'a'}; \}\par
2983 \};\par
2984 {\cf17 template} <>\par
2985 {\cf17 struct }ratio_string<std::femto> \{\par
2986     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'f'}; \}\par
2987 \};\par
2988 {\cf17 template} <>\par
2989 {\cf17 struct }ratio_string<std::pico> \{\par
2990     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'p'}; \}\par
2991 \};\par
2992 {\cf17 template} <>\par
2993 {\cf17 struct }ratio_string<std::nano> \{\par
2994     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'n'}; \}\par
2995 \};\par
2996 {\cf17 template} <>\par
2997 {\cf17 struct }ratio_string<std::micro> \{\par
2998     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'u'}; \}\par
2999 \};\par
3000 {\cf17 template} <>\par
3001 {\cf17 struct }ratio_string<std::milli> \{\par
3002     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'm'}; \}\par
3003 \};\par
3004 \par
3006     {\cf20 // std::chrono::duration specializations}\par
3007     {\cf17 template}<{\cf17 typename} Value, {\cf17 typename} Ratio>\par
3008     {\cf17 struct }StringMaker<std::chrono::duration<Value, Ratio>> \{\par
3009         {\cf17 static} std::string convert(std::chrono::duration<Value, Ratio> {\cf17 const}& duration) \{\par
3010             ReusableStringStream rss;\par
3011             rss << duration.count() << {\cf23 ' '} << ratio_string<Ratio>::symbol() << {\cf23 's'};\par
3012             {\cf19 return} rss.str();\par
3013         \}\par
3014     \};\par
3015     {\cf17 template}<{\cf17 typename} Value>\par
3016     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<1>>> \{\par
3017         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<1>> {\cf17 const}& duration) \{\par
3018             ReusableStringStream rss;\par
3019             rss << duration.count() << {\cf22 " s"};\par
3020             {\cf19 return} rss.str();\par
3021         \}\par
3022     \};\par
3023     {\cf17 template}<{\cf17 typename} Value>\par
3024     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<60>>> \{\par
3025         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<60>> {\cf17 const}& duration) \{\par
3026             ReusableStringStream rss;\par
3027             rss << duration.count() << {\cf22 " m"};\par
3028             {\cf19 return} rss.str();\par
3029         \}\par
3030     \};\par
3031     {\cf17 template}<{\cf17 typename} Value>\par
3032     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<3600>>> \{\par
3033         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<3600>> {\cf17 const}& duration) \{\par
3034             ReusableStringStream rss;\par
3035             rss << duration.count() << {\cf22 " h"};\par
3036             {\cf19 return} rss.str();\par
3037         \}\par
3038     \};\par
3039 \par
3041     {\cf20 // std::chrono::time_point specialization}\par
3042     {\cf20 // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>}\par
3043     {\cf17 template}<{\cf17 typename} Clock, {\cf17 typename} Duration>\par
3044     {\cf17 struct }StringMaker<std::chrono::time_point<Clock, Duration>> \{\par
3045         {\cf17 static} std::string convert(std::chrono::time_point<Clock, Duration> {\cf17 const}& time_point) \{\par
3046             return ::Catch::Detail::stringify(time_point.time_since_epoch()) + {\cf22 " since epoch"};\par
3047         \}\par
3048     \};\par
3049     {\cf20 // std::chrono::time_point<system_clock> specialization}\par
3050     {\cf17 template}<{\cf17 typename} Duration>\par
3051     {\cf17 struct }StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> \{\par
3052         {\cf17 static} std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> {\cf17 const}& time_point) \{\par
3053             {\cf17 auto} converted = std::chrono::system_clock::to_time_t(time_point);\par
3054 \par
3055 {\cf21 #ifdef _MSC_VER}\par
3056             std::tm timeInfo = \{\};\par
3057             gmtime_s(&timeInfo, &converted);\par
3058 {\cf21 #else}\par
3059             std::tm* timeInfo = std::gmtime(&converted);\par
3060 {\cf21 #endif}\par
3061 \par
3062             {\cf17 auto} {\cf17 const} timeStampSize = {\cf17 sizeof}({\cf22 "2017-01-16T17:06:45Z"});\par
3063             {\cf18 char} timeStamp[timeStampSize];\par
3064             {\cf17 const} {\cf18 char} * {\cf17 const} fmt = {\cf22 "%Y-%m-%dT%H:%M:%SZ"};\par
3065 \par
3066 {\cf21 #ifdef _MSC_VER}\par
3067             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\par
3068 {\cf21 #else}\par
3069             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\par
3070 {\cf21 #endif}\par
3071             {\cf19 return} std::string(timeStamp, timeStampSize - 1);\par
3072         \}\par
3073     \};\par
3074 \}\par
3075 \par
3076 \par
3077 {\cf21 #define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \\}\par
3078 {\cf21 namespace Catch \{ \\}\par
3079 {\cf21     template<> struct StringMaker<enumName> \{ \\}\par
3080 {\cf21         static std::string convert( enumName value ) \{ \\}\par
3081 {\cf21             static const auto& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, \{ __VA_ARGS__ \} ); \\}\par
3082 {\cf21             return static_cast<std::string>(enumInfo.lookup( static_cast<int>( value ) )); \\}\par
3083 {\cf21         \} \\}\par
3084 {\cf21     \}; \\}\par
3085 {\cf21 \}}\par
3086 \par
3087 {\cf21 #define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )}\par
3088 \par
3089 {\cf21 #ifdef _MSC_VER}\par
3090 {\cf21 #pragma warning(pop)}\par
3091 {\cf21 #endif}\par
3092 \par
3093 {\cf21 #endif }{\cf20 // CATCH_TOSTRING_HPP_INCLUDED}\par
3094 \par
3095 {\cf21 #include <type_traits>}\par
3096 \par
3097 {\cf17 namespace }Catch \{\par
3098 \par
3099     {\cf17 class }Approx \{\par
3100     {\cf17 private}:\par
3101         {\cf18 bool} equalityComparisonImpl({\cf18 double} other) {\cf17 const};\par
3102         {\cf20 // Sets and validates the new margin (margin >= 0)}\par
3103         {\cf18 void} setMargin({\cf18 double} margin);\par
3104         {\cf20 // Sets and validates the new epsilon (0 < epsilon < 1)}\par
3105         {\cf18 void} setEpsilon({\cf18 double} epsilon);\par
3106 \par
3107     {\cf17 public}:\par
3108         {\cf17 explicit} Approx ( {\cf18 double} value );\par
3109 \par
3110         {\cf17 static} Approx custom();\par
3111 \par
3112         Approx operator-() {\cf17 const};\par
3113 \par
3114         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3115         Approx operator()( T {\cf17 const}& value ){\cf17  const }\{\par
3116             Approx approx( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(value) );\par
3117             approx.m_epsilon = m_epsilon;\par
3118             approx.m_margin = m_margin;\par
3119             approx.m_scale = m_scale;\par
3120             {\cf19 return} approx;\par
3121         \}\par
3122 \par
3123         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3124         {\cf17 explicit} Approx( T {\cf17 const}& value ): Approx(static_cast<double>(value))\par
3125         \{\}\par
3126 \par
3127 \par
3128         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3129         {\cf17 friend} {\cf18 bool} operator == ( {\cf17 const} T& lhs, Approx {\cf17 const}& rhs ) \{\par
3130             {\cf17 auto} lhs_v = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs);\par
3131             {\cf19 return} rhs.equalityComparisonImpl(lhs_v);\par
3132         \}\par
3133 \par
3134         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3135         {\cf17 friend} {\cf18 bool} operator == ( Approx {\cf17 const}& lhs, {\cf17 const} T& rhs ) \{\par
3136             {\cf19 return} operator==( rhs, lhs );\par
3137         \}\par
3138 \par
3139         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3140         {\cf17 friend} {\cf18 bool} operator != ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
3141             {\cf19 return} !operator==( lhs, rhs );\par
3142         \}\par
3143 \par
3144         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3145         {\cf17 friend} {\cf18 bool} operator != ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
3146             {\cf19 return} !operator==( rhs, lhs );\par
3147         \}\par
3148 \par
3149         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3150         {\cf17 friend} {\cf18 bool} operator <= ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
3151             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) < rhs.m_value || lhs == rhs;\par
3152         \}\par
3153 \par
3154         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3155         {\cf17 friend} {\cf18 bool} operator <= ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
3156             {\cf19 return} lhs.m_value < {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
3157         \}\par
3158 \par
3159         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3160         {\cf17 friend} {\cf18 bool} operator >= ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
3161             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) > rhs.m_value || lhs == rhs;\par
3162         \}\par
3163 \par
3164         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3165         {\cf17 friend} {\cf18 bool} operator >= ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
3166             {\cf19 return} lhs.m_value > {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
3167         \}\par
3168 \par
3169         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3170         Approx& epsilon( T {\cf17 const}& newEpsilon ) \{\par
3171             {\cf17 const} {\cf17 auto} epsilonAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon);\par
3172             setEpsilon(epsilonAsDouble);\par
3173             {\cf19 return} *{\cf17 this};\par
3174         \}\par
3175 \par
3176         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3177         Approx& margin( T {\cf17 const}& newMargin ) \{\par
3178             {\cf17 const} {\cf17 auto} marginAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newMargin);\par
3179             setMargin(marginAsDouble);\par
3180             {\cf19 return} *{\cf17 this};\par
3181         \}\par
3182 \par
3183         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3184         Approx& scale( T {\cf17 const}& newScale ) \{\par
3185             m_scale = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale);\par
3186             {\cf19 return} *{\cf17 this};\par
3187         \}\par
3188 \par
3189         std::string toString() {\cf17 const};\par
3190 \par
3191     {\cf17 private}:\par
3192         {\cf18 double} m_epsilon;\par
3193         {\cf18 double} m_margin;\par
3194         {\cf18 double} m_scale;\par
3195         {\cf18 double} m_value;\par
3196     \};\par
3197 \par
3198 {\cf17 namespace }literals \{\par
3199     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 long} {\cf18 double} val);\par
3200     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 unsigned} {\cf18 long} {\cf18 long} val);\par
3201 \} {\cf20 // end namespace literals}\par
3202 \par
3203 {\cf17 template}<>\par
3204 {\cf17 struct }StringMaker<Catch::Approx> \{\par
3205     {\cf17 static} std::string convert(Catch::Approx {\cf17 const}& value);\par
3206 \};\par
3207 \par
3208 \} {\cf20 // end namespace Catch}\par
3209 \par
3210 {\cf21 #endif }{\cf20 // CATCH_APPROX_HPP_INCLUDED}\par
3211 \par
3212 \par
3213 {\cf21 #ifndef CATCH_ASSERTION_INFO_HPP_INCLUDED}\par
3214 {\cf21 #define CATCH_ASSERTION_INFO_HPP_INCLUDED}\par
3215 \par
3216 \par
3217 \par
3218 {\cf21 #ifndef CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}\par
3219 {\cf21 #define CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}\par
3220 \par
3221 {\cf21 #include <cstddef>}\par
3222 {\cf21 #include <iosfwd>}\par
3223 \par
3224 {\cf17 namespace }Catch \{\par
3225 \par
3226     {\cf17 struct }SourceLineInfo \{\par
3227 \par
3228         SourceLineInfo() = {\cf17 delete};\par
3229         {\cf17 constexpr} SourceLineInfo( {\cf18 char} {\cf17 const}* _file, std::size_t _line ) {\cf17 noexcept}:\par
3230             file( _file ),\par
3231             line( _line )\par
3232         \{\}\par
3233 \par
3234         {\cf18 bool} operator == ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept};\par
3235         {\cf18 bool} operator < ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept};\par
3236 \par
3237         {\cf18 char} {\cf17 const}* file;\par
3238         std::size_t line;\par
3239 \par
3240         {\cf17 friend} std::ostream& operator << (std::ostream& os, SourceLineInfo {\cf17 const}& info);\par
3241     \};\par
3242 \}\par
3243 \par
3244 {\cf21 #define CATCH_INTERNAL_LINEINFO \\}\par
3245 {\cf21     ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )}\par
3246 \par
3247 {\cf21 #endif }{\cf20 // CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}\par
3248 \par
3249 {\cf17 namespace }Catch \{\par
3250 \par
3251     {\cf17 struct }AssertionInfo \{\par
3252         {\cf20 // AssertionInfo() = delete;}\par
3253 \par
3254         StringRef macroName;\par
3255         SourceLineInfo lineInfo;\par
3256         StringRef capturedExpression;\par
3257         ResultDisposition::Flags resultDisposition;\par
3258     \};\par
3259 \par
3260 \} {\cf20 // end namespace Catch}\par
3261 \par
3262 {\cf21 #endif }{\cf20 // CATCH_ASSERTION_INFO_HPP_INCLUDED}\par
3263 \par
3264 \par
3265 {\cf21 #ifndef CATCH_ASSERTION_RESULT_HPP_INCLUDED}\par
3266 {\cf21 #define CATCH_ASSERTION_RESULT_HPP_INCLUDED}\par
3267 \par
3268 \par
3269 \par
3270 {\cf21 #ifndef CATCH_LAZY_EXPR_HPP_INCLUDED}\par
3271 {\cf21 #define CATCH_LAZY_EXPR_HPP_INCLUDED}\par
3272 \par
3273 {\cf21 #include <iosfwd>}\par
3274 \par
3275 {\cf17 namespace }Catch \{\par
3276 \par
3277     {\cf17 class }ITransientExpression;\par
3278 \par
3279     {\cf17 class }LazyExpression \{\par
3280         {\cf17 friend} {\cf17 class }AssertionHandler;\par
3281         {\cf17 friend} {\cf17 struct }AssertionStats;\par
3282         {\cf17 friend} {\cf17 class }RunContext;\par
3283 \par
3284         ITransientExpression {\cf17 const}* m_transientExpression = {\cf17 nullptr};\par
3285         {\cf18 bool} m_isNegated;\par
3286     {\cf17 public}:\par
3287         LazyExpression( {\cf18 bool} isNegated ):\par
3288             m_isNegated(isNegated)\par
3289         \{\}\par
3290         LazyExpression(LazyExpression {\cf17 const}& other) = {\cf19 default};\par
3291         LazyExpression& operator = ( LazyExpression {\cf17 const}& ) = {\cf17 delete};\par
3292 \par
3293         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
3294             {\cf19 return} m_transientExpression != {\cf17 nullptr};\par
3295         \}\par
3296 \par
3297         {\cf17 friend} {\cf17 auto} operator << ( std::ostream& os, LazyExpression {\cf17 const}& lazyExpr ) -> std::ostream&;\par
3298     \};\par
3299 \par
3300 \} {\cf20 // namespace Catch}\par
3301 \par
3302 {\cf21 #endif }{\cf20 // CATCH_LAZY_EXPR_HPP_INCLUDED}\par
3303 \par
3304 {\cf21 #include <string>}\par
3305 \par
3306 {\cf17 namespace }Catch \{\par
3307 \par
3308     {\cf17 struct }AssertionResultData\par
3309     \{\par
3310         AssertionResultData() = {\cf17 delete};\par
3311 \par
3312         AssertionResultData( ResultWas::OfType _resultType, LazyExpression {\cf17 const}& _lazyExpression );\par
3313 \par
3314         std::string message;\par
3315         {\cf17 mutable} std::string reconstructedExpression;\par
3316         LazyExpression lazyExpression;\par
3317         ResultWas::OfType resultType;\par
3318 \par
3319         std::string reconstructExpression() {\cf17 const};\par
3320     \};\par
3321 \par
3322     {\cf17 class }AssertionResult \{\par
3323     {\cf17 public}:\par
3324         AssertionResult() = {\cf17 delete};\par
3325         AssertionResult( AssertionInfo {\cf17 const}& info, AssertionResultData&& data );\par
3326 \par
3327         {\cf18 bool} isOk() {\cf17 const};\par
3328         {\cf18 bool} succeeded() {\cf17 const};\par
3329         ResultWas::OfType getResultType() {\cf17 const};\par
3330         {\cf18 bool} hasExpression() {\cf17 const};\par
3331         {\cf18 bool} hasMessage() {\cf17 const};\par
3332         std::string getExpression() {\cf17 const};\par
3333         std::string getExpressionInMacro() {\cf17 const};\par
3334         {\cf18 bool} hasExpandedExpression() {\cf17 const};\par
3335         std::string getExpandedExpression() {\cf17 const};\par
3336         StringRef getMessage() {\cf17 const};\par
3337         SourceLineInfo getSourceInfo() {\cf17 const};\par
3338         StringRef getTestMacroName() {\cf17 const};\par
3339 \par
3340     {\cf20 //protected:}\par
3341         AssertionInfo m_info;\par
3342         AssertionResultData m_resultData;\par
3343     \};\par
3344 \par
3345 \} {\cf20 // end namespace Catch}\par
3346 \par
3347 {\cf21 #endif }{\cf20 // CATCH_ASSERTION_RESULT_HPP_INCLUDED}\par
3348 \par
3349 \par
3350 {\cf21 #ifndef CATCH_CONFIG_HPP_INCLUDED}\par
3351 {\cf21 #define CATCH_CONFIG_HPP_INCLUDED}\par
3352 \par
3353 \par
3354 \par
3355 {\cf21 #ifndef CATCH_TEST_SPEC_HPP_INCLUDED}\par
3356 {\cf21 #define CATCH_TEST_SPEC_HPP_INCLUDED}\par
3357 \par
3358 {\cf21 #ifdef __clang__}\par
3359 {\cf21 #pragma clang diagnostic push}\par
3360 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
3361 {\cf21 #endif}\par
3362 \par
3363 \par
3364 \par
3365 {\cf21 #ifndef CATCH_WILDCARD_PATTERN_HPP_INCLUDED}\par
3366 {\cf21 #define CATCH_WILDCARD_PATTERN_HPP_INCLUDED}\par
3367 \par
3368 \par
3369 \par
3370 {\cf21 #ifndef CATCH_CASE_SENSITIVE_HPP_INCLUDED}\par
3371 {\cf21 #define CATCH_CASE_SENSITIVE_HPP_INCLUDED}\par
3372 \par
3373 {\cf17 namespace }Catch \{\par
3374 \par
3375     {\cf17 enum class} CaseSensitive \{ Yes, No \};\par
3376 \par
3377 \} {\cf20 // namespace Catch}\par
3378 \par
3379 {\cf21 #endif }{\cf20 // CATCH_CASE_SENSITIVE_HPP_INCLUDED}\par
3380 \par
3381 {\cf21 #include <string>}\par
3382 \par
3383 {\cf17 namespace }Catch\par
3384 \{\par
3385     {\cf17 class }WildcardPattern \{\par
3386         {\cf17 enum} WildcardPosition \{\par
3387             NoWildcard = 0,\par
3388             WildcardAtStart = 1,\par
3389             WildcardAtEnd = 2,\par
3390             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd\par
3391         \};\par
3392 \par
3393     {\cf17 public}:\par
3394 \par
3395         WildcardPattern( std::string {\cf17 const}& pattern, CaseSensitive caseSensitivity );\par
3396         {\cf18 bool} matches( std::string {\cf17 const}& str ) {\cf17 const};\par
3397 \par
3398     {\cf17 private}:\par
3399         std::string normaliseString( std::string {\cf17 const}& str ) {\cf17 const};\par
3400         CaseSensitive m_caseSensitivity;\par
3401         WildcardPosition m_wildcard = NoWildcard;\par
3402         std::string m_pattern;\par
3403     \};\par
3404 \}\par
3405 \par
3406 {\cf21 #endif }{\cf20 // CATCH_WILDCARD_PATTERN_HPP_INCLUDED}\par
3407 \par
3408 {\cf21 #include <iosfwd>}\par
3409 {\cf21 #include <string>}\par
3410 {\cf21 #include <vector>}\par
3411 \par
3412 {\cf17 namespace }Catch \{\par
3413 \par
3414     {\cf17 class }IConfig;\par
3415     {\cf17 struct }TestCaseInfo;\par
3416     {\cf17 class }TestCaseHandle;\par
3417 \par
3418     {\cf17 class }TestSpec \{\par
3419 \par
3420         {\cf17 class }Pattern \{\par
3421         {\cf17 public}:\par
3422             {\cf17 explicit} Pattern( std::string {\cf17 const}& name );\par
3423             {\cf17 virtual} ~Pattern();\par
3424             {\cf17 virtual} {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const} = 0;\par
3425             std::string {\cf17 const}& name() {\cf17 const};\par
3426         {\cf17 private}:\par
3427             {\cf17 virtual} {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const} = 0;\par
3428             {\cf20 // Writes string that would be reparsed into the pattern}\par
3429             {\cf17 friend} std::ostream& operator<<(std::ostream& out,\par
3430                                             Pattern {\cf17 const}& pattern) \{\par
3431                 pattern.serializeTo( out );\par
3432                 {\cf19 return} out;\par
3433             \}\par
3434 \par
3435             std::string {\cf17 const} m_name;\par
3436         \};\par
3437 \par
3438         {\cf17 class }NamePattern : {\cf17 public} Pattern \{\par
3439         {\cf17 public}:\par
3440             {\cf17 explicit} NamePattern( std::string {\cf17 const}& name, std::string {\cf17 const}& filterString );\par
3441             {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const override};\par
3442         {\cf17 private}:\par
3443             {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const override};\par
3444 \par
3445             WildcardPattern m_wildcardPattern;\par
3446         \};\par
3447 \par
3448         {\cf17 class }TagPattern : {\cf17 public} Pattern \{\par
3449         {\cf17 public}:\par
3450             {\cf17 explicit} TagPattern( std::string {\cf17 const}& tag, std::string {\cf17 const}& filterString );\par
3451             {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const override};\par
3452         {\cf17 private}:\par
3453             {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const override};\par
3454 \par
3455             std::string m_tag;\par
3456         \};\par
3457 \par
3458         {\cf17 struct }Filter \{\par
3459             std::vector<Detail::unique_ptr<Pattern>> m_required;\par
3460             std::vector<Detail::unique_ptr<Pattern>> m_forbidden;\par
3461 \par
3464             {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const};\par
3465             {\cf17 friend} std::ostream& operator<<(std::ostream& out, Filter {\cf17 const}& f) \{\par
3466                 f.serializeTo( out );\par
3467                 {\cf19 return} out;\par
3468             \}\par
3469 \par
3470             {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const};\par
3471         \};\par
3472 \par
3473         {\cf17 static} std::string extractFilterName( Filter {\cf17 const}& filter );\par
3474 \par
3475     {\cf17 public}:\par
3476         {\cf17 struct }FilterMatch \{\par
3477             std::string name;\par
3478             std::vector<TestCaseHandle const*> tests;\par
3479         \};\par
3480         {\cf17 using }Matches = std::vector<FilterMatch>;\par
3481         {\cf17 using }vectorStrings = std::vector<std::string>;\par
3482 \par
3483         {\cf18 bool} hasFilters() {\cf17 const};\par
3484         {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const};\par
3485         Matches matchesByFilter( std::vector<TestCaseHandle> {\cf17 const}& testCases, IConfig {\cf17 const}& config ) {\cf17 const};\par
3486         {\cf17 const} vectorStrings & getInvalidSpecs() {\cf17 const};\par
3487 \par
3488     {\cf17 private}:\par
3489         std::vector<Filter> m_filters;\par
3490         std::vector<std::string> m_invalidSpecs;\par
3491 \par
3492         {\cf17 friend} {\cf17 class }TestSpecParser;\par
3495         {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const};\par
3496         {\cf17 friend} std::ostream& operator<<(std::ostream& out,\par
3497                                         TestSpec {\cf17 const}& spec) \{\par
3498             spec.serializeTo( out );\par
3499             {\cf19 return} out;\par
3500         \}\par
3501     \};\par
3502 \}\par
3503 \par
3504 {\cf21 #ifdef __clang__}\par
3505 {\cf21 #pragma clang diagnostic pop}\par
3506 {\cf21 #endif}\par
3507 \par
3508 {\cf21 #endif }{\cf20 // CATCH_TEST_SPEC_HPP_INCLUDED}\par
3509 \par
3510 \par
3511 {\cf21 #ifndef CATCH_OPTIONAL_HPP_INCLUDED}\par
3512 {\cf21 #define CATCH_OPTIONAL_HPP_INCLUDED}\par
3513 \par
3514 \par
3515 {\cf21 #include <cassert>}\par
3516 \par
3517 {\cf17 namespace }Catch \{\par
3518 \par
3519     {\cf20 // An optional type}\par
3520     {\cf17 template}<{\cf17 typename} T>\par
3521     {\cf17 class }Optional \{\par
3522     {\cf17 public}:\par
3523         Optional(): nullableValue( nullptr ) \{\}\par
3524         ~Optional() \{ reset(); \}\par
3525 \par
3526         Optional( T {\cf17 const}& _value ):\par
3527             nullableValue( new ( storage ) T( _value ) ) \{\}\par
3528         Optional( T&& _value ):\par
3529             nullableValue( new ( storage ) T( CATCH_MOVE( _value ) ) ) \{\}\par
3530 \par
3531         Optional& operator=( T {\cf17 const}& _value ) \{\par
3532             reset();\par
3533             nullableValue = {\cf17 new} ( storage ) T( _value );\par
3534             {\cf19 return} *{\cf17 this};\par
3535         \}\par
3536         Optional& operator=( T&& _value ) \{\par
3537             reset();\par
3538             nullableValue = {\cf17 new} ( storage ) T( CATCH_MOVE( _value ) );\par
3539             {\cf19 return} *{\cf17 this};\par
3540         \}\par
3541 \par
3542         Optional( Optional {\cf17 const}& _other ):\par
3543             nullableValue( _other ? new ( storage ) T( *_other ) : nullptr ) \{\}\par
3544         Optional( Optional&& _other ):\par
3545             nullableValue( _other ? new ( storage ) T( CATCH_MOVE( *_other ) )\par
3546                                   : nullptr ) \{\}\par
3547 \par
3548         Optional& operator=( Optional {\cf17 const}& _other ) \{\par
3549             {\cf19 if} ( &_other != {\cf17 this} ) \{\par
3550                 reset();\par
3551                 {\cf19 if} ( _other ) \{ nullableValue = {\cf17 new} ( storage ) T( *_other ); \}\par
3552             \}\par
3553             {\cf19 return} *{\cf17 this};\par
3554         \}\par
3555         Optional& operator=( Optional&& _other ) \{\par
3556             {\cf19 if} ( &_other != {\cf17 this} ) \{\par
3557                 reset();\par
3558                 {\cf19 if} ( _other ) \{\par
3559                     nullableValue = {\cf17 new} ( storage ) T( CATCH_MOVE( *_other ) );\par
3560                 \}\par
3561             \}\par
3562             {\cf19 return} *{\cf17 this};\par
3563         \}\par
3564 \par
3565         {\cf18 void} reset() \{\par
3566             {\cf19 if} ( nullableValue ) \{ nullableValue->~T(); \}\par
3567             nullableValue = {\cf17 nullptr};\par
3568         \}\par
3569 \par
3570         T& operator*() \{\par
3571             assert(nullableValue);\par
3572             {\cf19 return} *nullableValue;\par
3573         \}\par
3574         T {\cf17 const}& operator*(){\cf17  const }\{\par
3575             assert(nullableValue);\par
3576             {\cf19 return} *nullableValue;\par
3577         \}\par
3578         T* operator->() \{\par
3579             assert(nullableValue);\par
3580             {\cf19 return} nullableValue;\par
3581         \}\par
3582         {\cf17 const} T* operator->(){\cf17  const }\{\par
3583             assert(nullableValue);\par
3584             {\cf19 return} nullableValue;\par
3585         \}\par
3586 \par
3587         T valueOr( T {\cf17 const}& defaultValue ){\cf17  const }\{\par
3588             {\cf19 return} nullableValue ? *nullableValue : defaultValue;\par
3589         \}\par
3590 \par
3591         {\cf18 bool} some(){\cf17  const }\{ {\cf19 return} nullableValue != {\cf17 nullptr}; \}\par
3592         {\cf18 bool} none(){\cf17  const }\{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
3593 \par
3594         {\cf18 bool} operator !(){\cf17  const }\{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
3595         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
3596             {\cf19 return} some();\par
3597         \}\par
3598 \par
3599         {\cf17 friend} {\cf18 bool} operator==(Optional {\cf17 const}& a, Optional {\cf17 const}& b) \{\par
3600             {\cf19 if} (a.none() && b.none()) \{\par
3601                 {\cf19 return} {\cf17 true};\par
3602             \} {\cf19 else} {\cf19 if} (a.some() && b.some()) \{\par
3603                 {\cf19 return} *a == *b;\par
3604             \} {\cf19 else} \{\par
3605                 {\cf19 return} {\cf17 false};\par
3606             \}\par
3607         \}\par
3608         {\cf17 friend} {\cf18 bool} operator!=(Optional {\cf17 const}& a, Optional {\cf17 const}& b) \{\par
3609             {\cf19 return} !( a == b );\par
3610         \}\par
3611 \par
3612     {\cf17 private}:\par
3613         T* nullableValue;\par
3614         {\cf17 alignas}({\cf17 alignof}(T)) {\cf18 char} storage[{\cf17 sizeof}(T)];\par
3615     \};\par
3616 \par
3617 \} {\cf20 // end namespace Catch}\par
3618 \par
3619 {\cf21 #endif }{\cf20 // CATCH_OPTIONAL_HPP_INCLUDED}\par
3620 \par
3621 \par
3622 {\cf21 #ifndef CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}\par
3623 {\cf21 #define CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}\par
3624 \par
3625 {\cf21 #include <cstdint>}\par
3626 \par
3627 {\cf17 namespace }Catch \{\par
3628 \par
3629     {\cf17 enum class} GenerateFrom \{\par
3630         Time,\par
3631         RandomDevice,\par
3633         Default\par
3634     \};\par
3635 \par
3636     std::uint32_t generateRandomSeed(GenerateFrom from);\par
3637 \par
3638 \} {\cf20 // end namespace Catch}\par
3639 \par
3640 {\cf21 #endif }{\cf20 // CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}\par
3641 \par
3642 \par
3643 {\cf21 #ifndef CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}\par
3644 {\cf21 #define CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}\par
3645 \par
3646 \par
3647 {\cf21 #include <map>}\par
3648 {\cf21 #include <string>}\par
3649 {\cf21 #include <vector>}\par
3650 \par
3651 {\cf17 namespace }Catch \{\par
3652 \par
3653     {\cf17 enum class} ColourMode : std::uint8_t;\par
3654 \par
3655     {\cf17 namespace }Detail \{\par
3657         std::vector<std::string> splitReporterSpec( StringRef reporterSpec );\par
3658 \par
3659         Optional<ColourMode> stringToColourMode( StringRef colourMode );\par
3660     \}\par
3661 \par
3670     {\cf17 class }ReporterSpec \{\par
3671         std::string m_name;\par
3672         Optional<std::string> m_outputFileName;\par
3673         Optional<ColourMode> m_colourMode;\par
3674         std::map<std::string, std::string> m_customOptions;\par
3675 \par
3676         {\cf17 friend} {\cf18 bool} operator==( ReporterSpec {\cf17 const}& lhs,\par
3677                                 ReporterSpec {\cf17 const}& rhs );\par
3678         {\cf17 friend} {\cf18 bool} operator!=( ReporterSpec {\cf17 const}& lhs,\par
3679                                 ReporterSpec {\cf17 const}& rhs ) \{\par
3680             {\cf19 return} !( lhs == rhs );\par
3681         \}\par
3682 \par
3683     {\cf17 public}:\par
3684         ReporterSpec(\par
3685             std::string name,\par
3686             Optional<std::string> outputFileName,\par
3687             Optional<ColourMode> colourMode,\par
3688             std::map<std::string, std::string> customOptions );\par
3689 \par
3690         std::string {\cf17 const}& name(){\cf17  const }\{ {\cf19 return} m_name; \}\par
3691 \par
3692         Optional<std::string> {\cf17 const}& outputFile(){\cf17  const }\{\par
3693             {\cf19 return} m_outputFileName;\par
3694         \}\par
3695 \par
3696         Optional<ColourMode> {\cf17 const}& colourMode(){\cf17  const }\{ {\cf19 return} m_colourMode; \}\par
3697 \par
3698         std::map<std::string, std::string> {\cf17 const}& customOptions(){\cf17  const }\{\par
3699             {\cf19 return} m_customOptions;\par
3700         \}\par
3701     \};\par
3702 \par
3713     Optional<ReporterSpec> parseReporterSpec( StringRef reporterSpec );\par
3714 \par
3715 \}\par
3716 \par
3717 {\cf21 #endif }{\cf20 // CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}\par
3718 \par
3719 {\cf21 #include <chrono>}\par
3720 {\cf21 #include <map>}\par
3721 {\cf21 #include <string>}\par
3722 {\cf21 #include <vector>}\par
3723 \par
3724 {\cf17 namespace }Catch \{\par
3725 \par
3726     {\cf17 class }IStream;\par
3727 \par
3733     {\cf17 struct }ProcessedReporterSpec \{\par
3734         std::string name;\par
3735         std::string outputFilename;\par
3736         ColourMode colourMode;\par
3737         std::map<std::string, std::string> customOptions;\par
3738         {\cf17 friend} {\cf18 bool} operator==( ProcessedReporterSpec {\cf17 const}& lhs,\par
3739                                 ProcessedReporterSpec {\cf17 const}& rhs );\par
3740         {\cf17 friend} {\cf18 bool} operator!=( ProcessedReporterSpec {\cf17 const}& lhs,\par
3741                                 ProcessedReporterSpec {\cf17 const}& rhs ) \{\par
3742             {\cf19 return} !( lhs == rhs );\par
3743         \}\par
3744     \};\par
3745 \par
3746     {\cf17 struct }ConfigData \{\par
3747 \par
3748         {\cf18 bool} listTests = {\cf17 false};\par
3749         {\cf18 bool} listTags = {\cf17 false};\par
3750         {\cf18 bool} listReporters = {\cf17 false};\par
3751         {\cf18 bool} listListeners = {\cf17 false};\par
3752 \par
3753         {\cf18 bool} showSuccessfulTests = {\cf17 false};\par
3754         {\cf18 bool} shouldDebugBreak = {\cf17 false};\par
3755         {\cf18 bool} noThrow = {\cf17 false};\par
3756         {\cf18 bool} showHelp = {\cf17 false};\par
3757         {\cf18 bool} showInvisibles = {\cf17 false};\par
3758         {\cf18 bool} filenamesAsTags = {\cf17 false};\par
3759         {\cf18 bool} libIdentify = {\cf17 false};\par
3760         {\cf18 bool} allowZeroTests = {\cf17 false};\par
3761 \par
3762         {\cf18 int} abortAfter = -1;\par
3763         uint32_t rngSeed = generateRandomSeed(GenerateFrom::Default);\par
3764 \par
3765         {\cf18 unsigned} {\cf18 int} shardCount = 1;\par
3766         {\cf18 unsigned} {\cf18 int} shardIndex = 0;\par
3767 \par
3768         {\cf18 bool} skipBenchmarks = {\cf17 false};\par
3769         {\cf18 bool} benchmarkNoAnalysis = {\cf17 false};\par
3770         {\cf18 unsigned} {\cf18 int} benchmarkSamples = 100;\par
3771         {\cf18 double} benchmarkConfidenceInterval = 0.95;\par
3772         {\cf18 unsigned} {\cf18 int} benchmarkResamples = 100'000;\par
3773         std::chrono::milliseconds::rep benchmarkWarmupTime = 100;\par
3774 \par
3775         Verbosity verbosity = Verbosity::Normal;\par
3776         WarnAbout::What warnings = WarnAbout::Nothing;\par
3777         ShowDurations showDurations = ShowDurations::DefaultForReporter;\par
3778         {\cf18 double} minDuration = -1;\par
3779         TestRunOrder runOrder = TestRunOrder::Declared;\par
3780         ColourMode defaultColourMode = ColourMode::PlatformDefault;\par
3781         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;\par
3782 \par
3783         std::string defaultOutputFilename;\par
3784         std::string name;\par
3785         std::string processName;\par
3786         std::vector<ReporterSpec> reporterSpecifications;\par
3787 \par
3788         std::vector<std::string> testsOrTags;\par
3789         std::vector<std::string> sectionsToRun;\par
3790     \};\par
3791 \par
3792 \par
3793     {\cf17 class }Config : {\cf17 public} IConfig \{\par
3794     {\cf17 public}:\par
3795 \par
3796         Config() = {\cf19 default};\par
3797         Config( ConfigData {\cf17 const}& data );\par
3798         ~Config() {\cf17 override}; {\cf20 // = default in the cpp file}\par
3799 \par
3800         {\cf18 bool} listTests() {\cf17 const};\par
3801         {\cf18 bool} listTags() {\cf17 const};\par
3802         {\cf18 bool} listReporters() {\cf17 const};\par
3803         {\cf18 bool} listListeners() {\cf17 const};\par
3804 \par
3805         std::vector<ReporterSpec> {\cf17 const}& getReporterSpecs() {\cf17 const};\par
3806         std::vector<ProcessedReporterSpec> {\cf17 const}&\par
3807         getProcessedReporterSpecs() {\cf17 const};\par
3808 \par
3809         std::vector<std::string> {\cf17 const}& getTestsOrTags() {\cf17 const override};\par
3810         std::vector<std::string> {\cf17 const}& getSectionsToRun() {\cf17 const override};\par
3811 \par
3812         TestSpec {\cf17 const}& testSpec() {\cf17 const override};\par
3813         {\cf18 bool} hasTestFilters() {\cf17 const override};\par
3814 \par
3815         {\cf18 bool} showHelp() {\cf17 const};\par
3816 \par
3817         {\cf20 // IConfig interface}\par
3818         {\cf18 bool} allowThrows() {\cf17 const override};\par
3819         StringRef name() {\cf17 const override};\par
3820         {\cf18 bool} includeSuccessfulResults() {\cf17 const override};\par
3821         {\cf18 bool} warnAboutMissingAssertions() {\cf17 const override};\par
3822         {\cf18 bool} warnAboutUnmatchedTestSpecs() {\cf17 const override};\par
3823         {\cf18 bool} zeroTestsCountAsSuccess() {\cf17 const override};\par
3824         ShowDurations showDurations() {\cf17 const override};\par
3825         {\cf18 double} minDuration() {\cf17 const override};\par
3826         TestRunOrder runOrder() {\cf17 const override};\par
3827         uint32_t rngSeed() {\cf17 const override};\par
3828         {\cf18 unsigned} {\cf18 int} shardCount() {\cf17 const override};\par
3829         {\cf18 unsigned} {\cf18 int} shardIndex() {\cf17 const override};\par
3830         ColourMode defaultColourMode() {\cf17 const override};\par
3831         {\cf18 bool} shouldDebugBreak() {\cf17 const override};\par
3832         {\cf18 int} abortAfter() {\cf17 const override};\par
3833         {\cf18 bool} showInvisibles() {\cf17 const override};\par
3834         Verbosity verbosity() {\cf17 const override};\par
3835         {\cf18 bool} skipBenchmarks() {\cf17 const override};\par
3836         {\cf18 bool} benchmarkNoAnalysis() {\cf17 const override};\par
3837         {\cf18 unsigned} {\cf18 int} benchmarkSamples() {\cf17 const override};\par
3838         {\cf18 double} benchmarkConfidenceInterval() {\cf17 const override};\par
3839         {\cf18 unsigned} {\cf18 int} benchmarkResamples() {\cf17 const override};\par
3840         std::chrono::milliseconds benchmarkWarmupTime() {\cf17 const override};\par
3841 \par
3842     {\cf17 private}:\par
3843         {\cf20 // Reads Bazel env vars and applies them to the config}\par
3844         {\cf18 void} readBazelEnvVars();\par
3845 \par
3846         ConfigData m_data;\par
3847         std::vector<ProcessedReporterSpec> m_processedReporterSpecs;\par
3848         TestSpec m_testSpec;\par
3849         {\cf18 bool} m_hasTestFilters = {\cf17 false};\par
3850     \};\par
3851 \} {\cf20 // end namespace Catch}\par
3852 \par
3853 {\cf21 #endif }{\cf20 // CATCH_CONFIG_HPP_INCLUDED}\par
3854 \par
3855 \par
3856 {\cf21 #ifndef CATCH_GET_RANDOM_SEED_HPP_INCLUDED}\par
3857 {\cf21 #define CATCH_GET_RANDOM_SEED_HPP_INCLUDED}\par
3858 \par
3859 {\cf21 #include <cstdint>}\par
3860 \par
3861 {\cf17 namespace }Catch \{\par
3863     std::uint32_t getSeed();\par
3864 \}\par
3865 \par
3866 {\cf21 #endif }{\cf20 // CATCH_GET_RANDOM_SEED_HPP_INCLUDED}\par
3867 \par
3868 \par
3869 {\cf21 #ifndef CATCH_MESSAGE_HPP_INCLUDED}\par
3870 {\cf21 #define CATCH_MESSAGE_HPP_INCLUDED}\par
3871 \par
3872 \par
3873 \par
3874 \par
3886 {\cf21 #ifndef CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}\par
3887 {\cf21 #define CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}\par
3888 \par
3889 \par
3890 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_PREFIX_MESSAGES)}\par
3891 {\cf21     #define CATCH_CONFIG_PREFIX_MESSAGES}\par
3892 {\cf21 #endif}\par
3893 \par
3894 {\cf21 #endif }{\cf20 // CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}\par
3895 \par
3896 \par
3897 {\cf21 #ifndef CATCH_STREAM_END_STOP_HPP_INCLUDED}\par
3898 {\cf21 #define CATCH_STREAM_END_STOP_HPP_INCLUDED}\par
3899 \par
3900 \par
3901 {\cf17 namespace }Catch \{\par
3902 \par
3903     {\cf20 // Use this in variadic streaming macros to allow}\par
3904     {\cf20 //    << +StreamEndStop}\par
3905     {\cf20 // as well as}\par
3906     {\cf20 //    << stuff +StreamEndStop}\par
3907     {\cf17 struct }StreamEndStop \{\par
3908         {\cf17 constexpr} StringRef operator+(){\cf17  const }\{ {\cf19 return} StringRef(); \}\par
3909 \par
3910         {\cf17 template} <{\cf17 typename} T>\par
3911         {\cf17 constexpr} {\cf17 friend} T {\cf17 const}& operator+( T {\cf17 const}& value, StreamEndStop ) \{\par
3912             {\cf19 return} value;\par
3913         \}\par
3914     \};\par
3915 \par
3916 \} {\cf20 // namespace Catch}\par
3917 \par
3918 {\cf21 #endif }{\cf20 // CATCH_STREAM_END_STOP_HPP_INCLUDED}\par
3919 \par
3920 \par
3921 {\cf21 #ifndef CATCH_MESSAGE_INFO_HPP_INCLUDED}\par
3922 {\cf21 #define CATCH_MESSAGE_INFO_HPP_INCLUDED}\par
3923 \par
3924 \par
3925 {\cf21 #include <string>}\par
3926 \par
3927 {\cf17 namespace }Catch \{\par
3928 \par
3929     {\cf17 struct }MessageInfo \{\par
3930         MessageInfo(    StringRef _macroName,\par
3931                         SourceLineInfo {\cf17 const}& _lineInfo,\par
3932                         ResultWas::OfType _type );\par
3933 \par
3934         StringRef macroName;\par
3935         std::string message;\par
3936         SourceLineInfo lineInfo;\par
3937         ResultWas::OfType type;\par
3938         {\cf18 unsigned} {\cf18 int} sequence;\par
3939 \par
3940         {\cf18 bool} operator == (MessageInfo {\cf17 const}& other){\cf17  const }\{\par
3941             {\cf19 return} sequence == other.sequence;\par
3942         \}\par
3943         {\cf18 bool} operator < (MessageInfo {\cf17 const}& other){\cf17  const }\{\par
3944             {\cf19 return} sequence < other.sequence;\par
3945         \}\par
3946     {\cf17 private}:\par
3947         {\cf17 static} {\cf18 unsigned} {\cf18 int} globalCount;\par
3948     \};\par
3949 \par
3950 \} {\cf20 // end namespace Catch}\par
3951 \par
3952 {\cf21 #endif }{\cf20 // CATCH_MESSAGE_INFO_HPP_INCLUDED}\par
3953 \par
3954 {\cf21 #include <string>}\par
3955 {\cf21 #include <vector>}\par
3956 \par
3957 {\cf17 namespace }Catch \{\par
3958 \par
3959     {\cf17 struct }SourceLineInfo;\par
3960     {\cf17 class }IResultCapture;\par
3961 \par
3962     {\cf17 struct }MessageStream \{\par
3963 \par
3964         {\cf17 template}<{\cf17 typename} T>\par
3965         MessageStream& operator << ( T {\cf17 const}& value ) \{\par
3966             m_stream << value;\par
3967             {\cf19 return} *{\cf17 this};\par
3968         \}\par
3969 \par
3970         ReusableStringStream m_stream;\par
3971     \};\par
3972 \par
3973     {\cf17 struct }MessageBuilder : MessageStream \{\par
3974         MessageBuilder( StringRef macroName,\par
3975                         SourceLineInfo {\cf17 const}& lineInfo,\par
3976                         ResultWas::OfType type ):\par
3977             m_info(macroName, lineInfo, type) \{\}\par
3978 \par
3979         {\cf17 template}<{\cf17 typename} T>\par
3980         MessageBuilder&& operator << ( T {\cf17 const}& value ) && \{\par
3981             m_stream << value;\par
3982             {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
3983         \}\par
3984 \par
3985         MessageInfo m_info;\par
3986     \};\par
3987 \par
3988     {\cf17 class }ScopedMessage \{\par
3989     {\cf17 public}:\par
3990         {\cf17 explicit} ScopedMessage( MessageBuilder&& builder );\par
3991         ScopedMessage( ScopedMessage& duplicate ) = {\cf17 delete};\par
3992         ScopedMessage( ScopedMessage&& old ) {\cf17 noexcept};\par
3993         ~ScopedMessage();\par
3994 \par
3995         MessageInfo m_info;\par
3996         {\cf18 bool} m_moved = {\cf17 false};\par
3997     \};\par
3998 \par
3999     {\cf17 class }Capturer \{\par
4000         std::vector<MessageInfo> m_messages;\par
4001         IResultCapture& m_resultCapture;\par
4002         {\cf18 size_t} m_captured = 0;\par
4003     {\cf17 public}:\par
4004         Capturer( StringRef macroName, SourceLineInfo {\cf17 const}& lineInfo, ResultWas::OfType resultType, StringRef names );\par
4005 \par
4006         Capturer(Capturer {\cf17 const}&) = {\cf17 delete};\par
4007         Capturer& operator=(Capturer {\cf17 const}&) = {\cf17 delete};\par
4008 \par
4009         ~Capturer();\par
4010 \par
4011         {\cf18 void} captureValue( {\cf18 size_t} index, std::string {\cf17 const}& value );\par
4012 \par
4013         {\cf17 template}<{\cf17 typename} T>\par
4014         {\cf18 void} captureValues( {\cf18 size_t} index, T {\cf17 const}& value ) \{\par
4015             captureValue( index, Catch::Detail::stringify( value ) );\par
4016         \}\par
4017 \par
4018         {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Ts>\par
4019         {\cf18 void} captureValues( {\cf18 size_t} index, T {\cf17 const}& value, Ts {\cf17 const}&... values ) \{\par
4020             captureValue( index, Catch::Detail::stringify(value) );\par
4021             captureValues( index+1, values... );\par
4022         \}\par
4023     \};\par
4024 \par
4025 \} {\cf20 // end namespace Catch}\par
4026 \par
4028 {\cf21 #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \\}\par
4029 {\cf21     do \{ \\}\par
4030 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \\}\par
4031 {\cf21         catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \\}\par
4032 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
4033 {\cf21     \} while( false )}\par
4034 \par
4036 {\cf21 #define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \\}\par
4037 {\cf21     Catch::Capturer varName( macroName##_catch_sr,        \\}\par
4038 {\cf21                              CATCH_INTERNAL_LINEINFO,     \\}\par
4039 {\cf21                              Catch::ResultWas::Info,      \\}\par
4040 {\cf21                              #__VA_ARGS__##_catch_sr );   \\}\par
4041 {\cf21     varName.captureValues( 0, __VA_ARGS__ )}\par
4042 \par
4044 {\cf21 #define INTERNAL_CATCH_INFO( macroName, log ) \\}\par
4045 {\cf21     const Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )}\par
4046 \par
4048 {\cf21 #define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \\}\par
4049 {\cf21     Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )}\par
4050 \par
4051 \par
4052 {\cf21 #if defined(CATCH_CONFIG_PREFIX_MESSAGES) && !defined(CATCH_CONFIG_DISABLE)}\par
4053 \par
4054 {\cf21   #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )}\par
4055 {\cf21   #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "CATCH_UNSCOPED_INFO", msg )}\par
4056 {\cf21   #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}\par
4057 {\cf21   #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CATCH_CAPTURE", __VA_ARGS__ )}\par
4058 \par
4059 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_MESSAGES) && defined(CATCH_CONFIG_DISABLE)}\par
4060 \par
4061 {\cf21   #define CATCH_INFO( msg )          (void)(0)}\par
4062 {\cf21   #define CATCH_UNSCOPED_INFO( msg ) (void)(0)}\par
4063 {\cf21   #define CATCH_WARN( msg )          (void)(0)}\par
4064 {\cf21   #define CATCH_CAPTURE( ... )       (void)(0)}\par
4065 \par
4066 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_MESSAGES) && !defined(CATCH_CONFIG_DISABLE)}\par
4067 \par
4068 {\cf21   #define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )}\par
4069 {\cf21   #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "UNSCOPED_INFO", msg )}\par
4070 {\cf21   #define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}\par
4071 {\cf21   #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CAPTURE", __VA_ARGS__ )}\par
4072 \par
4073 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_MESSAGES) && defined(CATCH_CONFIG_DISABLE)}\par
4074 \par
4075 {\cf21   #define INFO( msg )          (void)(0)}\par
4076 {\cf21   #define UNSCOPED_INFO( msg ) (void)(0)}\par
4077 {\cf21   #define WARN( msg )          (void)(0)}\par
4078 {\cf21   #define CAPTURE( ... )       (void)(0)}\par
4079 \par
4080 {\cf21 #endif }{\cf20 // end of user facing macro declarations}\par
4081 \par
4082 \par
4083 \par
4084 \par
4085 {\cf21 #endif }{\cf20 // CATCH_MESSAGE_HPP_INCLUDED}\par
4086 \par
4087 \par
4088 {\cf21 #ifndef CATCH_SECTION_INFO_HPP_INCLUDED}\par
4089 {\cf21 #define CATCH_SECTION_INFO_HPP_INCLUDED}\par
4090 \par
4091 \par
4092 \par
4093 {\cf21 #ifndef CATCH_TOTALS_HPP_INCLUDED}\par
4094 {\cf21 #define CATCH_TOTALS_HPP_INCLUDED}\par
4095 \par
4096 {\cf21 #include <cstdint>}\par
4097 \par
4098 {\cf17 namespace }Catch \{\par
4099 \par
4100     {\cf17 struct }Counts \{\par
4101         Counts operator - ( Counts {\cf17 const}& other ) {\cf17 const};\par
4102         Counts& operator += ( Counts {\cf17 const}& other );\par
4103 \par
4104         std::uint64_t total() {\cf17 const};\par
4105         {\cf18 bool} allPassed() {\cf17 const};\par
4106         {\cf18 bool} allOk() {\cf17 const};\par
4107 \par
4108         std::uint64_t passed = 0;\par
4109         std::uint64_t failed = 0;\par
4110         std::uint64_t failedButOk = 0;\par
4111         std::uint64_t skipped = 0;\par
4112     \};\par
4113 \par
4114     {\cf17 struct }Totals \{\par
4115 \par
4116         Totals operator - ( Totals {\cf17 const}& other ) {\cf17 const};\par
4117         Totals& operator += ( Totals {\cf17 const}& other );\par
4118 \par
4119         Totals delta( Totals {\cf17 const}& prevTotals ) {\cf17 const};\par
4120 \par
4121         Counts assertions;\par
4122         Counts testCases;\par
4123     \};\par
4124 \}\par
4125 \par
4126 {\cf21 #endif }{\cf20 // CATCH_TOTALS_HPP_INCLUDED}\par
4127 \par
4128 {\cf21 #include <string>}\par
4129 \par
4130 {\cf17 namespace }Catch \{\par
4131 \par
4132     {\cf17 struct }SectionInfo \{\par
4133         {\cf20 // The last argument is ignored, so that people can write}\par
4134         {\cf20 // SECTION("ShortName", "Proper description that is long") and}\par
4135         {\cf20 // still use the `-c` flag comfortably.}\par
4136         SectionInfo( SourceLineInfo {\cf17 const}& _lineInfo, std::string _name,\par
4137                     {\cf17 const} {\cf18 char}* {\cf17 const} = {\cf17 nullptr} ):\par
4138             name(CATCH_MOVE(_name)),\par
4139             lineInfo(_lineInfo)\par
4140             \{\}\par
4141 \par
4142         std::string name;\par
4143         SourceLineInfo lineInfo;\par
4144     \};\par
4145 \par
4146     {\cf17 struct }SectionEndInfo \{\par
4147         SectionInfo sectionInfo;\par
4148         Counts prevAssertions;\par
4149         {\cf18 double} durationInSeconds;\par
4150     \};\par
4151 \par
4152 \} {\cf20 // end namespace Catch}\par
4153 \par
4154 {\cf21 #endif }{\cf20 // CATCH_SECTION_INFO_HPP_INCLUDED}\par
4155 \par
4156 \par
4157 {\cf21 #ifndef CATCH_SESSION_HPP_INCLUDED}\par
4158 {\cf21 #define CATCH_SESSION_HPP_INCLUDED}\par
4159 \par
4160 \par
4161 \par
4162 {\cf21 #ifndef CATCH_COMMANDLINE_HPP_INCLUDED}\par
4163 {\cf21 #define CATCH_COMMANDLINE_HPP_INCLUDED}\par
4164 \par
4165 \par
4166 \par
4167 {\cf21 #ifndef CATCH_CLARA_HPP_INCLUDED}\par
4168 {\cf21 #define CATCH_CLARA_HPP_INCLUDED}\par
4169 \par
4170 {\cf21 #if defined( __clang__ )}\par
4171 {\cf21 #    pragma clang diagnostic push}\par
4172 {\cf21 #    pragma clang diagnostic ignored "-Wweak-vtables"}\par
4173 {\cf21 #    pragma clang diagnostic ignored "-Wshadow"}\par
4174 {\cf21 #    pragma clang diagnostic ignored "-Wdeprecated"}\par
4175 {\cf21 #endif}\par
4176 \par
4177 {\cf21 #if defined( __GNUC__ )}\par
4178 {\cf21 #    pragma GCC diagnostic push}\par
4179 {\cf21 #    pragma GCC diagnostic ignored "-Wsign-conversion"}\par
4180 {\cf21 #endif}\par
4181 \par
4182 {\cf21 #ifndef CLARA_CONFIG_OPTIONAL_TYPE}\par
4183 {\cf21 #    ifdef __has_include}\par
4184 {\cf21 #        if __has_include( <optional>) && __cplusplus >= 201703L}\par
4185 {\cf21 #            include <optional>}\par
4186 {\cf21 #            define CLARA_CONFIG_OPTIONAL_TYPE std::optional}\par
4187 {\cf21 #        endif}\par
4188 {\cf21 #    endif}\par
4189 {\cf21 #endif}\par
4190 \par
4191 \par
4192 {\cf21 #include <cassert>}\par
4193 {\cf21 #include <memory>}\par
4194 {\cf21 #include <ostream>}\par
4195 {\cf21 #include <sstream>}\par
4196 {\cf21 #include <string>}\par
4197 {\cf21 #include <type_traits>}\par
4198 {\cf21 #include <vector>}\par
4199 \par
4200 {\cf17 namespace }Catch \{\par
4201     {\cf17 namespace }Clara \{\par
4202 \par
4203         {\cf17 class }Args;\par
4204         {\cf17 class }Parser;\par
4205 \par
4206         {\cf20 // enum of result types from a parse}\par
4207         {\cf17 enum class} ParseResultType \{\par
4208             Matched,\par
4209             NoMatch,\par
4210             ShortCircuitAll,\par
4211             ShortCircuitSame\par
4212         \};\par
4213 \par
4214         {\cf17 struct }accept_many_t \{\};\par
4215         {\cf17 constexpr} accept_many_t accept_many \{\};\par
4216 \par
4217         {\cf17 namespace }Detail \{\par
4218             {\cf17 struct }fake_arg \{\par
4219                 {\cf17 template} <{\cf17 typename} T>\par
4220                 {\cf17 operator} T();\par
4221             \};\par
4222 \par
4223             {\cf17 template} <{\cf17 typename} F, {\cf17 typename} = {\cf18 void}>\par
4224             {\cf17 struct }is_unary_function : std::false_type \{\};\par
4225 \par
4226             {\cf17 template} <{\cf17 typename} F>\par
4227             {\cf17 struct }is_unary_function<\par
4228                 F,\par
4229                 Catch::Detail::void_t<decltype(\par
4230                     std::declval<F>()( fake_arg() ) )\par
4231                 >\par
4232             > : std::true_type \{\};\par
4233 \par
4234             {\cf20 // Traits for extracting arg and return type of lambdas (for single}\par
4235             {\cf20 // argument lambdas)}\par
4236             {\cf17 template} <{\cf17 typename} L>\par
4237             {\cf17 struct }UnaryLambdaTraits\par
4238                 : UnaryLambdaTraits<decltype( &L::operator() )> \{\};\par
4239 \par
4240             {\cf17 template} <{\cf17 typename} ClassT, {\cf17 typename} ReturnT, {\cf17 typename}... Args>\par
4241             {\cf17 struct }UnaryLambdaTraits<ReturnT ( ClassT::* )( Args... ) const> \{\par
4242                 {\cf17 static} {\cf17 const} {\cf18 bool} isValid = {\cf17 false};\par
4243             \};\par
4244 \par
4245             {\cf17 template} <{\cf17 typename} ClassT, {\cf17 typename} ReturnT, {\cf17 typename} ArgT>\par
4246             {\cf17 struct }UnaryLambdaTraits<ReturnT ( ClassT::* )( ArgT ) const> \{\par
4247                 {\cf17 static} {\cf17 const} {\cf18 bool} isValid = {\cf17 true};\par
4248                 {\cf17 using }ArgType = std::remove_const_t<std::remove_reference_t<ArgT>>;\par
4249                 {\cf17 using }ReturnType = ReturnT;\par
4250             \};\par
4251 \par
4252             {\cf17 class }TokenStream;\par
4253 \par
4254             {\cf20 // Wraps a token coming from a token stream. These may not directly}\par
4255             {\cf20 // correspond to strings as a single string may encode an option +}\par
4256             {\cf20 // its argument if the : or = form is used}\par
4257             {\cf17 enum class} TokenType \{ Option, Argument \};\par
4258             {\cf17 struct }Token \{\par
4259                 TokenType type;\par
4260                 StringRef token;\par
4261             \};\par
4262 \par
4263             {\cf20 // Abstracts iterators into args as a stream of tokens, with option}\par
4264             {\cf20 // arguments uniformly handled}\par
4265             {\cf17 class }TokenStream \{\par
4266                 {\cf17 using }Iterator = std::vector<StringRef>::const_iterator;\par
4267                 Iterator it;\par
4268                 Iterator itEnd;\par
4269                 std::vector<Token> m_tokenBuffer;\par
4270                 {\cf18 void} loadBuffer();\par
4271 \par
4272             {\cf17 public}:\par
4273                 {\cf17 explicit} TokenStream( Args {\cf17 const}& args );\par
4274                 TokenStream( Iterator it, Iterator itEnd );\par
4275 \par
4276                 {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
4277                     {\cf19 return} !m_tokenBuffer.empty() || it != itEnd;\par
4278                 \}\par
4279 \par
4280                 {\cf18 size_t} count(){\cf17  const }\{\par
4281                     {\cf19 return} m_tokenBuffer.size() + ( itEnd - it );\par
4282                 \}\par
4283 \par
4284                 Token operator*(){\cf17  const }\{\par
4285                     assert( !m_tokenBuffer.empty() );\par
4286                     {\cf19 return} m_tokenBuffer.front();\par
4287                 \}\par
4288 \par
4289                 Token {\cf17 const}* operator->(){\cf17  const }\{\par
4290                     assert( !m_tokenBuffer.empty() );\par
4291                     {\cf19 return} &m_tokenBuffer.front();\par
4292                 \}\par
4293 \par
4294                 TokenStream& operator++();\par
4295             \};\par
4296 \par
4298             {\cf17 enum class} ResultType \{\par
4299                 Ok,          \par
4300                 LogicError,  \par
4302                 RuntimeError \par
4303             \};\par
4304 \par
4305             {\cf17 class }ResultBase \{\par
4306             {\cf17 protected}:\par
4307                 ResultBase( ResultType type ): m_type( type ) \{\}\par
4308                 {\cf17 virtual} ~ResultBase(); {\cf20 // = default;}\par
4309 \par
4310 \par
4311                 ResultBase(ResultBase {\cf17 const}&) = {\cf19 default};\par
4312                 ResultBase& operator=(ResultBase {\cf17 const}&) = {\cf19 default};\par
4313                 ResultBase(ResultBase&&) = {\cf19 default};\par
4314                 ResultBase& operator=(ResultBase&&) = {\cf19 default};\par
4315 \par
4316                 {\cf17 virtual} {\cf18 void} enforceOk() {\cf17 const} = 0;\par
4317 \par
4318                 ResultType m_type;\par
4319             \};\par
4320 \par
4321             {\cf17 template} <{\cf17 typename} T>\par
4322             {\cf17 class }ResultValueBase : {\cf17 public} ResultBase \{\par
4323             {\cf17 public}:\par
4324                 T {\cf17 const}& value() const& \{\par
4325                     enforceOk();\par
4326                     {\cf19 return} m_value;\par
4327                 \}\par
4328                 T&& value() && \{\par
4329                     enforceOk();\par
4330                     {\cf19 return} CATCH_MOVE( m_value );\par
4331                 \}\par
4332 \par
4333             {\cf17 protected}:\par
4334                 ResultValueBase( ResultType type ): ResultBase( type ) \{\}\par
4335 \par
4336                 ResultValueBase( ResultValueBase {\cf17 const}& other ):\par
4337                     ResultBase( other ) \{\par
4338                     {\cf19 if} ( m_type == ResultType::Ok )\par
4339                         {\cf17 new} ( &m_value ) T( other.m_value );\par
4340                 \}\par
4341                 ResultValueBase( ResultValueBase&& other ):\par
4342                     ResultBase( other ) \{\par
4343                     {\cf19 if} ( m_type == ResultType::Ok )\par
4344                         {\cf17 new} ( &m_value ) T( CATCH_MOVE(other.m_value) );\par
4345                 \}\par
4346 \par
4347 \par
4348                 ResultValueBase( ResultType, T {\cf17 const}& value ):\par
4349                     ResultBase( ResultType::Ok ) \{\par
4350                     {\cf17 new} ( &m_value ) T( value );\par
4351                 \}\par
4352                 ResultValueBase( ResultType, T&& value ):\par
4353                     ResultBase( ResultType::Ok ) \{\par
4354                     {\cf17 new} ( &m_value ) T( CATCH_MOVE(value) );\par
4355                 \}\par
4356 \par
4357                 ResultValueBase& operator=( ResultValueBase {\cf17 const}& other ) \{\par
4358                     {\cf19 if} ( m_type == ResultType::Ok )\par
4359                         m_value.~T();\par
4360                     ResultBase::operator=( other );\par
4361                     {\cf19 if} ( m_type == ResultType::Ok )\par
4362                         {\cf17 new} ( &m_value ) T( other.m_value );\par
4363                     {\cf19 return} *{\cf17 this};\par
4364                 \}\par
4365                 ResultValueBase& operator=( ResultValueBase&& other ) \{\par
4366                     {\cf19 if} ( m_type == ResultType::Ok ) m_value.~T();\par
4367                     ResultBase::operator=( other );\par
4368                     {\cf19 if} ( m_type == ResultType::Ok )\par
4369                         {\cf17 new} ( &m_value ) T( CATCH_MOVE(other.m_value) );\par
4370                     {\cf19 return} *{\cf17 this};\par
4371                 \}\par
4372 \par
4373 \par
4374                 ~ResultValueBase(){\cf17  override }\{\par
4375                     {\cf19 if} ( m_type == ResultType::Ok )\par
4376                         m_value.~T();\par
4377                 \}\par
4378 \par
4379                 {\cf17 union }\{\par
4380                     T m_value;\par
4381                 \};\par
4382             \};\par
4383 \par
4384             {\cf17 template} <> {\cf17 class }ResultValueBase<void> : {\cf17 public} ResultBase \{\par
4385             {\cf17 protected}:\par
4386                 {\cf17 using }ResultBase::ResultBase;\par
4387             \};\par
4388 \par
4389             {\cf17 template} <{\cf17 typename} T = {\cf18 void}>\par
4390             {\cf17 class }BasicResult : {\cf17 public} ResultValueBase<T> \{\par
4391             {\cf17 public}:\par
4392                 {\cf17 template} <{\cf17 typename} U>\par
4393                 {\cf17 explicit} BasicResult( BasicResult<U> {\cf17 const}& other ):\par
4394                     ResultValueBase<T>( other.type() ),\par
4395                     m_errorMessage( other.errorMessage() ) \{\par
4396                     assert( type() != ResultType::Ok );\par
4397                 \}\par
4398 \par
4399                 {\cf17 template} <{\cf17 typename} U>\par
4400                 {\cf17 static} {\cf17 auto} ok( U&& value ) -> BasicResult \{\par
4401                     {\cf19 return} \{ ResultType::Ok, CATCH_FORWARD(value) \};\par
4402                 \}\par
4403                 {\cf17 static} {\cf17 auto} ok() -> BasicResult \{ {\cf19 return} \{ ResultType::Ok \}; \}\par
4404                 {\cf17 static} {\cf17 auto} logicError( std::string&& message )\par
4405                     -> BasicResult \{\par
4406                     {\cf19 return} \{ ResultType::LogicError, CATCH_MOVE(message) \};\par
4407                 \}\par
4408                 {\cf17 static} {\cf17 auto} runtimeError( std::string&& message )\par
4409                     -> BasicResult \{\par
4410                     {\cf19 return} \{ ResultType::RuntimeError, CATCH_MOVE(message) \};\par
4411                 \}\par
4412 \par
4413                 {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
4414                     {\cf19 return} m_type == ResultType::Ok;\par
4415                 \}\par
4416                 {\cf17 auto} type() const -> ResultType \{ {\cf19 return} m_type; \}\par
4417                 {\cf17 auto} errorMessage() const -> std::{\cf18 string} const& \{\par
4418                     {\cf19 return} m_errorMessage;\par
4419                 \}\par
4420 \par
4421             {\cf17 protected}:\par
4422                 {\cf18 void} enforceOk(){\cf17  const override }\{\par
4423 \par
4424                     {\cf20 // Errors shouldn't reach this point, but if they do}\par
4425                     {\cf20 // the actual error message will be in m_errorMessage}\par
4426                     assert( m_type != ResultType::LogicError );\par
4427                     assert( m_type != ResultType::RuntimeError );\par
4428                     {\cf19 if} ( m_type != ResultType::Ok )\par
4429                         std::abort();\par
4430                 \}\par
4431 \par
4432                 std::string\par
4433                     m_errorMessage; {\cf20 // Only populated if resultType is an error}\par
4434 \par
4435                 BasicResult( ResultType type,\par
4436                              std::string&& message ):\par
4437                     ResultValueBase<T>( type ), m_errorMessage( CATCH_MOVE(message) ) \{\par
4438                     assert( m_type != ResultType::Ok );\par
4439                 \}\par
4440 \par
4441                 {\cf17 using }ResultValueBase<T>::ResultValueBase;\par
4442                 {\cf17 using }ResultBase::m_type;\par
4443             \};\par
4444 \par
4445             {\cf17 class }ParseState \{\par
4446             {\cf17 public}:\par
4447                 ParseState( ParseResultType type,\par
4448                             TokenStream remainingTokens );\par
4449 \par
4450                 ParseResultType type(){\cf17  const }\{ {\cf19 return} m_type; \}\par
4451                 TokenStream {\cf17 const}& remainingTokens() const& \{\par
4452                     {\cf19 return} m_remainingTokens;\par
4453                 \}\par
4454                 TokenStream&& remainingTokens() && \{\par
4455                     {\cf19 return} CATCH_MOVE( m_remainingTokens );\par
4456                 \}\par
4457 \par
4458             {\cf17 private}:\par
4459                 ParseResultType m_type;\par
4460                 TokenStream m_remainingTokens;\par
4461             \};\par
4462 \par
4463             {\cf17 using }Result = BasicResult<void>;\par
4464             {\cf17 using }ParserResult = BasicResult<ParseResultType>;\par
4465             {\cf17 using }InternalParseResult = BasicResult<ParseState>;\par
4466 \par
4467             {\cf17 struct }HelpColumns \{\par
4468                 std::string left;\par
4469                 StringRef descriptions;\par
4470             \};\par
4471 \par
4472             {\cf17 template} <{\cf17 typename} T>\par
4473             ParserResult convertInto( std::string {\cf17 const}& source, T& target ) \{\par
4474                 std::stringstream ss( source );\par
4475                 ss >> target;\par
4476                 {\cf19 if} ( ss.fail() ) \{\par
4477                     {\cf19 return} ParserResult::runtimeError(\par
4478                         {\cf22 "Unable to convert '"} + source +\par
4479                         {\cf22 "' to destination type"} );\par
4480                 \} {\cf19 else} \{\par
4481                     {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
4482                 \}\par
4483             \}\par
4484             ParserResult convertInto( std::string {\cf17 const}& source,\par
4485                                       std::string& target );\par
4486             ParserResult convertInto( std::string {\cf17 const}& source, {\cf18 bool}& target );\par
4487 \par
4488 {\cf21 #ifdef CLARA_CONFIG_OPTIONAL_TYPE}\par
4489             {\cf17 template} <{\cf17 typename} T>\par
4490             {\cf17 auto} convertInto( std::string {\cf17 const}& source,\par
4491                               CLARA_CONFIG_OPTIONAL_TYPE<T>& target )\par
4492                 -> ParserResult \{\par
4493                 T temp;\par
4494                 {\cf17 auto} result = convertInto( source, temp );\par
4495                 {\cf19 if} ( result )\par
4496                     target = CATCH_MOVE( temp );\par
4497                 {\cf19 return} result;\par
4498             \}\par
4499 {\cf21 #endif }{\cf20 // CLARA_CONFIG_OPTIONAL_TYPE}\par
4500 \par
4501             {\cf17 struct }BoundRef : Catch::Detail::NonCopyable \{\par
4502                 {\cf17 virtual} ~BoundRef() = {\cf19 default};\par
4503                 {\cf17 virtual} {\cf18 bool} isContainer() {\cf17 const};\par
4504                 {\cf17 virtual} {\cf18 bool} isFlag() {\cf17 const};\par
4505             \};\par
4506             {\cf17 struct }BoundValueRefBase : BoundRef \{\par
4507                 {\cf17 virtual} {\cf17 auto} setValue( std::string {\cf17 const}& arg )\par
4508                     -> ParserResult = 0;\par
4509             \};\par
4510             {\cf17 struct }BoundFlagRefBase : BoundRef \{\par
4511                 {\cf17 virtual} {\cf17 auto} setFlag( {\cf18 bool} flag ) -> ParserResult = 0;\par
4512                 {\cf18 bool} isFlag() {\cf17 const override};\par
4513             \};\par
4514 \par
4515             {\cf17 template} <{\cf17 typename} T> {\cf17 struct }BoundValueRef : BoundValueRefBase \{\par
4516                 T& m_ref;\par
4517 \par
4518                 {\cf17 explicit} BoundValueRef( T& ref ): m_ref( ref ) \{\}\par
4519 \par
4520                 ParserResult setValue( std::string {\cf17 const}& arg ){\cf17  override }\{\par
4521                     {\cf19 return} convertInto( arg, m_ref );\par
4522                 \}\par
4523             \};\par
4524 \par
4525             {\cf17 template} <{\cf17 typename} T>\par
4526             {\cf17 struct }BoundValueRef<std::vector<T>> : BoundValueRefBase \{\par
4527                 std::vector<T>& m_ref;\par
4528 \par
4529                 {\cf17 explicit} BoundValueRef( std::vector<T>& ref ): m_ref( ref ) \{\}\par
4530 \par
4531                 {\cf17 auto} isContainer() const -> {\cf18 bool}{\cf17  override }\{ {\cf19 return} {\cf17 true}; \}\par
4532 \par
4533                 {\cf17 auto} setValue( std::string {\cf17 const}& arg )\par
4534                     -> ParserResult {\cf17 override} \{\par
4535                     T temp;\par
4536                     {\cf17 auto} result = convertInto( arg, temp );\par
4537                     {\cf19 if} ( result )\par
4538                         m_ref.push_back( temp );\par
4539                     {\cf19 return} result;\par
4540                 \}\par
4541             \};\par
4542 \par
4543             {\cf17 struct }BoundFlagRef : BoundFlagRefBase \{\par
4544                 {\cf18 bool}& m_ref;\par
4545 \par
4546                 {\cf17 explicit} BoundFlagRef( {\cf18 bool}& ref ): m_ref( ref ) \{\}\par
4547 \par
4548                 ParserResult setFlag( {\cf18 bool} flag ) {\cf17 override};\par
4549             \};\par
4550 \par
4551             {\cf17 template} <{\cf17 typename} ReturnType> {\cf17 struct }LambdaInvoker \{\par
4552                 {\cf17 static_assert}(\par
4553                     std::is_same<ReturnType, ParserResult>::value,\par
4554                     {\cf22 "Lambda must return void or clara::ParserResult"} );\par
4555 \par
4556                 {\cf17 template} <{\cf17 typename} L, {\cf17 typename} ArgType>\par
4557                 {\cf17 static} {\cf17 auto} invoke( L {\cf17 const}& lambda, ArgType {\cf17 const}& arg )\par
4558                     -> ParserResult \{\par
4559                     {\cf19 return} lambda( arg );\par
4560                 \}\par
4561             \};\par
4562 \par
4563             {\cf17 template} <> {\cf17 struct }LambdaInvoker<void> \{\par
4564                 {\cf17 template} <{\cf17 typename} L, {\cf17 typename} ArgType>\par
4565                 {\cf17 static} {\cf17 auto} invoke( L {\cf17 const}& lambda, ArgType {\cf17 const}& arg )\par
4566                     -> ParserResult \{\par
4567                     lambda( arg );\par
4568                     {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
4569                 \}\par
4570             \};\par
4571 \par
4572             {\cf17 template} <{\cf17 typename} ArgType, {\cf17 typename} L>\par
4573             {\cf17 auto} invokeLambda( L {\cf17 const}& lambda, std::string {\cf17 const}& arg )\par
4574                 -> ParserResult \{\par
4575                 ArgType temp\{\};\par
4576                 {\cf17 auto} result = convertInto( arg, temp );\par
4577                 {\cf19 return} !result ? result\par
4578                                : LambdaInvoker<{\cf17 typename} UnaryLambdaTraits<\par
4579                                      L>::ReturnType>::invoke( lambda, temp );\par
4580             \}\par
4581 \par
4582             {\cf17 template} <{\cf17 typename} L> {\cf17 struct }BoundLambda : BoundValueRefBase \{\par
4583                 L m_lambda;\par
4584 \par
4585                 {\cf17 static_assert}(\par
4586                     UnaryLambdaTraits<L>::isValid,\par
4587                     {\cf22 "Supplied lambda must take exactly one argument"} );\par
4588                 {\cf17 explicit} BoundLambda( L {\cf17 const}& lambda ): m_lambda( lambda ) \{\}\par
4589 \par
4590                 {\cf17 auto} setValue( std::string {\cf17 const}& arg )\par
4591                     -> ParserResult {\cf17 override} \{\par
4592                     {\cf19 return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>(\par
4593                         m_lambda, arg );\par
4594                 \}\par
4595             \};\par
4596 \par
4597             {\cf17 template} <{\cf17 typename} L> {\cf17 struct }BoundManyLambda : BoundLambda<L> \{\par
4598                 {\cf17 explicit} BoundManyLambda( L {\cf17 const}& lambda ): BoundLambda<L>( lambda ) \{\}\par
4599                 {\cf18 bool} isContainer(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
4600             \};\par
4601 \par
4602             {\cf17 template} <{\cf17 typename} L> {\cf17 struct }BoundFlagLambda : BoundFlagRefBase \{\par
4603                 L m_lambda;\par
4604 \par
4605                 {\cf17 static_assert}(\par
4606                     UnaryLambdaTraits<L>::isValid,\par
4607                     {\cf22 "Supplied lambda must take exactly one argument"} );\par
4608                 {\cf17 static_assert}(\par
4609                     std::is_same<typename UnaryLambdaTraits<L>::ArgType,\par
4610                                  {\cf18 bool}>::value,\par
4611                     {\cf22 "flags must be boolean"} );\par
4612 \par
4613                 {\cf17 explicit} BoundFlagLambda( L {\cf17 const}& lambda ):\par
4614                     m_lambda( lambda ) \{\}\par
4615 \par
4616                 {\cf17 auto} setFlag( {\cf18 bool} flag ) -> ParserResult {\cf17 override} \{\par
4617                     {\cf19 return} LambdaInvoker<{\cf17 typename} UnaryLambdaTraits<\par
4618                         L>::ReturnType>::invoke( m_lambda, flag );\par
4619                 \}\par
4620             \};\par
4621 \par
4622             {\cf17 enum class} Optionality \{ Optional, Required \};\par
4623 \par
4624             {\cf17 class }ParserBase \{\par
4625             {\cf17 public}:\par
4626                 {\cf17 virtual} ~ParserBase() = {\cf19 default};\par
4627                 {\cf17 virtual} {\cf17 auto} validate() const -> Result \{ {\cf19 return} Result::ok(); \}\par
4628                 {\cf17 virtual} {\cf17 auto} parse( std::string {\cf17 const}& exeName,\par
4629                                     TokenStream tokens ) {\cf17 const}\par
4630                     -> InternalParseResult = 0;\par
4631                 {\cf17 virtual} {\cf18 size_t} cardinality() {\cf17 const};\par
4632 \par
4633                 InternalParseResult parse( Args {\cf17 const}& args ) {\cf17 const};\par
4634             \};\par
4635 \par
4636             {\cf17 template} <{\cf17 typename} DerivedT>\par
4637             {\cf17 class }ComposableParserImpl : {\cf17 public} ParserBase \{\par
4638             {\cf17 public}:\par
4639                 {\cf17 template} <{\cf17 typename} T>\par
4640                 {\cf17 auto} operator|( T {\cf17 const}& other ) {\cf17 const} -> Parser;\par
4641             \};\par
4642 \par
4643             {\cf20 // Common code and state for Args and Opts}\par
4644             {\cf17 template} <{\cf17 typename} DerivedT>\par
4645             {\cf17 class }ParserRefImpl : {\cf17 public} ComposableParserImpl<DerivedT> \{\par
4646             {\cf17 protected}:\par
4647                 Optionality m_optionality = Optionality::Optional;\par
4648                 std::shared_ptr<BoundRef> m_ref;\par
4649                 StringRef m_hint;\par
4650                 StringRef m_description;\par
4651 \par
4652                 {\cf17 explicit} ParserRefImpl( std::shared_ptr<BoundRef> {\cf17 const}& ref ):\par
4653                     m_ref( ref ) \{\}\par
4654 \par
4655             {\cf17 public}:\par
4656                 {\cf17 template} <{\cf17 typename} LambdaT>\par
4657                 ParserRefImpl( accept_many_t,\par
4658                                LambdaT {\cf17 const}& ref,\par
4659                                StringRef hint ):\par
4660                     m_ref( std::make_shared<BoundManyLambda<LambdaT>>( ref ) ),\par
4661                     m_hint( hint ) \{\}\par
4662 \par
4663                 {\cf17 template} <{\cf17 typename} T,\par
4664                           {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4665                               !Detail::is_unary_function<T>::value>>\par
4666                 ParserRefImpl( T& ref, StringRef hint ):\par
4667                     m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\par
4668                     m_hint( hint ) \{\}\par
4669 \par
4670                 {\cf17 template} <{\cf17 typename} LambdaT,\par
4671                           {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4672                               Detail::is_unary_function<LambdaT>::value>>\par
4673                 ParserRefImpl( LambdaT {\cf17 const}& ref, StringRef hint ):\par
4674                     m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\par
4675                     m_hint( hint ) \{\}\par
4676 \par
4677                 DerivedT& operator()( StringRef description ) & \{\par
4678                     m_description = description;\par
4679                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4680                 \}\par
4681                 DerivedT&& operator()( StringRef description ) && \{\par
4682                     m_description = description;\par
4683                     {\cf19 return} {\cf17 static_cast<}DerivedT&&{\cf17 >}( *this );\par
4684                 \}\par
4685 \par
4686                 {\cf17 auto} optional() -> DerivedT& \{\par
4687                     m_optionality = Optionality::Optional;\par
4688                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4689                 \}\par
4690 \par
4691                 {\cf17 auto} required() -> DerivedT& \{\par
4692                     m_optionality = Optionality::Required;\par
4693                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4694                 \}\par
4695 \par
4696                 {\cf17 auto} isOptional() const -> {\cf18 bool} \{\par
4697                     {\cf19 return} m_optionality == Optionality::Optional;\par
4698                 \}\par
4699 \par
4700                 {\cf17 auto} cardinality() const -> {\cf18 size_t}{\cf17  override }\{\par
4701                     {\cf19 if} ( m_ref->isContainer() )\par
4702                         {\cf19 return} 0;\par
4703                     {\cf19 else}\par
4704                         {\cf19 return} 1;\par
4705                 \}\par
4706 \par
4707                 StringRef hint(){\cf17  const }\{ {\cf19 return} m_hint; \}\par
4708             \};\par
4709 \par
4710         \} {\cf20 // namespace detail}\par
4711 \par
4712 \par
4713         {\cf20 // A parser for arguments}\par
4714         {\cf17 class }Arg : {\cf17 public} Detail::ParserRefImpl<Arg> \{\par
4715         {\cf17 public}:\par
4716             {\cf17 using }ParserRefImpl::ParserRefImpl;\par
4717             {\cf17 using }ParserBase::parse;\par
4718 \par
4719             Detail::InternalParseResult\par
4720                 parse(std::string {\cf17 const}&,\par
4721                       Detail::TokenStream tokens) {\cf17 const override};\par
4722         \};\par
4723 \par
4724         {\cf20 // A parser for options}\par
4725         {\cf17 class }Opt : {\cf17 public} Detail::ParserRefImpl<Opt> \{\par
4726         {\cf17 protected}:\par
4727             std::vector<StringRef> m_optNames;\par
4728 \par
4729         {\cf17 public}:\par
4730             {\cf17 template} <{\cf17 typename} LambdaT>\par
4731             {\cf17 explicit} Opt(LambdaT {\cf17 const}& ref) :\par
4732                 ParserRefImpl(\par
4733                     std::make_shared<Detail::BoundFlagLambda<LambdaT>>(ref)) \{\}\par
4734 \par
4735             {\cf17 explicit} Opt({\cf18 bool}& ref);\par
4736 \par
4737             {\cf17 template} <{\cf17 typename} LambdaT,\par
4738                       {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4739                           Detail::is_unary_function<LambdaT>::value>>\par
4740             Opt( LambdaT {\cf17 const}& ref, StringRef hint ):\par
4741                 ParserRefImpl( ref, hint ) \{\}\par
4742 \par
4743             {\cf17 template} <{\cf17 typename} LambdaT>\par
4744             Opt( accept_many_t, LambdaT {\cf17 const}& ref, StringRef hint ):\par
4745                 ParserRefImpl( accept_many, ref, hint ) \{\}\par
4746 \par
4747             {\cf17 template} <{\cf17 typename} T,\par
4748                       {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4749                           !Detail::is_unary_function<T>::value>>\par
4750             Opt( T& ref, StringRef hint ):\par
4751                 ParserRefImpl( ref, hint ) \{\}\par
4752 \par
4753             Opt& operator[]( StringRef optName ) & \{\par
4754                 m_optNames.push_back(optName);\par
4755                 {\cf19 return} *{\cf17 this};\par
4756             \}\par
4757             Opt&& operator[]( StringRef optName ) && \{\par
4758                 m_optNames.push_back( optName );\par
4759                 {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
4760             \}\par
4761 \par
4762             Detail::HelpColumns getHelpColumns() {\cf17 const};\par
4763 \par
4764             {\cf18 bool} isMatch(StringRef optToken) {\cf17 const};\par
4765 \par
4766             {\cf17 using }ParserBase::parse;\par
4767 \par
4768             Detail::InternalParseResult\par
4769                 parse(std::string {\cf17 const}&,\par
4770                       Detail::TokenStream tokens) {\cf17 const override};\par
4771 \par
4772             Detail::Result validate() {\cf17 const override};\par
4773         \};\par
4774 \par
4775         {\cf20 // Specifies the name of the executable}\par
4776         {\cf17 class }ExeName : {\cf17 public} Detail::ComposableParserImpl<ExeName> \{\par
4777             std::shared_ptr<std::string> m_name;\par
4778             std::shared_ptr<Detail::BoundValueRefBase> m_ref;\par
4779 \par
4780         {\cf17 public}:\par
4781             ExeName();\par
4782             {\cf17 explicit} ExeName(std::string& ref);\par
4783 \par
4784             {\cf17 template} <{\cf17 typename} LambdaT>\par
4785             {\cf17 explicit} ExeName(LambdaT {\cf17 const}& lambda) : ExeName() \{\par
4786                 m_ref = std::make_shared<Detail::BoundLambda<LambdaT>>(lambda);\par
4787             \}\par
4788 \par
4789             {\cf20 // The exe name is not parsed out of the normal tokens, but is}\par
4790             {\cf20 // handled specially}\par
4791             Detail::InternalParseResult\par
4792                 parse(std::string {\cf17 const}&,\par
4793                       Detail::TokenStream tokens) {\cf17 const override};\par
4794 \par
4795             std::string {\cf17 const}& name(){\cf17  const }\{ {\cf19 return} *m_name; \}\par
4796             Detail::ParserResult set(std::string {\cf17 const}& newName);\par
4797         \};\par
4798 \par
4799 \par
4800         {\cf20 // A Combined parser}\par
4801         {\cf17 class }Parser : Detail::ParserBase \{\par
4802             {\cf17 mutable} ExeName m_exeName;\par
4803             std::vector<Opt> m_options;\par
4804             std::vector<Arg> m_args;\par
4805 \par
4806         {\cf17 public}:\par
4807 \par
4808             {\cf17 auto} operator|=(ExeName {\cf17 const}& exeName) -> Parser& \{\par
4809                 m_exeName = exeName;\par
4810                 {\cf19 return} *{\cf17 this};\par
4811             \}\par
4812 \par
4813             {\cf17 auto} operator|=(Arg {\cf17 const}& arg) -> Parser& \{\par
4814                 m_args.push_back(arg);\par
4815                 {\cf19 return} *{\cf17 this};\par
4816             \}\par
4817 \par
4818             {\cf17 friend} Parser& operator|=( Parser& p, Opt {\cf17 const}& opt ) \{\par
4819                 p.m_options.push_back( opt );\par
4820                 {\cf19 return} p;\par
4821             \}\par
4822             {\cf17 friend} Parser& operator|=( Parser& p, Opt&& opt ) \{\par
4823                 p.m_options.push_back( CATCH_MOVE(opt) );\par
4824                 {\cf19 return} p;\par
4825             \}\par
4826 \par
4827             Parser& operator|=(Parser {\cf17 const}& other);\par
4828 \par
4829             {\cf17 template} <{\cf17 typename} T>\par
4830             {\cf17 friend} Parser operator|( Parser {\cf17 const}& p, T&& rhs ) \{\par
4831                 Parser temp( p );\par
4832                 temp |= rhs;\par
4833                 {\cf19 return} temp;\par
4834             \}\par
4835 \par
4836             {\cf17 template} <{\cf17 typename} T>\par
4837             {\cf17 friend} Parser operator|( Parser&& p, T&& rhs ) \{\par
4838                 p |= CATCH_FORWARD(rhs);\par
4839                 {\cf19 return} CATCH_MOVE(p);\par
4840             \}\par
4841 \par
4842             std::vector<Detail::HelpColumns> getHelpColumns() {\cf17 const};\par
4843 \par
4844             {\cf18 void} writeToStream(std::ostream& os) {\cf17 const};\par
4845 \par
4846             {\cf17 friend} {\cf17 auto} operator<<(std::ostream& os, Parser {\cf17 const}& parser)\par
4847                 -> std::ostream& \{\par
4848                 parser.writeToStream(os);\par
4849                 {\cf19 return} os;\par
4850             \}\par
4851 \par
4852             Detail::Result validate() {\cf17 const override};\par
4853 \par
4854             {\cf17 using }ParserBase::parse;\par
4855             Detail::InternalParseResult\par
4856                 parse(std::string {\cf17 const}& exeName,\par
4857                       Detail::TokenStream tokens) {\cf17 const override};\par
4858         \};\par
4859 \par
4863         {\cf17 class }Args \{\par
4864             {\cf17 friend} Detail::TokenStream;\par
4865             StringRef m_exeName;\par
4866             std::vector<StringRef> m_args;\par
4867 \par
4868         {\cf17 public}:\par
4869             Args({\cf18 int} argc, {\cf18 char} {\cf17 const}* {\cf17 const}* argv);\par
4870             {\cf20 // Helper constructor for testing}\par
4871             Args(std::initializer_list<StringRef> args);\par
4872 \par
4873             StringRef exeName(){\cf17  const }\{ {\cf19 return} m_exeName; \}\par
4874         \};\par
4875 \par
4876 \par
4877         {\cf20 // Convenience wrapper for option parser that specifies the help option}\par
4878         {\cf17 struct }Help : Opt \{\par
4879             Help({\cf18 bool}& showHelpFlag);\par
4880         \};\par
4881 \par
4882         {\cf20 // Result type for parser operation}\par
4883         {\cf17 using }Detail::ParserResult;\par
4884 \par
4885         {\cf17 namespace }Detail \{\par
4886             {\cf17 template} <{\cf17 typename} DerivedT>\par
4887             {\cf17 template} <{\cf17 typename} T>\par
4888             Parser\par
4889                 ComposableParserImpl<DerivedT>::operator|(T {\cf17 const}& other){\cf17  const }\{\par
4890                 {\cf19 return} Parser() | {\cf17 static_cast<}DerivedT const&{\cf17 >}(*this) | other;\par
4891             \}\par
4892         \}\par
4893 \par
4894     \} {\cf20 // namespace Clara}\par
4895 \} {\cf20 // namespace Catch}\par
4896 \par
4897 {\cf21 #if defined( __clang__ )}\par
4898 {\cf21 #    pragma clang diagnostic pop}\par
4899 {\cf21 #endif}\par
4900 \par
4901 {\cf21 #if defined( __GNUC__ )}\par
4902 {\cf21 #    pragma GCC diagnostic pop}\par
4903 {\cf21 #endif}\par
4904 \par
4905 {\cf21 #endif }{\cf20 // CATCH_CLARA_HPP_INCLUDED}\par
4906 \par
4907 {\cf17 namespace }Catch \{\par
4908 \par
4909     {\cf17 struct }ConfigData;\par
4910 \par
4911     Clara::Parser makeCommandLineParser( ConfigData& config );\par
4912 \par
4913 \} {\cf20 // end namespace Catch}\par
4914 \par
4915 {\cf21 #endif }{\cf20 // CATCH_COMMANDLINE_HPP_INCLUDED}\par
4916 \par
4917 {\cf17 namespace }Catch \{\par
4918 \par
4919     {\cf17 class }Session : Detail::NonCopyable \{\par
4920     {\cf17 public}:\par
4921 \par
4922         Session();\par
4923         ~Session();\par
4924 \par
4925         {\cf18 void} showHelp() {\cf17 const};\par
4926         {\cf18 void} libIdentify();\par
4927 \par
4928         {\cf18 int} applyCommandLine( {\cf18 int} argc, {\cf18 char} {\cf17 const} * {\cf17 const} * argv );\par
4929 {\cf21     #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)}\par
4930         {\cf18 int} applyCommandLine( {\cf18 int} argc, {\cf18 wchar_t} {\cf17 const} * {\cf17 const} * argv );\par
4931 {\cf21     #endif}\par
4932 \par
4933         {\cf18 void} useConfigData( ConfigData {\cf17 const}& configData );\par
4934 \par
4935         {\cf17 template}<{\cf17 typename} CharT>\par
4936         {\cf18 int} run({\cf18 int} argc, CharT {\cf17 const} * {\cf17 const} argv[]) \{\par
4937             {\cf19 if} (m_startupExceptions)\par
4938                 {\cf19 return} 1;\par
4939             {\cf18 int} returnCode = applyCommandLine(argc, argv);\par
4940             {\cf19 if} (returnCode == 0)\par
4941                 returnCode = run();\par
4942             {\cf19 return} returnCode;\par
4943         \}\par
4944 \par
4945         {\cf18 int} run();\par
4946 \par
4947         Clara::Parser {\cf17 const}& cli() {\cf17 const};\par
4948         {\cf18 void} cli( Clara::Parser {\cf17 const}& newParser );\par
4949         ConfigData& configData();\par
4950         Config& config();\par
4951     {\cf17 private}:\par
4952         {\cf18 int} runInternal();\par
4953 \par
4954         Clara::Parser m_cli;\par
4955         ConfigData m_configData;\par
4956         Detail::unique_ptr<Config> m_config;\par
4957         {\cf18 bool} m_startupExceptions = {\cf17 false};\par
4958     \};\par
4959 \par
4960 \} {\cf20 // end namespace Catch}\par
4961 \par
4962 {\cf21 #endif }{\cf20 // CATCH_SESSION_HPP_INCLUDED}\par
4963 \par
4964 \par
4965 {\cf21 #ifndef CATCH_TAG_ALIAS_HPP_INCLUDED}\par
4966 {\cf21 #define CATCH_TAG_ALIAS_HPP_INCLUDED}\par
4967 \par
4968 \par
4969 {\cf21 #include <string>}\par
4970 \par
4971 {\cf17 namespace }Catch \{\par
4972 \par
4973     {\cf17 struct }TagAlias \{\par
4974         TagAlias(std::string {\cf17 const}& _tag, SourceLineInfo _lineInfo):\par
4975             tag(_tag),\par
4976             lineInfo(_lineInfo)\par
4977         \{\}\par
4978 \par
4979         std::string tag;\par
4980         SourceLineInfo lineInfo;\par
4981     \};\par
4982 \par
4983 \} {\cf20 // end namespace Catch}\par
4984 \par
4985 {\cf21 #endif }{\cf20 // CATCH_TAG_ALIAS_HPP_INCLUDED}\par
4986 \par
4987 \par
4988 {\cf21 #ifndef CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}\par
4989 {\cf21 #define CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}\par
4990 \par
4991 \par
4992 {\cf17 namespace }Catch \{\par
4993 \par
4994     {\cf17 struct }RegistrarForTagAliases \{\par
4995         RegistrarForTagAliases( {\cf18 char} {\cf17 const}* alias, {\cf18 char} {\cf17 const}* tag, SourceLineInfo {\cf17 const}& lineInfo );\par
4996     \};\par
4997 \par
4998 \} {\cf20 // end namespace Catch}\par
4999 \par
5000 {\cf21 #define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \\}\par
5001 {\cf21     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5002 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
5003 {\cf21     namespace\{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); \} \\}\par
5004 {\cf21     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5005 \par
5006 {\cf21 #endif }{\cf20 // CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}\par
5007 \par
5008 \par
5009 {\cf21 #ifndef CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}\par
5010 {\cf21 #define CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}\par
5011 \par
5012 {\cf20 // We need this suppression to leak, because it took until GCC 10}\par
5013 {\cf20 // for the front end to handle local suppression via _Pragma properly}\par
5014 {\cf20 // inside templates (so `TEMPLATE_TEST_CASE` and co).}\par
5015 {\cf20 // **THIS IS DIFFERENT FOR STANDARD TESTS, WHERE GCC 9 IS SUFFICIENT**}\par
5016 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ < 10}\par
5017 {\cf21 #pragma GCC diagnostic ignored "-Wparentheses"}\par
5018 {\cf21 #endif}\par
5019 \par
5020 \par
5021 \par
5022 \par
5023 {\cf21 #ifndef CATCH_TEST_MACROS_HPP_INCLUDED}\par
5024 {\cf21 #define CATCH_TEST_MACROS_HPP_INCLUDED}\par
5025 \par
5026 \par
5027 \par
5028 {\cf21 #ifndef CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}\par
5029 {\cf21 #define CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}\par
5030 \par
5031 \par
5032 \par
5033 {\cf21 #ifndef CATCH_ASSERTION_HANDLER_HPP_INCLUDED}\par
5034 {\cf21 #define CATCH_ASSERTION_HANDLER_HPP_INCLUDED}\par
5035 \par
5036 \par
5037 \par
5038 {\cf21 #ifndef CATCH_DECOMPOSER_HPP_INCLUDED}\par
5039 {\cf21 #define CATCH_DECOMPOSER_HPP_INCLUDED}\par
5040 \par
5041 \par
5042 \par
5043 {\cf21 #ifndef CATCH_COMPARE_TRAITS_HPP_INCLUDED}\par
5044 {\cf21 #define CATCH_COMPARE_TRAITS_HPP_INCLUDED}\par
5045 \par
5046 \par
5047 {\cf21 #include <type_traits>}\par
5048 \par
5049 {\cf17 namespace }Catch \{\par
5050     {\cf17 namespace }Detail \{\par
5051 \par
5052 {\cf21 #if defined( __GNUC__ ) && !defined( __clang__ )}\par
5053 {\cf21 #    pragma GCC diagnostic push}\par
5054     {\cf20 // GCC likes to complain about comparing bool with 0, in the decltype()}\par
5055     {\cf20 // that defines the comparable traits below.}\par
5056 {\cf21 #    pragma GCC diagnostic ignored "-Wbool-compare"}\par
5057     {\cf20 // "ordered comparison of pointer with integer zero" same as above,}\par
5058     {\cf20 // but it does not have a separate warning flag to suppress}\par
5059 {\cf21 #    pragma GCC diagnostic ignored "-Wextra"}\par
5060     {\cf20 // Did you know that comparing floats with `0` directly}\par
5061     {\cf20 // is super-duper dangerous in unevaluated context?}\par
5062 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
5063 {\cf21 #endif}\par
5064 \par
5065 {\cf21 #if defined( __clang__ )}\par
5066 {\cf21 #    pragma clang diagnostic push}\par
5067     {\cf20 // Did you know that comparing floats with `0` directly}\par
5068     {\cf20 // is super-duper dangerous in unevaluated context?}\par
5069 {\cf21 #    pragma clang diagnostic ignored "-Wfloat-equal"}\par
5070 {\cf21 #endif}\par
5071 \par
5072 {\cf21 #define CATCH_DEFINE_COMPARABLE_TRAIT( id, op )                               \\}\par
5073 {\cf21     template <typename, typename, typename = void>                            \\}\par
5074 {\cf21     struct is_##id##_comparable : std::false_type \{\};                         \\}\par
5075 {\cf21     template <typename T, typename U>                                         \\}\par
5076 {\cf21     struct is_##id##_comparable<                                              \\}\par
5077 {\cf21         T,                                                                    \\}\par
5078 {\cf21         U,                                                                    \\}\par
5079 {\cf21         void_t<decltype( std::declval<T>() op std::declval<U>() )>>           \\}\par
5080 {\cf21         : std::true_type \{\};                                                  \\}\par
5081 {\cf21     template <typename, typename = void>                                      \\}\par
5082 {\cf21     struct is_##id##_0_comparable : std::false_type \{\};                       \\}\par
5083 {\cf21     template <typename T>                                                     \\}\par
5084 {\cf21     struct is_##id##_0_comparable<T,                                          \\}\par
5085 {\cf21                                   void_t<decltype( std::declval<T>() op 0 )>> \\}\par
5086 {\cf21         : std::true_type \{\};}\par
5087 \par
5088         {\cf20 // We need all 6 pre-spaceship comparison ops: <, <=, >, >=, ==, !=}\par
5089         CATCH_DEFINE_COMPARABLE_TRAIT( lt, < )\par
5090         CATCH_DEFINE_COMPARABLE_TRAIT( le, <= )\par
5091         CATCH_DEFINE_COMPARABLE_TRAIT( gt, > )\par
5092         CATCH_DEFINE_COMPARABLE_TRAIT( ge, >= )\par
5093         CATCH_DEFINE_COMPARABLE_TRAIT( eq, == )\par
5094         CATCH_DEFINE_COMPARABLE_TRAIT( ne, != )\par
5095 \par
5096 {\cf21 #undef CATCH_DEFINE_COMPARABLE_TRAIT}\par
5097 \par
5098 {\cf21 #if defined( __GNUC__ ) && !defined( __clang__ )}\par
5099 {\cf21 #    pragma GCC diagnostic pop}\par
5100 {\cf21 #endif}\par
5101 {\cf21 #if defined( __clang__ )}\par
5102 {\cf21 #    pragma clang diagnostic pop}\par
5103 {\cf21 #endif}\par
5104 \par
5105 \par
5106     \} {\cf20 // namespace Detail}\par
5107 \} {\cf20 // namespace Catch}\par
5108 \par
5109 {\cf21 #endif }{\cf20 // CATCH_COMPARE_TRAITS_HPP_INCLUDED}\par
5110 \par
5111 \par
5112 {\cf21 #ifndef CATCH_LOGICAL_TRAITS_HPP_INCLUDED}\par
5113 {\cf21 #define CATCH_LOGICAL_TRAITS_HPP_INCLUDED}\par
5114 \par
5115 {\cf21 #include <type_traits>}\par
5116 \par
5117 {\cf17 namespace }Catch \{\par
5118 {\cf17 namespace }Detail \{\par
5119 \par
5120 {\cf21 #if defined( __cpp_lib_logical_traits ) && __cpp_lib_logical_traits >= 201510}\par
5121 \par
5122     {\cf17 using }std::conjunction;\par
5123     {\cf17 using }std::disjunction;\par
5124     {\cf17 using }std::negation;\par
5125 \par
5126 {\cf21 #else}\par
5127 \par
5128     {\cf17 template} <{\cf17 class}...> {\cf17 struct }conjunction : std::true_type \{\};\par
5129     {\cf17 template} <{\cf17 class} B1> {\cf17 struct }conjunction<B1> : B1 \{\};\par
5130     {\cf17 template} <{\cf17 class }B1, {\cf17 class}... Bn>\par
5131     {\cf17 struct }conjunction<B1, Bn...>\par
5132         : std::conditional_t<bool( B1::value ), conjunction<Bn...>, B1> \{\};\par
5133 \par
5134     {\cf17 template} <{\cf17 class}...> {\cf17 struct }disjunction : std::false_type \{\};\par
5135     {\cf17 template} <{\cf17 class} B1> {\cf17 struct }disjunction<B1> : B1 \{\};\par
5136     {\cf17 template} <{\cf17 class }B1, {\cf17 class}... Bn>\par
5137     {\cf17 struct }disjunction<B1, Bn...>\par
5138         : std::conditional_t<bool( B1::value ), B1, disjunction<Bn...>> \{\};\par
5139 \par
5140     {\cf17 template} <{\cf17 class} B>\par
5141     {\cf17 struct }negation : std::integral_constant<bool, !bool(B::value)> \{\};\par
5142 \par
5143 {\cf21 #endif}\par
5144 \par
5145 \} {\cf20 // namespace Detail}\par
5146 \} {\cf20 // namespace Catch}\par
5147 \par
5148 {\cf21 #endif }{\cf20 // CATCH_LOGICAL_TRAITS_HPP_INCLUDED}\par
5149 \par
5150 {\cf21 #include <type_traits>}\par
5151 {\cf21 #include <iosfwd>}\par
5152 \par
5233 {\cf21 #ifdef _MSC_VER}\par
5234 {\cf21 #pragma warning(push)}\par
5235 {\cf21 #pragma warning(disable:4389) }{\cf20 // '==' : signed/unsigned mismatch}\par
5236 {\cf21 #pragma warning(disable:4018) }{\cf20 // more "signed/unsigned mismatch"}\par
5237 {\cf21 #pragma warning(disable:4312) }{\cf20 // Converting int to T* using reinterpret_cast (issue on x64 platform)}\par
5238 {\cf21 #pragma warning(disable:4180) }{\cf20 // qualifier applied to function type has no meaning}\par
5239 {\cf21 #pragma warning(disable:4800) }{\cf20 // Forcing result to true or false}\par
5240 {\cf21 #endif}\par
5241 \par
5242 {\cf21 #ifdef __clang__}\par
5243 {\cf21 #  pragma clang diagnostic push}\par
5244 {\cf21 #  pragma clang diagnostic ignored "-Wsign-compare"}\par
5245 {\cf21 #  pragma clang diagnostic ignored "-Wnon-virtual-dtor"}\par
5246 {\cf21 #elif defined __GNUC__}\par
5247 {\cf21 #  pragma GCC diagnostic push}\par
5248 {\cf21 #  pragma GCC diagnostic ignored "-Wsign-compare"}\par
5249 {\cf21 #  pragma GCC diagnostic ignored "-Wnon-virtual-dtor"}\par
5250 {\cf21 #endif}\par
5251 \par
5252 {\cf21 #if defined(CATCH_CPP20_OR_GREATER) && __has_include(<compare>)}\par
5253 {\cf21 #  include <compare>}\par
5254 {\cf21 #    if defined( __cpp_lib_three_way_comparison ) && \\}\par
5255 {\cf21             __cpp_lib_three_way_comparison >= 201907L}\par
5256 {\cf21 #      define CATCH_CONFIG_CPP20_COMPARE_OVERLOADS}\par
5257 {\cf21 #    endif}\par
5258 {\cf21 #endif}\par
5259 \par
5260 {\cf17 namespace }Catch \{\par
5261 \par
5262     {\cf17 namespace }Detail \{\par
5263         {\cf20 // This was added in C++20, but we require only C++14 for now.}\par
5264         {\cf17 template} <{\cf17 typename} T>\par
5265         {\cf17 using }RemoveCVRef_t = std::remove_cv_t<std::remove_reference_t<T>>;\par
5266     \}\par
5267 \par
5268     {\cf20 // Note: There is nothing that stops us from extending this,}\par
5269     {\cf20 //       e.g. to `std::is_scalar`, but the more encompassing}\par
5270     {\cf20 //       traits are usually also more expensive. For now we}\par
5271     {\cf20 //       keep this as it used to be and it can be changed later.}\par
5272     {\cf17 template} <{\cf17 typename} T>\par
5273     {\cf17 struct }capture_by_value\par
5274         : std::integral_constant<bool, std::is_arithmetic<T>\{\}> \{\};\par
5275 \par
5276 {\cf21 #if defined( CATCH_CONFIG_CPP20_COMPARE_OVERLOADS )}\par
5277     {\cf17 template} <>\par
5278     {\cf17 struct }capture_by_value<std::strong_ordering> : std::true_type \{\};\par
5279     {\cf17 template} <>\par
5280     {\cf17 struct }capture_by_value<std::weak_ordering> : std::true_type \{\};\par
5281     {\cf17 template} <>\par
5282     {\cf17 struct }capture_by_value<std::partial_ordering> : std::true_type \{\};\par
5283 {\cf21 #endif}\par
5284 \par
5285     {\cf17 template} <{\cf17 typename} T>\par
5286     {\cf17 struct }always_false : std::false_type \{\};\par
5287 \par
5288     {\cf17 class }ITransientExpression \{\par
5289         {\cf18 bool} m_isBinaryExpression;\par
5290         {\cf18 bool} m_result;\par
5291 \par
5292     {\cf17 public}:\par
5293         {\cf17 constexpr} {\cf17 auto} isBinaryExpression() const -> {\cf18 bool} \{ {\cf19 return} m_isBinaryExpression; \}\par
5294         {\cf17 constexpr} {\cf17 auto} getResult() const -> {\cf18 bool} \{ {\cf19 return} m_result; \}\par
5296         {\cf17 virtual} {\cf18 void} streamReconstructedExpression( std::ostream& os ) {\cf17 const};\par
5297 \par
5298         {\cf17 constexpr} ITransientExpression( {\cf18 bool} isBinaryExpression, {\cf18 bool} result )\par
5299         :   m_isBinaryExpression( isBinaryExpression ),\par
5300             m_result( result )\par
5301         \{\}\par
5302 \par
5303         ITransientExpression() = {\cf19 default};\par
5304         ITransientExpression(ITransientExpression {\cf17 const}&) = {\cf19 default};\par
5305         ITransientExpression& operator=(ITransientExpression {\cf17 const}&) = {\cf19 default};\par
5306 \par
5307         {\cf17 friend} std::ostream& operator<<(std::ostream& out, ITransientExpression {\cf17 const}& expr) \{\par
5308             expr.streamReconstructedExpression(out);\par
5309             {\cf19 return} out;\par
5310         \}\par
5311 \par
5312     {\cf17 protected}:\par
5313         ~ITransientExpression() = {\cf19 default};\par
5314     \};\par
5315 \par
5316     {\cf18 void} formatReconstructedExpression( std::ostream &os, std::string {\cf17 const}& lhs, StringRef op, std::string {\cf17 const}& rhs );\par
5317 \par
5318     {\cf17 template}<{\cf17 typename} LhsT, {\cf17 typename} RhsT>\par
5319     {\cf17 class }BinaryExpr  : {\cf17 public} ITransientExpression \{\par
5320         LhsT m_lhs;\par
5321         StringRef m_op;\par
5322         RhsT m_rhs;\par
5323 \par
5324         {\cf18 void} streamReconstructedExpression( std::ostream &os ){\cf17  const override }\{\par
5325             formatReconstructedExpression\par
5326                     ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\par
5327         \}\par
5328 \par
5329     {\cf17 public}:\par
5330         {\cf17 constexpr} BinaryExpr( {\cf18 bool} comparisonResult, LhsT lhs, StringRef op, RhsT rhs )\par
5331         :   ITransientExpression\{ true, comparisonResult \},\par
5332             m_lhs( lhs ),\par
5333             m_op( op ),\par
5334             m_rhs( rhs )\par
5335         \{\}\par
5336 \par
5337         {\cf17 template}<{\cf17 typename} T>\par
5338         {\cf17 auto} operator && ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5339             {\cf17 static_assert}(always_false<T>::value,\par
5340             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5341             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5342         \}\par
5343 \par
5344         {\cf17 template}<{\cf17 typename} T>\par
5345         {\cf17 auto} operator || ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5346             {\cf17 static_assert}(always_false<T>::value,\par
5347             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5348             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5349         \}\par
5350 \par
5351         {\cf17 template}<{\cf17 typename} T>\par
5352         {\cf17 auto} operator == ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5353             {\cf17 static_assert}(always_false<T>::value,\par
5354             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5355             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5356         \}\par
5357 \par
5358         {\cf17 template}<{\cf17 typename} T>\par
5359         {\cf17 auto} operator != ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5360             {\cf17 static_assert}(always_false<T>::value,\par
5361             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5362             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5363         \}\par
5364 \par
5365         {\cf17 template}<{\cf17 typename} T>\par
5366         {\cf17 auto} operator > ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5367             {\cf17 static_assert}(always_false<T>::value,\par
5368             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5369             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5370         \}\par
5371 \par
5372         {\cf17 template}<{\cf17 typename} T>\par
5373         {\cf17 auto} operator < ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5374             {\cf17 static_assert}(always_false<T>::value,\par
5375             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5376             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5377         \}\par
5378 \par
5379         {\cf17 template}<{\cf17 typename} T>\par
5380         {\cf17 auto} operator >= ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5381             {\cf17 static_assert}(always_false<T>::value,\par
5382             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5383             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5384         \}\par
5385 \par
5386         {\cf17 template}<{\cf17 typename} T>\par
5387         {\cf17 auto} operator <= ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5388             {\cf17 static_assert}(always_false<T>::value,\par
5389             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5390             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5391         \}\par
5392     \};\par
5393 \par
5394     {\cf17 template}<{\cf17 typename} LhsT>\par
5395     {\cf17 class }UnaryExpr : {\cf17 public} ITransientExpression \{\par
5396         LhsT m_lhs;\par
5397 \par
5398         {\cf18 void} streamReconstructedExpression( std::ostream &os ){\cf17  const override }\{\par
5399             os << Catch::Detail::stringify( m_lhs );\par
5400         \}\par
5401 \par
5402     {\cf17 public}:\par
5403         {\cf17 explicit} {\cf17 constexpr} UnaryExpr( LhsT lhs )\par
5404         :   ITransientExpression\{ false, static_cast<bool>(lhs) \},\par
5405             m_lhs( lhs )\par
5406         \{\}\par
5407     \};\par
5408 \par
5409 \par
5410     {\cf17 template}<{\cf17 typename} LhsT>\par
5411     {\cf17 class }ExprLhs \{\par
5412         LhsT m_lhs;\par
5413     {\cf17 public}:\par
5414         {\cf17 explicit} {\cf17 constexpr} ExprLhs( LhsT lhs ) : m_lhs( lhs ) \{\}\par
5415 \par
5416 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( id, op )           \\}\par
5417 {\cf21     template <typename RhsT>                                                   \\}\par
5418 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5419 {\cf21         -> std::enable_if_t<                                                   \\}\par
5420 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5421 {\cf21                                 Detail::negation<capture_by_value<             \\}\par
5422 {\cf21                                     Detail::RemoveCVRef_t<RhsT>>>>::value,     \\}\par
5423 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5424 {\cf21         return \{                                                               \\}\par
5425 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5426 {\cf21     \}                                                                          \\}\par
5427 {\cf21     template <typename RhsT>                                                   \\}\par
5428 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5429 {\cf21         -> std::enable_if_t<                                                   \\}\par
5430 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5431 {\cf21                                 capture_by_value<RhsT>>::value,                \\}\par
5432 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5433 {\cf21         return \{                                                               \\}\par
5434 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5435 {\cf21     \}                                                                          \\}\par
5436 {\cf21     template <typename RhsT>                                                   \\}\par
5437 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5438 {\cf21         -> std::enable_if_t<                                                   \\}\par
5439 {\cf21             Detail::conjunction<                                               \\}\par
5440 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5441 {\cf21                 Detail::is_eq_0_comparable<LhsT>,                              \\}\par
5442 {\cf21               }{\cf20 /* We allow long because we want `ptr op NULL` to be accepted */}{\cf21  \\}\par
5443 {\cf21                 Detail::disjunction<std::is_same<RhsT, int>,                   \\}\par
5444 {\cf21                                     std::is_same<RhsT, long>>>::value,         \\}\par
5445 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5446 {\cf21         if ( rhs != 0 ) \{ throw_test_failure_exception(); \}                    \\}\par
5447 {\cf21         return \{                                                               \\}\par
5448 {\cf21             static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs \};   \\}\par
5449 {\cf21     \}                                                                          \\}\par
5450 {\cf21     template <typename RhsT>                                                   \\}\par
5451 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5452 {\cf21         -> std::enable_if_t<                                                   \\}\par
5453 {\cf21             Detail::conjunction<                                               \\}\par
5454 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5455 {\cf21                 Detail::is_eq_0_comparable<RhsT>,                              \\}\par
5456 {\cf21               }{\cf20 /* We allow long because we want `ptr op NULL` to be accepted */}{\cf21  \\}\par
5457 {\cf21                 Detail::disjunction<std::is_same<LhsT, int>,                   \\}\par
5458 {\cf21                                     std::is_same<LhsT, long>>>::value,         \\}\par
5459 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5460 {\cf21         if ( lhs.m_lhs != 0 ) \{ throw_test_failure_exception(); \}              \\}\par
5461 {\cf21         return \{ static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs \};    \\}\par
5462 {\cf21     \}}\par
5463 \par
5464         CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( eq, == )\par
5465         CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( ne, != )\par
5466 \par
5467     {\cf21 #undef CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR}\par
5468 \par
5469 \par
5470 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( id, op )         \\}\par
5471 {\cf21     template <typename RhsT>                                                   \\}\par
5472 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5473 {\cf21         -> std::enable_if_t<                                                   \\}\par
5474 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5475 {\cf21                                 Detail::negation<capture_by_value<             \\}\par
5476 {\cf21                                     Detail::RemoveCVRef_t<RhsT>>>>::value,     \\}\par
5477 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5478 {\cf21         return \{                                                               \\}\par
5479 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5480 {\cf21     \}                                                                          \\}\par
5481 {\cf21     template <typename RhsT>                                                   \\}\par
5482 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5483 {\cf21         -> std::enable_if_t<                                                   \\}\par
5484 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5485 {\cf21                                 capture_by_value<RhsT>>::value,                \\}\par
5486 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5487 {\cf21         return \{                                                               \\}\par
5488 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5489 {\cf21     \}                                                                          \\}\par
5490 {\cf21     template <typename RhsT>                                                   \\}\par
5491 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5492 {\cf21         -> std::enable_if_t<                                                   \\}\par
5493 {\cf21             Detail::conjunction<                                               \\}\par
5494 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5495 {\cf21                 Detail::is_##id##_0_comparable<LhsT>,                          \\}\par
5496 {\cf21                 std::is_same<RhsT, int>>::value,                               \\}\par
5497 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5498 {\cf21         if ( rhs != 0 ) \{ throw_test_failure_exception(); \}                    \\}\par
5499 {\cf21         return \{                                                               \\}\par
5500 {\cf21             static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs \};   \\}\par
5501 {\cf21     \}                                                                          \\}\par
5502 {\cf21     template <typename RhsT>                                                   \\}\par
5503 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5504 {\cf21         -> std::enable_if_t<                                                   \\}\par
5505 {\cf21             Detail::conjunction<                                               \\}\par
5506 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5507 {\cf21                 Detail::is_##id##_0_comparable<RhsT>,                          \\}\par
5508 {\cf21                 std::is_same<LhsT, int>>::value,                               \\}\par
5509 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5510 {\cf21         if ( lhs.m_lhs != 0 ) \{ throw_test_failure_exception(); \}              \\}\par
5511 {\cf21         return \{ static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs \};    \\}\par
5512 {\cf21     \}}\par
5513 \par
5514         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( lt, < )\par
5515         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( le, <= )\par
5516         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( gt, > )\par
5517         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( ge, >= )\par
5518 \par
5519     {\cf21 #undef CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR}\par
5520 \par
5521 \par
5522 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR( op )                        \\}\par
5523 {\cf21     template <typename RhsT>                                                   \\}\par
5524 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5525 {\cf21         -> std::enable_if_t<                                                   \\}\par
5526 {\cf21             !capture_by_value<Detail::RemoveCVRef_t<RhsT>>::value,             \\}\par
5527 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5528 {\cf21         return \{                                                               \\}\par
5529 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5530 {\cf21     \}                                                                          \\}\par
5531 {\cf21     template <typename RhsT>                                                   \\}\par
5532 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5533 {\cf21         -> std::enable_if_t<capture_by_value<RhsT>::value,                     \\}\par
5534 {\cf21                             BinaryExpr<LhsT, RhsT>> \{                          \\}\par
5535 {\cf21         return \{                                                               \\}\par
5536 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5537 {\cf21     \}}\par
5538 \par
5539         CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(|)\par
5540         CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(&)\par
5541         CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(^)\par
5542 \par
5543     {\cf21 #undef CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR}\par
5544 \par
5545         {\cf17 template}<{\cf17 typename} RhsT>\par
5546         {\cf17 friend} {\cf17 auto} operator && ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> \{\par
5547             {\cf17 static_assert}(always_false<RhsT>::value,\par
5548             {\cf22 "operator&& is not supported inside assertions, "}\par
5549             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5550         \}\par
5551 \par
5552         {\cf17 template}<{\cf17 typename} RhsT>\par
5553         {\cf17 friend} {\cf17 auto} operator || ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> \{\par
5554             {\cf17 static_assert}(always_false<RhsT>::value,\par
5555             {\cf22 "operator|| is not supported inside assertions, "}\par
5556             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5557         \}\par
5558 \par
5559         {\cf17 constexpr} {\cf17 auto} makeUnaryExpr() const -> UnaryExpr<LhsT> \{\par
5560             {\cf19 return} UnaryExpr<LhsT>\{ m_lhs \};\par
5561         \}\par
5562     \};\par
5563 \par
5564     {\cf17 struct }Decomposer \{\par
5565         {\cf17 template} <{\cf17 typename} T,\par
5566                   std::enable_if_t<!capture_by_value<Detail::RemoveCVRef_t<T>>::value,\par
5567                       {\cf18 int}> = 0>\par
5568         {\cf17 constexpr} {\cf17 friend} {\cf17 auto} operator <= ( Decomposer &&, T && lhs ) -> ExprLhs<T const&> \{\par
5569             {\cf19 return} ExprLhs<const T&>\{ lhs \};\par
5570         \}\par
5571 \par
5572         {\cf17 template} <{\cf17 typename} T,\par
5573                   std::enable_if_t<capture_by_value<T>::value, {\cf18 int}> = 0>\par
5574         {\cf17 constexpr} {\cf17 friend} {\cf17 auto} operator <= ( Decomposer &&, T value ) -> ExprLhs<T> \{\par
5575             {\cf19 return} ExprLhs<T>\{ value \};\par
5576         \}\par
5577     \};\par
5578 \par
5579 \} {\cf20 // end namespace Catch}\par
5580 \par
5581 {\cf21 #ifdef _MSC_VER}\par
5582 {\cf21 #pragma warning(pop)}\par
5583 {\cf21 #endif}\par
5584 {\cf21 #ifdef __clang__}\par
5585 {\cf21 #  pragma clang diagnostic pop}\par
5586 {\cf21 #elif defined __GNUC__}\par
5587 {\cf21 #  pragma GCC diagnostic pop}\par
5588 {\cf21 #endif}\par
5589 \par
5590 {\cf21 #endif }{\cf20 // CATCH_DECOMPOSER_HPP_INCLUDED}\par
5591 \par
5592 {\cf21 #include <string>}\par
5593 \par
5594 {\cf17 namespace }Catch \{\par
5595 \par
5596     {\cf17 struct }AssertionReaction \{\par
5597         {\cf18 bool} shouldDebugBreak = {\cf17 false};\par
5598         {\cf18 bool} shouldThrow = {\cf17 false};\par
5599         {\cf18 bool} shouldSkip = {\cf17 false};\par
5600     \};\par
5601 \par
5602     {\cf17 class }AssertionHandler \{\par
5603         AssertionInfo m_assertionInfo;\par
5604         AssertionReaction m_reaction;\par
5605         {\cf18 bool} m_completed = {\cf17 false};\par
5606         IResultCapture& m_resultCapture;\par
5607 \par
5608     {\cf17 public}:\par
5609         AssertionHandler\par
5610             (   StringRef macroName,\par
5611                 SourceLineInfo {\cf17 const}& lineInfo,\par
5612                 StringRef capturedExpression,\par
5613                 ResultDisposition::Flags resultDisposition );\par
5614         ~AssertionHandler() \{\par
5615             {\cf19 if} ( !m_completed ) \{\par
5616                 m_resultCapture.handleIncomplete( m_assertionInfo );\par
5617             \}\par
5618         \}\par
5619 \par
5620 \par
5621         {\cf17 template}<{\cf17 typename} T>\par
5622         {\cf18 void} handleExpr( ExprLhs<T> {\cf17 const}& expr ) \{\par
5623             handleExpr( expr.makeUnaryExpr() );\par
5624         \}\par
5625         {\cf18 void} handleExpr( ITransientExpression {\cf17 const}& expr );\par
5626 \par
5627         {\cf18 void} handleMessage(ResultWas::OfType resultType, StringRef message);\par
5628 \par
5629         {\cf18 void} handleExceptionThrownAsExpected();\par
5630         {\cf18 void} handleUnexpectedExceptionNotThrown();\par
5631         {\cf18 void} handleExceptionNotThrownAsExpected();\par
5632         {\cf18 void} handleThrowingCallSkipped();\par
5633         {\cf18 void} handleUnexpectedInflightException();\par
5634 \par
5635         {\cf18 void} complete();\par
5636 \par
5637         {\cf20 // query}\par
5638         {\cf17 auto} allowThrows() const -> {\cf18 bool};\par
5639     \};\par
5640 \par
5641     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, std::{\cf18 string} const& str );\par
5642 \par
5643 \} {\cf20 // namespace Catch}\par
5644 \par
5645 {\cf21 #endif }{\cf20 // CATCH_ASSERTION_HANDLER_HPP_INCLUDED}\par
5646 \par
5647 \par
5648 {\cf21 #ifndef CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}\par
5649 {\cf21 #define CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}\par
5650 \par
5651 \par
5652 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)}\par
5653 {\cf21   #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__##_catch_sr}\par
5654 {\cf21 #else}\par
5655 {\cf21   #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"_catch_sr}\par
5656 {\cf21 #endif}\par
5657 \par
5658 {\cf21 #endif }{\cf20 // CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}\par
5659 \par
5660 {\cf20 // We need this suppression to leak, because it took until GCC 10}\par
5661 {\cf20 // for the front end to handle local suppression via _Pragma properly}\par
5662 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ <= 9}\par
5663 {\cf21   #pragma GCC diagnostic ignored "-Wparentheses"}\par
5664 {\cf21 #endif}\par
5665 \par
5666 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
5667 \par
5668 {\cf21 #if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
5669 \par
5671 {\cf20 // Another way to speed-up compilation is to omit local try-catch for REQUIRE*}\par
5672 {\cf20 // macros.}\par
5673 {\cf21 #define INTERNAL_CATCH_TRY}\par
5674 {\cf21 #define INTERNAL_CATCH_CATCH( capturer )}\par
5675 \par
5676 {\cf21 #else }{\cf20 // CATCH_CONFIG_FAST_COMPILE}\par
5677 \par
5678 {\cf21 #define INTERNAL_CATCH_TRY try}\par
5679 {\cf21 #define INTERNAL_CATCH_CATCH( handler ) catch(...) \{ (handler).handleUnexpectedInflightException(); \}}\par
5680 \par
5681 {\cf21 #endif}\par
5682 \par
5683 {\cf21 #define INTERNAL_CATCH_REACT( handler ) handler.complete();}\par
5684 \par
5686 {\cf21 #define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \\}\par
5687 {\cf21     do \{ }{\cf20 /* NOLINT(bugprone-infinite-loop) */}{\cf21  \\}\par
5688 {\cf21         }{\cf20 /* The expression should not be evaluated, but warnings should hopefully be checked */}{\cf21  \\}\par
5689 {\cf21         CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \\}\par
5690 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
5691 {\cf21         INTERNAL_CATCH_TRY \{ \\}\par
5692 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5693 {\cf21             CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
5694 {\cf21             catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); }{\cf20 /* NOLINT(bugprone-chained-comparison) */}{\cf21  \\}\par
5695 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5696 {\cf21         \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\}\par
5697 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5698 {\cf21     \} while( (void)0, (false) && static_cast<const bool&>( !!(__VA_ARGS__) ) ) }{\cf20 // the expression here is never evaluated at runtime but it forces the compiler to give it a look}\par
5699     {\cf20 // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.}\par
5700 \par
5702 {\cf21 #define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \\}\par
5703 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
5704 {\cf21     if( Catch::getResultCapture().lastAssertionPassed() )}\par
5705 \par
5707 {\cf21 #define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \\}\par
5708 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
5709 {\cf21     if( !Catch::getResultCapture().lastAssertionPassed() )}\par
5710 \par
5712 {\cf21 #define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \\}\par
5713 {\cf21     do \{ \\}\par
5714 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
5715 {\cf21         try \{ \\}\par
5716 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5717 {\cf21             CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5718 {\cf21             static_cast<void>(__VA_ARGS__); \\}\par
5719 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5720 {\cf21             catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\}\par
5721 {\cf21         \} \\}\par
5722 {\cf21         catch( ... ) \{ \\}\par
5723 {\cf21             catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
5724 {\cf21         \} \\}\par
5725 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5726 {\cf21     \} while( false )}\par
5727 \par
5729 {\cf21 #define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \\}\par
5730 {\cf21     do \{ \\}\par
5731 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\}\par
5732 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5733 {\cf21             try \{ \\}\par
5734 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5735 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5736 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5737 {\cf21                 static_cast<void>(__VA_ARGS__); \\}\par
5738 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5739 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5740 {\cf21             \} \\}\par
5741 {\cf21             catch( ... ) \{ \\}\par
5742 {\cf21                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\}\par
5743 {\cf21             \} \\}\par
5744 {\cf21         else \\}\par
5745 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5746 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5747 {\cf21     \} while( false )}\par
5748 \par
5750 {\cf21 #define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \\}\par
5751 {\cf21     do \{ \\}\par
5752 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\}\par
5753 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5754 {\cf21             try \{ \\}\par
5755 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5756 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5757 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5758 {\cf21                 static_cast<void>(expr); \\}\par
5759 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5760 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5761 {\cf21             \} \\}\par
5762 {\cf21             catch( exceptionType const& ) \{ \\}\par
5763 {\cf21                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\}\par
5764 {\cf21             \} \\}\par
5765 {\cf21             catch( ... ) \{ \\}\par
5766 {\cf21                 catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
5767 {\cf21             \} \\}\par
5768 {\cf21         else \\}\par
5769 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5770 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5771 {\cf21     \} while( false )}\par
5772 \par
5773 \par
5774 \par
5776 {\cf20 // Although this is matcher-based, it can be used with just a string}\par
5777 {\cf21 #define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \\}\par
5778 {\cf21     do \{ \\}\par
5779 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\}\par
5780 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5781 {\cf21             try \{ \\}\par
5782 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5783 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5784 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5785 {\cf21                 static_cast<void>(__VA_ARGS__); \\}\par
5786 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5787 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5788 {\cf21             \} \\}\par
5789 {\cf21             catch( ... ) \{ \\}\par
5790 {\cf21                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher ); \\}\par
5791 {\cf21             \} \\}\par
5792 {\cf21         else \\}\par
5793 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5794 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5795 {\cf21     \} while( false )}\par
5796 \par
5797 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE}\par
5798 \par
5799 {\cf21 #endif }{\cf20 // CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}\par
5800 \par
5801 \par
5802 {\cf21 #ifndef CATCH_SECTION_HPP_INCLUDED}\par
5803 {\cf21 #define CATCH_SECTION_HPP_INCLUDED}\par
5804 \par
5805 \par
5806 \par
5807 \par
5817 {\cf21 #ifndef CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}\par
5818 {\cf21 #define CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}\par
5819 \par
5820 \par
5821 {\cf21 #if defined(__clang_analyzer__) || defined(__COVERITY__)}\par
5822 {\cf21     #define CATCH_INTERNAL_CONFIG_STATIC_ANALYSIS_SUPPORT}\par
5823 {\cf21 #endif}\par
5824 \par
5825 {\cf21 #if defined( CATCH_INTERNAL_CONFIG_STATIC_ANALYSIS_SUPPORT ) && \\}\par
5826 {\cf21     !defined( CATCH_CONFIG_NO_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT ) && \\}\par
5827 {\cf21     !defined( CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT )}\par
5828 {\cf21 #    define CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT}\par
5829 {\cf21 #endif}\par
5830 \par
5831 \par
5832 {\cf21 #endif }{\cf20 // CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}\par
5833 \par
5834 \par
5835 {\cf21 #ifndef CATCH_TIMER_HPP_INCLUDED}\par
5836 {\cf21 #define CATCH_TIMER_HPP_INCLUDED}\par
5837 \par
5838 {\cf21 #include <cstdint>}\par
5839 \par
5840 {\cf17 namespace }Catch \{\par
5841 \par
5842     {\cf17 class }Timer \{\par
5843         uint64_t m_nanoseconds = 0;\par
5844     {\cf17 public}:\par
5845         {\cf18 void} start();\par
5846         {\cf17 auto} getElapsedNanoseconds() {\cf17 const} -> uint64_t;\par
5847         {\cf17 auto} getElapsedMicroseconds() {\cf17 const} -> uint64_t;\par
5848         {\cf17 auto} getElapsedMilliseconds() {\cf17 const} -> {\cf18 unsigned} int;\par
5849         {\cf17 auto} getElapsedSeconds() {\cf17 const} -> double;\par
5850     \};\par
5851 \par
5852 \} {\cf20 // namespace Catch}\par
5853 \par
5854 {\cf21 #endif }{\cf20 // CATCH_TIMER_HPP_INCLUDED}\par
5855 \par
5856 {\cf17 namespace }Catch \{\par
5857 \par
5858     {\cf17 class }Section : Detail::NonCopyable \{\par
5859     {\cf17 public}:\par
5860         Section( SectionInfo&& info );\par
5861         Section( SourceLineInfo {\cf17 const}& _lineInfo,\par
5862                  StringRef _name,\par
5863                  {\cf17 const} {\cf18 char}* {\cf17 const} = {\cf17 nullptr} );\par
5864         ~Section();\par
5865 \par
5866         {\cf20 // This indicates whether the section should be executed or not}\par
5867         {\cf17 explicit} {\cf17 operator} bool() {\cf17 const};\par
5868 \par
5869     {\cf17 private}:\par
5870         SectionInfo m_info;\par
5871 \par
5872         Counts m_assertions;\par
5873         {\cf18 bool} m_sectionIncluded;\par
5874         Timer m_timer;\par
5875     \};\par
5876 \par
5877 \} {\cf20 // end namespace Catch}\par
5878 \par
5879 {\cf21 #if !defined(CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT)}\par
5880 {\cf21 #    define INTERNAL_CATCH_SECTION( ... )                                 \\}\par
5881 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                         \\}\par
5882 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                  \\}\par
5883 {\cf21         if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(            \\}\par
5884 {\cf21                  catch_internal_Section ) =                               \\}\par
5885 {\cf21                  Catch::Section( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \\}\par
5886 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5887 \par
5888 {\cf21 #    define INTERNAL_CATCH_DYNAMIC_SECTION( ... )                     \\}\par
5889 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                     \\}\par
5890 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS              \\}\par
5891 {\cf21         if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(        \\}\par
5892 {\cf21                  catch_internal_Section ) =                           \\}\par
5893 {\cf21                  Catch::SectionInfo(                                  \\}\par
5894 {\cf21                      CATCH_INTERNAL_LINEINFO,                         \\}\par
5895 {\cf21                      ( Catch::ReusableStringStream() << __VA_ARGS__ ) \\}\par
5896 {\cf21                          .str() ) )                                   \\}\par
5897 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5898 \par
5899 {\cf21 #else}\par
5900 \par
5901 {\cf20 // These section definitions imply that at most one section at one level}\par
5902 {\cf20 // will be intered (because only one section's __LINE__ can be equal to}\par
5903 {\cf20 // the dummy `catchInternalSectionHint` variable from `TEST_CASE`).}\par
5904 \par
5905 {\cf17 namespace }Catch \{\par
5906     {\cf17 namespace }Detail \{\par
5907         {\cf20 // Intentionally without linkage, as it should only be used as a dummy}\par
5908         {\cf20 // symbol for static analysis.}\par
5909         {\cf20 // The arguments are used as a dummy for checking warnings in the passed}\par
5910         {\cf20 // expressions.}\par
5911         {\cf18 int} GetNewSectionHint( StringRef, {\cf17 const} {\cf18 char}* {\cf17 const} = {\cf17 nullptr} );\par
5912     \} {\cf20 // namespace Detail}\par
5913 \} {\cf20 // namespace Catch}\par
5914 \par
5915 \par
5916 {\cf21 #    define INTERNAL_CATCH_SECTION( ... )                                   \\}\par
5917 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                           \\}\par
5918 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                    \\}\par
5919 {\cf21         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\}\par
5920 {\cf21         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\}\par
5921 {\cf21                  catchInternalSectionHint,                                  \\}\par
5922 {\cf21              catchInternalSectionHint =                                     \\}\par
5923 {\cf21                  Catch::Detail::GetNewSectionHint(__VA_ARGS__);             \\}\par
5924 {\cf21              catchInternalPreviousSectionHint == __LINE__ )                 \\}\par
5925 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5926 \par
5927 {\cf21 #    define INTERNAL_CATCH_DYNAMIC_SECTION( ... )                           \\}\par
5928 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                           \\}\par
5929 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                    \\}\par
5930 {\cf21         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\}\par
5931 {\cf21         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\}\par
5932 {\cf21                  catchInternalSectionHint,                                  \\}\par
5933 {\cf21              catchInternalSectionHint = Catch::Detail::GetNewSectionHint(   \\}\par
5934 {\cf21                 ( Catch::ReusableStringStream() << __VA_ARGS__ ).str());    \\}\par
5935 {\cf21              catchInternalPreviousSectionHint == __LINE__ )                 \\}\par
5936 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5937 \par
5938 {\cf21 #endif}\par
5939 \par
5940 \par
5941 {\cf21 #endif }{\cf20 // CATCH_SECTION_HPP_INCLUDED}\par
5942 \par
5943 \par
5944 {\cf21 #ifndef CATCH_TEST_REGISTRY_HPP_INCLUDED}\par
5945 {\cf21 #define CATCH_TEST_REGISTRY_HPP_INCLUDED}\par
5946 \par
5947 \par
5948 \par
5949 {\cf21 #ifndef CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}\par
5950 {\cf21 #define CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}\par
5951 \par
5952 {\cf17 namespace }Catch \{\par
5953 \par
5954     {\cf17 class }ITestInvoker \{\par
5955     {\cf17 public}:\par
5956         {\cf17 virtual} {\cf18 void} invoke() {\cf17 const} = 0;\par
5957         {\cf17 virtual} ~ITestInvoker(); {\cf20 // = default}\par
5958     \};\par
5959 \par
5960 \} {\cf20 // namespace Catch}\par
5961 \par
5962 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}\par
5963 \par
5964 \par
5965 {\cf21 #ifndef CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}\par
5966 {\cf21 #define CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}\par
5967 \par
5968 {\cf21 #define INTERNAL_CATCH_EXPAND1( param ) INTERNAL_CATCH_EXPAND2( param )}\par
5969 {\cf21 #define INTERNAL_CATCH_EXPAND2( ... ) INTERNAL_CATCH_NO##__VA_ARGS__}\par
5970 {\cf21 #define INTERNAL_CATCH_DEF( ... ) INTERNAL_CATCH_DEF __VA_ARGS__}\par
5971 {\cf21 #define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF}\par
5972 \par
5973 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS( ... ) \\}\par
5974 {\cf21     INTERNAL_CATCH_EXPAND1( INTERNAL_CATCH_DEF __VA_ARGS__ )}\par
5975 \par
5976 {\cf21 #endif }{\cf20 // CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}\par
5977 \par
5978 {\cf20 // GCC 5 and older do not properly handle disabling unused-variable warning}\par
5979 {\cf20 // with a _Pragma. This means that we have to leak the suppression to the}\par
5980 {\cf20 // user code as well :-(}\par
5981 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5}\par
5982 {\cf21 #pragma GCC diagnostic ignored "-Wunused-variable"}\par
5983 {\cf21 #endif}\par
5984 \par
5985 \par
5986 \par
5987 {\cf17 namespace }Catch \{\par
5988 \par
5989 {\cf17 template}<{\cf17 typename} C>\par
5990 {\cf17 class }TestInvokerAsMethod : {\cf17 public} ITestInvoker \{\par
5991     void (C::*m_testAsMethod)();\par
5992 {\cf17 public}:\par
5993     TestInvokerAsMethod( {\cf18 void} (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) \{\}\par
5994 \par
5995     {\cf18 void} invoke(){\cf17  const override }\{\par
5996         C obj;\par
5997         (obj.*m_testAsMethod)();\par
5998     \}\par
5999 \};\par
6000 \par
6001 Detail::unique_ptr<ITestInvoker> makeTestInvoker( {\cf18 void}(*testAsFunction)() );\par
6002 \par
6003 {\cf17 template}<{\cf17 typename} C>\par
6004 Detail::unique_ptr<ITestInvoker> makeTestInvoker( {\cf18 void} (C::*testAsMethod)() ) \{\par
6005     {\cf19 return} Detail::make_unique<TestInvokerAsMethod<C>>( testAsMethod );\par
6006 \}\par
6007 \par
6008 {\cf17 struct }NameAndTags \{\par
6009     {\cf17 constexpr} NameAndTags( StringRef name_ = StringRef(),\par
6010                            StringRef tags_ = StringRef() ) noexcept:\par
6011         name( name_ ), tags( tags_ ) \{\}\par
6012     StringRef name;\par
6013     StringRef tags;\par
6014 \};\par
6015 \par
6016 {\cf17 struct }AutoReg : Detail::NonCopyable \{\par
6017     AutoReg( Detail::unique_ptr<ITestInvoker> invoker, SourceLineInfo {\cf17 const}& lineInfo, StringRef classOrMethod, NameAndTags {\cf17 const}& nameAndTags ) {\cf17 noexcept};\par
6018 \};\par
6019 \par
6020 \} {\cf20 // end namespace Catch}\par
6021 \par
6022 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
6023 {\cf21     #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \\}\par
6024 {\cf21         static inline void TestName()}\par
6025 {\cf21     #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \\}\par
6026 {\cf21         namespace\{                        \\}\par
6027 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) \{ \\}\par
6028 {\cf21                 void test();              \\}\par
6029 {\cf21             \};                            \\}\par
6030 {\cf21         \}                                 \\}\par
6031 {\cf21         void TestName::test()}\par
6032 {\cf21 #endif}\par
6033 \par
6034 \par
6035 {\cf21 #if !defined(CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT)}\par
6036 \par
6038 {\cf21     #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \\}\par
6039 {\cf21         static void TestName(); \\}\par
6040 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6041 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6042 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6043 {\cf21         namespace\{ const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); \} }{\cf20 /* NOLINT */}{\cf21  \\}\par
6044 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6045 {\cf21         static void TestName()}\par
6046 {\cf21     #define INTERNAL_CATCH_TESTCASE( ... ) \\}\par
6047 {\cf21         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__ )}\par
6048 \par
6049 {\cf21 #else  }{\cf20 // ^^ !CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT | vv CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT}\par
6050 \par
6051 \par
6052 {\cf20 // Dummy registrator for the dumy test case macros}\par
6053 {\cf17 namespace }Catch \{\par
6054     {\cf17 namespace }Detail \{\par
6055         {\cf17 struct }DummyUse \{\par
6056             DummyUse( {\cf18 void} ( * )( {\cf18 int} ), Catch::NameAndTags {\cf17 const}& );\par
6057         \};\par
6058     \} {\cf20 // namespace Detail}\par
6059 \} {\cf20 // namespace Catch}\par
6060 \par
6061 {\cf20 // Note that both the presence of the argument and its exact name are}\par
6062 {\cf20 // necessary for the section support.}\par
6063 \par
6064 {\cf20 // We provide a shadowed variable so that a `SECTION` inside non-`TEST_CASE`}\par
6065 {\cf20 // tests can compile. The redefined `TEST_CASE` shadows this with param.}\par
6066 {\cf17 static} {\cf18 int} catchInternalSectionHint = 0;\par
6067 \par
6068 {\cf21 #    define INTERNAL_CATCH_TESTCASE2( fname, ... )                         \\}\par
6069 {\cf21         static void fname( int );                                          \\}\par
6070 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \\}\par
6071 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \\}\par
6072 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                   \\}\par
6073 {\cf21         static const Catch::Detail::DummyUse INTERNAL_CATCH_UNIQUE_NAME(   \\}\par
6074 {\cf21             dummyUser )( &(fname), Catch::NameAndTags\{ __VA_ARGS__ \} );    \\}\par
6075 {\cf21         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                            \\}\par
6076 {\cf21         static void fname( [[maybe_unused]] int catchInternalSectionHint ) \\}\par
6077 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
6078 {\cf21 #    define INTERNAL_CATCH_TESTCASE( ... ) \\}\par
6079 {\cf21         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ), __VA_ARGS__ )}\par
6080 \par
6081 \par
6082 {\cf21 #endif }{\cf20 // CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT}\par
6083 \par
6085 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\}\par
6086 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6087 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6088 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6089 {\cf21         namespace\{ \\}\par
6090 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) \{ \\}\par
6091 {\cf21                 void test(); \\}\par
6092 {\cf21             \}; \\}\par
6093 {\cf21             const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\}\par
6094 {\cf21             Catch::makeTestInvoker( &TestName::test ),                    \\}\par
6095 {\cf21             CATCH_INTERNAL_LINEINFO,                                      \\}\par
6096 {\cf21             #ClassName##_catch_sr,                                        \\}\par
6097 {\cf21             Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
6098 {\cf21         \} \\}\par
6099 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6100 {\cf21         void TestName::test()}\par
6101 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \\}\par
6102 {\cf21         INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), ClassName, __VA_ARGS__ )}\par
6103 \par
6104 \par
6106 {\cf21     #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\}\par
6107 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6108 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6109 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6110 {\cf21         namespace \{                                                           \\}\par
6111 {\cf21         const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\}\par
6112 {\cf21             Catch::makeTestInvoker( &QualifiedMethod ),                   \\}\par
6113 {\cf21             CATCH_INTERNAL_LINEINFO,                                      \\}\par
6114 {\cf21             "&" #QualifiedMethod##_catch_sr,                              \\}\par
6115 {\cf21             Catch::NameAndTags\{ __VA_ARGS__ \} );                          \\}\par
6116 {\cf21     \} }{\cf20 /* NOLINT */}{\cf21  \\}\par
6117 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
6118 \par
6119 \par
6121 {\cf21     #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \\}\par
6122 {\cf21         do \{ \\}\par
6123 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6124 {\cf21             CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6125 {\cf21             CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6126 {\cf21             Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
6127 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6128 {\cf21         \} while(false)}\par
6129 \par
6130 \par
6131 {\cf21 #endif }{\cf20 // CATCH_TEST_REGISTRY_HPP_INCLUDED}\par
6132 \par
6133 \par
6134 {\cf20 // All of our user-facing macros support configuration toggle, that}\par
6135 {\cf20 // forces them to be defined prefixed with CATCH_. We also like to}\par
6136 {\cf20 // support another toggle that can minimize (disable) their implementation.}\par
6137 {\cf20 // Given this, we have 4 different configuration options below}\par
6138 \par
6139 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
6140 \par
6141 {\cf21   #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6142 {\cf21   #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6143 \par
6144 {\cf21   #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6145 {\cf21   #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )}\par
6146 {\cf21   #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6147 \par
6148 {\cf21   #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6149 {\cf21   #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6150 {\cf21   #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6151 {\cf21   #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6152 {\cf21   #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6153 \par
6154 {\cf21   #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6155 {\cf21   #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}\par
6156 {\cf21   #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6157 \par
6158 {\cf21   #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )}\par
6159 {\cf21   #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6160 {\cf21   #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )}\par
6161 {\cf21   #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )}\par
6162 {\cf21   #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )}\par
6163 {\cf21   #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )}\par
6164 {\cf21   #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6165 {\cf21   #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6166 {\cf21   #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6167 {\cf21   #define CATCH_SKIP( ... ) INTERNAL_CATCH_MSG( "SKIP", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6168 \par
6169 \par
6170 {\cf21   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)}\par
6171 {\cf21     #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )}\par
6172 {\cf21     #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )}\par
6173 {\cf21     #define CATCH_STATIC_CHECK( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )}\par
6174 {\cf21     #define CATCH_STATIC_CHECK_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )}\par
6175 {\cf21   #else}\par
6176 {\cf21     #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )}\par
6177 {\cf21     #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )}\par
6178 {\cf21     #define CATCH_STATIC_CHECK( ... )       CATCH_CHECK( __VA_ARGS__ )}\par
6179 {\cf21     #define CATCH_STATIC_CHECK_FALSE( ... ) CATCH_CHECK_FALSE( __VA_ARGS__ )}\par
6180 {\cf21   #endif}\par
6181 \par
6182 \par
6183   {\cf20 // "BDD-style" convenience wrappers}\par
6184 {\cf21   #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )}\par
6185 {\cf21   #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )}\par
6186 {\cf21   #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )}\par
6187 {\cf21   #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )}\par
6188 {\cf21   #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )}\par
6189 {\cf21   #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )}\par
6190 {\cf21   #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )}\par
6191 {\cf21   #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )}\par
6192 \par
6193 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) }{\cf20 // ^^ prefixed, implemented | vv prefixed, disabled}\par
6194 \par
6195 {\cf21   #define CATCH_REQUIRE( ... )        (void)(0)}\par
6196 {\cf21   #define CATCH_REQUIRE_FALSE( ... )  (void)(0)}\par
6197 \par
6198 {\cf21   #define CATCH_REQUIRE_THROWS( ... ) (void)(0)}\par
6199 {\cf21   #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6200 {\cf21   #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)}\par
6201 \par
6202 {\cf21   #define CATCH_CHECK( ... )         (void)(0)}\par
6203 {\cf21   #define CATCH_CHECK_FALSE( ... )   (void)(0)}\par
6204 {\cf21   #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)}\par
6205 {\cf21   #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))}\par
6206 {\cf21   #define CATCH_CHECK_NOFAIL( ... )  (void)(0)}\par
6207 \par
6208 {\cf21   #define CATCH_CHECK_THROWS( ... )  (void)(0)}\par
6209 {\cf21   #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6210 {\cf21   #define CATCH_CHECK_NOTHROW( ... ) (void)(0)}\par
6211 \par
6212 {\cf21   #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6213 {\cf21   #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6214 {\cf21   #define CATCH_METHOD_AS_TEST_CASE( method, ... )}\par
6215 {\cf21   #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)}\par
6216 {\cf21   #define CATCH_SECTION( ... )}\par
6217 {\cf21   #define CATCH_DYNAMIC_SECTION( ... )}\par
6218 {\cf21   #define CATCH_FAIL( ... ) (void)(0)}\par
6219 {\cf21   #define CATCH_FAIL_CHECK( ... ) (void)(0)}\par
6220 {\cf21   #define CATCH_SUCCEED( ... ) (void)(0)}\par
6221 {\cf21   #define CATCH_SKIP( ... ) (void)(0)}\par
6222 \par
6223 {\cf21   #define CATCH_STATIC_REQUIRE( ... )       (void)(0)}\par
6224 {\cf21   #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)}\par
6225 {\cf21   #define CATCH_STATIC_CHECK( ... )       (void)(0)}\par
6226 {\cf21   #define CATCH_STATIC_CHECK_FALSE( ... ) (void)(0)}\par
6227 \par
6228   {\cf20 // "BDD-style" convenience wrappers}\par
6229 {\cf21   #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6230 {\cf21   #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), className )}\par
6231 {\cf21   #define CATCH_GIVEN( desc )}\par
6232 {\cf21   #define CATCH_AND_GIVEN( desc )}\par
6233 {\cf21   #define CATCH_WHEN( desc )}\par
6234 {\cf21   #define CATCH_AND_WHEN( desc )}\par
6235 {\cf21   #define CATCH_THEN( desc )}\par
6236 {\cf21   #define CATCH_AND_THEN( desc )}\par
6237 \par
6238 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE) }{\cf20 // ^^ prefixed, disabled | vv unprefixed, implemented}\par
6239 \par
6240 {\cf21   #define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )}\par
6241 {\cf21   #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6242 \par
6243 {\cf21   #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6244 {\cf21   #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )}\par
6245 {\cf21   #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6246 \par
6247 {\cf21   #define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6248 {\cf21   #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6249 {\cf21   #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6250 {\cf21   #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6251 {\cf21   #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6252 \par
6253 {\cf21   #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6254 {\cf21   #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}\par
6255 {\cf21   #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6256 \par
6257 {\cf21   #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )}\par
6258 {\cf21   #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6259 {\cf21   #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )}\par
6260 {\cf21   #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )}\par
6261 {\cf21   #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )}\par
6262 {\cf21   #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )}\par
6263 {\cf21   #define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6264 {\cf21   #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6265 {\cf21   #define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6266 {\cf21   #define SKIP( ... ) INTERNAL_CATCH_MSG( "SKIP", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6267 \par
6268 \par
6269 {\cf21   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)}\par
6270 {\cf21     #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )}\par
6271 {\cf21     #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )}\par
6272 {\cf21     #define STATIC_CHECK( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )}\par
6273 {\cf21     #define STATIC_CHECK_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )}\par
6274 {\cf21   #else}\par
6275 {\cf21     #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )}\par
6276 {\cf21     #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )}\par
6277 {\cf21     #define STATIC_CHECK( ... )       CHECK( __VA_ARGS__ )}\par
6278 {\cf21     #define STATIC_CHECK_FALSE( ... ) CHECK_FALSE( __VA_ARGS__ )}\par
6279 {\cf21   #endif}\par
6280 \par
6281   {\cf20 // "BDD-style" convenience wrappers}\par
6282 {\cf21   #define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )}\par
6283 {\cf21   #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )}\par
6284 {\cf21   #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )}\par
6285 {\cf21   #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )}\par
6286 {\cf21   #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )}\par
6287 {\cf21   #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )}\par
6288 {\cf21   #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )}\par
6289 {\cf21   #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )}\par
6290 \par
6291 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) }{\cf20 // ^^ unprefixed, implemented | vv unprefixed, disabled}\par
6292 \par
6293 {\cf21   #define REQUIRE( ... )       (void)(0)}\par
6294 {\cf21   #define REQUIRE_FALSE( ... ) (void)(0)}\par
6295 \par
6296 {\cf21   #define REQUIRE_THROWS( ... ) (void)(0)}\par
6297 {\cf21   #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6298 {\cf21   #define REQUIRE_NOTHROW( ... ) (void)(0)}\par
6299 \par
6300 {\cf21   #define CHECK( ... ) (void)(0)}\par
6301 {\cf21   #define CHECK_FALSE( ... ) (void)(0)}\par
6302 {\cf21   #define CHECKED_IF( ... ) if (__VA_ARGS__)}\par
6303 {\cf21   #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))}\par
6304 {\cf21   #define CHECK_NOFAIL( ... ) (void)(0)}\par
6305 \par
6306 {\cf21   #define CHECK_THROWS( ... )  (void)(0)}\par
6307 {\cf21   #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6308 {\cf21   #define CHECK_NOTHROW( ... ) (void)(0)}\par
6309 \par
6310 {\cf21   #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__)}\par
6311 {\cf21   #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6312 {\cf21   #define METHOD_AS_TEST_CASE( method, ... )}\par
6313 {\cf21   #define REGISTER_TEST_CASE( Function, ... ) (void)(0)}\par
6314 {\cf21   #define SECTION( ... )}\par
6315 {\cf21   #define DYNAMIC_SECTION( ... )}\par
6316 {\cf21   #define FAIL( ... ) (void)(0)}\par
6317 {\cf21   #define FAIL_CHECK( ... ) (void)(0)}\par
6318 {\cf21   #define SUCCEED( ... ) (void)(0)}\par
6319 {\cf21   #define SKIP( ... ) (void)(0)}\par
6320 \par
6321 {\cf21   #define STATIC_REQUIRE( ... )       (void)(0)}\par
6322 {\cf21   #define STATIC_REQUIRE_FALSE( ... ) (void)(0)}\par
6323 {\cf21   #define STATIC_CHECK( ... )       (void)(0)}\par
6324 {\cf21   #define STATIC_CHECK_FALSE( ... ) (void)(0)}\par
6325 \par
6326   {\cf20 // "BDD-style" convenience wrappers}\par
6327 {\cf21   #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ) )}\par
6328 {\cf21   #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), className )}\par
6329 \par
6330 {\cf21   #define GIVEN( desc )}\par
6331 {\cf21   #define AND_GIVEN( desc )}\par
6332 {\cf21   #define WHEN( desc )}\par
6333 {\cf21   #define AND_WHEN( desc )}\par
6334 {\cf21   #define THEN( desc )}\par
6335 {\cf21   #define AND_THEN( desc )}\par
6336 \par
6337 {\cf21 #endif }{\cf20 // ^^ unprefixed, disabled}\par
6338 \par
6339 {\cf20 // end of user facing macros}\par
6340 \par
6341 {\cf21 #endif }{\cf20 // CATCH_TEST_MACROS_HPP_INCLUDED}\par
6342 \par
6343 \par
6344 {\cf21 #ifndef CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}\par
6345 {\cf21 #define CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}\par
6346 \par
6347 \par
6348 \par
6349 {\cf21 #ifndef CATCH_PREPROCESSOR_HPP_INCLUDED}\par
6350 {\cf21 #define CATCH_PREPROCESSOR_HPP_INCLUDED}\par
6351 \par
6352 \par
6353 {\cf21 #if defined(__GNUC__)}\par
6354 {\cf20 // We need to silence "empty __VA_ARGS__ warning", and using just _Pragma does not work}\par
6355 {\cf21 #pragma GCC system_header}\par
6356 {\cf21 #endif}\par
6357 \par
6358 \par
6359 {\cf21 #define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__}\par
6360 {\cf21 #define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))}\par
6361 {\cf21 #define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))}\par
6362 {\cf21 #define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))}\par
6363 {\cf21 #define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))}\par
6364 {\cf21 #define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))}\par
6365 \par
6366 {\cf21 #ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6367 {\cf21 #define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__}\par
6368 {\cf20 // MSVC needs more evaluations}\par
6369 {\cf21 #define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))}\par
6370 {\cf21 #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))}\par
6371 {\cf21 #else}\par
6372 {\cf21 #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)}\par
6373 {\cf21 #endif}\par
6374 \par
6375 {\cf21 #define CATCH_REC_END(...)}\par
6376 {\cf21 #define CATCH_REC_OUT}\par
6377 \par
6378 {\cf21 #define CATCH_EMPTY()}\par
6379 {\cf21 #define CATCH_DEFER(id) id CATCH_EMPTY()}\par
6380 \par
6381 {\cf21 #define CATCH_REC_GET_END2() 0, CATCH_REC_END}\par
6382 {\cf21 #define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2}\par
6383 {\cf21 #define CATCH_REC_GET_END(...) CATCH_REC_GET_END1}\par
6384 {\cf21 #define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT}\par
6385 {\cf21 #define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)}\par
6386 {\cf21 #define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)}\par
6387 \par
6388 {\cf21 #define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )}\par
6389 {\cf21 #define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )}\par
6390 {\cf21 #define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )}\par
6391 \par
6392 {\cf21 #define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )}\par
6393 {\cf21 #define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )}\par
6394 {\cf21 #define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )}\par
6395 \par
6396 {\cf20 // Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,}\par
6397 {\cf20 // and passes userdata as the first parameter to each invocation,}\par
6398 {\cf20 // e.g. CATCH_REC_LIST_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)}\par
6399 {\cf21 #define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))}\par
6400 \par
6401 {\cf21 #define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))}\par
6402 \par
6403 {\cf21 #define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)}\par
6404 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6405 {\cf21 #define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__}\par
6406 {\cf21 #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))}\par
6407 {\cf21 #else}\par
6408 {\cf20 // MSVC is adding extra space and needs another indirection to expand INTERNAL_CATCH_NOINTERNAL_CATCH_DEF}\par
6409 {\cf21 #define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)}\par
6410 {\cf21 #define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__}\par
6411 {\cf21 #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)}\par
6412 {\cf21 #endif}\par
6413 \par
6414 {\cf21 #define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__}\par
6415 {\cf21 #define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)}\par
6416 \par
6417 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6418 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())}\par
6419 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))}\par
6420 {\cf21 #else}\par
6421 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))}\par
6422 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))}\par
6423 {\cf21 #endif}\par
6424 \par
6425 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\\}\par
6426 {\cf21     CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)}\par
6427 \par
6428 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)}\par
6429 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)}\par
6430 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)}\par
6431 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)}\par
6432 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)}\par
6433 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)}\par
6434 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)}\par
6435 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)}\par
6436 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)}\par
6437 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)}\par
6438 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)}\par
6439 \par
6440 {\cf21 #define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N}\par
6441 \par
6442 {\cf21 #define INTERNAL_CATCH_TYPE_GEN\\}\par
6443 {\cf21     template<typename...> struct TypeList \{\};\\}\par
6444 {\cf21     template<typename...Ts>\\}\par
6445 {\cf21     constexpr auto get_wrapper() noexcept -> TypeList<Ts...> \{ return \{\}; \}\\}\par
6446 {\cf21     template<template<typename...> class...> struct TemplateTypeList\{\};\\}\par
6447 {\cf21     template<template<typename...> class...Cs>\\}\par
6448 {\cf21     constexpr auto get_wrapper() noexcept -> TemplateTypeList<Cs...> \{ return \{\}; \}\\}\par
6449 {\cf21     template<typename...>\\}\par
6450 {\cf21     struct append;\\}\par
6451 {\cf21     template<typename...>\\}\par
6452 {\cf21     struct rewrap;\\}\par
6453 {\cf21     template<template<typename...> class, typename...>\\}\par
6454 {\cf21     struct create;\\}\par
6455 {\cf21     template<template<typename...> class, typename>\\}\par
6456 {\cf21     struct convert;\\}\par
6457 {\cf21     \\}\par
6458 {\cf21     template<typename T> \\}\par
6459 {\cf21     struct append<T> \{ using type = T; \};\\}\par
6460 {\cf21     template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\}\par
6461 {\cf21     struct append<L1<E1...>, L2<E2...>, Rest...> \{ using type = typename append<L1<E1...,E2...>, Rest...>::type; \};\\}\par
6462 {\cf21     template< template<typename...> class L1, typename...E1, typename...Rest>\\}\par
6463 {\cf21     struct append<L1<E1...>, TypeList<mpl_::na>, Rest...> \{ using type = L1<E1...>; \};\\}\par
6464 {\cf21     \\}\par
6465 {\cf21     template< template<typename...> class Container, template<typename...> class List, typename...elems>\\}\par
6466 {\cf21     struct rewrap<TemplateTypeList<Container>, List<elems...>> \{ using type = TypeList<Container<elems...>>; \};\\}\par
6467 {\cf21     template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\\}\par
6468 {\cf21     struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> \{ using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; \};\\}\par
6469 {\cf21     \\}\par
6470 {\cf21     template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\}\par
6471 {\cf21     struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; \};\\}\par
6472 {\cf21     template<template <typename...> class Final, template <typename...> class List, typename...Ts>\\}\par
6473 {\cf21     struct convert<Final, List<Ts...>> \{ using type = typename append<Final<>,TypeList<Ts>...>::type; \};}\par
6474 \par
6475 {\cf21 #define INTERNAL_CATCH_NTTP_1(signature, ...)\\}\par
6476 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp\{\};\\}\par
6477 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6478 {\cf21     constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> \{ return \{\}; \} \\}\par
6479 {\cf21     template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...> struct NttpTemplateTypeList\{\};\\}\par
6480 {\cf21     template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Cs>\\}\par
6481 {\cf21     constexpr auto get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> \{ return \{\}; \} \\}\par
6482 {\cf21     \\}\par
6483 {\cf21     template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6484 {\cf21     struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> \{ using type = TypeList<Container<__VA_ARGS__>>; \};\\}\par
6485 {\cf21     template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\\}\par
6486 {\cf21     struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> \{ using type = typename append<TypeList<Container<__VA_ARGS__>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; \};\\}\par
6487 {\cf21     template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\\}\par
6488 {\cf21     struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; \};}\par
6489 \par
6490 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)}\par
6491 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\\}\par
6492 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6493 {\cf21     static void TestName()}\par
6494 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\\}\par
6495 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6496 {\cf21     static void TestName()}\par
6497 \par
6498 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)}\par
6499 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\\}\par
6500 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6501 {\cf21     static void TestName()}\par
6502 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\\}\par
6503 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6504 {\cf21     static void TestName()}\par
6505 \par
6506 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\\}\par
6507 {\cf21     template<typename Type>\\}\par
6508 {\cf21     void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\}\par
6509 {\cf21     \{\\}\par
6510 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\}\par
6511 {\cf21     \}}\par
6512 \par
6513 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\\}\par
6514 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6515 {\cf21     void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\}\par
6516 {\cf21     \{\\}\par
6517 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\}\par
6518 {\cf21     \}}\par
6519 \par
6520 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\\}\par
6521 {\cf21     template<typename Type>\\}\par
6522 {\cf21     void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\}\par
6523 {\cf21     \{\\}\par
6524 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\}\par
6525 {\cf21     \}}\par
6526 \par
6527 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\\}\par
6528 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6529 {\cf21     void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\}\par
6530 {\cf21     \{\\}\par
6531 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\}\par
6532 {\cf21     \}}\par
6533 \par
6534 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)}\par
6535 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\\}\par
6536 {\cf21     template<typename TestType> \\}\par
6537 {\cf21     struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> \{ \\}\par
6538 {\cf21         void test();\\}\par
6539 {\cf21     \}}\par
6540 \par
6541 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\\}\par
6542 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\}\par
6543 {\cf21     struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> \{ \\}\par
6544 {\cf21         void test();\\}\par
6545 {\cf21     \}}\par
6546 \par
6547 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)}\par
6548 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\\}\par
6549 {\cf21     template<typename TestType> \\}\par
6550 {\cf21     void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()}\par
6551 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\\}\par
6552 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\}\par
6553 {\cf21     void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()}\par
6554 \par
6555 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6556 {\cf21 #define INTERNAL_CATCH_NTTP_0}\par
6557 {\cf21 #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)}\par
6558 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)}\par
6559 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)}\par
6560 {\cf21 #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)}\par
6561 {\cf21 #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)}\par
6562 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)}\par
6563 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)}\par
6564 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)}\par
6565 {\cf21 #else}\par
6566 {\cf21 #define INTERNAL_CATCH_NTTP_0(signature)}\par
6567 {\cf21 #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))}\par
6568 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))}\par
6569 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))}\par
6570 {\cf21 #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))}\par
6571 {\cf21 #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))}\par
6572 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))}\par
6573 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))}\par
6574 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))}\par
6575 {\cf21 #endif}\par
6576 \par
6577 {\cf21 #endif }{\cf20 // CATCH_PREPROCESSOR_HPP_INCLUDED}\par
6578 \par
6579 \par
6580 {\cf20 // GCC 5 and older do not properly handle disabling unused-variable warning}\par
6581 {\cf20 // with a _Pragma. This means that we have to leak the suppression to the}\par
6582 {\cf20 // user code as well :-(}\par
6583 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5}\par
6584 {\cf21 #pragma GCC diagnostic ignored "-Wunused-variable"}\par
6585 {\cf21 #endif}\par
6586 \par
6587 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
6588 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \\}\par
6589 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6590 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \\}\par
6591 {\cf21         namespace\{                                                                                  \\}\par
6592 {\cf21             namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) \{                                      \\}\par
6593 {\cf21             INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6594 {\cf21         \}                                                                                           \\}\par
6595 {\cf21         \}                                                                                           \\}\par
6596 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6597 \par
6598 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6599 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\}\par
6600 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ )}\par
6601 {\cf21     #else}\par
6602 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\}\par
6603 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )}\par
6604 {\cf21     #endif}\par
6605 \par
6606 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6607 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\}\par
6608 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )}\par
6609 {\cf21     #else}\par
6610 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\}\par
6611 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )}\par
6612 {\cf21     #endif}\par
6613 \par
6614 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6615 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\}\par
6616 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
6617 {\cf21     #else}\par
6618 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\}\par
6619 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )}\par
6620 {\cf21     #endif}\par
6621 \par
6622 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6623 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\}\par
6624 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
6625 {\cf21     #else}\par
6626 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\}\par
6627 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )}\par
6628 {\cf21     #endif}\par
6629 {\cf21 #endif}\par
6630 \par
6631 \par
6633 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\}\par
6634 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6635 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6636 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6637 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6638 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6639 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6640 {\cf21         INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6641 {\cf21         namespace \{\\}\par
6642 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\}\par
6643 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6644 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6645 {\cf21             INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6646 {\cf21             template<typename...Types> \\}\par
6647 {\cf21             struct TestName\{\\}\par
6648 {\cf21                 TestName()\{\\}\par
6649 {\cf21                     size_t index = 0;                                    \\}\par
6650 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\}; }{\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}{\cf21 \\}\par
6651 {\cf21                     using expander = size_t[]; }{\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}{\cf21 \\}\par
6652 {\cf21                     (void)expander\{(reg_test(Types\{\}, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index]), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6653 {\cf21                 \}\\}\par
6654 {\cf21             \};\\}\par
6655 {\cf21             static const int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6656 {\cf21             TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\}\par
6657 {\cf21             return 0;\\}\par
6658 {\cf21         \}();\\}\par
6659 {\cf21         \}\\}\par
6660 {\cf21         \}\\}\par
6661 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6662 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6663 \par
6664 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6665 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\}\par
6666 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ )}\par
6667 {\cf21 #else}\par
6668 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\}\par
6669 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )}\par
6670 {\cf21 #endif}\par
6671 \par
6672 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6673 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\}\par
6674 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )}\par
6675 {\cf21 #else}\par
6676 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\}\par
6677 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )}\par
6678 {\cf21 #endif}\par
6679 \par
6680 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\}\par
6681 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \\}\par
6682 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\}\par
6683 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\}\par
6684 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS       \\}\par
6685 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6686 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6687 {\cf21         template<typename TestType> static void TestFuncName();       \\}\par
6688 {\cf21         namespace \{\\}\par
6689 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) \{                                     \\}\par
6690 {\cf21             INTERNAL_CATCH_TYPE_GEN                                                  \\}\par
6691 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\}\par
6692 {\cf21             template<typename... Types>                               \\}\par
6693 {\cf21             struct TestName \{                                         \\}\par
6694 {\cf21                 void reg_tests() \{                                          \\}\par
6695 {\cf21                     size_t index = 0;                                    \\}\par
6696 {\cf21                     using expander = size_t[];                           \\}\par
6697 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))\};\\}\par
6698 {\cf21                     constexpr char const* types_list[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))\};\\}\par
6699 {\cf21                     constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\\}\par
6700 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21 \\}\par
6701 {\cf21                 \}                                                     \\}\par
6702 {\cf21             \};                                                        \\}\par
6703 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{ \\}\par
6704 {\cf21                 using TestInit = typename create<TestName, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type; \\}\par
6705 {\cf21                 TestInit t;                                           \\}\par
6706 {\cf21                 t.reg_tests();                                        \\}\par
6707 {\cf21                 return 0;                                             \\}\par
6708 {\cf21             \}();                                                      \\}\par
6709 {\cf21         \}                                                             \\}\par
6710 {\cf21         \}                                                             \\}\par
6711 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \\}\par
6712 {\cf21         template<typename TestType>                                   \\}\par
6713 {\cf21         static void TestFuncName()}\par
6714 \par
6715 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6716 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\}\par
6717 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename T,__VA_ARGS__)}\par
6718 {\cf21 #else}\par
6719 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\}\par
6720 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename T, __VA_ARGS__ ) )}\par
6721 {\cf21 #endif}\par
6722 \par
6723 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6724 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\}\par
6725 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__)}\par
6726 {\cf21 #else}\par
6727 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\}\par
6728 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )}\par
6729 {\cf21 #endif}\par
6730 \par
6731 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\\}\par
6732 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6733 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6734 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6735 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6736 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6737 {\cf21         template<typename TestType> static void TestFunc();       \\}\par
6738 {\cf21         namespace \{\\}\par
6739 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\}\par
6740 {\cf21         INTERNAL_CATCH_TYPE_GEN\\}\par
6741 {\cf21         template<typename... Types>                               \\}\par
6742 {\cf21         struct TestName \{                                         \\}\par
6743 {\cf21             void reg_tests() \{                                          \\}\par
6744 {\cf21                 size_t index = 0;                                    \\}\par
6745 {\cf21                 using expander = size_t[];                           \\}\par
6746 {\cf21                 (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21 \\}\par
6747 {\cf21             \}                                                     \\}\par
6748 {\cf21         \};\\}\par
6749 {\cf21         static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{ \\}\par
6750 {\cf21                 using TestInit = typename convert<TestName, TmplList>::type; \\}\par
6751 {\cf21                 TestInit t;                                           \\}\par
6752 {\cf21                 t.reg_tests();                                        \\}\par
6753 {\cf21                 return 0;                                             \\}\par
6754 {\cf21             \}();                                                      \\}\par
6755 {\cf21         \}\}\\}\par
6756 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \\}\par
6757 {\cf21         template<typename TestType>                                   \\}\par
6758 {\cf21         static void TestFunc()}\par
6759 \par
6760 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \\}\par
6761 {\cf21         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, TmplList )}\par
6762 \par
6763 \par
6764 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\}\par
6765 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6766 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6767 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6768 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6769 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6770 {\cf21         namespace \{\\}\par
6771 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\}\par
6772 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6773 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6774 {\cf21             INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6775 {\cf21             INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6776 {\cf21             template<typename...Types> \\}\par
6777 {\cf21             struct TestNameClass\{\\}\par
6778 {\cf21                 TestNameClass()\{\\}\par
6779 {\cf21                     size_t index = 0;                                    \\}\par
6780 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\};\\}\par
6781 {\cf21                     using expander = size_t[];\\}\par
6782 {\cf21                     (void)expander\{(reg_test(Types\{\}, #ClassName, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index]), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6783 {\cf21                 \}\\}\par
6784 {\cf21             \};\\}\par
6785 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6786 {\cf21                 TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\}\par
6787 {\cf21                 return 0;\\}\par
6788 {\cf21         \}();\\}\par
6789 {\cf21         \}\\}\par
6790 {\cf21         \}\\}\par
6791 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6792 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6793 \par
6794 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6795 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\}\par
6796 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
6797 {\cf21 #else}\par
6798 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\}\par
6799 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )}\par
6800 {\cf21 #endif}\par
6801 \par
6802 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6803 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\}\par
6804 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
6805 {\cf21 #else}\par
6806 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\}\par
6807 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )}\par
6808 {\cf21 #endif}\par
6809 \par
6810 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\}\par
6811 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6812 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6813 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6814 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6815 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6816 {\cf21         template<typename TestType> \\}\par
6817 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) \{ \\}\par
6818 {\cf21                 void test();\\}\par
6819 {\cf21             \};\\}\par
6820 {\cf21         namespace \{\\}\par
6821 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) \{\\}\par
6822 {\cf21             INTERNAL_CATCH_TYPE_GEN                  \\}\par
6823 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6824 {\cf21             template<typename...Types>\\}\par
6825 {\cf21             struct TestNameClass\{\\}\par
6826 {\cf21                 void reg_tests()\{\\}\par
6827 {\cf21                     std::size_t index = 0;\\}\par
6828 {\cf21                     using expander = std::size_t[];\\}\par
6829 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))\};\\}\par
6830 {\cf21                     constexpr char const* types_list[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))\};\\}\par
6831 {\cf21                     constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\\}\par
6832 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6833 {\cf21                 \}\\}\par
6834 {\cf21             \};\\}\par
6835 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6836 {\cf21                 using TestInit = typename create<TestNameClass, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type;\\}\par
6837 {\cf21                 TestInit t;\\}\par
6838 {\cf21                 t.reg_tests();\\}\par
6839 {\cf21                 return 0;\\}\par
6840 {\cf21             \}(); \\}\par
6841 {\cf21         \}\\}\par
6842 {\cf21         \}\\}\par
6843 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6844 {\cf21         template<typename TestType> \\}\par
6845 {\cf21         void TestName<TestType>::test()}\par
6846 \par
6847 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6848 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\}\par
6849 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
6850 {\cf21 #else}\par
6851 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\}\par
6852 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )}\par
6853 {\cf21 #endif}\par
6854 \par
6855 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6856 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\}\par
6857 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
6858 {\cf21 #else}\par
6859 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\}\par
6860 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )}\par
6861 {\cf21 #endif}\par
6862 \par
6863 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \\}\par
6864 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6865 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6866 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6867 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6868 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6869 {\cf21         template<typename TestType> \\}\par
6870 {\cf21         struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) \{ \\}\par
6871 {\cf21             void test();\\}\par
6872 {\cf21         \};\\}\par
6873 {\cf21         namespace \{\\}\par
6874 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\}\par
6875 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6876 {\cf21             template<typename...Types>\\}\par
6877 {\cf21             struct TestNameClass\{\\}\par
6878 {\cf21                 void reg_tests()\{\\}\par
6879 {\cf21                     size_t index = 0;\\}\par
6880 {\cf21                     using expander = size_t[];\\}\par
6881 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName##_catch_sr, Catch::NameAndTags\{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6882 {\cf21                 \}\\}\par
6883 {\cf21             \};\\}\par
6884 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6885 {\cf21                 using TestInit = typename convert<TestNameClass, TmplList>::type;\\}\par
6886 {\cf21                 TestInit t;\\}\par
6887 {\cf21                 t.reg_tests();\\}\par
6888 {\cf21                 return 0;\\}\par
6889 {\cf21             \}(); \\}\par
6890 {\cf21         \}\}\\}\par
6891 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6892 {\cf21         template<typename TestType> \\}\par
6893 {\cf21         void TestName<TestType>::test()}\par
6894 \par
6895 {\cf21 #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \\}\par
6896 {\cf21         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, TmplList )}\par
6897 \par
6898 \par
6899 {\cf21 #endif }{\cf20 // CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}\par
6900 \par
6901 \par
6902 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
6903 \par
6904 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6905 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6906 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )}\par
6907 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6908 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6909 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )}\par
6910 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )}\par
6911 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6912 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6913 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)}\par
6914 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6915 {\cf21   #else}\par
6916 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )}\par
6917 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6918 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6919 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6920 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )}\par
6921 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6922 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6923 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6924 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )}\par
6925 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6926 {\cf21   #endif}\par
6927 \par
6928 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
6929 \par
6930 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6931 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)}\par
6932 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)}\par
6933 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)}\par
6934 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )}\par
6935 {\cf21   #else}\par
6936 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )}\par
6937 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )}\par
6938 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6939 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6940 {\cf21   #endif}\par
6941 \par
6942   {\cf20 // When disabled, these can be shared between proper preprocessor and MSVC preprocessor}\par
6943 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6944 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6945 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6946 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6947 {\cf21   #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE(__VA_ARGS__)}\par
6948 {\cf21   #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6949 \par
6950 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
6951 \par
6952 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6953 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6954 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )}\par
6955 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6956 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6957 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )}\par
6958 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )}\par
6959 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6960 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6961 {\cf21     #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)}\par
6962 {\cf21     #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6963 {\cf21   #else}\par
6964 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )}\par
6965 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6966 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6967 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6968 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )}\par
6969 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6970 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6971 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6972 {\cf21     #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )}\par
6973 {\cf21     #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6974 {\cf21   #endif}\par
6975 \par
6976 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
6977 \par
6978 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6979 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)}\par
6980 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)}\par
6981 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)}\par
6982 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )}\par
6983 {\cf21   #else}\par
6984 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )}\par
6985 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )}\par
6986 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6987 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6988 {\cf21   #endif}\par
6989 \par
6990   {\cf20 // When disabled, these can be shared between proper preprocessor and MSVC preprocessor}\par
6991 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6992 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6993 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6994 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6995 {\cf21   #define TEMPLATE_LIST_TEST_CASE( ... ) TEMPLATE_TEST_CASE(__VA_ARGS__)}\par
6996 {\cf21   #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6997 \par
6998 {\cf21 #endif }{\cf20 // end of user facing macro declarations}\par
6999 \par
7000 \par
7001 {\cf21 #endif }{\cf20 // CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}\par
7002 \par
7003 \par
7004 {\cf21 #ifndef CATCH_TEST_CASE_INFO_HPP_INCLUDED}\par
7005 {\cf21 #define CATCH_TEST_CASE_INFO_HPP_INCLUDED}\par
7006 \par
7007 \par
7008 \par
7009 {\cf21 #include <cstdint>}\par
7010 {\cf21 #include <string>}\par
7011 {\cf21 #include <vector>}\par
7012 \par
7013 {\cf21 #ifdef __clang__}\par
7014 {\cf21 #pragma clang diagnostic push}\par
7015 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
7016 {\cf21 #endif}\par
7017 \par
7018 {\cf17 namespace }Catch \{\par
7019 \par
7027     {\cf17 struct }Tag \{\par
7028         {\cf17 constexpr} Tag(StringRef original_):\par
7029             original(original_)\par
7030         \{\}\par
7031         StringRef original;\par
7032 \par
7033         {\cf17 friend} {\cf18 bool} operator< ( Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs );\par
7034         {\cf17 friend} {\cf18 bool} operator==( Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs );\par
7035     \};\par
7036 \par
7037     {\cf17 class }ITestInvoker;\par
7038     {\cf17 struct }NameAndTags;\par
7039 \par
7040     {\cf17 enum class} TestCaseProperties : uint8_t \{\par
7041         None = 0,\par
7042         IsHidden = 1 << 1,\par
7043         ShouldFail = 1 << 2,\par
7044         MayFail = 1 << 3,\par
7045         Throws = 1 << 4,\par
7046         NonPortable = 1 << 5,\par
7047         Benchmark = 1 << 6\par
7048     \};\par
7049 \par
7059     {\cf17 struct }TestCaseInfo : Detail::NonCopyable \{\par
7060 \par
7061         TestCaseInfo(StringRef _className,\par
7062                      NameAndTags {\cf17 const}& _nameAndTags,\par
7063                      SourceLineInfo {\cf17 const}& _lineInfo);\par
7064 \par
7065         {\cf18 bool} isHidden() {\cf17 const};\par
7066         {\cf18 bool} {\cf19 throws}() {\cf17 const};\par
7067         {\cf18 bool} okToFail() {\cf17 const};\par
7068         {\cf18 bool} expectedToFail() {\cf17 const};\par
7069 \par
7070         {\cf20 // Adds the tag(s) with test's filename (for the -# flag)}\par
7071         {\cf18 void} addFilenameTag();\par
7072 \par
7074         {\cf17 friend} {\cf18 bool} operator<( TestCaseInfo {\cf17 const}& lhs,\par
7075                                TestCaseInfo {\cf17 const}& rhs );\par
7076 \par
7077 \par
7078         std::string tagsAsString() {\cf17 const};\par
7079 \par
7080         std::string name;\par
7081         StringRef className;\par
7082     {\cf17 private}:\par
7083         std::string backingTags;\par
7084         {\cf20 // Internally we copy tags to the backing storage and then add}\par
7085         {\cf20 // refs to this storage to the tags vector.}\par
7086         {\cf18 void} internalAppendTag(StringRef tagString);\par
7087     {\cf17 public}:\par
7088         std::vector<Tag> tags;\par
7089         SourceLineInfo lineInfo;\par
7090         TestCaseProperties properties = TestCaseProperties::None;\par
7091     \};\par
7092 \par
7099     {\cf17 class }TestCaseHandle \{\par
7100         TestCaseInfo* m_info;\par
7101         ITestInvoker* m_invoker;\par
7102     {\cf17 public}:\par
7103         TestCaseHandle(TestCaseInfo* info, ITestInvoker* invoker) :\par
7104             m_info(info), m_invoker(invoker) \{\}\par
7105 \par
7106         {\cf18 void} invoke(){\cf17  const }\{\par
7107             m_invoker->invoke();\par
7108         \}\par
7109 \par
7110         TestCaseInfo {\cf17 const}& getTestCaseInfo() {\cf17 const};\par
7111     \};\par
7112 \par
7113     Detail::unique_ptr<TestCaseInfo>\par
7114     makeTestCaseInfo( StringRef className,\par
7115                       NameAndTags {\cf17 const}& nameAndTags,\par
7116                       SourceLineInfo {\cf17 const}& lineInfo );\par
7117 \}\par
7118 \par
7119 {\cf21 #ifdef __clang__}\par
7120 {\cf21 #pragma clang diagnostic pop}\par
7121 {\cf21 #endif}\par
7122 \par
7123 {\cf21 #endif }{\cf20 // CATCH_TEST_CASE_INFO_HPP_INCLUDED}\par
7124 \par
7125 \par
7126 {\cf21 #ifndef CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}\par
7127 {\cf21 #define CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}\par
7128 \par
7129 \par
7130 \par
7131 {\cf21 #ifndef CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}\par
7132 {\cf21 #define CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}\par
7133 \par
7134 \par
7135 {\cf21 #include <string>}\par
7136 {\cf21 #include <vector>}\par
7137 \par
7138 {\cf17 namespace }Catch \{\par
7139     {\cf17 using }exceptionTranslateFunction = std::string(*)();\par
7140 \par
7141     {\cf17 class }IExceptionTranslator;\par
7142     {\cf17 using }ExceptionTranslators = std::vector<Detail::unique_ptr<IExceptionTranslator const>>;\par
7143 \par
7144     {\cf17 class }IExceptionTranslator \{\par
7145     {\cf17 public}:\par
7146         {\cf17 virtual} ~IExceptionTranslator(); {\cf20 // = default}\par
7147         {\cf17 virtual} std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) {\cf17 const} = 0;\par
7148     \};\par
7149 \par
7150     {\cf17 class }IExceptionTranslatorRegistry \{\par
7151     {\cf17 public}:\par
7152         {\cf17 virtual} ~IExceptionTranslatorRegistry(); {\cf20 // = default}\par
7153         {\cf17 virtual} std::string translateActiveException() {\cf17 const} = 0;\par
7154     \};\par
7155 \par
7156 \} {\cf20 // namespace Catch}\par
7157 \par
7158 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}\par
7159 \par
7160 {\cf21 #include <exception>}\par
7161 \par
7162 {\cf17 namespace }Catch \{\par
7163     {\cf17 namespace }Detail \{\par
7164         {\cf18 void} registerTranslatorImpl(\par
7165             Detail::unique_ptr<IExceptionTranslator>&& translator );\par
7166     \}\par
7167 \par
7168     {\cf17 class }ExceptionTranslatorRegistrar \{\par
7169         {\cf17 template}<{\cf17 typename} T>\par
7170         {\cf17 class }ExceptionTranslator : {\cf17 public} IExceptionTranslator \{\par
7171         {\cf17 public}:\par
7172 \par
7173             ExceptionTranslator( std::string(*translateFunction)( T {\cf17 const}& ) )\par
7174             : m_translateFunction( translateFunction )\par
7175             \{\}\par
7176 \par
7177             std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ){\cf17  const override }\{\par
7178 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
7179                 {\cf19 try} \{\par
7180                     {\cf19 if}( it == itEnd )\par
7181                         std::rethrow_exception(std::current_exception());\par
7182                     {\cf19 else}\par
7183                         {\cf19 return} (*it)->translate( it+1, itEnd );\par
7184                 \}\par
7185                 {\cf19 catch}( T {\cf17 const}& ex ) \{\par
7186                     {\cf19 return} m_translateFunction( ex );\par
7187                 \}\par
7188 {\cf21 #else}\par
7189                 {\cf19 return} {\cf22 "You should never get here!"};\par
7190 {\cf21 #endif}\par
7191             \}\par
7192 \par
7193         {\cf17 protected}:\par
7194             std::string(*m_translateFunction)( T {\cf17 const}& );\par
7195         \};\par
7196 \par
7197     {\cf17 public}:\par
7198         {\cf17 template}<{\cf17 typename} T>\par
7199         ExceptionTranslatorRegistrar( std::string(*translateFunction)( T {\cf17 const}& ) ) \{\par
7200             Detail::registerTranslatorImpl(\par
7201                 Detail::make_unique<ExceptionTranslator<T>>(\par
7202                     translateFunction ) );\par
7203         \}\par
7204     \};\par
7205 \par
7206 \} {\cf20 // namespace Catch}\par
7207 \par
7209 {\cf21 #define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \\}\par
7210 {\cf21     static std::string translatorName( signature ); \\}\par
7211 {\cf21     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
7212 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
7213 {\cf21     namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); \} \\}\par
7214 {\cf21     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
7215 {\cf21     static std::string translatorName( signature )}\par
7216 \par
7217 {\cf21 #define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )}\par
7218 \par
7219 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
7220 {\cf21     #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \\}\par
7221 {\cf21             static std::string translatorName( signature )}\par
7222 {\cf21 #endif}\par
7223 \par
7224 \par
7225 {\cf20 // This macro is always prefixed}\par
7226 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
7227 {\cf21 #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )}\par
7228 {\cf21 #else}\par
7229 {\cf21 #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )}\par
7230 {\cf21 #endif}\par
7231 \par
7232 \par
7233 {\cf21 #endif }{\cf20 // CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}\par
7234 \par
7235 \par
7236 {\cf21 #ifndef CATCH_VERSION_HPP_INCLUDED}\par
7237 {\cf21 #define CATCH_VERSION_HPP_INCLUDED}\par
7238 \par
7239 {\cf21 #include <iosfwd>}\par
7240 \par
7241 {\cf17 namespace }Catch \{\par
7242 \par
7243     {\cf20 // Versioning information}\par
7244     {\cf17 struct }Version \{\par
7245         Version( Version {\cf17 const}& ) = {\cf17 delete};\par
7246         Version& operator=( Version {\cf17 const}& ) = {\cf17 delete};\par
7247         Version(    {\cf18 unsigned} {\cf18 int} _majorVersion,\par
7248                     {\cf18 unsigned} {\cf18 int} _minorVersion,\par
7249                     {\cf18 unsigned} {\cf18 int} _patchNumber,\par
7250                     {\cf18 char} {\cf17 const} * {\cf17 const} _branchName,\par
7251                     {\cf18 unsigned} {\cf18 int} _buildNumber );\par
7252 \par
7253         {\cf18 unsigned} {\cf18 int} {\cf17 const} majorVersion;\par
7254         {\cf18 unsigned} {\cf18 int} {\cf17 const} minorVersion;\par
7255         {\cf18 unsigned} {\cf18 int} {\cf17 const} patchNumber;\par
7256 \par
7257         {\cf20 // buildNumber is only used if branchName is not null}\par
7258         {\cf18 char} {\cf17 const} * {\cf17 const} branchName;\par
7259         {\cf18 unsigned} {\cf18 int} {\cf17 const} buildNumber;\par
7260 \par
7261         {\cf17 friend} std::ostream& operator << ( std::ostream& os, Version {\cf17 const}& version );\par
7262     \};\par
7263 \par
7264     Version {\cf17 const}& libraryVersion();\par
7265 \}\par
7266 \par
7267 {\cf21 #endif }{\cf20 // CATCH_VERSION_HPP_INCLUDED}\par
7268 \par
7269 \par
7270 {\cf21 #ifndef CATCH_VERSION_MACROS_HPP_INCLUDED}\par
7271 {\cf21 #define CATCH_VERSION_MACROS_HPP_INCLUDED}\par
7272 \par
7273 {\cf21 #define CATCH_VERSION_MAJOR 3}\par
7274 {\cf21 #define CATCH_VERSION_MINOR 6}\par
7275 {\cf21 #define CATCH_VERSION_PATCH 0}\par
7276 \par
7277 {\cf21 #endif }{\cf20 // CATCH_VERSION_MACROS_HPP_INCLUDED}\par
7278 \par
7279 \par
7293 {\cf21 #ifndef CATCH_GENERATORS_ALL_HPP_INCLUDED}\par
7294 {\cf21 #define CATCH_GENERATORS_ALL_HPP_INCLUDED}\par
7295 \par
7296 \par
7297 \par
7298 {\cf21 #ifndef CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}\par
7299 {\cf21 #define CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}\par
7300 \par
7301 {\cf21 #include <exception>}\par
7302 \par
7303 {\cf17 namespace }Catch \{\par
7304 \par
7305     {\cf20 // Exception type to be thrown when a Generator runs into an error,}\par
7306     {\cf20 // e.g. it cannot initialize the first return value based on}\par
7307     {\cf20 // runtime information}\par
7308     {\cf17 class }GeneratorException : {\cf17 public} std::exception \{\par
7309         {\cf17 const} {\cf18 char}* {\cf17 const} m_msg = {\cf22 ""};\par
7310 \par
7311     {\cf17 public}:\par
7312         GeneratorException({\cf17 const} {\cf18 char}* msg):\par
7313             m_msg(msg)\par
7314         \{\}\par
7315 \par
7316         {\cf17 const} {\cf18 char}* what() const noexcept override final;\par
7317     \};\par
7318 \par
7319 \} {\cf20 // end namespace Catch}\par
7320 \par
7321 {\cf21 #endif }{\cf20 // CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}\par
7322 \par
7323 \par
7324 {\cf21 #ifndef CATCH_GENERATORS_HPP_INCLUDED}\par
7325 {\cf21 #define CATCH_GENERATORS_HPP_INCLUDED}\par
7326 \par
7327 \par
7328 \par
7329 {\cf21 #ifndef CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}\par
7330 {\cf21 #define CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}\par
7331 \par
7332 \par
7333 {\cf21 #include <string>}\par
7334 \par
7335 {\cf17 namespace }Catch \{\par
7336 \par
7337     {\cf17 namespace }Generators \{\par
7338         {\cf17 class }GeneratorUntypedBase \{\par
7339             {\cf20 // Caches result from `toStringImpl`, assume that when it is an}\par
7340             {\cf20 // empty string, the cache is invalidated.}\par
7341             {\cf17 mutable} std::string m_stringReprCache;\par
7342 \par
7343             {\cf20 // Counts based on `next` returning true}\par
7344             std::size_t m_currentElementIndex = 0;\par
7345 \par
7352             {\cf17 virtual} {\cf18 bool} next() = 0;\par
7353 \par
7355             {\cf17 virtual} std::string stringifyImpl() {\cf17 const} = 0;\par
7356 \par
7357         {\cf17 public}:\par
7358             GeneratorUntypedBase() = {\cf19 default};\par
7359             {\cf20 // Generation of copy ops is deprecated (and Clang will complain)}\par
7360             {\cf20 // if there is a user destructor defined}\par
7361             GeneratorUntypedBase(GeneratorUntypedBase {\cf17 const}&) = {\cf19 default};\par
7362             GeneratorUntypedBase& operator=(GeneratorUntypedBase {\cf17 const}&) = {\cf19 default};\par
7363 \par
7364             {\cf17 virtual} ~GeneratorUntypedBase(); {\cf20 // = default;}\par
7365 \par
7376             {\cf18 bool} countedNext();\par
7377 \par
7378             std::size_t currentElementIndex(){\cf17  const }\{ {\cf19 return} m_currentElementIndex; \}\par
7379 \par
7393             StringRef currentElementAsString() {\cf17 const};\par
7394         \};\par
7395         {\cf17 using }GeneratorBasePtr = Catch::Detail::unique_ptr<GeneratorUntypedBase>;\par
7396 \par
7397     \} {\cf20 // namespace Generators}\par
7398 \par
7399     {\cf17 class }IGeneratorTracker \{\par
7400     {\cf17 public}:\par
7401         {\cf17 virtual} ~IGeneratorTracker(); {\cf20 // = default;}\par
7402         {\cf17 virtual} {\cf17 auto} hasGenerator() const -> {\cf18 bool} = 0;\par
7403         virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;\par
7404         virtual {\cf18 void} setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;\par
7405     \};\par
7406 \par
7407 \} {\cf20 // namespace Catch}\par
7408 \par
7409 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}\par
7410 \par
7411 {\cf21 #include <vector>}\par
7412 {\cf21 #include <tuple>}\par
7413 \par
7414 {\cf17 namespace }Catch \{\par
7415 \par
7416 {\cf17 namespace }Generators \{\par
7417 \par
7418 {\cf17 namespace }Detail \{\par
7419 \par
7421     [[noreturn]]\par
7422     {\cf18 void} throw_generator_exception({\cf18 char} {\cf17 const} * msg);\par
7423 \par
7424 \} {\cf20 // end namespace detail}\par
7425 \par
7426     {\cf17 template}<{\cf17 typename} T>\par
7427     {\cf17 class }IGenerator : {\cf17 public} GeneratorUntypedBase \{\par
7428         std::string stringifyImpl(){\cf17  const override }\{\par
7429             return ::Catch::Detail::stringify( get() );\par
7430         \}\par
7431 \par
7432     {\cf17 public}:\par
7433         {\cf20 // Returns the current element of the generator}\par
7434         {\cf20 //}\par
7435         {\cf20 // \\Precondition The generator is either freshly constructed,}\par
7436         {\cf20 // or the last call to `next()` returned true}\par
7437         {\cf17 virtual} T {\cf17 const}& get() {\cf17 const} = 0;\par
7438         {\cf17 using }type = T;\par
7439     \};\par
7440 \par
7441     {\cf17 template} <{\cf17 typename} T>\par
7442     {\cf17 using }GeneratorPtr = Catch::Detail::unique_ptr<IGenerator<T>>;\par
7443 \par
7444     {\cf17 template} <{\cf17 typename} T>\par
7445     {\cf17 class }GeneratorWrapper final \{\par
7446         GeneratorPtr<T> m_generator;\par
7447     {\cf17 public}:\par
7449         GeneratorWrapper(IGenerator<T>* generator):\par
7450             m_generator(generator) \{\}\par
7451         GeneratorWrapper(GeneratorPtr<T> generator):\par
7452             m_generator(CATCH_MOVE(generator)) \{\}\par
7453 \par
7454         T {\cf17 const}& get(){\cf17  const }\{\par
7455             {\cf19 return} m_generator->get();\par
7456         \}\par
7457         {\cf18 bool} next() \{\par
7458             {\cf19 return} m_generator->countedNext();\par
7459         \}\par
7460     \};\par
7461 \par
7462 \par
7463     {\cf17 template}<{\cf17 typename} T>\par
7464     {\cf17 class }SingleValueGenerator final : {\cf17 public} IGenerator<T> \{\par
7465         T m_value;\par
7466     {\cf17 public}:\par
7467         SingleValueGenerator(T {\cf17 const}& value) :\par
7468             m_value(value)\par
7469         \{\}\par
7470         SingleValueGenerator(T&& value):\par
7471             m_value(CATCH_MOVE(value))\par
7472         \{\}\par
7473 \par
7474         T {\cf17 const}& get(){\cf17  const override }\{\par
7475             {\cf19 return} m_value;\par
7476         \}\par
7477         {\cf18 bool} next(){\cf17  override }\{\par
7478             {\cf19 return} {\cf17 false};\par
7479         \}\par
7480     \};\par
7481 \par
7482     {\cf17 template}<{\cf17 typename} T>\par
7483     {\cf17 class }FixedValuesGenerator final : {\cf17 public} IGenerator<T> \{\par
7484         {\cf17 static_assert}(!std::is_same<T, bool>::value,\par
7485             {\cf22 "FixedValuesGenerator does not support bools because of std::vector<bool>"}\par
7486             {\cf22 "specialization, use SingleValue Generator instead."});\par
7487         std::vector<T> m_values;\par
7488         {\cf18 size_t} m_idx = 0;\par
7489     {\cf17 public}:\par
7490         FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) \{\}\par
7491 \par
7492         T {\cf17 const}& get(){\cf17  const override }\{\par
7493             {\cf19 return} m_values[m_idx];\par
7494         \}\par
7495         {\cf18 bool} next(){\cf17  override }\{\par
7496             ++m_idx;\par
7497             {\cf19 return} m_idx < m_values.size();\par
7498         \}\par
7499     \};\par
7500 \par
7501     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} DecayedT = std::decay_t<T>>\par
7502     GeneratorWrapper<DecayedT> value( T&& value ) \{\par
7503         {\cf19 return} GeneratorWrapper<DecayedT>(\par
7504             Catch::Detail::make_unique<SingleValueGenerator<DecayedT>>(\par
7505                 CATCH_FORWARD( value ) ) );\par
7506     \}\par
7507     {\cf17 template} <{\cf17 typename} T>\par
7508     GeneratorWrapper<T> values(std::initializer_list<T> values) \{\par
7509         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<FixedValuesGenerator<T>>(values));\par
7510     \}\par
7511 \par
7512     {\cf17 template}<{\cf17 typename} T>\par
7513     {\cf17 class }Generators : {\cf17 public} IGenerator<T> \{\par
7514         std::vector<GeneratorWrapper<T>> m_generators;\par
7515         {\cf18 size_t} m_current = 0;\par
7516 \par
7517         {\cf18 void} add_generator( GeneratorWrapper<T>&& generator ) \{\par
7518             m_generators.emplace_back( CATCH_MOVE( generator ) );\par
7519         \}\par
7520         {\cf18 void} add_generator( T {\cf17 const}& val ) \{\par
7521             m_generators.emplace_back( value( val ) );\par
7522         \}\par
7523         {\cf18 void} add_generator( T&& val ) \{\par
7524             m_generators.emplace_back( value( CATCH_MOVE( val ) ) );\par
7525         \}\par
7526         {\cf17 template} <{\cf17 typename} U>\par
7527         std::enable_if_t<!std::is_same<std::decay_t<U>, T>::value>\par
7528         add_generator( U&& val ) \{\par
7529             add_generator( T( CATCH_FORWARD( val ) ) );\par
7530         \}\par
7531 \par
7532         {\cf17 template} <{\cf17 typename} U> {\cf18 void} add_generators( U&& valueOrGenerator ) \{\par
7533             add_generator( CATCH_FORWARD( valueOrGenerator ) );\par
7534         \}\par
7535 \par
7536         {\cf17 template} <{\cf17 typename} U, {\cf17 typename}... Gs>\par
7537         {\cf18 void} add_generators( U&& valueOrGenerator, Gs&&... moreGenerators ) \{\par
7538             add_generator( CATCH_FORWARD( valueOrGenerator ) );\par
7539             add_generators( CATCH_FORWARD( moreGenerators )... );\par
7540         \}\par
7541 \par
7542     {\cf17 public}:\par
7543         {\cf17 template} <{\cf17 typename}... Gs>\par
7544         Generators(Gs &&... moreGenerators) \{\par
7545             m_generators.reserve({\cf17 sizeof}...(Gs));\par
7546             add_generators(CATCH_FORWARD(moreGenerators)...);\par
7547         \}\par
7548 \par
7549         T {\cf17 const}& get(){\cf17  const override }\{\par
7550             {\cf19 return} m_generators[m_current].get();\par
7551         \}\par
7552 \par
7553         {\cf18 bool} next(){\cf17  override }\{\par
7554             {\cf19 if} (m_current >= m_generators.size()) \{\par
7555                 {\cf19 return} {\cf17 false};\par
7556             \}\par
7557             {\cf17 const} {\cf18 bool} current_status = m_generators[m_current].next();\par
7558             {\cf19 if} (!current_status) \{\par
7559                 ++m_current;\par
7560             \}\par
7561             {\cf19 return} m_current < m_generators.size();\par
7562         \}\par
7563     \};\par
7564 \par
7565 \par
7566     {\cf17 template} <{\cf17 typename}... Ts>\par
7567     GeneratorWrapper<std::tuple<std::decay_t<Ts>...>>\par
7568     table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) \{\par
7569         {\cf19 return} values<std::tuple<Ts...>>( tuples );\par
7570     \}\par
7571 \par
7572     {\cf20 // Tag type to signal that a generator sequence should convert arguments to a specific type}\par
7573     {\cf17 template} <{\cf17 typename} T>\par
7574     {\cf17 struct }as \{\};\par
7575 \par
7576     {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Gs>\par
7577     {\cf17 auto} makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> \{\par
7578         {\cf19 return} Generators<T>(CATCH_MOVE(generator), CATCH_FORWARD(moreGenerators)...);\par
7579     \}\par
7580     {\cf17 template}<{\cf17 typename} T>\par
7581     {\cf17 auto} makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> \{\par
7582         {\cf19 return} Generators<T>(CATCH_MOVE(generator));\par
7583     \}\par
7584     {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Gs>\par
7585     {\cf17 auto} makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<std::decay_t<T>> \{\par
7586         {\cf19 return} makeGenerators( value( CATCH_FORWARD( val ) ), CATCH_FORWARD( moreGenerators )... );\par
7587     \}\par
7588     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} U, {\cf17 typename}... Gs>\par
7589     {\cf17 auto} makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> \{\par
7590         {\cf19 return} makeGenerators( value( T( CATCH_FORWARD( val ) ) ), CATCH_FORWARD( moreGenerators )... );\par
7591     \}\par
7592 \par
7593     IGeneratorTracker* acquireGeneratorTracker( StringRef generatorName,\par
7594                                                 SourceLineInfo {\cf17 const}& lineInfo );\par
7595     IGeneratorTracker* createGeneratorTracker( StringRef generatorName,\par
7596                                                SourceLineInfo lineInfo,\par
7597                                                GeneratorBasePtr&& generator );\par
7598 \par
7599     {\cf17 template}<{\cf17 typename} L>\par
7600     {\cf17 auto} generate( StringRef generatorName, SourceLineInfo {\cf17 const}& lineInfo, L {\cf17 const}& generatorExpression ) -> {\cf17 typename} {\cf17 decltype}(generatorExpression())::type \{\par
7601         {\cf17 using }UnderlyingType = {\cf17 typename} {\cf17 decltype}(generatorExpression())::type;\par
7602 \par
7603         IGeneratorTracker* tracker = acquireGeneratorTracker( generatorName, lineInfo );\par
7604         {\cf20 // Creation of tracker is delayed after generator creation, so}\par
7605         {\cf20 // that constructing generator can fail without breaking everything.}\par
7606         {\cf19 if} (!tracker) \{\par
7607             tracker = createGeneratorTracker(\par
7608                 generatorName,\par
7609                 lineInfo,\par
7610                 Catch::Detail::make_unique<Generators<UnderlyingType>>(\par
7611                     generatorExpression() ) );\par
7612         \}\par
7613 \par
7614         {\cf17 auto} {\cf17 const}& generator = {\cf17 static_cast<}IGenerator<UnderlyingType> const&{\cf17 >}( *tracker->getGenerator() );\par
7615         {\cf19 return} generator.get();\par
7616     \}\par
7617 \par
7618 \} {\cf20 // namespace Generators}\par
7619 \} {\cf20 // namespace Catch}\par
7620 \par
7621 {\cf21 #define CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL( ... ) #__VA_ARGS__##_catch_sr}\par
7622 {\cf21 #define CATCH_INTERNAL_GENERATOR_STRINGIZE(...) CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL(__VA_ARGS__)}\par
7623 \par
7624 {\cf21 #define GENERATE( ... ) \\}\par
7625 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7626 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7627 {\cf21                                  [ ]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
7628 {\cf21 #define GENERATE_COPY( ... ) \\}\par
7629 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7630 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7631 {\cf21                                  [=]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
7632 {\cf21 #define GENERATE_REF( ... ) \\}\par
7633 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7634 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7635 {\cf21                                  [&]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
7636 \par
7637 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_HPP_INCLUDED}\par
7638 \par
7639 \par
7640 {\cf21 #ifndef CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}\par
7641 {\cf21 #define CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}\par
7642 \par
7643 \par
7644 {\cf21 #include <cassert>}\par
7645 \par
7646 {\cf17 namespace }Catch \{\par
7647 {\cf17 namespace }Generators \{\par
7648 \par
7649     {\cf17 template} <{\cf17 typename} T>\par
7650     {\cf17 class }TakeGenerator final : {\cf17 public} IGenerator<T> \{\par
7651         GeneratorWrapper<T> m_generator;\par
7652         {\cf18 size_t} m_returned = 0;\par
7653         {\cf18 size_t} m_target;\par
7654     {\cf17 public}:\par
7655         TakeGenerator({\cf18 size_t} target, GeneratorWrapper<T>&& generator):\par
7656             m_generator(CATCH_MOVE(generator)),\par
7657             m_target(target)\par
7658         \{\par
7659             assert(target != 0 && {\cf22 "Empty generators are not allowed"});\par
7660         \}\par
7661         T {\cf17 const}& get(){\cf17  const override }\{\par
7662             {\cf19 return} m_generator.get();\par
7663         \}\par
7664         {\cf18 bool} next(){\cf17  override }\{\par
7665             ++m_returned;\par
7666             {\cf19 if} (m_returned >= m_target) \{\par
7667                 {\cf19 return} {\cf17 false};\par
7668             \}\par
7669 \par
7670             {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7671             {\cf20 // If the underlying generator does not contain enough values}\par
7672             {\cf20 // then we cut short as well}\par
7673             {\cf19 if} (!success) \{\par
7674                 m_returned = m_target;\par
7675             \}\par
7676             {\cf19 return} success;\par
7677         \}\par
7678     \};\par
7679 \par
7680     {\cf17 template} <{\cf17 typename} T>\par
7681     GeneratorWrapper<T> take({\cf18 size_t} target, GeneratorWrapper<T>&& generator) \{\par
7682         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<TakeGenerator<T>>(target, CATCH_MOVE(generator)));\par
7683     \}\par
7684 \par
7685 \par
7686     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Predicate>\par
7687     {\cf17 class }FilterGenerator final : {\cf17 public} IGenerator<T> \{\par
7688         GeneratorWrapper<T> m_generator;\par
7689         Predicate m_predicate;\par
7690     {\cf17 public}:\par
7691         {\cf17 template} <{\cf17 typename} P = Predicate>\par
7692         FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):\par
7693             m_generator(CATCH_MOVE(generator)),\par
7694             m_predicate(CATCH_FORWARD(pred))\par
7695         \{\par
7696             {\cf19 if} (!m_predicate(m_generator.get())) \{\par
7697                 {\cf20 // It might happen that there are no values that pass the}\par
7698                 {\cf20 // filter. In that case we throw an exception.}\par
7699                 auto has_initial_value = next();\par
7700                 if (!has_initial_value) \{\par
7701                     Detail::throw_generator_exception({\cf22 "No valid value found in filtered generator"});\par
7702                 \}\par
7703             \}\par
7704         \}\par
7705 \par
7706         T {\cf17 const}& get(){\cf17  const override }\{\par
7707             {\cf19 return} m_generator.get();\par
7708         \}\par
7709 \par
7710         {\cf18 bool} next(){\cf17  override }\{\par
7711             {\cf18 bool} success = m_generator.next();\par
7712             {\cf19 if} (!success) \{\par
7713                 {\cf19 return} {\cf17 false};\par
7714             \}\par
7715             {\cf19 while} (!m_predicate(m_generator.get()) && (success = m_generator.next()) == {\cf17 true});\par
7716             {\cf19 return} success;\par
7717         \}\par
7718     \};\par
7719 \par
7720 \par
7721     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Predicate>\par
7722     GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) \{\par
7723         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<FilterGenerator<T, Predicate>>(CATCH_FORWARD(pred), CATCH_MOVE(generator)));\par
7724     \}\par
7725 \par
7726     {\cf17 template} <{\cf17 typename} T>\par
7727     {\cf17 class }RepeatGenerator final : {\cf17 public} IGenerator<T> \{\par
7728         {\cf17 static_assert}(!std::is_same<T, bool>::value,\par
7729             {\cf22 "RepeatGenerator currently does not support bools"}\par
7730             {\cf22 "because of std::vector<bool> specialization"});\par
7731         GeneratorWrapper<T> m_generator;\par
7732         {\cf17 mutable} std::vector<T> m_returned;\par
7733         {\cf18 size_t} m_target_repeats;\par
7734         {\cf18 size_t} m_current_repeat = 0;\par
7735         {\cf18 size_t} m_repeat_index = 0;\par
7736     {\cf17 public}:\par
7737         RepeatGenerator({\cf18 size_t} repeats, GeneratorWrapper<T>&& generator):\par
7738             m_generator(CATCH_MOVE(generator)),\par
7739             m_target_repeats(repeats)\par
7740         \{\par
7741             assert(m_target_repeats > 0 && {\cf22 "Repeat generator must repeat at least once"});\par
7742         \}\par
7743 \par
7744         T {\cf17 const}& get(){\cf17  const override }\{\par
7745             {\cf19 if} (m_current_repeat == 0) \{\par
7746                 m_returned.push_back(m_generator.get());\par
7747                 {\cf19 return} m_returned.back();\par
7748             \}\par
7749             {\cf19 return} m_returned[m_repeat_index];\par
7750         \}\par
7751 \par
7752         {\cf18 bool} next(){\cf17  override }\{\par
7753             {\cf20 // There are 2 basic cases:}\par
7754             {\cf20 // 1) We are still reading the generator}\par
7755             {\cf20 // 2) We are reading our own cache}\par
7756 \par
7757             {\cf20 // In the first case, we need to poke the underlying generator.}\par
7758             {\cf20 // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache}\par
7759             {\cf19 if} (m_current_repeat == 0) \{\par
7760                 {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7761                 {\cf19 if} (!success) \{\par
7762                     ++m_current_repeat;\par
7763                 \}\par
7764                 {\cf19 return} m_current_repeat < m_target_repeats;\par
7765             \}\par
7766 \par
7767             {\cf20 // In the second case, we need to move indices forward and check that we haven't run up against the end}\par
7768             ++m_repeat_index;\par
7769             {\cf19 if} (m_repeat_index == m_returned.size()) \{\par
7770                 m_repeat_index = 0;\par
7771                 ++m_current_repeat;\par
7772             \}\par
7773             {\cf19 return} m_current_repeat < m_target_repeats;\par
7774         \}\par
7775     \};\par
7776 \par
7777     {\cf17 template} <{\cf17 typename} T>\par
7778     GeneratorWrapper<T> repeat({\cf18 size_t} repeats, GeneratorWrapper<T>&& generator) \{\par
7779         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<RepeatGenerator<T>>(repeats, CATCH_MOVE(generator)));\par
7780     \}\par
7781 \par
7782     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U, {\cf17 typename} Func>\par
7783     {\cf17 class }MapGenerator final : {\cf17 public} IGenerator<T> \{\par
7784         {\cf20 // TBD: provide static assert for mapping function, for friendly error message}\par
7785         GeneratorWrapper<U> m_generator;\par
7786         Func m_function;\par
7787         {\cf20 // To avoid returning dangling reference, we have to save the values}\par
7788         T m_cache;\par
7789     {\cf17 public}:\par
7790         {\cf17 template} <{\cf17 typename} F2 = Func>\par
7791         MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :\par
7792             m_generator(CATCH_MOVE(generator)),\par
7793             m_function(CATCH_FORWARD(function)),\par
7794             m_cache(m_function(m_generator.get()))\par
7795         \{\}\par
7796 \par
7797         T {\cf17 const}& get(){\cf17  const override }\{\par
7798             {\cf19 return} m_cache;\par
7799         \}\par
7800         {\cf18 bool} next(){\cf17  override }\{\par
7801             {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7802             {\cf19 if} (success) \{\par
7803                 m_cache = m_function(m_generator.get());\par
7804             \}\par
7805             {\cf19 return} success;\par
7806         \}\par
7807     \};\par
7808 \par
7809     {\cf17 template} <{\cf17 typename} Func, {\cf17 typename} U, {\cf17 typename} T = FunctionReturnType<Func, U>>\par
7810     GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) \{\par
7811         {\cf19 return} GeneratorWrapper<T>(\par
7812             Catch::Detail::make_unique<MapGenerator<T, U, Func>>(CATCH_FORWARD(function), CATCH_MOVE(generator))\par
7813         );\par
7814     \}\par
7815 \par
7816     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U, {\cf17 typename} Func>\par
7817     GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) \{\par
7818         {\cf19 return} GeneratorWrapper<T>(\par
7819             Catch::Detail::make_unique<MapGenerator<T, U, Func>>(CATCH_FORWARD(function), CATCH_MOVE(generator))\par
7820         );\par
7821     \}\par
7822 \par
7823     {\cf17 template} <{\cf17 typename} T>\par
7824     {\cf17 class }ChunkGenerator final : {\cf17 public} IGenerator<std::vector<T>> \{\par
7825         std::vector<T> m_chunk;\par
7826         {\cf18 size_t} m_chunk_size;\par
7827         GeneratorWrapper<T> m_generator;\par
7828         {\cf18 bool} m_used_up = {\cf17 false};\par
7829     {\cf17 public}:\par
7830         ChunkGenerator({\cf18 size_t} size, GeneratorWrapper<T> generator) :\par
7831             m_chunk_size(size), m_generator(CATCH_MOVE(generator))\par
7832         \{\par
7833             m_chunk.reserve(m_chunk_size);\par
7834             {\cf19 if} (m_chunk_size != 0) \{\par
7835                 m_chunk.push_back(m_generator.get());\par
7836                 {\cf19 for} ({\cf18 size_t} i = 1; i < m_chunk_size; ++i) \{\par
7837                     {\cf19 if} (!m_generator.next()) \{\par
7838                         Detail::throw_generator_exception({\cf22 "Not enough values to initialize the first chunk"});\par
7839                     \}\par
7840                     m_chunk.push_back(m_generator.get());\par
7841                 \}\par
7842             \}\par
7843         \}\par
7844         std::vector<T> {\cf17 const}& get(){\cf17  const override }\{\par
7845             {\cf19 return} m_chunk;\par
7846         \}\par
7847         {\cf18 bool} next(){\cf17  override }\{\par
7848             m_chunk.clear();\par
7849             {\cf19 for} ({\cf18 size_t} idx = 0; idx < m_chunk_size; ++idx) \{\par
7850                 {\cf19 if} (!m_generator.next()) \{\par
7851                     {\cf19 return} {\cf17 false};\par
7852                 \}\par
7853                 m_chunk.push_back(m_generator.get());\par
7854             \}\par
7855             {\cf19 return} {\cf17 true};\par
7856         \}\par
7857     \};\par
7858 \par
7859     {\cf17 template} <{\cf17 typename} T>\par
7860     GeneratorWrapper<std::vector<T>> chunk({\cf18 size_t} size, GeneratorWrapper<T>&& generator) \{\par
7861         {\cf19 return} GeneratorWrapper<std::vector<T>>(\par
7862             Catch::Detail::make_unique<ChunkGenerator<T>>(size, CATCH_MOVE(generator))\par
7863         );\par
7864     \}\par
7865 \par
7866 \} {\cf20 // namespace Generators}\par
7867 \} {\cf20 // namespace Catch}\par
7868 \par
7869 \par
7870 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}\par
7871 \par
7872 \par
7873 {\cf21 #ifndef CATCH_GENERATORS_RANDOM_HPP_INCLUDED}\par
7874 {\cf21 #define CATCH_GENERATORS_RANDOM_HPP_INCLUDED}\par
7875 \par
7876 \par
7877 \par
7878 {\cf21 #ifndef CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}\par
7879 {\cf21 #define CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}\par
7880 \par
7881 {\cf21 #include <cstdint>}\par
7882 \par
7883 {\cf17 namespace }Catch \{\par
7884 \par
7885     {\cf20 // This is a simple implementation of C++11 Uniform Random Number}\par
7886     {\cf20 // Generator. It does not provide all operators, because Catch2}\par
7887     {\cf20 // does not use it, but it should behave as expected inside stdlib's}\par
7888     {\cf20 // distributions.}\par
7889     {\cf20 // The implementation is based on the PCG family (http://pcg-random.org)}\par
7890     {\cf17 class }SimplePcg32 \{\par
7891         {\cf17 using }state_type = std::uint64_t;\par
7892     {\cf17 public}:\par
7893         {\cf17 using }result_type = std::uint32_t;\par
7894         {\cf17 static} {\cf17 constexpr} result_type (min)() \{\par
7895             {\cf19 return} 0;\par
7896         \}\par
7897         {\cf17 static} {\cf17 constexpr} result_type (max)() \{\par
7898             {\cf19 return} {\cf17 static_cast<}result_type{\cf17 >}(-1);\par
7899         \}\par
7900 \par
7901         {\cf20 // Provide some default initial state for the default constructor}\par
7902         SimplePcg32():SimplePcg32(0xed743cc4U) \{\}\par
7903 \par
7904         {\cf17 explicit} SimplePcg32(result_type seed_);\par
7905 \par
7906         {\cf18 void} seed(result_type seed_);\par
7907         {\cf18 void} discard(uint64_t skip);\par
7908 \par
7909         result_type operator()();\par
7910 \par
7911     {\cf17 private}:\par
7912         {\cf17 friend} {\cf18 bool} operator==(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs);\par
7913         {\cf17 friend} {\cf18 bool} operator!=(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs);\par
7914 \par
7915         {\cf20 // In theory we also need operator<< and operator>>}\par
7916         {\cf20 // In practice we do not use them, so we will skip them for now}\par
7917 \par
7918 \par
7919         std::uint64_t m_state;\par
7920         {\cf20 // This part of the state determines which "stream" of the numbers}\par
7921         {\cf20 // is chosen -- we take it as a constant for Catch2, so we only}\par
7922         {\cf20 // need to deal with seeding the main state.}\par
7923         {\cf20 // Picked by reading 8 bytes from `/dev/random` :-)}\par
7924         {\cf17 static} {\cf17 const} std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;\par
7925     \};\par
7926 \par
7927 \} {\cf20 // end namespace Catch}\par
7928 \par
7929 {\cf21 #endif }{\cf20 // CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}\par
7930 \par
7931 \par
7932 \par
7933 {\cf21 #ifndef CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}\par
7934 {\cf21 #define CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}\par
7935 \par
7936 \par
7937 \par
7938 \par
7939 {\cf21 #ifndef CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}\par
7940 {\cf21 #define CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}\par
7941 \par
7942 {\cf21 #include <climits>}\par
7943 {\cf21 #include <cstddef>}\par
7944 {\cf21 #include <cstdint>}\par
7945 {\cf21 #include <type_traits>}\par
7946 \par
7947 {\cf20 // Note: We use the usual enable-disable-autodetect dance here even though}\par
7948 {\cf20 //       we do not support these in CMake configuration options (yet?).}\par
7949 {\cf20 //       It is highly unlikely that we will need to make these actually}\par
7950 {\cf20 //       user-configurable, but this will make it simpler if weend up needing}\par
7951 {\cf20 //       it, and it provides an escape hatch to the users who need it.}\par
7952 {\cf21 #if defined( __SIZEOF_INT128__ )}\par
7953 {\cf21 #    define CATCH_CONFIG_INTERNAL_UINT128}\par
7954 {\cf20 // Unlike GCC, MSVC does not polyfill umul as mulh + mul pair on ARM machines.}\par
7955 {\cf20 // Currently we do not bother doing this ourselves, but we could if it became}\par
7956 {\cf20 // important for perf.}\par
7957 {\cf21 #elif defined( _MSC_VER ) && defined( _M_X64 )}\par
7958 {\cf21 #    define CATCH_CONFIG_INTERNAL_MSVC_UMUL128}\par
7959 {\cf21 #endif}\par
7960 \par
7961 {\cf21 #if defined( CATCH_CONFIG_INTERNAL_UINT128 ) && \\}\par
7962 {\cf21     !defined( CATCH_CONFIG_NO_UINT128 ) &&      \\}\par
7963 {\cf21     !defined( CATCH_CONFIG_UINT128 )}\par
7964 {\cf21 #define CATCH_CONFIG_UINT128}\par
7965 {\cf21 #endif}\par
7966 \par
7967 {\cf21 #if defined( CATCH_CONFIG_INTERNAL_MSVC_UMUL128 ) && \\}\par
7968 {\cf21     !defined( CATCH_CONFIG_NO_MSVC_UMUL128 ) &&      \\}\par
7969 {\cf21     !defined( CATCH_CONFIG_MSVC_UMUL128 )}\par
7970 {\cf21 #    define CATCH_CONFIG_MSVC_UMUL128}\par
7971 {\cf21 #    include <intrin.h>}\par
7972 {\cf21 #endif}\par
7973 \par
7974 \par
7975 {\cf17 namespace }Catch \{\par
7976     {\cf17 namespace }Detail \{\par
7977 \par
7978         {\cf17 template} <std::{\cf18 size_t}>\par
7979         {\cf17 struct }SizedUnsignedType;\par
7980 {\cf21 #define SizedUnsignedTypeHelper( TYPE )        \\}\par
7981 {\cf21     template <>                                \\}\par
7982 {\cf21     struct SizedUnsignedType<sizeof( TYPE )> \{ \\}\par
7983 {\cf21         using type = TYPE;                     \\}\par
7984 {\cf21     \}}\par
7985 \par
7986         SizedUnsignedTypeHelper( std::uint8_t );\par
7987         SizedUnsignedTypeHelper( std::uint16_t );\par
7988         SizedUnsignedTypeHelper( std::uint32_t );\par
7989         SizedUnsignedTypeHelper( std::uint64_t );\par
7990 {\cf21 #undef SizedUnsignedTypeHelper}\par
7991 \par
7992         {\cf17 template} <std::{\cf18 size_t} sz>\par
7993         {\cf17 using }SizedUnsignedType_t = {\cf17 typename} SizedUnsignedType<sz>::type;\par
7994 \par
7995         {\cf17 template} <{\cf17 typename} T>\par
7996         {\cf17 using }DoubleWidthUnsignedType_t = SizedUnsignedType_t<2 * {\cf17 sizeof}( T )>;\par
7997 \par
7998         {\cf17 template} <{\cf17 typename} T>\par
7999         {\cf17 struct }ExtendedMultResult \{\par
8000             T upper;\par
8001             T lower;\par
8002             {\cf18 bool} operator==( ExtendedMultResult {\cf17 const}& rhs ){\cf17  const }\{\par
8003                 {\cf19 return} upper == rhs.upper && lower == rhs.lower;\par
8004             \}\par
8005         \};\par
8006 \par
8013         {\cf17 constexpr} ExtendedMultResult<std::uint64_t>\par
8014         extendedMultPortable(std::uint64_t lhs, std::uint64_t rhs) \{\par
8015 {\cf21 #define CarryBits( x ) ( x >> 32 )}\par
8016 {\cf21 #define Digits( x ) ( x & 0xFF'FF'FF'FF )}\par
8017             std::uint64_t lhs_low = Digits( lhs );\par
8018             std::uint64_t rhs_low = Digits( rhs );\par
8019             std::uint64_t low_low = ( lhs_low * rhs_low );\par
8020             std::uint64_t high_high = CarryBits( lhs ) * CarryBits( rhs );\par
8021 \par
8022             {\cf20 // We add in carry bits from low-low already}\par
8023             std::uint64_t high_low =\par
8024                 ( CarryBits( lhs ) * rhs_low ) + CarryBits( low_low );\par
8025             {\cf20 // Note that we can add only low bits from high_low, to avoid}\par
8026             {\cf20 // overflow with large inputs}\par
8027             std::uint64_t low_high =\par
8028                 ( lhs_low * CarryBits( rhs ) ) + Digits( high_low );\par
8029 \par
8030             {\cf19 return} \{ high_high + CarryBits( high_low ) + CarryBits( low_high ),\par
8031                      ( low_high << 32 ) | Digits( low_low ) \};\par
8032 {\cf21 #undef CarryBits}\par
8033 {\cf21 #undef Digits}\par
8034         \}\par
8035 \par
8037         {\cf17 inline} ExtendedMultResult<std::uint64_t>\par
8038         extendedMult( std::uint64_t lhs, std::uint64_t rhs ) \{\par
8039 {\cf21 #if defined( CATCH_CONFIG_UINT128 )}\par
8040             {\cf17 auto} result = __uint128_t( lhs ) * __uint128_t( rhs );\par
8041             {\cf19 return} \{ {\cf17 static_cast<}std::uint64_t{\cf17 >}( result >> 64 ),\par
8042                      {\cf17 static_cast<}std::uint64_t{\cf17 >}( result ) \};\par
8043 {\cf21 #elif defined( CATCH_CONFIG_MSVC_UMUL128 )}\par
8044             std::uint64_t high;\par
8045             std::uint64_t low = _umul128( lhs, rhs, &high );\par
8046             {\cf19 return} \{ high, low \};\par
8047 {\cf21 #else}\par
8048             {\cf19 return} extendedMultPortable( lhs, rhs );\par
8049 {\cf21 #endif}\par
8050         \}\par
8051 \par
8052 \par
8053         {\cf17 template} <{\cf17 typename} UInt>\par
8054         {\cf17 constexpr} ExtendedMultResult<UInt> extendedMult( UInt lhs, UInt rhs ) \{\par
8055             {\cf17 static_assert}( std::is_unsigned<UInt>::value,\par
8056                            {\cf22 "extendedMult can only handle unsigned integers"} );\par
8057             {\cf17 static_assert}( {\cf17 sizeof}( UInt ) < {\cf17 sizeof}( std::uint64_t ),\par
8058                            {\cf22 "Generic extendedMult can only handle types smaller "}\par
8059                            {\cf22 "than uint64_t"} );\par
8060             {\cf17 using }WideType = DoubleWidthUnsignedType_t<UInt>;\par
8061 \par
8062             {\cf17 auto} result = WideType( lhs ) * WideType( rhs );\par
8063             {\cf19 return} \{\par
8064                 {\cf17 static_cast<}UInt{\cf17 >}( result >> ( CHAR_BIT * {\cf17 sizeof}( UInt ) ) ),\par
8065                 {\cf17 static_cast<}UInt{\cf17 >}( result & UInt( -1 ) ) \};\par
8066         \}\par
8067 \par
8068 \par
8069         {\cf17 template} <{\cf17 typename} TargetType,\par
8070                   {\cf17 typename} Generator>\par
8071             std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) >= {\cf17 sizeof}(TargetType),\par
8072             TargetType> fillBitsFrom(Generator& gen) \{\par
8073             {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;\par
8074             {\cf17 static_assert}( std::is_unsigned<TargetType>::value, {\cf22 "Only unsigned integers are supported"} );\par
8075             {\cf17 static_assert}( Generator::min() == 0 &&\par
8076                            Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),\par
8077                            {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );\par
8078 \par
8079             {\cf20 // We want to return the top bits from a generator, as they are}\par
8080             {\cf20 // usually considered higher quality.}\par
8081             {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;\par
8082             {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;\par
8083 \par
8084             {\cf19 return} {\cf17 static_cast<}TargetType{\cf17 >}( gen() >>\par
8085                                             ( generated_bits - return_bits) );\par
8086         \}\par
8087 \par
8088         {\cf17 template} <{\cf17 typename} TargetType,\par
8089                   {\cf17 typename} Generator>\par
8090             std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) < {\cf17 sizeof}(TargetType),\par
8091             TargetType> fillBitsFrom(Generator& gen) \{\par
8092             {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;\par
8093             {\cf17 static_assert}( std::is_unsigned<TargetType>::value,\par
8094                            {\cf22 "Only unsigned integers are supported"} );\par
8095             {\cf17 static_assert}( Generator::min() == 0 &&\par
8096                            Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),\par
8097                            {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );\par
8098 \par
8099             {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;\par
8100             {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;\par
8101             std::size_t filled_bits = 0;\par
8102             TargetType ret = 0;\par
8103             {\cf19 do} \{\par
8104                 ret <<= generated_bits;\par
8105                 ret |= gen();\par
8106                 filled_bits += generated_bits;\par
8107             \} {\cf19 while} ( filled_bits < return_bits );\par
8108 \par
8109             {\cf19 return} ret;\par
8110         \}\par
8111 \par
8112         {\cf20 /*}\par
8113 {\cf20          * Transposes numbers into unsigned type while keeping their ordering}\par
8114 {\cf20          *}\par
8115 {\cf20          * This means that signed types are changed so that the ordering is}\par
8116 {\cf20          * [INT_MIN, ..., -1, 0, ..., INT_MAX], rather than order we would}\par
8117 {\cf20          * get by simple casting ([0, ..., INT_MAX, INT_MIN, ..., -1])}\par
8118 {\cf20          */}\par
8119         {\cf17 template} <{\cf17 typename} OriginalType, {\cf17 typename} Un{\cf18 signed}Type>\par
8120         std::enable_if_t<std::is_signed<OriginalType>::value, UnsignedType>\par
8121         transposeToNaturalOrder( UnsignedType in ) \{\par
8122             {\cf17 static_assert}(\par
8123                 {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),\par
8124                 {\cf22 "reordering requires the same sized types on both sides"} );\par
8125             {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value,\par
8126                            {\cf22 "Input type must be unsigned"} );\par
8127             {\cf20 // Assuming 2s complement (standardized in current C++), the}\par
8128             {\cf20 // positive and negative numbers are already internally ordered,}\par
8129             {\cf20 // and their difference is in the top bit. Swapping it orders}\par
8130             {\cf20 // them the desired way.}\par
8131             {\cf17 constexpr} {\cf17 auto} highest_bit =\par
8132                 UnsignedType( 1 ) << ( {\cf17 sizeof}( UnsignedType ) * CHAR_BIT - 1 );\par
8133             {\cf19 return} {\cf17 static_cast<}UnsignedType{\cf17 >}( in ^ highest_bit );\par
8134         \}\par
8135 \par
8136 \par
8137 \par
8138         {\cf17 template} <{\cf17 typename} OriginalType,\par
8139                   {\cf17 typename} UnsignedType>\par
8140         std::enable_if_t<std::is_unsigned<OriginalType>::value, UnsignedType>\par
8141             transposeToNaturalOrder(UnsignedType in) \{\par
8142             {\cf17 static_assert}(\par
8143                 {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),\par
8144                 {\cf22 "reordering requires the same sized types on both sides"} );\par
8145             {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value, {\cf22 "Input type must be unsigned"} );\par
8146             {\cf20 // No reordering is needed for unsigned -> unsigned}\par
8147             {\cf19 return} in;\par
8148         \}\par
8149     \} {\cf20 // namespace Detail}\par
8150 \} {\cf20 // namespace Catch}\par
8151 \par
8152 {\cf21 #endif }{\cf20 // CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}\par
8153 \par
8154 {\cf17 namespace }Catch \{\par
8155 \par
8167 {\cf17 template} <{\cf17 typename} IntegerType>\par
8168 {\cf17 class }uniform_integer_distribution \{\par
8169     {\cf17 static_assert}(std::is_integral<IntegerType>::value, {\cf22 "..."});\par
8170 \par
8171     {\cf17 using }UnsignedIntegerType = Detail::SizedUnsignedType_t<{\cf17 sizeof}(IntegerType)>;\par
8172 \par
8173     {\cf20 // Only the left bound is stored, and we store it converted to its}\par
8174     {\cf20 // unsigned image. This avoids having to do the conversions inside}\par
8175     {\cf20 // the operator(), at the cost of having to do the conversion in}\par
8176     {\cf20 // the a() getter. The right bound is only needed in the b() getter,}\par
8177     {\cf20 // so we recompute it there from other stored data.}\par
8178     UnsignedIntegerType m_a;\par
8179 \par
8180     {\cf20 // How many different values are there in [a, b]. a == b => 1, can be 0 for distribution over all values in the type.}\par
8181     UnsignedIntegerType m_ab_distance;\par
8182 \par
8183     {\cf20 // We hoisted this out of the main generation function. Technically,}\par
8184     {\cf20 // this means that using this distribution will be slower than Lemire's}\par
8185     {\cf20 // algorithm if this distribution instance will be used only few times,}\par
8186     {\cf20 // but it will be faster if it is used many times. Since Catch2 uses}\par
8187     {\cf20 // distributions only to implement random generators, we assume that each}\par
8188     {\cf20 // distribution will be reused many times and this is an optimization.}\par
8189     UnsignedIntegerType m_rejection_threshold = 0;\par
8190 \par
8191     UnsignedIntegerType computeDistance(IntegerType a, IntegerType b){\cf17  const }\{\par
8192         {\cf20 // This overflows and returns 0 if a == 0 and b == TYPE_MAX.}\par
8193         {\cf20 // We handle that later when generating the number.}\par
8194         {\cf19 return} transposeTo(b) - transposeTo(a) + 1;\par
8195     \}\par
8196 \par
8197     {\cf17 static} UnsignedIntegerType computeRejectionThreshold(UnsignedIntegerType ab_distance) \{\par
8198         {\cf20 // distance == 0 means that we will return all possible values from}\par
8199         {\cf20 // the type's range, and that we shouldn't reject anything.}\par
8200         {\cf19 if} ( ab_distance == 0 ) \{ {\cf19 return} 0; \}\par
8201         {\cf19 return} ( ~ab_distance + 1 ) % ab_distance;\par
8202     \}\par
8203 \par
8204     {\cf17 static} UnsignedIntegerType transposeTo(IntegerType in) \{\par
8205         {\cf19 return} Detail::transposeToNaturalOrder<IntegerType>(\par
8206             {\cf17 static_cast<}UnsignedIntegerType{\cf17 >}( in ) );\par
8207     \}\par
8208     {\cf17 static} IntegerType transposeBack(UnsignedIntegerType in) \{\par
8209         {\cf19 return} {\cf17 static_cast<}IntegerType{\cf17 >}(\par
8210             Detail::transposeToNaturalOrder<IntegerType>(in) );\par
8211     \}\par
8212 \par
8213 {\cf17 public}:\par
8214     {\cf17 using }result_type = IntegerType;\par
8215 \par
8216     uniform_integer_distribution( IntegerType a, IntegerType b ):\par
8217         m_a( transposeTo(a) ),\par
8218         m_ab_distance( computeDistance(a, b) ),\par
8219         m_rejection_threshold( computeRejectionThreshold(m_ab_distance) ) \{\par
8220         assert( a <= b );\par
8221     \}\par
8222 \par
8223     {\cf17 template} <{\cf17 typename} Generator>\par
8224     result_type operator()( Generator& g ) \{\par
8225         {\cf20 // All possible values of result_type are valid.}\par
8226         {\cf19 if} ( m_ab_distance == 0 ) \{\par
8227             {\cf19 return} transposeBack( Detail::fillBitsFrom<UnsignedIntegerType>( g ) );\par
8228         \}\par
8229 \par
8230         {\cf17 auto} random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );\par
8231         {\cf17 auto} emul = Detail::extendedMult( random_number, m_ab_distance );\par
8232         {\cf20 // Unlike Lemire's algorithm we skip the ab_distance check, since}\par
8233         {\cf20 // we precomputed the rejection threshold, which is always tighter.}\par
8234         {\cf19 while} (emul.lower < m_rejection_threshold) \{\par
8235             random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );\par
8236             emul = Detail::extendedMult( random_number, m_ab_distance );\par
8237         \}\par
8238 \par
8239         {\cf19 return} transposeBack(m_a + emul.upper);\par
8240     \}\par
8241 \par
8242     result_type a(){\cf17  const }\{ {\cf19 return} transposeBack(m_a); \}\par
8243     result_type b(){\cf17  const }\{ {\cf19 return} transposeBack(m_ab_distance + m_a - 1); \}\par
8244 \};\par
8245 \par
8246 \} {\cf20 // end namespace Catch}\par
8247 \par
8248 {\cf21 #endif }{\cf20 // CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}\par
8249 \par
8250 \par
8251 \par
8252 {\cf21 #ifndef CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED}\par
8253 {\cf21 #define CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED}\par
8254 \par
8255 \par
8256 \par
8257 \par
8258 {\cf21 #ifndef CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
8259 {\cf21 #define CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
8260 \par
8261 \par
8262 \par
8263 {\cf21 #ifndef CATCH_POLYFILLS_HPP_INCLUDED}\par
8264 {\cf21 #define CATCH_POLYFILLS_HPP_INCLUDED}\par
8265 \par
8266 {\cf17 namespace }Catch \{\par
8267 \par
8268     {\cf18 bool} isnan({\cf18 float} f);\par
8269     {\cf18 bool} isnan({\cf18 double} d);\par
8270 \par
8271     {\cf18 float} nextafter({\cf18 float} x, {\cf18 float} y);\par
8272     {\cf18 double} nextafter({\cf18 double} x, {\cf18 double} y);\par
8273 \par
8274 \}\par
8275 \par
8276 {\cf21 #endif }{\cf20 // CATCH_POLYFILLS_HPP_INCLUDED}\par
8277 \par
8278 {\cf21 #include <cassert>}\par
8279 {\cf21 #include <cmath>}\par
8280 {\cf21 #include <cstdint>}\par
8281 {\cf21 #include <limits>}\par
8282 {\cf21 #include <type_traits>}\par
8283 \par
8284 {\cf17 namespace }Catch \{\par
8285 \par
8286     {\cf17 namespace }Detail \{\par
8292         {\cf17 template} <{\cf17 typename} FloatType>\par
8293         FloatType gamma(FloatType a, FloatType b) \{\par
8294             {\cf17 static_assert}( std::is_floating_point<FloatType>::value,\par
8295                            {\cf22 "gamma returns the largest ULP magnitude within "}\par
8296                            {\cf22 "floating point range [a, b]. This only makes sense "}\par
8297                            {\cf22 "for floating point types"} );\par
8298             assert( a <= b );\par
8299 \par
8300             {\cf17 const} {\cf17 auto} gamma_up = Catch::nextafter( a, std::numeric_limits<FloatType>::infinity() ) - a;\par
8301             {\cf17 const} {\cf17 auto} gamma_down = b - Catch::nextafter( b, -std::numeric_limits<FloatType>::infinity() );\par
8302 \par
8303             {\cf19 return} gamma_up < gamma_down ? gamma_down : gamma_up;\par
8304         \}\par
8305 \par
8306         {\cf17 template} <{\cf17 typename} FloatingPo{\cf18 int}>\par
8307         {\cf17 struct }DistanceTypePicker;\par
8308         {\cf17 template} <>\par
8309         {\cf17 struct }DistanceTypePicker<float> \{\par
8310             {\cf17 using }type = std::uint32_t;\par
8311         \};\par
8312         {\cf17 template} <>\par
8313         {\cf17 struct }DistanceTypePicker<double> \{\par
8314             {\cf17 using }type = std::uint64_t;\par
8315         \};\par
8316 \par
8317         {\cf17 template} <{\cf17 typename} T>\par
8318         {\cf17 using }DistanceType = {\cf17 typename} DistanceTypePicker<T>::type;\par
8319 \par
8320 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8321 {\cf21 #    pragma GCC diagnostic push}\par
8322 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
8323 {\cf21 #endif}\par
8333         {\cf17 template} <{\cf17 typename} FloatType>\par
8334         DistanceType<FloatType>\par
8335         count_equidistant_floats( FloatType a, FloatType b, FloatType distance ) \{\par
8336             assert( a <= b );\par
8337             {\cf20 // We get distance as gamma for our uniform float distribution,}\par
8338             {\cf20 // so this will round perfectly.}\par
8339             {\cf17 const} {\cf17 auto} ag = a / distance;\par
8340             {\cf17 const} {\cf17 auto} bg = b / distance;\par
8341 \par
8342             {\cf17 const} {\cf17 auto} s = bg - ag;\par
8343             {\cf17 const} {\cf17 auto} err = ( std::fabs( a ) <= std::fabs( b ) )\par
8344                                  ? -ag - ( s - bg )\par
8345                                  : bg - ( s + ag );\par
8346             {\cf17 const} {\cf17 auto} ceil_s = {\cf17 static_cast<}DistanceType<FloatType>{\cf17 >}( std::ceil( s ) );\par
8347 \par
8348             {\cf19 return} ( ceil_s != s ) ? ceil_s : ceil_s + ( err > 0 );\par
8349         \}\par
8350 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8351 {\cf21 #    pragma GCC diagnostic pop}\par
8352 {\cf21 #endif}\par
8353 \par
8354     \}\par
8355 \par
8356 \} {\cf20 // end namespace Catch}\par
8357 \par
8358 {\cf21 #endif }{\cf20 // CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
8359 \par
8360 {\cf21 #include <cmath>}\par
8361 {\cf21 #include <type_traits>}\par
8362 \par
8363 {\cf17 namespace }Catch \{\par
8364 \par
8365     {\cf17 namespace }Detail \{\par
8366 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8367 {\cf21 #    pragma GCC diagnostic push}\par
8368 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
8369 {\cf21 #endif}\par
8370         {\cf20 // The issue with overflow only happens with maximal ULP and HUGE}\par
8371         {\cf20 // distance, e.g. when generating numbers in [-inf, inf] for given}\par
8372         {\cf20 // type. So we only check for the largest possible ULP in the}\par
8373         {\cf20 // type, and return something that does not overflow to inf in 1 mult.}\par
8374         {\cf17 constexpr} std::uint64_t calculate_max_steps_in_one_go({\cf18 double} gamma) \{\par
8375             {\cf19 if} ( gamma == 1.99584030953472e+292 ) \{ {\cf19 return} 9007199254740991; \}\par
8376             {\cf19 return} {\cf17 static_cast<}std::uint64_t{\cf17 >}( -1 );\par
8377         \}\par
8378         {\cf17 constexpr} std::uint32_t calculate_max_steps_in_one_go({\cf18 float} gamma) \{\par
8379             {\cf19 if} ( gamma == 2.028241e+31f ) \{ {\cf19 return} 16777215; \}\par
8380             {\cf19 return} {\cf17 static_cast<}std::uint32_t{\cf17 >}( -1 );\par
8381         \}\par
8382 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8383 {\cf21 #    pragma GCC diagnostic pop}\par
8384 {\cf21 #endif}\par
8385     \}\par
8386 \par
8413 {\cf17 template} <{\cf17 typename} FloatType>\par
8414 {\cf17 class }uniform_floating_point_distribution \{\par
8415     {\cf17 static_assert}(std::is_floating_point<FloatType>::value, {\cf22 "..."});\par
8416     {\cf17 static_assert}(!std::is_same<FloatType, long double>::value,\par
8417                   {\cf22 "We do not support long double due to inconsistent behaviour between platforms"});\par
8418 \par
8419     {\cf17 using }WidthType = Detail::DistanceType<FloatType>;\par
8420 \par
8421     FloatType m_a, m_b;\par
8422     FloatType m_ulp_magnitude;\par
8423     WidthType m_floats_in_range;\par
8424     uniform_integer_distribution<WidthType> m_int_dist;\par
8425 \par
8426     {\cf20 // In specific cases, we can overflow into `inf` when computing the}\par
8427     {\cf20 // `steps * g` offset. To avoid this, we don't offset by more than this}\par
8428     {\cf20 // in one multiply + addition.}\par
8429     WidthType m_max_steps_in_one_go;\par
8430     {\cf20 // We don't want to do the magnitude check every call to `operator()`}\par
8431     {\cf18 bool} m_a_has_leq_magnitude;\par
8432 \par
8433 {\cf17 public}:\par
8434     {\cf17 using }result_type = FloatType;\par
8435 \par
8436     uniform_floating_point_distribution( FloatType a, FloatType b ):\par
8437         m_a( a ),\par
8438         m_b( b ),\par
8439         m_ulp_magnitude( Detail::gamma( m_a, m_b ) ),\par
8440         m_floats_in_range( Detail::count_equidistant_floats( m_a, m_b, m_ulp_magnitude ) ),\par
8441         m_int_dist(0, m_floats_in_range),\par
8442         m_max_steps_in_one_go( Detail::calculate_max_steps_in_one_go(m_ulp_magnitude)),\par
8443         m_a_has_leq_magnitude(std::fabs(m_a) <= std::fabs(m_b))\par
8444     \{\par
8445         assert( a <= b );\par
8446     \}\par
8447 \par
8448     {\cf17 template} <{\cf17 typename} Generator>\par
8449     result_type operator()( Generator& g ) \{\par
8450         WidthType steps = m_int_dist( g );\par
8451         {\cf19 if} ( m_a_has_leq_magnitude ) \{\par
8452             {\cf19 if} ( steps == m_floats_in_range ) \{ {\cf19 return} m_a; \}\par
8453             {\cf17 auto} b = m_b;\par
8454             {\cf19 while} (steps > m_max_steps_in_one_go) \{\par
8455                 b -= m_max_steps_in_one_go * m_ulp_magnitude;\par
8456                 steps -= m_max_steps_in_one_go;\par
8457             \}\par
8458             {\cf19 return} b - steps * m_ulp_magnitude;\par
8459         \} {\cf19 else} \{\par
8460             {\cf19 if} ( steps == m_floats_in_range ) \{ {\cf19 return} m_b; \}\par
8461             {\cf17 auto} a = m_a;\par
8462             {\cf19 while} (steps > m_max_steps_in_one_go) \{\par
8463                 a += m_max_steps_in_one_go * m_ulp_magnitude;\par
8464                 steps -= m_max_steps_in_one_go;\par
8465             \}\par
8466             {\cf19 return} a + steps * m_ulp_magnitude;\par
8467         \}\par
8468     \}\par
8469 \par
8470     result_type a(){\cf17  const }\{ {\cf19 return} m_a; \}\par
8471     result_type b(){\cf17  const }\{ {\cf19 return} m_b; \}\par
8472 \};\par
8473 \par
8474 \} {\cf20 // end namespace Catch}\par
8475 \par
8476 {\cf21 #endif }{\cf20 // CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED}\par
8477 \par
8478 {\cf17 namespace }Catch \{\par
8479 {\cf17 namespace }Generators \{\par
8480 {\cf17 namespace }Detail \{\par
8481     {\cf20 // Returns a suitable seed for a random floating generator based off}\par
8482     {\cf20 // the primary internal rng. It does so by taking current value from}\par
8483     {\cf20 // the rng and returning it as the seed.}\par
8484     std::uint32_t getSeed();\par
8485 \}\par
8486 \par
8487 {\cf17 template} <{\cf17 typename} Float>\par
8488 {\cf17 class }RandomFloatingGenerator final : {\cf17 public} IGenerator<Float> \{\par
8489     Catch::SimplePcg32 m_rng;\par
8490     Catch::uniform_floating_point_distribution<Float> m_dist;\par
8491     Float m_current_number;\par
8492 {\cf17 public}:\par
8493     RandomFloatingGenerator( Float a, Float b, std::uint32_t seed ):\par
8494         m_rng(seed),\par
8495         m_dist(a, b) \{\par
8496         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(next());\par
8497     \}\par
8498 \par
8499     Float {\cf17 const}& get(){\cf17  const override }\{\par
8500         {\cf19 return} m_current_number;\par
8501     \}\par
8502     {\cf18 bool} next(){\cf17  override }\{\par
8503         m_current_number = m_dist(m_rng);\par
8504         {\cf19 return} {\cf17 true};\par
8505     \}\par
8506 \};\par
8507 \par
8508 {\cf17 template} <>\par
8509 {\cf17 class }RandomFloatingGenerator<long double> final : {\cf17 public} IGenerator<long double> \{\par
8510     {\cf20 // We still rely on <random> for this specialization, but we don't}\par
8511     {\cf20 // want to drag it into the header.}\par
8512     {\cf17 struct }PImpl;\par
8513     Catch::Detail::unique_ptr<PImpl> m_pimpl;\par
8514     {\cf18 long} {\cf18 double} m_current_number;\par
8515 \par
8516 {\cf17 public}:\par
8517     RandomFloatingGenerator( {\cf18 long} {\cf18 double} a, {\cf18 long} {\cf18 double} b, std::uint32_t seed );\par
8518 \par
8519     {\cf18 long} {\cf18 double} {\cf17 const}& get(){\cf17  const override }\{ {\cf19 return} m_current_number; \}\par
8520     {\cf18 bool} next() {\cf17 override};\par
8521 \par
8522     ~RandomFloatingGenerator() {\cf17 override}; {\cf20 // = default}\par
8523 \};\par
8524 \par
8525 {\cf17 template} <{\cf17 typename} Integer>\par
8526 {\cf17 class }RandomIntegerGenerator final : {\cf17 public} IGenerator<Integer> \{\par
8527     Catch::SimplePcg32 m_rng;\par
8528     Catch::uniform_integer_distribution<Integer> m_dist;\par
8529     Integer m_current_number;\par
8530 {\cf17 public}:\par
8531     RandomIntegerGenerator( Integer a, Integer b, std::uint32_t seed ):\par
8532         m_rng(seed),\par
8533         m_dist(a, b) \{\par
8534         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(next());\par
8535     \}\par
8536 \par
8537     Integer {\cf17 const}& get(){\cf17  const override }\{\par
8538         {\cf19 return} m_current_number;\par
8539     \}\par
8540     {\cf18 bool} next(){\cf17  override }\{\par
8541         m_current_number = m_dist(m_rng);\par
8542         {\cf19 return} {\cf17 true};\par
8543     \}\par
8544 \};\par
8545 \par
8546 {\cf17 template} <{\cf17 typename} T>\par
8547 std::enable_if_t<std::is_integral<T>::value, GeneratorWrapper<T>>\par
8548 random(T a, T b) \{\par
8549     {\cf19 return} GeneratorWrapper<T>(\par
8550         Catch::Detail::make_unique<RandomIntegerGenerator<T>>(a, b, Detail::getSeed())\par
8551     );\par
8552 \}\par
8553 \par
8554 {\cf17 template} <{\cf17 typename} T>\par
8555 std::enable_if_t<std::is_floating_point<T>::value,\par
8556 GeneratorWrapper<T>>\par
8557 random(T a, T b) \{\par
8558     {\cf19 return} GeneratorWrapper<T>(\par
8559         Catch::Detail::make_unique<RandomFloatingGenerator<T>>(a, b, Detail::getSeed())\par
8560     );\par
8561 \}\par
8562 \par
8563 \par
8564 \} {\cf20 // namespace Generators}\par
8565 \} {\cf20 // namespace Catch}\par
8566 \par
8567 \par
8568 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_RANDOM_HPP_INCLUDED}\par
8569 \par
8570 \par
8571 {\cf21 #ifndef CATCH_GENERATORS_RANGE_HPP_INCLUDED}\par
8572 {\cf21 #define CATCH_GENERATORS_RANGE_HPP_INCLUDED}\par
8573 \par
8574 \par
8575 {\cf21 #include <iterator>}\par
8576 {\cf21 #include <type_traits>}\par
8577 \par
8578 {\cf17 namespace }Catch \{\par
8579 {\cf17 namespace }Generators \{\par
8580 \par
8581 \par
8582 {\cf17 template} <{\cf17 typename} T>\par
8583 {\cf17 class }RangeGenerator final : {\cf17 public} IGenerator<T> \{\par
8584     T m_current;\par
8585     T m_end;\par
8586     T m_step;\par
8587     {\cf18 bool} m_positive;\par
8588 \par
8589 {\cf17 public}:\par
8590     RangeGenerator(T {\cf17 const}& start, T {\cf17 const}& end, T {\cf17 const}& step):\par
8591         m_current(start),\par
8592         m_end(end),\par
8593         m_step(step),\par
8594         m_positive(m_step > T(0))\par
8595     \{\par
8596         assert(m_current != m_end && {\cf22 "Range start and end cannot be equal"});\par
8597         assert(m_step != T(0) && {\cf22 "Step size cannot be zero"});\par
8598         assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && {\cf22 "Step moves away from end"});\par
8599     \}\par
8600 \par
8601     RangeGenerator(T {\cf17 const}& start, T {\cf17 const}& end):\par
8602         RangeGenerator(start, end, (start < end) ? T(1) : T(-1))\par
8603     \{\}\par
8604 \par
8605     T {\cf17 const}& get(){\cf17  const override }\{\par
8606         {\cf19 return} m_current;\par
8607     \}\par
8608 \par
8609     {\cf18 bool} next(){\cf17  override }\{\par
8610         m_current += m_step;\par
8611         {\cf19 return} (m_positive) ? (m_current < m_end) : (m_current > m_end);\par
8612     \}\par
8613 \};\par
8614 \par
8615 {\cf17 template} <{\cf17 typename} T>\par
8616 GeneratorWrapper<T> range(T {\cf17 const}& start, T {\cf17 const}& end, T {\cf17 const}& step) \{\par
8617     {\cf17 static_assert}(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, {\cf22 "Type must be numeric"});\par
8618     {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end, step));\par
8619 \}\par
8620 \par
8621 {\cf17 template} <{\cf17 typename} T>\par
8622 GeneratorWrapper<T> range(T {\cf17 const}& start, T {\cf17 const}& end) \{\par
8623     {\cf17 static_assert}(std::is_integral<T>::value && !std::is_same<T, bool>::value, {\cf22 "Type must be an integer"});\par
8624     {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end));\par
8625 \}\par
8626 \par
8627 \par
8628 {\cf17 template} <{\cf17 typename} T>\par
8629 {\cf17 class }IteratorGenerator final : {\cf17 public} IGenerator<T> \{\par
8630     {\cf17 static_assert}(!std::is_same<T, bool>::value,\par
8631         {\cf22 "IteratorGenerator currently does not support bools"}\par
8632         {\cf22 "because of std::vector<bool> specialization"});\par
8633 \par
8634     std::vector<T> m_elems;\par
8635     {\cf18 size_t} m_current = 0;\par
8636 {\cf17 public}:\par
8637     {\cf17 template} <{\cf17 typename} InputIterator, {\cf17 typename} InputSentinel>\par
8638     IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) \{\par
8639         {\cf19 if} (m_elems.empty()) \{\par
8640             Detail::throw_generator_exception({\cf22 "IteratorGenerator received no valid values"});\par
8641         \}\par
8642     \}\par
8643 \par
8644     T {\cf17 const}& get(){\cf17  const override }\{\par
8645         {\cf19 return} m_elems[m_current];\par
8646     \}\par
8647 \par
8648     {\cf18 bool} next(){\cf17  override }\{\par
8649         ++m_current;\par
8650         {\cf19 return} m_current != m_elems.size();\par
8651     \}\par
8652 \};\par
8653 \par
8654 {\cf17 template} <{\cf17 typename} InputIterator,\par
8655           {\cf17 typename} InputSentinel,\par
8656           {\cf17 typename} ResultType = {\cf17 typename} std::iterator_traits<InputIterator>::value_type>\par
8657 GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) \{\par
8658     {\cf19 return} GeneratorWrapper<ResultType>(Catch::Detail::make_unique<IteratorGenerator<ResultType>>(from, to));\par
8659 \}\par
8660 \par
8661 {\cf17 template} <{\cf17 typename} Container>\par
8662 {\cf17 auto} from_range(Container {\cf17 const}& cnt) \{\par
8663     {\cf17 using }std::begin;\par
8664     {\cf17 using }std::end;\par
8665     {\cf19 return} from_range( begin( cnt ), end( cnt ) );\par
8666 \}\par
8667 \par
8668 \par
8669 \} {\cf20 // namespace Generators}\par
8670 \} {\cf20 // namespace Catch}\par
8671 \par
8672 \par
8673 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_RANGE_HPP_INCLUDED}\par
8674 \par
8675 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_ALL_HPP_INCLUDED}\par
8676 \par
8677 \par
8692 {\cf21 #ifndef CATCH_INTERFACES_ALL_HPP_INCLUDED}\par
8693 {\cf21 #define CATCH_INTERFACES_ALL_HPP_INCLUDED}\par
8694 \par
8695 \par
8696 \par
8697 {\cf21 #ifndef CATCH_INTERFACES_REPORTER_HPP_INCLUDED}\par
8698 {\cf21 #define CATCH_INTERFACES_REPORTER_HPP_INCLUDED}\par
8699 \par
8700 \par
8701 \par
8702 {\cf21 #ifndef CATCH_TEST_RUN_INFO_HPP_INCLUDED}\par
8703 {\cf21 #define CATCH_TEST_RUN_INFO_HPP_INCLUDED}\par
8704 \par
8705 \par
8706 {\cf17 namespace }Catch \{\par
8707 \par
8708     {\cf17 struct }TestRunInfo \{\par
8709         {\cf17 constexpr} TestRunInfo(StringRef _name) : name(_name) \{\}\par
8710         StringRef name;\par
8711     \};\par
8712 \par
8713 \} {\cf20 // end namespace Catch}\par
8714 \par
8715 {\cf21 #endif }{\cf20 // CATCH_TEST_RUN_INFO_HPP_INCLUDED}\par
8716 \par
8717 {\cf21 #include <map>}\par
8718 {\cf21 #include <string>}\par
8719 {\cf21 #include <vector>}\par
8720 {\cf21 #include <iosfwd>}\par
8721 \par
8722 {\cf17 namespace }Catch \{\par
8723 \par
8724     {\cf17 struct }ReporterDescription;\par
8725     {\cf17 struct }ListenerDescription;\par
8726     {\cf17 struct }TagInfo;\par
8727     {\cf17 struct }TestCaseInfo;\par
8728     {\cf17 class }TestCaseHandle;\par
8729     {\cf17 class }IConfig;\par
8730     {\cf17 class }IStream;\par
8731     {\cf17 enum class} ColourMode : std::uint8_t;\par
8732 \par
8733     {\cf17 struct }ReporterConfig \{\par
8734         ReporterConfig( IConfig {\cf17 const}* _fullConfig,\par
8735                         Detail::unique_ptr<IStream> _stream,\par
8736                         ColourMode colourMode,\par
8737                         std::map<std::string, std::string> customOptions );\par
8738 \par
8739         ReporterConfig( ReporterConfig&& ) = {\cf19 default};\par
8740         ReporterConfig& operator=( ReporterConfig&& ) = {\cf19 default};\par
8741         ~ReporterConfig(); {\cf20 // = default}\par
8742 \par
8743         Detail::unique_ptr<IStream> takeStream() &&;\par
8744         IConfig {\cf17 const}* fullConfig() {\cf17 const};\par
8745         ColourMode colourMode() {\cf17 const};\par
8746         std::map<std::string, std::string> {\cf17 const}& customOptions() {\cf17 const};\par
8747 \par
8748     {\cf17 private}:\par
8749         Detail::unique_ptr<IStream> m_stream;\par
8750         IConfig {\cf17 const}* m_fullConfig;\par
8751         ColourMode m_colourMode;\par
8752         std::map<std::string, std::string> m_customOptions;\par
8753     \};\par
8754 \par
8755     {\cf17 struct }AssertionStats \{\par
8756         AssertionStats( AssertionResult {\cf17 const}& _assertionResult,\par
8757                         std::vector<MessageInfo> {\cf17 const}& _infoMessages,\par
8758                         Totals {\cf17 const}& _totals );\par
8759 \par
8760         AssertionStats( AssertionStats {\cf17 const}& )              = {\cf19 default};\par
8761         AssertionStats( AssertionStats && )                  = {\cf19 default};\par
8762         AssertionStats& operator = ( AssertionStats {\cf17 const}& ) = {\cf17 delete};\par
8763         AssertionStats& operator = ( AssertionStats && )     = {\cf17 delete};\par
8764 \par
8765         AssertionResult assertionResult;\par
8766         std::vector<MessageInfo> infoMessages;\par
8767         Totals totals;\par
8768     \};\par
8769 \par
8770     {\cf17 struct }SectionStats \{\par
8771         SectionStats(   SectionInfo&& _sectionInfo,\par
8772                         Counts {\cf17 const}& _assertions,\par
8773                         {\cf18 double} _durationInSeconds,\par
8774                         {\cf18 bool} _missingAssertions );\par
8775 \par
8776         SectionInfo sectionInfo;\par
8777         Counts assertions;\par
8778         {\cf18 double} durationInSeconds;\par
8779         {\cf18 bool} missingAssertions;\par
8780     \};\par
8781 \par
8782     {\cf17 struct }TestCaseStats \{\par
8783         TestCaseStats(  TestCaseInfo {\cf17 const}& _testInfo,\par
8784                         Totals {\cf17 const}& _totals,\par
8785                         std::string&& _stdOut,\par
8786                         std::string&& _stdErr,\par
8787                         {\cf18 bool} _aborting );\par
8788 \par
8789         TestCaseInfo {\cf17 const} * testInfo;\par
8790         Totals totals;\par
8791         std::string stdOut;\par
8792         std::string stdErr;\par
8793         {\cf18 bool} aborting;\par
8794     \};\par
8795 \par
8796     {\cf17 struct }TestRunStats \{\par
8797         TestRunStats(   TestRunInfo {\cf17 const}& _runInfo,\par
8798                         Totals {\cf17 const}& _totals,\par
8799                         {\cf18 bool} _aborting );\par
8800 \par
8801         TestRunInfo runInfo;\par
8802         Totals totals;\par
8803         {\cf18 bool} aborting;\par
8804     \};\par
8805 \par
8809     {\cf17 struct }ReporterPreferences \{\par
8812         {\cf18 bool} shouldRedirectStdOut = {\cf17 false};\par
8815         {\cf18 bool} shouldReportAllAssertions = {\cf17 false};\par
8816     \};\par
8817 \par
8830     {\cf17 class }IEventListener \{\par
8831     {\cf17 protected}:\par
8833         ReporterPreferences m_preferences;\par
8835         IConfig {\cf17 const}* m_config;\par
8836 \par
8837     {\cf17 public}:\par
8838         IEventListener( IConfig {\cf17 const}* config ): m_config( config ) \{\}\par
8839 \par
8840         {\cf17 virtual} ~IEventListener(); {\cf20 // = default;}\par
8841 \par
8842         {\cf20 // Implementing class must also provide the following static methods:}\par
8843         {\cf20 // static std::string getDescription();}\par
8844 \par
8845         ReporterPreferences {\cf17 const}& getPreferences(){\cf17  const }\{\par
8846             {\cf19 return} m_preferences;\par
8847         \}\par
8848 \par
8850         {\cf17 virtual} {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) = 0;\par
8852         {\cf17 virtual} {\cf18 void} reportInvalidTestSpec( StringRef invalidArgument ) = 0;\par
8853 \par
8859         {\cf17 virtual} {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) = 0;\par
8860 \par
8862         {\cf17 virtual} {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) = 0;\par
8864         {\cf17 virtual} {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}& testInfo, uint64_t partNumber ) = 0;\par
8866         {\cf17 virtual} {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) = 0;\par
8867 \par
8869         {\cf17 virtual} {\cf18 void} benchmarkPreparing( StringRef benchmarkName ) = 0;\par
8871         {\cf17 virtual} {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) = 0;\par
8873         {\cf17 virtual} {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) = 0;\par
8875         {\cf17 virtual} {\cf18 void} benchmarkFailed( StringRef benchmarkName ) = 0;\par
8876 \par
8878         {\cf17 virtual} {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) = 0;\par
8879 \par
8881         {\cf17 virtual} {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) = 0;\par
8882 \par
8884         {\cf17 virtual} {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) = 0;\par
8886         {\cf17 virtual} {\cf18 void} testCasePartialEnded(TestCaseStats {\cf17 const}& testCaseStats, uint64_t partNumber ) = 0;\par
8888         {\cf17 virtual} {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) = 0;\par
8894         {\cf17 virtual} {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) = 0;\par
8895 \par
8902         {\cf17 virtual} {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) = 0;\par
8903 \par
8905         {\cf17 virtual} {\cf18 void} fatalErrorEncountered( StringRef error ) = 0;\par
8906 \par
8908         {\cf17 virtual} {\cf18 void} listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) = 0;\par
8910         {\cf17 virtual} {\cf18 void} listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) = 0;\par
8912         {\cf17 virtual} {\cf18 void} listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) = 0;\par
8914         {\cf17 virtual} {\cf18 void} listTags(std::vector<TagInfo> {\cf17 const}& tags) = 0;\par
8915     \};\par
8916     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
8917 \par
8918 \} {\cf20 // end namespace Catch}\par
8919 \par
8920 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_REPORTER_HPP_INCLUDED}\par
8921 \par
8922 \par
8923 {\cf21 #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED}\par
8924 {\cf21 #define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED}\par
8925 \par
8926 \par
8927 {\cf21 #include <string>}\par
8928 \par
8929 {\cf17 namespace }Catch \{\par
8930 \par
8931     {\cf17 struct }ReporterConfig;\par
8932     {\cf17 class }IConfig;\par
8933     {\cf17 class }IEventListener;\par
8934     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
8935 \par
8936 \par
8937     {\cf17 class }IReporterFactory \{\par
8938     {\cf17 public}:\par
8939         {\cf17 virtual} ~IReporterFactory(); {\cf20 // = default}\par
8940 \par
8941         {\cf17 virtual} IEventListenerPtr\par
8942         create( ReporterConfig&& config ) {\cf17 const} = 0;\par
8943         {\cf17 virtual} std::string getDescription() {\cf17 const} = 0;\par
8944     \};\par
8945     {\cf17 using }IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;\par
8946 \par
8947     {\cf17 class }EventListenerFactory \{\par
8948     {\cf17 public}:\par
8949         {\cf17 virtual} ~EventListenerFactory(); {\cf20 // = default}\par
8950         {\cf17 virtual} IEventListenerPtr create( IConfig {\cf17 const}* config ) {\cf17 const} = 0;\par
8952         {\cf17 virtual} StringRef getName() {\cf17 const} = 0;\par
8954         {\cf17 virtual} std::string getDescription() {\cf17 const} = 0;\par
8955     \};\par
8956 \} {\cf20 // namespace Catch}\par
8957 \par
8958 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED}\par
8959 \par
8960 \par
8961 {\cf21 #ifndef CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
8962 {\cf21 #define CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
8963 \par
8964 {\cf21 #include <string>}\par
8965 \par
8966 {\cf17 namespace }Catch \{\par
8967 \par
8968     {\cf17 struct }TagAlias;\par
8969 \par
8970     {\cf17 class }ITagAliasRegistry \{\par
8971     {\cf17 public}:\par
8972         {\cf17 virtual} ~ITagAliasRegistry(); {\cf20 // = default}\par
8973         {\cf20 // Nullptr if not present}\par
8974         {\cf17 virtual} TagAlias {\cf17 const}* find( std::string {\cf17 const}& alias ) {\cf17 const} = 0;\par
8975         {\cf17 virtual} std::string expandAliases( std::string {\cf17 const}& unexpandedTestSpec ) {\cf17 const} = 0;\par
8976 \par
8977         {\cf17 static} ITagAliasRegistry {\cf17 const}& get();\par
8978     \};\par
8979 \par
8980 \} {\cf20 // end namespace Catch}\par
8981 \par
8982 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
8983 \par
8984 \par
8985 {\cf21 #ifndef CATCH_INTERFACES_TESTCASE_HPP_INCLUDED}\par
8986 {\cf21 #define CATCH_INTERFACES_TESTCASE_HPP_INCLUDED}\par
8987 \par
8988 {\cf21 #include <vector>}\par
8989 \par
8990 {\cf17 namespace }Catch \{\par
8991 \par
8992     {\cf17 struct }TestCaseInfo;\par
8993     {\cf17 class }TestCaseHandle;\par
8994     {\cf17 class }IConfig;\par
8995 \par
8996     {\cf17 class }ITestCaseRegistry \{\par
8997     {\cf17 public}:\par
8998         {\cf17 virtual} ~ITestCaseRegistry(); {\cf20 // = default}\par
8999         {\cf20 // TODO: this exists only for adding filenames to test cases -- let's expose this in a saner way later}\par
9000         {\cf17 virtual} std::vector<TestCaseInfo* > {\cf17 const}& getAllInfos() {\cf17 const} = 0;\par
9001         {\cf17 virtual} std::vector<TestCaseHandle> {\cf17 const}& getAllTests() {\cf17 const} = 0;\par
9002         {\cf17 virtual} std::vector<TestCaseHandle> {\cf17 const}& getAllTestsSorted( IConfig {\cf17 const}& config ) {\cf17 const} = 0;\par
9003     \};\par
9004 \par
9005 \}\par
9006 \par
9007 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_TESTCASE_HPP_INCLUDED}\par
9008 \par
9009 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_ALL_HPP_INCLUDED}\par
9010 \par
9011 \par
9012 {\cf21 #ifndef CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED}\par
9013 {\cf21 #define CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED}\par
9014 \par
9015 \par
9016 {\cf17 namespace }Catch \{\par
9017     {\cf17 namespace }Detail \{\par
9019         {\cf17 struct }CaseInsensitiveLess \{\par
9020             {\cf18 bool} operator()( StringRef lhs,\par
9021                              StringRef rhs ) {\cf17 const};\par
9022         \};\par
9023 \par
9025         {\cf17 struct }CaseInsensitiveEqualTo \{\par
9026             {\cf18 bool} operator()( StringRef lhs,\par
9027                              StringRef rhs ) {\cf17 const};\par
9028         \};\par
9029 \par
9030     \} {\cf20 // namespace Detail}\par
9031 \} {\cf20 // namespace Catch}\par
9032 \par
9033 {\cf21 #endif }{\cf20 // CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED}\par
9034 \par
9035 \par
9036 \par
9045 {\cf21 #ifndef CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED}\par
9046 {\cf21 #define CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED}\par
9047 \par
9048 \par
9049 {\cf21 #if defined(__ANDROID__)}\par
9050 {\cf21 #    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE}\par
9051 {\cf21 #endif}\par
9052 \par
9053 \par
9054 {\cf21 #if defined( CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE ) && \\}\par
9055 {\cf21     !defined( CATCH_CONFIG_NO_ANDROID_LOGWRITE ) &&      \\}\par
9056 {\cf21     !defined( CATCH_CONFIG_ANDROID_LOGWRITE )}\par
9057 {\cf21 #    define CATCH_CONFIG_ANDROID_LOGWRITE}\par
9058 {\cf21 #endif}\par
9059 \par
9060 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED}\par
9061 \par
9062 \par
9063 \par
9072 {\cf21 #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
9073 {\cf21 #define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
9074 \par
9075 \par
9076 {\cf21 #if defined(_MSC_VER)}\par
9077 {\cf21 #  if _MSC_VER >= 1900 }{\cf20 // Visual Studio 2015 or newer}\par
9078 {\cf21 #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
9079 {\cf21 #  endif}\par
9080 {\cf21 #endif}\par
9081 \par
9082 \par
9083 {\cf21 #include <exception>}\par
9084 \par
9085 {\cf21 #if defined(__cpp_lib_uncaught_exceptions) \\}\par
9086 {\cf21     && !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
9087 \par
9088 {\cf21 #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
9089 {\cf21 #endif }{\cf20 // __cpp_lib_uncaught_exceptions}\par
9090 \par
9091 \par
9092 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \\}\par
9093 {\cf21     && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \\}\par
9094 {\cf21     && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
9095 \par
9096 {\cf21 #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
9097 {\cf21 #endif}\par
9098 \par
9099 \par
9100 {\cf21 #endif }{\cf20 // CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
9101 \par
9102 \par
9103 {\cf21 #ifndef CATCH_CONSOLE_COLOUR_HPP_INCLUDED}\par
9104 {\cf21 #define CATCH_CONSOLE_COLOUR_HPP_INCLUDED}\par
9105 \par
9106 \par
9107 {\cf21 #include <iosfwd>}\par
9108 {\cf21 #include <cstdint>}\par
9109 \par
9110 {\cf17 namespace }Catch \{\par
9111 \par
9112     {\cf17 enum class} ColourMode : std::uint8_t;\par
9113     {\cf17 class }IStream;\par
9114 \par
9115     {\cf17 struct }Colour \{\par
9116         {\cf17 enum} Code \{\par
9117             None = 0,\par
9118 \par
9119             White,\par
9120             Red,\par
9121             Green,\par
9122             Blue,\par
9123             Cyan,\par
9124             Yellow,\par
9125             Grey,\par
9126 \par
9127             Bright = 0x10,\par
9128 \par
9129             BrightRed = Bright | Red,\par
9130             BrightGreen = Bright | Green,\par
9131             LightGrey = Bright | Grey,\par
9132             BrightWhite = Bright | White,\par
9133             BrightYellow = Bright | Yellow,\par
9134 \par
9135             {\cf20 // By intention}\par
9136             FileName = LightGrey,\par
9137             Warning = BrightYellow,\par
9138             ResultError = BrightRed,\par
9139             ResultSuccess = BrightGreen,\par
9140             ResultExpectedFailure = Warning,\par
9141 \par
9142             Error = BrightRed,\par
9143             Success = Green,\par
9144             Skip = LightGrey,\par
9145 \par
9146             OriginalExpression = Cyan,\par
9147             ReconstructedExpression = BrightYellow,\par
9148 \par
9149             SecondaryText = LightGrey,\par
9150             Headers = White\par
9151         \};\par
9152     \};\par
9153 \par
9154     {\cf17 class }ColourImpl \{\par
9155     {\cf17 protected}:\par
9157         IStream* m_stream;\par
9158     {\cf17 public}:\par
9159         ColourImpl( IStream* stream ): m_stream( stream ) \{\}\par
9160 \par
9163         {\cf17 class }ColourGuard \{\par
9164             ColourImpl {\cf17 const}* m_colourImpl;\par
9165             Colour::Code m_code;\par
9166             {\cf18 bool} m_engaged = {\cf17 false};\par
9167 \par
9168         {\cf17 public}:\par
9170             ColourGuard( Colour::Code code,\par
9171                          ColourImpl {\cf17 const}* colour );\par
9172 \par
9173             ColourGuard( ColourGuard {\cf17 const}& rhs ) = {\cf17 delete};\par
9174             ColourGuard& operator=( ColourGuard {\cf17 const}& rhs ) = {\cf17 delete};\par
9175 \par
9176             ColourGuard( ColourGuard&& rhs ) {\cf17 noexcept};\par
9177             ColourGuard& operator=( ColourGuard&& rhs ) {\cf17 noexcept};\par
9178 \par
9180             ~ColourGuard();\par
9181 \par
9187             ColourGuard& engage( std::ostream& stream ) &;\par
9193             ColourGuard&& engage( std::ostream& stream ) &&;\par
9194 \par
9195         {\cf17 private}:\par
9197             {\cf17 friend} std::ostream& operator<<( std::ostream& lhs,\par
9198                                              ColourGuard& guard ) \{\par
9199                 guard.engageImpl( lhs );\par
9200                 {\cf19 return} lhs;\par
9201             \}\par
9203             {\cf17 friend} std::ostream& operator<<( std::ostream& lhs,\par
9204                                             ColourGuard&& guard) \{\par
9205                 guard.engageImpl( lhs );\par
9206                 {\cf19 return} lhs;\par
9207             \}\par
9208 \par
9209             {\cf18 void} engageImpl( std::ostream& stream );\par
9210 \par
9211         \};\par
9212 \par
9213         {\cf17 virtual} ~ColourImpl(); {\cf20 // = default}\par
9220         ColourGuard guardColour( Colour::Code colourCode );\par
9221 \par
9222     {\cf17 private}:\par
9223         {\cf17 virtual} {\cf18 void} use( Colour::Code colourCode ) {\cf17 const} = 0;\par
9224     \};\par
9225 \par
9227     Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,\par
9228                                                    IStream* stream );\par
9229 \par
9231     {\cf18 bool} isColourImplAvailable( ColourMode colourSelection );\par
9232 \par
9233 \} {\cf20 // end namespace Catch}\par
9234 \par
9235 {\cf21 #endif }{\cf20 // CATCH_CONSOLE_COLOUR_HPP_INCLUDED}\par
9236 \par
9237 \par
9238 {\cf21 #ifndef CATCH_CONSOLE_WIDTH_HPP_INCLUDED}\par
9239 {\cf21 #define CATCH_CONSOLE_WIDTH_HPP_INCLUDED}\par
9240 \par
9241 {\cf20 // This include must be kept so that user's configured value for CONSOLE_WIDTH}\par
9242 {\cf20 // is used before we attempt to provide a default value}\par
9243 \par
9244 {\cf21 #ifndef CATCH_CONFIG_CONSOLE_WIDTH}\par
9245 {\cf21 #define CATCH_CONFIG_CONSOLE_WIDTH 80}\par
9246 {\cf21 #endif}\par
9247 \par
9248 {\cf21 #endif }{\cf20 // CATCH_CONSOLE_WIDTH_HPP_INCLUDED}\par
9249 \par
9250 \par
9251 {\cf21 #ifndef CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED}\par
9252 {\cf21 #define CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED}\par
9253 \par
9254 \par
9255 {\cf21 #include <cstddef>}\par
9256 {\cf21 #include <initializer_list>}\par
9257 \par
9258 {\cf20 // We want a simple polyfill over `std::empty`, `std::size` and so on}\par
9259 {\cf20 // for C++14 or C++ libraries with incomplete support.}\par
9260 {\cf20 // We also have to handle that MSVC std lib will happily provide these}\par
9261 {\cf20 // under older standards.}\par
9262 {\cf21 #if defined(CATCH_CPP17_OR_GREATER) || defined(_MSC_VER)}\par
9263 \par
9264 {\cf20 // We are already using this header either way, so there shouldn't}\par
9265 {\cf20 // be much additional overhead in including it to get the feature}\par
9266 {\cf20 // test macros}\par
9267 {\cf21 #include <string>}\par
9268 \par
9269 {\cf21 #  if !defined(__cpp_lib_nonmember_container_access)}\par
9270 {\cf21 #      define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS}\par
9271 {\cf21 #  endif}\par
9272 \par
9273 {\cf21 #else}\par
9274 {\cf21 #define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS}\par
9275 {\cf21 #endif}\par
9276 \par
9277 \par
9278 \par
9279 {\cf17 namespace }Catch \{\par
9280 {\cf17 namespace }Detail \{\par
9281 \par
9282 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
9283     {\cf17 template} <{\cf17 typename} Container>\par
9284     {\cf17 constexpr} {\cf17 auto} empty(Container {\cf17 const}& cont) -> {\cf17 decltype}(cont.empty()) \{\par
9285         {\cf19 return} cont.empty();\par
9286     \}\par
9287     {\cf17 template} <{\cf17 typename} T, std::{\cf18 size_t} N>\par
9288     {\cf17 constexpr} {\cf18 bool} empty({\cf17 const} T (&)[N]) {\cf17 noexcept} \{\par
9289         {\cf20 // GCC < 7 does not support the const T(&)[] parameter syntax}\par
9290         {\cf20 // so we have to ignore the length explicitly}\par
9291         (void)N;\par
9292         {\cf19 return} {\cf17 false};\par
9293     \}\par
9294     {\cf17 template} <{\cf17 typename} T>\par
9295     {\cf17 constexpr} {\cf18 bool} empty(std::initializer_list<T> list) {\cf17 noexcept} \{\par
9296         {\cf19 return} list.size() > 0;\par
9297     \}\par
9298 \par
9299 \par
9300     {\cf17 template} <{\cf17 typename} Container>\par
9301     {\cf17 constexpr} {\cf17 auto} size(Container {\cf17 const}& cont) -> {\cf17 decltype}(cont.size()) \{\par
9302         {\cf19 return} cont.size();\par
9303     \}\par
9304     {\cf17 template} <{\cf17 typename} T, std::{\cf18 size_t} N>\par
9305     {\cf17 constexpr} std::size_t size({\cf17 const} T(&)[N]) {\cf17 noexcept} \{\par
9306         {\cf19 return} N;\par
9307     \}\par
9308 {\cf21 #endif }{\cf20 // CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS}\par
9309 \par
9310 \} {\cf20 // end namespace Detail}\par
9311 \} {\cf20 // end namespace Catch}\par
9312 \par
9313 \par
9314 \par
9315 {\cf21 #endif }{\cf20 // CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED}\par
9316 \par
9317 \par
9318 {\cf21 #ifndef CATCH_DEBUG_CONSOLE_HPP_INCLUDED}\par
9319 {\cf21 #define CATCH_DEBUG_CONSOLE_HPP_INCLUDED}\par
9320 \par
9321 {\cf21 #include <string>}\par
9322 \par
9323 {\cf17 namespace }Catch \{\par
9324     {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text );\par
9325 \}\par
9326 \par
9327 {\cf21 #endif }{\cf20 // CATCH_DEBUG_CONSOLE_HPP_INCLUDED}\par
9328 \par
9329 \par
9330 {\cf21 #ifndef CATCH_DEBUGGER_HPP_INCLUDED}\par
9331 {\cf21 #define CATCH_DEBUGGER_HPP_INCLUDED}\par
9332 \par
9333 \par
9334 {\cf17 namespace }Catch \{\par
9335     {\cf18 bool} isDebuggerActive();\par
9336 \}\par
9337 \par
9338 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
9339 \par
9340 {\cf21     #if defined(__i386__) || defined(__x86_64__)}\par
9341 {\cf21         #define CATCH_TRAP() __asm__("int $3\\n" : : ) }{\cf20 /* NOLINT */}{\cf21 }\par
9342 {\cf21     #elif defined(__aarch64__)}\par
9343 {\cf21         #define CATCH_TRAP() __asm__(".inst 0xd43e0000")}\par
9344 {\cf21     #elif defined(__POWERPC__)}\par
9345 {\cf21         #define CATCH_TRAP() __asm__("li r0, 20\\nsc\\nnop\\nli r0, 37\\nli r4, 2\\nsc\\nnop\\n" \\}\par
9346 {\cf21         : : : "memory","r0","r3","r4" ) }{\cf20 /* NOLINT */}{\cf21 }\par
9347 {\cf21     #endif}\par
9348 \par
9349 {\cf21 #elif defined(CATCH_PLATFORM_IPHONE)}\par
9350 \par
9351     {\cf20 // use inline assembler}\par
9352 {\cf21     #if defined(__i386__) || defined(__x86_64__)}\par
9353 {\cf21         #define CATCH_TRAP()  __asm__("int $3")}\par
9354 {\cf21     #elif defined(__aarch64__)}\par
9355 {\cf21         #define CATCH_TRAP()  __asm__(".inst 0xd4200000")}\par
9356 {\cf21     #elif defined(__arm__) && !defined(__thumb__)}\par
9357 {\cf21         #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")}\par
9358 {\cf21     #elif defined(__arm__) &&  defined(__thumb__)}\par
9359 {\cf21         #define CATCH_TRAP()  __asm__(".inst 0xde01")}\par
9360 {\cf21     #endif}\par
9361 \par
9362 {\cf21 #elif defined(CATCH_PLATFORM_LINUX)}\par
9363     {\cf20 // If we can use inline assembler, do it because this allows us to break}\par
9364     {\cf20 // directly at the location of the failing check instead of breaking inside}\par
9365     {\cf20 // raise() called from it, i.e. one stack frame below.}\par
9366 {\cf21     #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))}\par
9367 {\cf21         #define CATCH_TRAP() asm volatile ("int $3") }{\cf20 /* NOLINT */}{\cf21 }\par
9368 {\cf21     #else }{\cf20 // Fall back to the generic way.}\par
9369 {\cf21         #include <signal.h>}\par
9370 \par
9371 {\cf21         #define CATCH_TRAP() raise(SIGTRAP)}\par
9372 {\cf21     #endif}\par
9373 {\cf21 #elif defined(_MSC_VER)}\par
9374 {\cf21     #define CATCH_TRAP() __debugbreak()}\par
9375 {\cf21 #elif defined(__MINGW32__)}\par
9376     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 void} __stdcall DebugBreak();\par
9377 {\cf21     #define CATCH_TRAP() DebugBreak()}\par
9378 {\cf21 #endif}\par
9379 \par
9380 {\cf21 #ifndef CATCH_BREAK_INTO_DEBUGGER}\par
9381 {\cf21     #ifdef CATCH_TRAP}\par
9382 {\cf21         #define CATCH_BREAK_INTO_DEBUGGER() []\{ if( Catch::isDebuggerActive() ) \{ CATCH_TRAP(); \} \}()}\par
9383 {\cf21     #else}\par
9384 {\cf21         #define CATCH_BREAK_INTO_DEBUGGER() []\{\}()}\par
9385 {\cf21     #endif}\par
9386 {\cf21 #endif}\par
9387 \par
9388 {\cf21 #endif }{\cf20 // CATCH_DEBUGGER_HPP_INCLUDED}\par
9389 \par
9390 \par
9391 {\cf21 #ifndef CATCH_ENFORCE_HPP_INCLUDED}\par
9392 {\cf21 #define CATCH_ENFORCE_HPP_INCLUDED}\par
9393 \par
9394 \par
9395 {\cf21 #include <exception>}\par
9396 \par
9397 {\cf17 namespace }Catch \{\par
9398 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
9399     {\cf17 template} <{\cf17 typename} Ex>\par
9400     [[noreturn]]\par
9401     {\cf18 void} throw_exception(Ex {\cf17 const}& e) \{\par
9402         {\cf19 throw} e;\par
9403     \}\par
9404 {\cf21 #else }{\cf20 // ^^ Exceptions are enabled //  Exceptions are disabled vv}\par
9405     [[noreturn]]\par
9406     {\cf18 void} throw_exception(std::exception {\cf17 const}& e);\par
9407 {\cf21 #endif}\par
9408 \par
9409     [[noreturn]]\par
9410     {\cf18 void} throw_logic_error(std::string {\cf17 const}& msg);\par
9411     [[noreturn]]\par
9412     {\cf18 void} throw_domain_error(std::string {\cf17 const}& msg);\par
9413     [[noreturn]]\par
9414     {\cf18 void} throw_runtime_error(std::string {\cf17 const}& msg);\par
9415 \par
9416 \} {\cf20 // namespace Catch;}\par
9417 \par
9418 {\cf21 #define CATCH_MAKE_MSG(...) \\}\par
9419 {\cf21     (Catch::ReusableStringStream() << __VA_ARGS__).str()}\par
9420 \par
9421 {\cf21 #define CATCH_INTERNAL_ERROR(...) \\}\par
9422 {\cf21     Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))}\par
9423 \par
9424 {\cf21 #define CATCH_ERROR(...) \\}\par
9425 {\cf21     Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))}\par
9426 \par
9427 {\cf21 #define CATCH_RUNTIME_ERROR(...) \\}\par
9428 {\cf21     Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))}\par
9429 \par
9430 {\cf21 #define CATCH_ENFORCE( condition, ... ) \\}\par
9431 {\cf21     do\{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); \} while(false)}\par
9432 \par
9433 \par
9434 {\cf21 #endif }{\cf20 // CATCH_ENFORCE_HPP_INCLUDED}\par
9435 \par
9436 \par
9437 {\cf21 #ifndef CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
9438 {\cf21 #define CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
9439 \par
9440 \par
9441 {\cf21 #include <vector>}\par
9442 \par
9443 {\cf17 namespace }Catch \{\par
9444 \par
9445     {\cf17 namespace }Detail \{\par
9446 \par
9447         Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values );\par
9448 \par
9449         {\cf17 class }EnumValuesRegistry : {\cf17 public} IMutableEnumValuesRegistry \{\par
9450 \par
9451             std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;\par
9452 \par
9453             EnumInfo {\cf17 const}& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values) {\cf17 override};\par
9454         \};\par
9455 \par
9456         std::vector<StringRef> parseEnums( StringRef enums );\par
9457 \par
9458     \} {\cf20 // Detail}\par
9459 \par
9460 \} {\cf20 // Catch}\par
9461 \par
9462 {\cf21 #endif }{\cf20 // CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
9463 \par
9464 \par
9465 {\cf21 #ifndef CATCH_ERRNO_GUARD_HPP_INCLUDED}\par
9466 {\cf21 #define CATCH_ERRNO_GUARD_HPP_INCLUDED}\par
9467 \par
9468 {\cf17 namespace }Catch \{\par
9469 \par
9472     {\cf17 class }ErrnoGuard \{\par
9473     {\cf17 public}:\par
9474         {\cf20 // Keep these outlined to avoid dragging in macros from <cerrno>}\par
9475 \par
9476         ErrnoGuard();\par
9477         ~ErrnoGuard();\par
9478     {\cf17 private}:\par
9479         {\cf18 int} m_oldErrno;\par
9480     \};\par
9481 \par
9482 \}\par
9483 \par
9484 {\cf21 #endif }{\cf20 // CATCH_ERRNO_GUARD_HPP_INCLUDED}\par
9485 \par
9486 \par
9487 {\cf21 #ifndef CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED}\par
9488 {\cf21 #define CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED}\par
9489 \par
9490 \par
9491 {\cf21 #include <vector>}\par
9492 {\cf21 #include <string>}\par
9493 \par
9494 {\cf17 namespace }Catch \{\par
9495 \par
9496     {\cf17 class }ExceptionTranslatorRegistry : {\cf17 public} IExceptionTranslatorRegistry \{\par
9497     {\cf17 public}:\par
9498         ~ExceptionTranslatorRegistry() {\cf17 override};\par
9499         {\cf18 void} registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator );\par
9500         std::string translateActiveException() {\cf17 const override};\par
9501 \par
9502     {\cf17 private}:\par
9503         ExceptionTranslators m_translators;\par
9504     \};\par
9505 \}\par
9506 \par
9507 {\cf21 #endif }{\cf20 // CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED}\par
9508 \par
9509 \par
9510 {\cf21 #ifndef CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED}\par
9511 {\cf21 #define CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED}\par
9512 \par
9513 {\cf21 #include <cassert>}\par
9514 \par
9515 {\cf17 namespace }Catch \{\par
9516 \par
9527     {\cf17 class }FatalConditionHandler \{\par
9528         {\cf18 bool} m_started = {\cf17 false};\par
9529 \par
9530         {\cf20 // Install/disengage implementation for specific platform.}\par
9531         {\cf20 // Should be if-defed to work on current platform, can assume}\par
9532         {\cf20 // engage-disengage 1:1 pairing.}\par
9533         {\cf18 void} engage_platform();\par
9534         {\cf18 void} disengage_platform() noexcept;\par
9535     public:\par
9536         {\cf20 // Should also have platform-specific implementations as needed}\par
9537         FatalConditionHandler();\par
9538         ~FatalConditionHandler();\par
9539 \par
9540         {\cf18 void} engage() \{\par
9541             assert(!m_started && {\cf22 "Handler cannot be installed twice."});\par
9542             m_started = {\cf17 true};\par
9543             engage_platform();\par
9544         \}\par
9545 \par
9546         {\cf18 void} disengage() noexcept \{\par
9547             assert(m_started && {\cf22 "Handler cannot be uninstalled without being installed first"});\par
9548             m_started = {\cf17 false};\par
9549             disengage_platform();\par
9550         \}\par
9551     \};\par
9552 \par
9554     {\cf17 class }FatalConditionHandlerGuard \{\par
9555         FatalConditionHandler* m_handler;\par
9556     {\cf17 public}:\par
9557         FatalConditionHandlerGuard(FatalConditionHandler* handler):\par
9558             m_handler(handler) \{\par
9559             m_handler->engage();\par
9560         \}\par
9561         ~FatalConditionHandlerGuard() \{\par
9562             m_handler->disengage();\par
9563         \}\par
9564     \};\par
9565 \par
9566 \} {\cf20 // end namespace Catch}\par
9567 \par
9568 {\cf21 #endif }{\cf20 // CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED}\par
9569 \par
9570 \par
9571 {\cf21 #ifndef CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
9572 {\cf21 #define CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
9573 \par
9574 \par
9575 {\cf21 #include <cassert>}\par
9576 {\cf21 #include <cmath>}\par
9577 {\cf21 #include <cstdint>}\par
9578 {\cf21 #include <utility>}\par
9579 {\cf21 #include <limits>}\par
9580 \par
9581 {\cf17 namespace }Catch \{\par
9582     {\cf17 namespace }Detail \{\par
9583 \par
9584         uint32_t convertToBits({\cf18 float} f);\par
9585         uint64_t convertToBits({\cf18 double} d);\par
9586 \par
9587         {\cf20 // Used when we know we want == comparison of two doubles}\par
9588         {\cf20 // to centralize warning suppression}\par
9589         {\cf18 bool} directCompare( {\cf18 float} lhs, {\cf18 float} rhs );\par
9590         {\cf18 bool} directCompare( {\cf18 double} lhs, {\cf18 double} rhs );\par
9591 \par
9592     \} {\cf20 // end namespace Detail}\par
9593 \par
9594 \par
9595 \par
9596 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
9597 {\cf21 #    pragma GCC diagnostic push}\par
9598     {\cf20 // We do a bunch of direct compensations of floating point numbers,}\par
9599     {\cf20 // because we know what we are doing and actually do want the direct}\par
9600     {\cf20 // comparison behaviour.}\par
9601 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
9602 {\cf21 #endif}\par
9603 \par
9621     {\cf17 template} <{\cf17 typename} FP>\par
9622     uint64_t ulpDistance( FP lhs, FP rhs ) \{\par
9623         assert( std::numeric_limits<FP>::is_iec559 &&\par
9624             {\cf22 "ulpDistance assumes IEEE-754 format for floating point types"} );\par
9625         assert( !Catch::isnan( lhs ) &&\par
9626                 {\cf22 "Distance between NaN and number is not meaningful"} );\par
9627         assert( !Catch::isnan( rhs ) &&\par
9628                 {\cf22 "Distance between NaN and number is not meaningful"} );\par
9629 \par
9630         {\cf20 // We want X == Y to imply 0 ULP distance even if X and Y aren't}\par
9631         {\cf20 // bit-equal (-0 and 0), or X - Y != 0 (same sign infinities).}\par
9632         {\cf19 if} ( lhs == rhs ) \{ {\cf19 return} 0; \}\par
9633 \par
9634         {\cf20 // We need a properly typed positive zero for type inference.}\par
9635         {\cf17 static} {\cf17 constexpr} FP positive_zero\{\};\par
9636 \par
9637         {\cf20 // We want to ensure that +/- 0 is always represented as positive zero}\par
9638         {\cf19 if} ( lhs == positive_zero ) \{ lhs = positive_zero; \}\par
9639         {\cf19 if} ( rhs == positive_zero ) \{ rhs = positive_zero; \}\par
9640 \par
9641         {\cf20 // If arguments have different signs, we can handle them by summing}\par
9642         {\cf20 // how far are they from 0 each.}\par
9643         {\cf19 if} ( std::signbit( lhs ) != std::signbit( rhs ) ) \{\par
9644             {\cf19 return} ulpDistance( std::abs( lhs ), positive_zero ) +\par
9645                    ulpDistance( std::abs( rhs ), positive_zero );\par
9646         \}\par
9647 \par
9648         {\cf20 // When both lhs and rhs are of the same sign, we can just}\par
9649         {\cf20 // read the numbers bitwise as integers, and then subtract them}\par
9650         {\cf20 // (assuming IEEE).}\par
9651         uint64_t lc = Detail::convertToBits( lhs );\par
9652         uint64_t rc = Detail::convertToBits( rhs );\par
9653 \par
9654         {\cf20 // The ulp distance between two numbers is symmetric, so to avoid}\par
9655         {\cf20 // dealing with overflows we want the bigger converted number on the lhs}\par
9656         {\cf19 if} ( lc < rc ) \{\par
9657             std::swap( lc, rc );\par
9658         \}\par
9659 \par
9660         {\cf19 return} lc - rc;\par
9661     \}\par
9662 \par
9663 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
9664 {\cf21 #    pragma GCC diagnostic pop}\par
9665 {\cf21 #endif}\par
9666 \par
9667 \par
9668 \} {\cf20 // end namespace Catch}\par
9669 \par
9670 {\cf21 #endif }{\cf20 // CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
9671 \par
9672 \par
9673 {\cf21 #ifndef CATCH_GETENV_HPP_INCLUDED}\par
9674 {\cf21 #define CATCH_GETENV_HPP_INCLUDED}\par
9675 \par
9676 {\cf17 namespace }Catch \{\par
9677 {\cf17 namespace }Detail \{\par
9678 \par
9680     {\cf18 char} {\cf17 const}* getEnv({\cf18 char} {\cf17 const}* varName);\par
9681 \par
9682 \}\par
9683 \}\par
9684 \par
9685 {\cf21 #endif }{\cf20 // CATCH_GETENV_HPP_INCLUDED}\par
9686 \par
9687 \par
9688 {\cf21 #ifndef CATCH_IS_PERMUTATION_HPP_INCLUDED}\par
9689 {\cf21 #define CATCH_IS_PERMUTATION_HPP_INCLUDED}\par
9690 \par
9691 {\cf21 #include <algorithm>}\par
9692 {\cf21 #include <iterator>}\par
9693 \par
9694 {\cf17 namespace }Catch \{\par
9695     {\cf17 namespace }Detail \{\par
9696 \par
9697         {\cf17 template} <{\cf17 typename} ForwardIter,\par
9698                   {\cf17 typename} Sentinel,\par
9699                   {\cf17 typename} T,\par
9700                   {\cf17 typename} Comparator>\par
9701         ForwardIter find_sentinel( ForwardIter start,\par
9702                                    Sentinel sentinel,\par
9703                                    T {\cf17 const}& value,\par
9704                                    Comparator cmp ) \{\par
9705             {\cf19 while} ( start != sentinel ) \{\par
9706                 {\cf19 if} ( cmp( *start, value ) ) \{ {\cf19 break}; \}\par
9707                 ++start;\par
9708             \}\par
9709             {\cf19 return} start;\par
9710         \}\par
9711 \par
9712         {\cf17 template} <{\cf17 typename} ForwardIter,\par
9713                   {\cf17 typename} Sentinel,\par
9714                   {\cf17 typename} T,\par
9715                   {\cf17 typename} Comparator>\par
9716         std::ptrdiff_t count_sentinel( ForwardIter start,\par
9717                                        Sentinel sentinel,\par
9718                                        T {\cf17 const}& value,\par
9719                                        Comparator cmp ) \{\par
9720             std::ptrdiff_t count = 0;\par
9721             {\cf19 while} ( start != sentinel ) \{\par
9722                 {\cf19 if} ( cmp( *start, value ) ) \{ ++count; \}\par
9723                 ++start;\par
9724             \}\par
9725             {\cf19 return} count;\par
9726         \}\par
9727 \par
9728         {\cf17 template} <{\cf17 typename} ForwardIter, {\cf17 typename} Sentinel>\par
9729         std::enable_if_t<!std::is_same<ForwardIter, Sentinel>::value,\par
9730                          std::ptrdiff_t>\par
9731         sentinel_distance( ForwardIter iter, {\cf17 const} Sentinel sentinel ) \{\par
9732             std::ptrdiff_t dist = 0;\par
9733             {\cf19 while} ( iter != sentinel ) \{\par
9734                 ++iter;\par
9735                 ++dist;\par
9736             \}\par
9737             {\cf19 return} dist;\par
9738         \}\par
9739 \par
9740         {\cf17 template} <{\cf17 typename} ForwardIter>\par
9741         std::ptrdiff_t sentinel_distance( ForwardIter first,\par
9742                                           ForwardIter last ) \{\par
9743             {\cf19 return} std::distance( first, last );\par
9744         \}\par
9745 \par
9746         {\cf17 template} <{\cf17 typename} ForwardIter1,\par
9747                   {\cf17 typename} Sentinel1,\par
9748                   {\cf17 typename} ForwardIter2,\par
9749                   {\cf17 typename} Sentinel2,\par
9750                   {\cf17 typename} Comparator>\par
9751         {\cf18 bool} check_element_counts( ForwardIter1 first_1,\par
9752                                    {\cf17 const} Sentinel1 end_1,\par
9753                                    ForwardIter2 first_2,\par
9754                                    {\cf17 const} Sentinel2 end_2,\par
9755                                    Comparator cmp ) \{\par
9756             {\cf17 auto} cursor = first_1;\par
9757             {\cf19 while} ( cursor != end_1 ) \{\par
9758                 {\cf19 if} ( find_sentinel( first_1, cursor, *cursor, cmp ) ==\par
9759                      cursor ) \{\par
9760                     {\cf20 // we haven't checked this element yet}\par
9761                     {\cf17 const} {\cf17 auto} count_in_range_2 =\par
9762                         count_sentinel( first_2, end_2, *cursor, cmp );\par
9763                     {\cf20 // Not a single instance in 2nd range, so it cannot be a}\par
9764                     {\cf20 // permutation of 1st range}\par
9765                     {\cf19 if} ( count_in_range_2 == 0 ) \{ {\cf19 return} {\cf17 false}; \}\par
9766 \par
9767                     {\cf17 const} {\cf17 auto} count_in_range_1 =\par
9768                         count_sentinel( cursor, end_1, *cursor, cmp );\par
9769                     {\cf19 if} ( count_in_range_1 != count_in_range_2 ) \{\par
9770                         {\cf19 return} {\cf17 false};\par
9771                     \}\par
9772                 \}\par
9773 \par
9774                 ++cursor;\par
9775             \}\par
9776 \par
9777             {\cf19 return} {\cf17 true};\par
9778         \}\par
9779 \par
9780         {\cf17 template} <{\cf17 typename} ForwardIter1,\par
9781                   {\cf17 typename} Sentinel1,\par
9782                   {\cf17 typename} ForwardIter2,\par
9783                   {\cf17 typename} Sentinel2,\par
9784                   {\cf17 typename} Comparator>\par
9785         {\cf18 bool} is_permutation( ForwardIter1 first_1,\par
9786                              {\cf17 const} Sentinel1 end_1,\par
9787                              ForwardIter2 first_2,\par
9788                              {\cf17 const} Sentinel2 end_2,\par
9789                              Comparator cmp ) \{\par
9790             {\cf20 // TODO: no optimization for stronger iterators, because we would also have to constrain on sentinel vs not sentinel types}\par
9791             {\cf20 // TODO: Comparator has to be "both sides", e.g. a == b => b == a}\par
9792             {\cf20 // This skips shared prefix of the two ranges}\par
9793             {\cf19 while} (first_1 != end_1 && first_2 != end_2 && cmp(*first_1, *first_2)) \{\par
9794                 ++first_1;\par
9795                 ++first_2;\par
9796             \}\par
9797 \par
9798             {\cf20 // We need to handle case where at least one of the ranges has no more elements}\par
9799             {\cf19 if} (first_1 == end_1 || first_2 == end_2) \{\par
9800                 {\cf19 return} first_1 == end_1 && first_2 == end_2;\par
9801             \}\par
9802 \par
9803             {\cf20 // pair counting is n**2, so we pay linear walk to compare the sizes first}\par
9804             {\cf17 auto} dist_1 = sentinel_distance( first_1, end_1 );\par
9805             {\cf17 auto} dist_2 = sentinel_distance( first_2, end_2 );\par
9806 \par
9807             {\cf19 if} (dist_1 != dist_2) \{ {\cf19 return} {\cf17 false}; \}\par
9808 \par
9809             {\cf20 // Since we do not try to handle stronger iterators pair (e.g.}\par
9810             {\cf20 // bidir) optimally, the only thing left to do is to check counts in}\par
9811             {\cf20 // the remaining ranges.}\par
9812             {\cf19 return} check_element_counts( first_1, end_1, first_2, end_2, cmp );\par
9813         \}\par
9814 \par
9815     \} {\cf20 // namespace Detail}\par
9816 \} {\cf20 // namespace Catch}\par
9817 \par
9818 {\cf21 #endif }{\cf20 // CATCH_IS_PERMUTATION_HPP_INCLUDED}\par
9819 \par
9820 \par
9821 {\cf21 #ifndef CATCH_ISTREAM_HPP_INCLUDED}\par
9822 {\cf21 #define CATCH_ISTREAM_HPP_INCLUDED}\par
9823 \par
9824 \par
9825 {\cf21 #include <iosfwd>}\par
9826 {\cf21 #include <cstddef>}\par
9827 {\cf21 #include <ostream>}\par
9828 {\cf21 #include <string>}\par
9829 \par
9830 {\cf17 namespace }Catch \{\par
9831 \par
9832     {\cf17 class }IStream \{\par
9833     {\cf17 public}:\par
9834         {\cf17 virtual} ~IStream(); {\cf20 // = default}\par
9835         {\cf17 virtual} std::ostream& stream() = 0;\par
9847         {\cf17 virtual} {\cf18 bool} isConsole(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
9848     \};\par
9849 \par
9861     {\cf17 auto} makeStream( std::string {\cf17 const}& filename ) -> Detail::unique_ptr<IStream>;\par
9862 \par
9863 \}\par
9864 \par
9865 {\cf21 #endif }{\cf20 // CATCH_STREAM_HPP_INCLUDED}\par
9866 \par
9867 \par
9868 {\cf21 #ifndef CATCH_JSONWRITER_HPP_INCLUDED}\par
9869 {\cf21 #define CATCH_JSONWRITER_HPP_INCLUDED}\par
9870 \par
9871 \par
9872 {\cf21 #include <cstdint>}\par
9873 {\cf21 #include <sstream>}\par
9874 \par
9875 {\cf17 namespace }Catch \{\par
9876     {\cf17 class }JsonObjectWriter;\par
9877     {\cf17 class }JsonArrayWriter;\par
9878 \par
9879     {\cf17 struct }JsonUtils \{\par
9880         {\cf17 static} {\cf18 void} indent( std::ostream& os, std::uint64_t level );\par
9881         {\cf17 static} {\cf18 void} appendCommaNewline( std::ostream& os,\par
9882                                         {\cf18 bool}& should_comma,\par
9883                                         std::uint64_t level );\par
9884     \};\par
9885 \par
9886     {\cf17 class }JsonValueWriter \{\par
9887     {\cf17 public}:\par
9888         JsonValueWriter( std::ostream& os );\par
9889         JsonValueWriter( std::ostream& os, std::uint64_t indent_level );\par
9890 \par
9891         JsonObjectWriter writeObject() &&;\par
9892         JsonArrayWriter writeArray() &&;\par
9893 \par
9894         {\cf17 template} <{\cf17 typename} T>\par
9895         {\cf18 void} write( T {\cf17 const}& value ) && \{\par
9896             writeImpl( value, !std::is_arithmetic<T>::value );\par
9897         \}\par
9898         {\cf18 void} write( StringRef value ) &&;\par
9899         {\cf18 void} write( {\cf18 bool} value ) &&;\par
9900 \par
9901     {\cf17 private}:\par
9902         {\cf18 void} writeImpl( StringRef value, {\cf18 bool} quote );\par
9903 \par
9904         {\cf20 // Without this SFINAE, this overload is a better match}\par
9905         {\cf20 // for `std::string`, `char const*`, `char const[N]` args.}\par
9906         {\cf20 // While it would still work, it would cause code bloat}\par
9907         {\cf20 // and multiple iteration over the strings}\par
9908         {\cf17 template} <{\cf17 typename} T,\par
9909                   {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
9910                       !std::is_convertible<T, StringRef>::value>>\par
9911         {\cf18 void} writeImpl( T {\cf17 const}& value, {\cf18 bool} quote_value ) \{\par
9912             m_sstream << value;\par
9913             writeImpl( m_sstream.str(), quote_value );\par
9914         \}\par
9915 \par
9916         std::ostream& m_os;\par
9917         std::stringstream m_sstream;\par
9918         std::uint64_t m_indent_level;\par
9919     \};\par
9920 \par
9921     {\cf17 class }JsonObjectWriter \{\par
9922     {\cf17 public}:\par
9923         JsonObjectWriter( std::ostream& os );\par
9924         JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );\par
9925 \par
9926         JsonObjectWriter( JsonObjectWriter&& source ) {\cf17 noexcept};\par
9927         JsonObjectWriter& operator=( JsonObjectWriter&& source ) = {\cf17 delete};\par
9928 \par
9929         ~JsonObjectWriter();\par
9930 \par
9931         JsonValueWriter write( StringRef key );\par
9932 \par
9933     {\cf17 private}:\par
9934         std::ostream& m_os;\par
9935         std::uint64_t m_indent_level;\par
9936         {\cf18 bool} m_should_comma = {\cf17 false};\par
9937         {\cf18 bool} m_active = {\cf17 true};\par
9938     \};\par
9939 \par
9940     {\cf17 class }JsonArrayWriter \{\par
9941     {\cf17 public}:\par
9942         JsonArrayWriter( std::ostream& os );\par
9943         JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );\par
9944 \par
9945         JsonArrayWriter( JsonArrayWriter&& source ) {\cf17 noexcept};\par
9946         JsonArrayWriter& operator=( JsonArrayWriter&& source ) = {\cf17 delete};\par
9947 \par
9948         ~JsonArrayWriter();\par
9949 \par
9950         JsonObjectWriter writeObject();\par
9951         JsonArrayWriter writeArray();\par
9952 \par
9953         {\cf17 template} <{\cf17 typename} T>\par
9954         JsonArrayWriter& write( T {\cf17 const}& value ) \{\par
9955             {\cf19 return} writeImpl( value );\par
9956         \}\par
9957 \par
9958         JsonArrayWriter& write( {\cf18 bool} value );\par
9959 \par
9960     {\cf17 private}:\par
9961         {\cf17 template} <{\cf17 typename} T>\par
9962         JsonArrayWriter& writeImpl( T {\cf17 const}& value ) \{\par
9963             JsonUtils::appendCommaNewline(\par
9964                 m_os, m_should_comma, m_indent_level + 1 );\par
9965             JsonValueWriter\{ m_os \}.write( value );\par
9966 \par
9967             {\cf19 return} *{\cf17 this};\par
9968         \}\par
9969 \par
9970         std::ostream& m_os;\par
9971         std::uint64_t m_indent_level;\par
9972         {\cf18 bool} m_should_comma = {\cf17 false};\par
9973         {\cf18 bool} m_active = {\cf17 true};\par
9974     \};\par
9975 \par
9976 \} {\cf20 // namespace Catch}\par
9977 \par
9978 {\cf21 #endif }{\cf20 // CATCH_JSONWRITER_HPP_INCLUDED}\par
9979 \par
9980 \par
9981 {\cf21 #ifndef CATCH_LEAK_DETECTOR_HPP_INCLUDED}\par
9982 {\cf21 #define CATCH_LEAK_DETECTOR_HPP_INCLUDED}\par
9983 \par
9984 {\cf17 namespace }Catch \{\par
9985 \par
9986     {\cf17 struct }LeakDetector \{\par
9987         LeakDetector();\par
9988         ~LeakDetector();\par
9989     \};\par
9990 \par
9991 \}\par
9992 {\cf21 #endif }{\cf20 // CATCH_LEAK_DETECTOR_HPP_INCLUDED}\par
9993 \par
9994 \par
9995 {\cf21 #ifndef CATCH_LIST_HPP_INCLUDED}\par
9996 {\cf21 #define CATCH_LIST_HPP_INCLUDED}\par
9997 \par
9998 \par
9999 {\cf21 #include <set>}\par
10000 {\cf21 #include <string>}\par
10001 \par
10002 \par
10003 {\cf17 namespace }Catch \{\par
10004 \par
10005     {\cf17 class }IEventListener;\par
10006     {\cf17 class }Config;\par
10007 \par
10008 \par
10009     {\cf17 struct }ReporterDescription \{\par
10010         std::string name, description;\par
10011     \};\par
10012     {\cf17 struct }ListenerDescription \{\par
10013         StringRef name;\par
10014         std::string description;\par
10015     \};\par
10016 \par
10017     {\cf17 struct }TagInfo \{\par
10018         {\cf18 void} add(StringRef spelling);\par
10019         std::string all() {\cf17 const};\par
10020 \par
10021         std::set<StringRef> spellings;\par
10022         std::size_t count = 0;\par
10023     \};\par
10024 \par
10025     {\cf18 bool} list( IEventListener& reporter, Config {\cf17 const}& config );\par
10026 \par
10027 \} {\cf20 // end namespace Catch}\par
10028 \par
10029 {\cf21 #endif }{\cf20 // CATCH_LIST_HPP_INCLUDED}\par
10030 \par
10031 \par
10032 {\cf21 #ifndef CATCH_OUTPUT_REDIRECT_HPP_INCLUDED}\par
10033 {\cf21 #define CATCH_OUTPUT_REDIRECT_HPP_INCLUDED}\par
10034 \par
10035 \par
10036 {\cf21 #include <cstdio>}\par
10037 {\cf21 #include <iosfwd>}\par
10038 {\cf21 #include <string>}\par
10039 \par
10040 {\cf17 namespace }Catch \{\par
10041 \par
10042     {\cf17 class }RedirectedStream \{\par
10043         std::ostream& m_originalStream;\par
10044         std::ostream& m_redirectionStream;\par
10045         std::streambuf* m_prevBuf;\par
10046 \par
10047     {\cf17 public}:\par
10048         RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );\par
10049         ~RedirectedStream();\par
10050     \};\par
10051 \par
10052     {\cf17 class }RedirectedStdOut \{\par
10053         ReusableStringStream m_rss;\par
10054         RedirectedStream m_cout;\par
10055     {\cf17 public}:\par
10056         RedirectedStdOut();\par
10057         {\cf17 auto} str() const -> std::{\cf18 string};\par
10058     \};\par
10059 \par
10060     {\cf20 // StdErr has two constituent streams in C++, std::cerr and std::clog}\par
10061     {\cf20 // This means that we need to redirect 2 streams into 1 to keep proper}\par
10062     {\cf20 // order of writes}\par
10063     class RedirectedStdErr \{\par
10064         ReusableStringStream m_rss;\par
10065         RedirectedStream m_cerr;\par
10066         RedirectedStream m_clog;\par
10067     {\cf17 public}:\par
10068         RedirectedStdErr();\par
10069         {\cf17 auto} str() const -> std::{\cf18 string};\par
10070     \};\par
10071 \par
10072     class RedirectedStreams \{\par
10073     {\cf17 public}:\par
10074         RedirectedStreams(RedirectedStreams {\cf17 const}&) = {\cf17 delete};\par
10075         RedirectedStreams& operator=(RedirectedStreams {\cf17 const}&) = {\cf17 delete};\par
10076         RedirectedStreams(RedirectedStreams&&) = {\cf17 delete};\par
10077         RedirectedStreams& operator=(RedirectedStreams&&) = {\cf17 delete};\par
10078 \par
10079         RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);\par
10080         ~RedirectedStreams();\par
10081     {\cf17 private}:\par
10082         std::string& m_redirectedCout;\par
10083         std::string& m_redirectedCerr;\par
10084         RedirectedStdOut m_redirectedStdOut;\par
10085         RedirectedStdErr m_redirectedStdErr;\par
10086     \};\par
10087 \par
10088 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
10089 \par
10090     {\cf20 // Windows's implementation of std::tmpfile is terrible (it tries}\par
10091     {\cf20 // to create a file inside system folder, thus requiring elevated}\par
10092     {\cf20 // privileges for the binary), so we have to use tmpnam(_s) and}\par
10093     {\cf20 // create the file ourselves there.}\par
10094     {\cf17 class }TempFile \{\par
10095     {\cf17 public}:\par
10096         TempFile(TempFile {\cf17 const}&) = {\cf17 delete};\par
10097         TempFile& operator=(TempFile {\cf17 const}&) = {\cf17 delete};\par
10098         TempFile(TempFile&&) = {\cf17 delete};\par
10099         TempFile& operator=(TempFile&&) = {\cf17 delete};\par
10100 \par
10101         TempFile();\par
10102         ~TempFile();\par
10103 \par
10104         std::FILE* getFile();\par
10105         std::string getContents();\par
10106 \par
10107     {\cf17 private}:\par
10108         std::FILE* m_file = {\cf17 nullptr};\par
10109 {\cf21     #if defined(_MSC_VER)}\par
10110         {\cf18 char} m_buffer[L_tmpnam] = \{ 0 \};\par
10111 {\cf21     #endif}\par
10112     \};\par
10113 \par
10114 \par
10115     {\cf17 class }OutputRedirect \{\par
10116     {\cf17 public}:\par
10117         OutputRedirect(OutputRedirect {\cf17 const}&) = {\cf17 delete};\par
10118         OutputRedirect& operator=(OutputRedirect {\cf17 const}&) = {\cf17 delete};\par
10119         OutputRedirect(OutputRedirect&&) = {\cf17 delete};\par
10120         OutputRedirect& operator=(OutputRedirect&&) = {\cf17 delete};\par
10121 \par
10122 \par
10123         OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);\par
10124         ~OutputRedirect();\par
10125 \par
10126     {\cf17 private}:\par
10127         {\cf18 int} m_originalStdout = -1;\par
10128         {\cf18 int} m_originalStderr = -1;\par
10129         TempFile m_stdoutFile;\par
10130         TempFile m_stderrFile;\par
10131         std::string& m_stdoutDest;\par
10132         std::string& m_stderrDest;\par
10133     \};\par
10134 \par
10135 {\cf21 #endif}\par
10136 \par
10137 \} {\cf20 // end namespace Catch}\par
10138 \par
10139 {\cf21 #endif }{\cf20 // CATCH_OUTPUT_REDIRECT_HPP_INCLUDED}\par
10140 \par
10141 \par
10142 {\cf21 #ifndef CATCH_PARSE_NUMBERS_HPP_INCLUDED}\par
10143 {\cf21 #define CATCH_PARSE_NUMBERS_HPP_INCLUDED}\par
10144 \par
10145 \par
10146 {\cf21 #include <string>}\par
10147 \par
10148 {\cf17 namespace }Catch \{\par
10149 \par
10156     Optional<unsigned int> parseUInt(std::string {\cf17 const}& input, {\cf18 int} base = 10);\par
10157 \}\par
10158 \par
10159 {\cf21 #endif }{\cf20 // CATCH_PARSE_NUMBERS_HPP_INCLUDED}\par
10160 \par
10161 \par
10162 {\cf21 #ifndef CATCH_REPORTER_REGISTRY_HPP_INCLUDED}\par
10163 {\cf21 #define CATCH_REPORTER_REGISTRY_HPP_INCLUDED}\par
10164 \par
10165 \par
10166 {\cf21 #include <map>}\par
10167 {\cf21 #include <string>}\par
10168 {\cf21 #include <vector>}\par
10169 \par
10170 {\cf17 namespace }Catch \{\par
10171 \par
10172     {\cf17 class }IEventListener;\par
10173     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
10174     {\cf17 class }IReporterFactory;\par
10175     {\cf17 using }IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;\par
10176     {\cf17 struct }ReporterConfig;\par
10177     {\cf17 class }EventListenerFactory;\par
10178 \par
10179     {\cf17 class }ReporterRegistry \{\par
10180         {\cf17 struct }ReporterRegistryImpl;\par
10181         Detail::unique_ptr<ReporterRegistryImpl> m_impl;\par
10182 \par
10183     {\cf17 public}:\par
10184         ReporterRegistry();\par
10185         ~ReporterRegistry(); {\cf20 // = default;}\par
10186 \par
10187         IEventListenerPtr create( std::string {\cf17 const}& name,\par
10188                                   ReporterConfig&& config ) {\cf17 const};\par
10189 \par
10190         {\cf18 void} registerReporter( std::string {\cf17 const}& name,\par
10191                                IReporterFactoryPtr factory );\par
10192 \par
10193         {\cf18 void}\par
10194         registerListener( Detail::unique_ptr<EventListenerFactory> factory );\par
10195 \par
10196         std::map<std::string,\par
10197                  IReporterFactoryPtr,\par
10198                  Detail::CaseInsensitiveLess> {\cf17 const}&\par
10199         getFactories() {\cf17 const};\par
10200 \par
10201         std::vector<Detail::unique_ptr<EventListenerFactory>> {\cf17 const}&\par
10202         getListeners() {\cf17 const};\par
10203     \};\par
10204 \par
10205 \} {\cf20 // end namespace Catch}\par
10206 \par
10207 {\cf21 #endif }{\cf20 // CATCH_REPORTER_REGISTRY_HPP_INCLUDED}\par
10208 \par
10209 \par
10210 {\cf21 #ifndef CATCH_RUN_CONTEXT_HPP_INCLUDED}\par
10211 {\cf21 #define CATCH_RUN_CONTEXT_HPP_INCLUDED}\par
10212 \par
10213 \par
10214 \par
10215 {\cf21 #ifndef CATCH_TEST_CASE_TRACKER_HPP_INCLUDED}\par
10216 {\cf21 #define CATCH_TEST_CASE_TRACKER_HPP_INCLUDED}\par
10217 \par
10218 \par
10219 {\cf21 #include <string>}\par
10220 {\cf21 #include <vector>}\par
10221 \par
10222 {\cf17 namespace }Catch \{\par
10223 {\cf17 namespace }TestCaseTracking \{\par
10224 \par
10225     {\cf17 struct }NameAndLocation \{\par
10226         std::string name;\par
10227         SourceLineInfo location;\par
10228 \par
10229         NameAndLocation( std::string&& _name, SourceLineInfo {\cf17 const}& _location );\par
10230         {\cf17 friend} {\cf18 bool} operator==(NameAndLocation {\cf17 const}& lhs, NameAndLocation {\cf17 const}& rhs) \{\par
10231             {\cf20 // This is a very cheap check that should have a very high hit rate.}\par
10232             {\cf20 // If we get to SourceLineInfo::operator==, we will redo it, but the}\par
10233             {\cf20 // cost of repeating is trivial at that point (we will be paying}\par
10234             {\cf20 // multiple strcmp/memcmps at that point).}\par
10235             {\cf19 if} ( lhs.location.line != rhs.location.line ) \{ {\cf19 return} {\cf17 false}; \}\par
10236             {\cf19 return} lhs.name == rhs.name && lhs.location == rhs.location;\par
10237         \}\par
10238         {\cf17 friend} {\cf18 bool} operator!=(NameAndLocation {\cf17 const}& lhs,\par
10239                                NameAndLocation {\cf17 const}& rhs) \{\par
10240             {\cf19 return} !( lhs == rhs );\par
10241         \}\par
10242     \};\par
10243 \par
10251     {\cf17 struct }NameAndLocationRef \{\par
10252         StringRef name;\par
10253         SourceLineInfo location;\par
10254 \par
10255         {\cf17 constexpr} NameAndLocationRef( StringRef name_,\par
10256                                       SourceLineInfo location_ ):\par
10257             name( name_ ), location( location_ ) \{\}\par
10258 \par
10259         {\cf17 friend} {\cf18 bool} operator==( NameAndLocation {\cf17 const}& lhs,\par
10260                                 NameAndLocationRef {\cf17 const}& rhs ) \{\par
10261             {\cf20 // This is a very cheap check that should have a very high hit rate.}\par
10262             {\cf20 // If we get to SourceLineInfo::operator==, we will redo it, but the}\par
10263             {\cf20 // cost of repeating is trivial at that point (we will be paying}\par
10264             {\cf20 // multiple strcmp/memcmps at that point).}\par
10265             {\cf19 if} ( lhs.location.line != rhs.location.line ) \{ {\cf19 return} {\cf17 false}; \}\par
10266             {\cf19 return} StringRef( lhs.name ) == rhs.name &&\par
10267                    lhs.location == rhs.location;\par
10268         \}\par
10269         {\cf17 friend} {\cf18 bool} operator==( NameAndLocationRef {\cf17 const}& lhs,\par
10270                                 NameAndLocation {\cf17 const}& rhs ) \{\par
10271             {\cf19 return} rhs == lhs;\par
10272         \}\par
10273     \};\par
10274 \par
10275     {\cf17 class }ITracker;\par
10276 \par
10277     {\cf17 using }ITrackerPtr = Catch::Detail::unique_ptr<ITracker>;\par
10278 \par
10279     {\cf17 class }ITracker \{\par
10280         NameAndLocation m_nameAndLocation;\par
10281 \par
10282         {\cf17 using }Children = std::vector<ITrackerPtr>;\par
10283 \par
10284     {\cf17 protected}:\par
10285         {\cf17 enum} CycleState \{\par
10286             NotStarted,\par
10287             Executing,\par
10288             ExecutingChildren,\par
10289             NeedsAnotherRun,\par
10290             CompletedSuccessfully,\par
10291             Failed\par
10292         \};\par
10293 \par
10294         ITracker* m_parent = {\cf17 nullptr};\par
10295         Children m_children;\par
10296         CycleState m_runState = NotStarted;\par
10297 \par
10298     {\cf17 public}:\par
10299         ITracker( NameAndLocation&& nameAndLoc, ITracker* parent ):\par
10300             m_nameAndLocation( CATCH_MOVE(nameAndLoc) ),\par
10301             m_parent( parent )\par
10302         \{\}\par
10303 \par
10304 \par
10305         {\cf20 // static queries}\par
10306         NameAndLocation {\cf17 const}& nameAndLocation(){\cf17  const }\{\par
10307             {\cf19 return} m_nameAndLocation;\par
10308         \}\par
10309         ITracker* parent(){\cf17  const }\{\par
10310             {\cf19 return} m_parent;\par
10311         \}\par
10312 \par
10313         {\cf17 virtual} ~ITracker(); {\cf20 // = default}\par
10314 \par
10315 \par
10316         {\cf20 // dynamic queries}\par
10317 \par
10319         {\cf17 virtual} {\cf18 bool} isComplete() {\cf17 const} = 0;\par
10321         {\cf18 bool} isSuccessfullyCompleted(){\cf17  const }\{\par
10322             {\cf19 return} m_runState == CompletedSuccessfully;\par
10323         \}\par
10325         {\cf18 bool} isOpen() {\cf17 const};\par
10327         {\cf18 bool} hasStarted() {\cf17 const};\par
10328 \par
10329         {\cf20 // actions}\par
10330         {\cf17 virtual} {\cf18 void} close() = 0; {\cf20 // Successfully complete}\par
10331         {\cf17 virtual} {\cf18 void} fail() = 0;\par
10332         {\cf18 void} markAsNeedingAnotherRun();\par
10333 \par
10335         {\cf18 void} addChild( ITrackerPtr&& child );\par
10341         ITracker* findChild( NameAndLocationRef {\cf17 const}& nameAndLocation );\par
10343         {\cf18 bool} hasChildren(){\cf17  const }\{\par
10344             {\cf19 return} !m_children.empty();\par
10345         \}\par
10346 \par
10347 \par
10349         {\cf18 void} openChild();\par
10350 \par
10357         {\cf17 virtual} {\cf18 bool} isSectionTracker() {\cf17 const};\par
10364         {\cf17 virtual} {\cf18 bool} isGeneratorTracker() {\cf17 const};\par
10365     \};\par
10366 \par
10367     {\cf17 class }TrackerContext \{\par
10368 \par
10369         {\cf17 enum} RunState \{\par
10370             NotStarted,\par
10371             Executing,\par
10372             CompletedCycle\par
10373         \};\par
10374 \par
10375         ITrackerPtr m_rootTracker;\par
10376         ITracker* m_currentTracker = {\cf17 nullptr};\par
10377         RunState m_runState = NotStarted;\par
10378 \par
10379     {\cf17 public}:\par
10380 \par
10381         ITracker& startRun();\par
10382 \par
10383         {\cf18 void} startCycle() \{\par
10384             m_currentTracker = m_rootTracker.get();\par
10385             m_runState = Executing;\par
10386         \}\par
10387         {\cf18 void} completeCycle();\par
10388 \par
10389         {\cf18 bool} completedCycle() {\cf17 const};\par
10390         ITracker& currentTracker() \{ {\cf19 return} *m_currentTracker; \}\par
10391         {\cf18 void} setCurrentTracker( ITracker* tracker );\par
10392     \};\par
10393 \par
10394     {\cf17 class }TrackerBase : {\cf17 public} ITracker \{\par
10395     {\cf17 protected}:\par
10396 \par
10397         TrackerContext& m_ctx;\par
10398 \par
10399     {\cf17 public}:\par
10400         TrackerBase( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );\par
10401 \par
10402         {\cf18 bool} isComplete() {\cf17 const override};\par
10403 \par
10404         {\cf18 void} open();\par
10405 \par
10406         {\cf18 void} close() {\cf17 override};\par
10407         {\cf18 void} fail() {\cf17 override};\par
10408 \par
10409     {\cf17 private}:\par
10410         {\cf18 void} moveToParent();\par
10411         {\cf18 void} moveToThis();\par
10412     \};\par
10413 \par
10414     {\cf17 class }SectionTracker : {\cf17 public} TrackerBase \{\par
10415         std::vector<StringRef> m_filters;\par
10416         {\cf20 // Note that lifetime-wise we piggy back off the name stored in the `ITracker` parent`.}\par
10417         {\cf20 // Currently it allocates owns the name, so this is safe. If it is later refactored}\par
10418         {\cf20 // to not own the name, the name still has to outlive the `ITracker` parent, so}\par
10419         {\cf20 // this should still be safe.}\par
10420         StringRef m_trimmed_name;\par
10421     {\cf17 public}:\par
10422         SectionTracker( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );\par
10423 \par
10424         {\cf18 bool} isSectionTracker() {\cf17 const override};\par
10425 \par
10426         {\cf18 bool} isComplete() {\cf17 const override};\par
10427 \par
10428         {\cf17 static} SectionTracker& acquire( TrackerContext& ctx, NameAndLocationRef {\cf17 const}& nameAndLocation );\par
10429 \par
10430         {\cf18 void} tryOpen();\par
10431 \par
10432         {\cf18 void} addInitialFilters( std::vector<std::string> {\cf17 const}& filters );\par
10433         {\cf18 void} addNextFilters( std::vector<StringRef> {\cf17 const}& filters );\par
10435         std::vector<StringRef> {\cf17 const}& getFilters(){\cf17  const }\{ {\cf19 return} m_filters; \}\par
10437         StringRef trimmedName() {\cf17 const};\par
10438     \};\par
10439 \par
10440 \} {\cf20 // namespace TestCaseTracking}\par
10441 \par
10442 {\cf17 using }TestCaseTracking::ITracker;\par
10443 {\cf17 using }TestCaseTracking::TrackerContext;\par
10444 {\cf17 using }TestCaseTracking::SectionTracker;\par
10445 \par
10446 \} {\cf20 // namespace Catch}\par
10447 \par
10448 {\cf21 #endif }{\cf20 // CATCH_TEST_CASE_TRACKER_HPP_INCLUDED}\par
10449 \par
10450 {\cf21 #include <string>}\par
10451 \par
10452 {\cf17 namespace }Catch \{\par
10453 \par
10454     {\cf17 class }IGeneratorTracker;\par
10455     {\cf17 class }IConfig;\par
10456     {\cf17 class }IEventListener;\par
10457     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
10458 \par
10460 \par
10461     {\cf17 class }RunContext final : {\cf17 public} IResultCapture \{\par
10462 \par
10463     {\cf17 public}:\par
10464         RunContext( RunContext {\cf17 const}& ) = {\cf17 delete};\par
10465         RunContext& operator =( RunContext {\cf17 const}& ) = {\cf17 delete};\par
10466 \par
10467         {\cf17 explicit} RunContext( IConfig {\cf17 const}* _config, IEventListenerPtr&& reporter );\par
10468 \par
10469         ~RunContext() {\cf17 override};\par
10470 \par
10471         Totals runTest(TestCaseHandle {\cf17 const}& testCase);\par
10472 \par
10473     {\cf17 public}: {\cf20 // IResultCapture}\par
10474 \par
10475         {\cf20 // Assertion handlers}\par
10476         {\cf18 void} handleExpr\par
10477                 (   AssertionInfo {\cf17 const}& info,\par
10478                     ITransientExpression {\cf17 const}& expr,\par
10479                     AssertionReaction& reaction ) {\cf17 override};\par
10480         {\cf18 void} handleMessage\par
10481                 (   AssertionInfo {\cf17 const}& info,\par
10482                     ResultWas::OfType resultType,\par
10483                     StringRef message,\par
10484                     AssertionReaction& reaction ) {\cf17 override};\par
10485         {\cf18 void} handleUnexpectedExceptionNotThrown\par
10486                 (   AssertionInfo {\cf17 const}& info,\par
10487                     AssertionReaction& reaction ) {\cf17 override};\par
10488         {\cf18 void} handleUnexpectedInflightException\par
10489                 (   AssertionInfo {\cf17 const}& info,\par
10490                     std::string&& message,\par
10491                     AssertionReaction& reaction ) {\cf17 override};\par
10492         {\cf18 void} handleIncomplete\par
10493                 (   AssertionInfo {\cf17 const}& info ) {\cf17 override};\par
10494         {\cf18 void} handleNonExpr\par
10495                 (   AssertionInfo {\cf17 const} &info,\par
10496                     ResultWas::OfType resultType,\par
10497                     AssertionReaction &reaction ) {\cf17 override};\par
10498 \par
10499         {\cf18 void} notifyAssertionStarted( AssertionInfo {\cf17 const}& info ) {\cf17 override};\par
10500         {\cf18 bool} sectionStarted( StringRef sectionName,\par
10501                              SourceLineInfo {\cf17 const}& sectionLineInfo,\par
10502                              Counts& assertions ) {\cf17 override};\par
10503 \par
10504         {\cf18 void} sectionEnded( SectionEndInfo&& endInfo ) {\cf17 override};\par
10505         {\cf18 void} sectionEndedEarly( SectionEndInfo&& endInfo ) {\cf17 override};\par
10506 \par
10507         IGeneratorTracker*\par
10508         acquireGeneratorTracker( StringRef generatorName,\par
10509                                  SourceLineInfo {\cf17 const}& lineInfo ) {\cf17 override};\par
10510         IGeneratorTracker* createGeneratorTracker(\par
10511             StringRef generatorName,\par
10512             SourceLineInfo lineInfo,\par
10513             Generators::GeneratorBasePtr&& generator ) {\cf17 override};\par
10514 \par
10515 \par
10516         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
10517         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) {\cf17 override};\par
10518         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& stats ) {\cf17 override};\par
10519         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
10520 \par
10521         {\cf18 void} pushScopedMessage( MessageInfo {\cf17 const}& message ) {\cf17 override};\par
10522         {\cf18 void} popScopedMessage( MessageInfo {\cf17 const}& message ) {\cf17 override};\par
10523 \par
10524         {\cf18 void} emplaceUnscopedMessage( MessageBuilder&& builder ) {\cf17 override};\par
10525 \par
10526         std::string getCurrentTestName() {\cf17 const override};\par
10527 \par
10528         {\cf17 const} AssertionResult* getLastResult() {\cf17 const override};\par
10529 \par
10530         {\cf18 void} exceptionEarlyReported() {\cf17 override};\par
10531 \par
10532         {\cf18 void} handleFatalErrorCondition( StringRef message ) {\cf17 override};\par
10533 \par
10534         {\cf18 bool} lastAssertionPassed() {\cf17 override};\par
10535 \par
10536         {\cf18 void} assertionPassed() {\cf17 override};\par
10537 \par
10538     {\cf17 public}:\par
10539         {\cf20 // !TBD We need to do this another way!}\par
10540         {\cf18 bool} aborting() {\cf17 const};\par
10541 \par
10542     {\cf17 private}:\par
10543 \par
10544         {\cf18 void} runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );\par
10545         {\cf18 void} invokeActiveTestCase();\par
10546 \par
10547         {\cf18 void} resetAssertionInfo();\par
10548         {\cf18 bool} testForMissingAssertions( Counts& assertions );\par
10549 \par
10550         {\cf18 void} assertionEnded( AssertionResult&& result );\par
10551         {\cf18 void} reportExpr\par
10552                 (   AssertionInfo {\cf17 const} &info,\par
10553                     ResultWas::OfType resultType,\par
10554                     ITransientExpression {\cf17 const} *expr,\par
10555                     {\cf18 bool} negated );\par
10556 \par
10557         {\cf18 void} populateReaction( AssertionReaction& reaction );\par
10558 \par
10559     {\cf17 private}:\par
10560 \par
10561         {\cf18 void} handleUnfinishedSections();\par
10562 \par
10563         TestRunInfo m_runInfo;\par
10564         TestCaseHandle {\cf17 const}* m_activeTestCase = {\cf17 nullptr};\par
10565         ITracker* m_testCaseTracker = {\cf17 nullptr};\par
10566         Optional<AssertionResult> m_lastResult;\par
10567 \par
10568         IConfig {\cf17 const}* m_config;\par
10569         Totals m_totals;\par
10570         IEventListenerPtr m_reporter;\par
10571         std::vector<MessageInfo> m_messages;\par
10572         std::vector<ScopedMessage> m_messageScopes; {\cf20 /* Keeps owners of so-called unscoped messages. */}\par
10573         AssertionInfo m_lastAssertionInfo;\par
10574         std::vector<SectionEndInfo> m_unfinishedSections;\par
10575         std::vector<ITracker*> m_activeSections;\par
10576         TrackerContext m_trackerContext;\par
10577         FatalConditionHandler m_fatalConditionhandler;\par
10578         {\cf18 bool} m_lastAssertionPassed = {\cf17 false};\par
10579         {\cf18 bool} m_shouldReportUnexpected = {\cf17 true};\par
10580         {\cf18 bool} m_includeSuccessfulResults;\par
10581     \};\par
10582 \par
10583     {\cf18 void} seedRng(IConfig {\cf17 const}& config);\par
10584     {\cf18 unsigned} {\cf18 int} rngSeed();\par
10585 \} {\cf20 // end namespace Catch}\par
10586 \par
10587 {\cf21 #endif }{\cf20 // CATCH_RUN_CONTEXT_HPP_INCLUDED}\par
10588 \par
10589 \par
10590 {\cf21 #ifndef CATCH_SHARDING_HPP_INCLUDED}\par
10591 {\cf21 #define CATCH_SHARDING_HPP_INCLUDED}\par
10592 \par
10593 {\cf21 #include <cassert>}\par
10594 {\cf21 #include <cmath>}\par
10595 {\cf21 #include <algorithm>}\par
10596 \par
10597 {\cf17 namespace }Catch \{\par
10598 \par
10599     {\cf17 template}<{\cf17 typename} Container>\par
10600     Container createShard(Container {\cf17 const}& container, std::size_t {\cf17 const} shardCount, std::size_t {\cf17 const} shardIndex) \{\par
10601         assert(shardCount > shardIndex);\par
10602 \par
10603         {\cf19 if} (shardCount == 1) \{\par
10604             {\cf19 return} container;\par
10605         \}\par
10606 \par
10607         {\cf17 const} std::size_t totalTestCount = container.size();\par
10608 \par
10609         {\cf17 const} std::size_t shardSize = totalTestCount / shardCount;\par
10610         {\cf17 const} std::size_t leftoverTests = totalTestCount % shardCount;\par
10611 \par
10612         {\cf17 const} std::size_t startIndex = shardIndex * shardSize + (std::min)(shardIndex, leftoverTests);\par
10613         {\cf17 const} std::size_t endIndex = (shardIndex + 1) * shardSize + (std::min)(shardIndex + 1, leftoverTests);\par
10614 \par
10615         {\cf17 auto} startIterator = std::next(container.begin(), {\cf17 static_cast<}std::ptrdiff_t{\cf17 >}(startIndex));\par
10616         {\cf17 auto} endIterator = std::next(container.begin(), {\cf17 static_cast<}std::ptrdiff_t{\cf17 >}(endIndex));\par
10617 \par
10618         {\cf19 return} Container(startIterator, endIterator);\par
10619     \}\par
10620 \par
10621 \}\par
10622 \par
10623 {\cf21 #endif }{\cf20 // CATCH_SHARDING_HPP_INCLUDED}\par
10624 \par
10625 \par
10626 {\cf21 #ifndef CATCH_SINGLETONS_HPP_INCLUDED}\par
10627 {\cf21 #define CATCH_SINGLETONS_HPP_INCLUDED}\par
10628 \par
10629 {\cf17 namespace }Catch \{\par
10630 \par
10631     {\cf17 struct }ISingleton \{\par
10632         {\cf17 virtual} ~ISingleton(); {\cf20 // = default}\par
10633     \};\par
10634 \par
10635 \par
10636     {\cf18 void} addSingleton( ISingleton* singleton );\par
10637     {\cf18 void} cleanupSingletons();\par
10638 \par
10639 \par
10640     {\cf17 template}<{\cf17 typename} SingletonImplT, {\cf17 typename} InterfaceT = SingletonImplT, {\cf17 typename} MutableInterfaceT = InterfaceT>\par
10641     {\cf17 class }Singleton : SingletonImplT, {\cf17 public} ISingleton \{\par
10642 \par
10643         {\cf17 static} {\cf17 auto} getInternal() -> Singleton* \{\par
10644             {\cf17 static} Singleton* s_instance = {\cf17 nullptr};\par
10645             {\cf19 if}( !s_instance ) \{\par
10646                 s_instance = {\cf17 new} Singleton;\par
10647                 addSingleton( s_instance );\par
10648             \}\par
10649             {\cf19 return} s_instance;\par
10650         \}\par
10651 \par
10652     {\cf17 public}:\par
10653         {\cf17 static} {\cf17 auto} get() -> InterfaceT {\cf17 const}& \{\par
10654             {\cf19 return} *getInternal();\par
10655         \}\par
10656         {\cf17 static} {\cf17 auto} getMutable() -> MutableInterfaceT& \{\par
10657             {\cf19 return} *getInternal();\par
10658         \}\par
10659     \};\par
10660 \par
10661 \} {\cf20 // namespace Catch}\par
10662 \par
10663 {\cf21 #endif }{\cf20 // CATCH_SINGLETONS_HPP_INCLUDED}\par
10664 \par
10665 \par
10666 {\cf21 #ifndef CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED}\par
10667 {\cf21 #define CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED}\par
10668 \par
10669 \par
10670 {\cf21 #include <vector>}\par
10671 {\cf21 #include <exception>}\par
10672 \par
10673 {\cf17 namespace }Catch \{\par
10674 \par
10675     {\cf17 class }StartupExceptionRegistry \{\par
10676 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
10677     {\cf17 public}:\par
10678         {\cf18 void} add(std::exception_ptr {\cf17 const}& exception) {\cf17 noexcept};\par
10679         std::vector<std::exception_ptr> {\cf17 const}& getExceptions() const noexcept;\par
10680     private:\par
10681         std::vector<std::exception_ptr> m_exceptions;\par
10682 {\cf21 #endif}\par
10683     \};\par
10684 \par
10685 \} {\cf20 // end namespace Catch}\par
10686 \par
10687 {\cf21 #endif }{\cf20 // CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED}\par
10688 \par
10689 \par
10690 \par
10691 {\cf21 #ifndef CATCH_STDSTREAMS_HPP_INCLUDED}\par
10692 {\cf21 #define CATCH_STDSTREAMS_HPP_INCLUDED}\par
10693 \par
10694 {\cf21 #include <iosfwd>}\par
10695 \par
10696 {\cf17 namespace }Catch \{\par
10697 \par
10698     std::ostream& cout();\par
10699     std::ostream& cerr();\par
10700     std::ostream& clog();\par
10701 \par
10702 \} {\cf20 // namespace Catch}\par
10703 \par
10704 {\cf21 #endif}\par
10705 \par
10706 \par
10707 {\cf21 #ifndef CATCH_STRING_MANIP_HPP_INCLUDED}\par
10708 {\cf21 #define CATCH_STRING_MANIP_HPP_INCLUDED}\par
10709 \par
10710 \par
10711 {\cf21 #include <cstdint>}\par
10712 {\cf21 #include <string>}\par
10713 {\cf21 #include <iosfwd>}\par
10714 {\cf21 #include <vector>}\par
10715 \par
10716 {\cf17 namespace }Catch \{\par
10717 \par
10718     {\cf18 bool} startsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& prefix );\par
10719     {\cf18 bool} startsWith( StringRef s, {\cf18 char} prefix );\par
10720     {\cf18 bool} endsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& suffix );\par
10721     {\cf18 bool} endsWith( std::string {\cf17 const}& s, {\cf18 char} suffix );\par
10722     {\cf18 bool} contains( std::string {\cf17 const}& s, std::string {\cf17 const}& infix );\par
10723     {\cf18 void} toLowerInPlace( std::string& s );\par
10724     std::string toLower( std::string {\cf17 const}& s );\par
10725     {\cf18 char} toLower( {\cf18 char} c );\par
10727     std::string trim( std::string {\cf17 const}& str );\par
10729     StringRef trim(StringRef ref);\par
10730 \par
10731     {\cf20 // !!! Be aware, returns refs into original string - make sure original string outlives them}\par
10732     std::vector<StringRef> splitStringRef( StringRef str, {\cf18 char} delimiter );\par
10733     {\cf18 bool} replaceInPlace( std::string& str, std::string {\cf17 const}& replaceThis, std::string {\cf17 const}& withThis );\par
10734 \par
10745     {\cf17 class }pluralise \{\par
10746         std::uint64_t m_count;\par
10747         StringRef m_label;\par
10748 \par
10749     {\cf17 public}:\par
10750         {\cf17 constexpr} pluralise(std::uint64_t count, StringRef label):\par
10751             m_count(count),\par
10752             m_label(label)\par
10753         \{\}\par
10754 \par
10755         {\cf17 friend} std::ostream& operator << ( std::ostream& os, pluralise {\cf17 const}& pluraliser );\par
10756     \};\par
10757 \}\par
10758 \par
10759 {\cf21 #endif }{\cf20 // CATCH_STRING_MANIP_HPP_INCLUDED}\par
10760 \par
10761 \par
10762 {\cf21 #ifndef CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
10763 {\cf21 #define CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
10764 \par
10765 \par
10766 {\cf21 #include <map>}\par
10767 {\cf21 #include <string>}\par
10768 \par
10769 {\cf17 namespace }Catch \{\par
10770     {\cf17 struct }SourceLineInfo;\par
10771 \par
10772     {\cf17 class }TagAliasRegistry : {\cf17 public} ITagAliasRegistry \{\par
10773     {\cf17 public}:\par
10774         ~TagAliasRegistry() {\cf17 override};\par
10775         TagAlias {\cf17 const}* find( std::string {\cf17 const}& alias ) {\cf17 const override};\par
10776         std::string expandAliases( std::string {\cf17 const}& unexpandedTestSpec ) {\cf17 const override};\par
10777         {\cf18 void} add( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo );\par
10778 \par
10779     {\cf17 private}:\par
10780         std::map<std::string, TagAlias> m_registry;\par
10781     \};\par
10782 \par
10783 \} {\cf20 // end namespace Catch}\par
10784 \par
10785 {\cf21 #endif }{\cf20 // CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
10786 \par
10787 \par
10788 {\cf21 #ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED}\par
10789 {\cf21 #define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED}\par
10790 \par
10791 {\cf21 #include <cstdint>}\par
10792 \par
10793 {\cf17 namespace }Catch \{\par
10794 \par
10795     {\cf17 struct }TestCaseInfo;\par
10796 \par
10797     {\cf17 class }TestCaseInfoHasher \{\par
10798     {\cf17 public}:\par
10799         {\cf17 using }hash_t = std::uint64_t;\par
10800         TestCaseInfoHasher( hash_t seed );\par
10801         uint32_t operator()( TestCaseInfo {\cf17 const}& t ) {\cf17 const};\par
10802 \par
10803     {\cf17 private}:\par
10804         hash_t m_seed;\par
10805     \};\par
10806 \par
10807 \} {\cf20 // namespace Catch}\par
10808 \par
10809 {\cf21 #endif }{\cf20 /* CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED */}{\cf21 }\par
10810 \par
10811 \par
10812 {\cf21 #ifndef CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED}\par
10813 {\cf21 #define CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED}\par
10814 \par
10815 \par
10816 {\cf21 #include <vector>}\par
10817 \par
10818 {\cf17 namespace }Catch \{\par
10819 \par
10820     {\cf17 class }IConfig;\par
10821     {\cf17 class }ITestInvoker;\par
10822     {\cf17 class }TestCaseHandle;\par
10823     {\cf17 class }TestSpec;\par
10824 \par
10825     std::vector<TestCaseHandle> sortTests( IConfig {\cf17 const}& config, std::vector<TestCaseHandle> {\cf17 const}& unsortedTestCases );\par
10826 \par
10827     {\cf18 bool} isThrowSafe( TestCaseHandle {\cf17 const}& testCase, IConfig {\cf17 const}& config );\par
10828 \par
10829     std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> {\cf17 const}& testCases, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config );\par
10830     std::vector<TestCaseHandle> {\cf17 const}& getAllTestCasesSorted( IConfig {\cf17 const}& config );\par
10831 \par
10832     {\cf17 class }TestRegistry : {\cf17 public} ITestCaseRegistry \{\par
10833     {\cf17 public}:\par
10834         {\cf18 void} registerTest( Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker );\par
10835 \par
10836         std::vector<TestCaseInfo*> {\cf17 const}& getAllInfos() {\cf17 const override};\par
10837         std::vector<TestCaseHandle> {\cf17 const}& getAllTests() {\cf17 const override};\par
10838         std::vector<TestCaseHandle> {\cf17 const}& getAllTestsSorted( IConfig {\cf17 const}& config ) {\cf17 const override};\par
10839 \par
10840         ~TestRegistry() {\cf17 override}; {\cf20 // = default}\par
10841 \par
10842     {\cf17 private}:\par
10843         std::vector<Detail::unique_ptr<TestCaseInfo>> m_owned_test_infos;\par
10844         {\cf20 // Keeps a materialized vector for `getAllInfos`.}\par
10845         {\cf20 // We should get rid of that eventually (see interface note)}\par
10846         std::vector<TestCaseInfo*> m_viewed_test_infos;\par
10847 \par
10848         std::vector<Detail::unique_ptr<ITestInvoker>> m_invokers;\par
10849         std::vector<TestCaseHandle> m_handles;\par
10850         {\cf17 mutable} TestRunOrder m_currentSortOrder = TestRunOrder::Declared;\par
10851         {\cf17 mutable} std::vector<TestCaseHandle> m_sortedFunctions;\par
10852     \};\par
10853 \par
10855 \par
10856 \par
10857 \} {\cf20 // end namespace Catch}\par
10858 \par
10859 \par
10860 {\cf21 #endif }{\cf20 // CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED}\par
10861 \par
10862 \par
10863 {\cf21 #ifndef CATCH_TEST_SPEC_PARSER_HPP_INCLUDED}\par
10864 {\cf21 #define CATCH_TEST_SPEC_PARSER_HPP_INCLUDED}\par
10865 \par
10866 {\cf21 #ifdef __clang__}\par
10867 {\cf21 #pragma clang diagnostic push}\par
10868 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
10869 {\cf21 #endif}\par
10870 \par
10871 \par
10872 {\cf21 #include <vector>}\par
10873 {\cf21 #include <string>}\par
10874 \par
10875 {\cf17 namespace }Catch \{\par
10876 \par
10877     {\cf17 class }ITagAliasRegistry;\par
10878 \par
10879     {\cf17 class }TestSpecParser \{\par
10880         {\cf17 enum} Mode\{ None, Name, QuotedName, Tag, EscapedName \};\par
10881         Mode m_mode = None;\par
10882         Mode lastMode = None;\par
10883         {\cf18 bool} m_exclusion = {\cf17 false};\par
10884         std::size_t m_pos = 0;\par
10885         std::size_t m_realPatternPos = 0;\par
10886         std::string m_arg;\par
10887         std::string m_substring;\par
10888         std::string m_patternName;\par
10889         std::vector<std::size_t> m_escapeChars;\par
10890         TestSpec::Filter m_currentFilter;\par
10891         TestSpec m_testSpec;\par
10892         ITagAliasRegistry {\cf17 const}* m_tagAliases = {\cf17 nullptr};\par
10893 \par
10894     {\cf17 public}:\par
10895         TestSpecParser( ITagAliasRegistry {\cf17 const}& tagAliases );\par
10896 \par
10897         TestSpecParser& parse( std::string {\cf17 const}& arg );\par
10898         TestSpec testSpec();\par
10899 \par
10900     {\cf17 private}:\par
10901         {\cf18 bool} visitChar( {\cf18 char} c );\par
10902         {\cf18 void} startNewMode( Mode mode );\par
10903         {\cf18 bool} processNoneChar( {\cf18 char} c );\par
10904         {\cf18 void} processNameChar( {\cf18 char} c );\par
10905         {\cf18 bool} processOtherChar( {\cf18 char} c );\par
10906         {\cf18 void} endMode();\par
10907         {\cf18 void} escape();\par
10908         {\cf18 bool} isControlChar( {\cf18 char} c ) {\cf17 const};\par
10909         {\cf18 void} saveLastMode();\par
10910         {\cf18 void} revertBackToLastMode();\par
10911         {\cf18 void} addFilter();\par
10912         {\cf18 bool} separate();\par
10913 \par
10914         {\cf20 // Handles common preprocessing of the pattern for name/tag patterns}\par
10915         std::string preprocessPattern();\par
10916         {\cf20 // Adds the current pattern as a test name}\par
10917         {\cf18 void} addNamePattern();\par
10918         {\cf20 // Adds the current pattern as a tag}\par
10919         {\cf18 void} addTagPattern();\par
10920 \par
10921         {\cf17 inline} {\cf18 void} addCharToPattern({\cf18 char} c) \{\par
10922             m_substring += c;\par
10923             m_patternName += c;\par
10924             m_realPatternPos++;\par
10925         \}\par
10926 \par
10927     \};\par
10928 \par
10929 \} {\cf20 // namespace Catch}\par
10930 \par
10931 {\cf21 #ifdef __clang__}\par
10932 {\cf21 #pragma clang diagnostic pop}\par
10933 {\cf21 #endif}\par
10934 \par
10935 {\cf21 #endif }{\cf20 // CATCH_TEST_SPEC_PARSER_HPP_INCLUDED}\par
10936 \par
10937 \par
10938 {\cf21 #ifndef CATCH_TEXTFLOW_HPP_INCLUDED}\par
10939 {\cf21 #define CATCH_TEXTFLOW_HPP_INCLUDED}\par
10940 \par
10941 \par
10942 {\cf21 #include <cassert>}\par
10943 {\cf21 #include <string>}\par
10944 {\cf21 #include <vector>}\par
10945 \par
10946 {\cf17 namespace }Catch \{\par
10947     {\cf17 namespace }TextFlow \{\par
10948 \par
10949         {\cf17 class }Columns;\par
10950 \par
10963         {\cf17 class }AnsiSkippingString \{\par
10964             std::string m_string;\par
10965             std::size_t m_size = 0;\par
10966 \par
10967             {\cf20 // perform 0xff replacement and calculate m_size}\par
10968             {\cf18 void} preprocessString();\par
10969 \par
10970         {\cf17 public}:\par
10971             {\cf17 class }const_iterator;\par
10972             {\cf17 using }iterator = const_iterator;\par
10973             {\cf20 // note: must be u-suffixed or this will cause a "truncation of}\par
10974             {\cf20 // constant value" warning on MSVC}\par
10975             {\cf17 static} {\cf17 constexpr} {\cf18 char} sentinel = {\cf17 static_cast<}{\cf18 char}{\cf17 >}( 0xffu );\par
10976 \par
10977             {\cf17 explicit} AnsiSkippingString( std::string {\cf17 const}& text );\par
10978             {\cf17 explicit} AnsiSkippingString( std::string&& text );\par
10979 \par
10980             const_iterator begin() {\cf17 const};\par
10981             const_iterator end() {\cf17 const};\par
10982 \par
10983             {\cf18 size_t} size(){\cf17  const }\{ {\cf19 return} m_size; \}\par
10984 \par
10985             std::string substring( const_iterator begin,\par
10986                                    const_iterator end ) {\cf17 const};\par
10987         \};\par
10988 \par
10989         {\cf17 class }AnsiSkippingString::const_iterator \{\par
10990             {\cf17 friend} AnsiSkippingString;\par
10991             {\cf17 struct }EndTag \{\};\par
10992 \par
10993             {\cf17 const} std::string* m_string;\par
10994             std::string::const_iterator m_it;\par
10995 \par
10996             {\cf17 explicit} const_iterator( {\cf17 const} std::string& {\cf18 string}, EndTag ):\par
10997                 m_string( &string ), m_it( string.end() ) \{\}\par
10998 \par
10999             {\cf18 void} tryParseAnsiEscapes();\par
11000             {\cf18 void} advance();\par
11001             {\cf18 void} unadvance();\par
11002 \par
11003         {\cf17 public}:\par
11004             {\cf17 using }difference_type = std::ptrdiff_t;\par
11005             {\cf17 using }value_type = char;\par
11006             {\cf17 using }pointer = value_type*;\par
11007             {\cf17 using }reference = value_type&;\par
11008             {\cf17 using }iterator_category = std::bidirectional_iterator_tag;\par
11009 \par
11010             {\cf17 explicit} const_iterator( {\cf17 const} std::string& {\cf18 string} ):\par
11011                 m_string( &string ), m_it( string.begin() ) \{\par
11012                 tryParseAnsiEscapes();\par
11013             \}\par
11014 \par
11015             {\cf18 char} operator*(){\cf17  const }\{ {\cf19 return} *m_it; \}\par
11016 \par
11017             const_iterator& operator++() \{\par
11018                 advance();\par
11019                 {\cf19 return} *{\cf17 this};\par
11020             \}\par
11021             const_iterator operator++( {\cf18 int} ) \{\par
11022                 iterator prev( *{\cf17 this} );\par
11023                 operator++();\par
11024                 {\cf19 return} prev;\par
11025             \}\par
11026             const_iterator& operator--() \{\par
11027                 unadvance();\par
11028                 {\cf19 return} *{\cf17 this};\par
11029             \}\par
11030             const_iterator operator--( {\cf18 int} ) \{\par
11031                 iterator prev( *{\cf17 this} );\par
11032                 operator--();\par
11033                 {\cf19 return} prev;\par
11034             \}\par
11035 \par
11036             {\cf18 bool} operator==( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11037                 {\cf19 return} m_it == other.m_it;\par
11038             \}\par
11039             {\cf18 bool} operator!=( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11040                 {\cf19 return} !operator==( other );\par
11041             \}\par
11042             {\cf18 bool} operator<=( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11043                 {\cf19 return} m_it <= other.m_it;\par
11044             \}\par
11045 \par
11046             const_iterator oneBefore(){\cf17  const }\{\par
11047                 {\cf17 auto} it = *{\cf17 this};\par
11048                 {\cf19 return} --it;\par
11049             \}\par
11050         \};\par
11051 \par
11059         {\cf17 class }Column \{\par
11060             {\cf20 // String to be written out}\par
11061             AnsiSkippingString m_string;\par
11062             {\cf20 // Width of the column for linebreaking}\par
11063             {\cf18 size_t} m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;\par
11064             {\cf20 // Indentation of other lines (including first if initial indent is}\par
11065             {\cf20 // unset)}\par
11066             {\cf18 size_t} m_indent = 0;\par
11067             {\cf20 // Indentation of the first line}\par
11068             {\cf18 size_t} m_initialIndent = std::string::npos;\par
11069 \par
11070         {\cf17 public}:\par
11074             {\cf17 class }const_iterator \{\par
11075                 {\cf17 friend} Column;\par
11076                 {\cf17 struct }EndTag \{\};\par
11077 \par
11078                 Column {\cf17 const}& m_column;\par
11079                 {\cf20 // Where does the current line start?}\par
11080                 AnsiSkippingString::const_iterator m_lineStart;\par
11081                 {\cf20 // How long should the current line be?}\par
11082                 AnsiSkippingString::const_iterator m_lineEnd;\par
11083                 {\cf20 // How far have we checked the string to iterate?}\par
11084                 AnsiSkippingString::const_iterator m_parsedTo;\par
11085                 {\cf20 // Should a '-' be appended to the line?}\par
11086                 {\cf18 bool} m_addHyphen = {\cf17 false};\par
11087 \par
11088                 const_iterator( Column {\cf17 const}& column, EndTag ):\par
11089                     m_column( column ),\par
11090                     m_lineStart( m_column.m_string.end() ),\par
11091                     m_lineEnd( column.m_string.end() ),\par
11092                     m_parsedTo( column.m_string.end() ) \{\}\par
11093 \par
11094                 {\cf20 // Calculates the length of the current line}\par
11095                 {\cf18 void} calcLength();\par
11096 \par
11097                 {\cf20 // Returns current indentation width}\par
11098                 {\cf18 size_t} indentSize() {\cf17 const};\par
11099 \par
11100                 {\cf20 // Creates an indented and (optionally) suffixed string from}\par
11101                 {\cf20 // current iterator position, indentation and length.}\par
11102                 std::string addIndentAndSuffix(\par
11103                     AnsiSkippingString::const_iterator start,\par
11104                     AnsiSkippingString::const_iterator end ) {\cf17 const};\par
11105 \par
11106             {\cf17 public}:\par
11107                 {\cf17 using }difference_type = std::ptrdiff_t;\par
11108                 {\cf17 using }value_type = std::string;\par
11109                 {\cf17 using }pointer = value_type*;\par
11110                 {\cf17 using }reference = value_type&;\par
11111                 {\cf17 using }iterator_category = std::forward_iterator_tag;\par
11112 \par
11113                 {\cf17 explicit} const_iterator( Column {\cf17 const}& column );\par
11114 \par
11115                 std::string operator*() {\cf17 const};\par
11116 \par
11117                 const_iterator& operator++();\par
11118                 const_iterator operator++( {\cf18 int} );\par
11119 \par
11120                 {\cf18 bool} operator==( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11121                     {\cf19 return} m_lineStart == other.m_lineStart &&\par
11122                            &m_column == &other.m_column;\par
11123                 \}\par
11124                 {\cf18 bool} operator!=( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11125                     {\cf19 return} !operator==( other );\par
11126                 \}\par
11127             \};\par
11128             {\cf17 using }iterator = const_iterator;\par
11129 \par
11130             {\cf17 explicit} Column( std::string {\cf17 const}& text ): m_string( text ) \{\}\par
11131             {\cf17 explicit} Column( std::string&& text ):\par
11132                 m_string( CATCH_MOVE( text ) ) \{\}\par
11133 \par
11134             Column& width( {\cf18 size_t} newWidth ) & \{\par
11135                 assert( newWidth > 0 );\par
11136                 m_width = newWidth;\par
11137                 {\cf19 return} *{\cf17 this};\par
11138             \}\par
11139             Column&& width( {\cf18 size_t} newWidth ) && \{\par
11140                 assert( newWidth > 0 );\par
11141                 m_width = newWidth;\par
11142                 {\cf19 return} CATCH_MOVE( *{\cf17 this} );\par
11143             \}\par
11144             Column& indent( {\cf18 size_t} newIndent ) & \{\par
11145                 m_indent = newIndent;\par
11146                 {\cf19 return} *{\cf17 this};\par
11147             \}\par
11148             Column&& indent( {\cf18 size_t} newIndent ) && \{\par
11149                 m_indent = newIndent;\par
11150                 {\cf19 return} CATCH_MOVE( *{\cf17 this} );\par
11151             \}\par
11152             Column& initialIndent( {\cf18 size_t} newIndent ) & \{\par
11153                 m_initialIndent = newIndent;\par
11154                 {\cf19 return} *{\cf17 this};\par
11155             \}\par
11156             Column&& initialIndent( {\cf18 size_t} newIndent ) && \{\par
11157                 m_initialIndent = newIndent;\par
11158                 {\cf19 return} CATCH_MOVE( *{\cf17 this} );\par
11159             \}\par
11160 \par
11161             {\cf18 size_t} width(){\cf17  const }\{ {\cf19 return} m_width; \}\par
11162             const_iterator begin(){\cf17  const }\{ {\cf19 return} const_iterator( *{\cf17 this} ); \}\par
11163             const_iterator end(){\cf17  const }\{\par
11164                 {\cf19 return} \{ *{\cf17 this}, const_iterator::EndTag\{\} \};\par
11165             \}\par
11166 \par
11167             {\cf17 friend} std::ostream& operator<<( std::ostream& os,\par
11168                                              Column {\cf17 const}& col );\par
11169 \par
11170             {\cf17 friend} Columns operator+( Column {\cf17 const}& lhs, Column {\cf17 const}& rhs );\par
11171             {\cf17 friend} Columns operator+( Column&& lhs, Column&& rhs );\par
11172         \};\par
11173 \par
11175         Column Spacer( {\cf18 size_t} spaceWidth );\par
11176 \par
11177         {\cf17 class }Columns \{\par
11178             std::vector<Column> m_columns;\par
11179 \par
11180         {\cf17 public}:\par
11181             {\cf17 class }iterator \{\par
11182                 {\cf17 friend} Columns;\par
11183                 {\cf17 struct }EndTag \{\};\par
11184 \par
11185                 std::vector<Column> {\cf17 const}& m_columns;\par
11186                 std::vector<Column::const_iterator> m_iterators;\par
11187                 {\cf18 size_t} m_activeIterators;\par
11188 \par
11189                 iterator( Columns {\cf17 const}& columns, EndTag );\par
11190 \par
11191             {\cf17 public}:\par
11192                 {\cf17 using }difference_type = std::ptrdiff_t;\par
11193                 {\cf17 using }value_type = std::string;\par
11194                 {\cf17 using }pointer = value_type*;\par
11195                 {\cf17 using }reference = value_type&;\par
11196                 {\cf17 using }iterator_category = std::forward_iterator_tag;\par
11197 \par
11198                 {\cf17 explicit} iterator( Columns {\cf17 const}& columns );\par
11199 \par
11200                 {\cf17 auto} operator==( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
11201                     {\cf19 return} m_iterators == other.m_iterators;\par
11202                 \}\par
11203                 {\cf17 auto} operator!=( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
11204                     {\cf19 return} m_iterators != other.m_iterators;\par
11205                 \}\par
11206                 std::string operator*() {\cf17 const};\par
11207                 iterator& operator++();\par
11208                 iterator operator++( {\cf18 int} );\par
11209             \};\par
11210             {\cf17 using }const_iterator = iterator;\par
11211 \par
11212             iterator begin(){\cf17  const }\{ {\cf19 return} iterator( *{\cf17 this} ); \}\par
11213             iterator end(){\cf17  const }\{ {\cf19 return} \{ *{\cf17 this}, iterator::EndTag() \}; \}\par
11214 \par
11215             {\cf17 friend} Columns& operator+=( Columns& lhs, Column {\cf17 const}& rhs );\par
11216             {\cf17 friend} Columns& operator+=( Columns& lhs, Column&& rhs );\par
11217             {\cf17 friend} Columns operator+( Columns {\cf17 const}& lhs, Column {\cf17 const}& rhs );\par
11218             {\cf17 friend} Columns operator+( Columns&& lhs, Column&& rhs );\par
11219 \par
11220             {\cf17 friend} std::ostream& operator<<( std::ostream& os,\par
11221                                              Columns {\cf17 const}& cols );\par
11222         \};\par
11223 \par
11224     \} {\cf20 // namespace TextFlow}\par
11225 \} {\cf20 // namespace Catch}\par
11226 {\cf21 #endif }{\cf20 // CATCH_TEXTFLOW_HPP_INCLUDED}\par
11227 \par
11228 \par
11229 {\cf21 #ifndef CATCH_TO_STRING_HPP_INCLUDED}\par
11230 {\cf21 #define CATCH_TO_STRING_HPP_INCLUDED}\par
11231 \par
11232 {\cf21 #include <string>}\par
11233 \par
11234 \par
11235 {\cf17 namespace }Catch \{\par
11236     {\cf17 template} <{\cf17 typename} T>\par
11237     std::string to_string(T {\cf17 const}& t) \{\par
11238 {\cf21 #if defined(CATCH_CONFIG_CPP11_TO_STRING)}\par
11239         {\cf19 return} std::to_string(t);\par
11240 {\cf21 #else}\par
11241         ReusableStringStream rss;\par
11242         rss << t;\par
11243         {\cf19 return} rss.str();\par
11244 {\cf21 #endif}\par
11245     \}\par
11246 \} {\cf20 // end namespace Catch}\par
11247 \par
11248 {\cf21 #endif }{\cf20 // CATCH_TO_STRING_HPP_INCLUDED}\par
11249 \par
11250 \par
11251 {\cf21 #ifndef CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
11252 {\cf21 #define CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
11253 \par
11254 {\cf17 namespace }Catch \{\par
11255     {\cf18 bool} uncaught_exceptions();\par
11256 \} {\cf20 // end namespace Catch}\par
11257 \par
11258 {\cf21 #endif }{\cf20 // CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
11259 \par
11260 \par
11261 {\cf21 #ifndef CATCH_XMLWRITER_HPP_INCLUDED}\par
11262 {\cf21 #define CATCH_XMLWRITER_HPP_INCLUDED}\par
11263 \par
11264 \par
11265 {\cf21 #include <iosfwd>}\par
11266 {\cf21 #include <vector>}\par
11267 \par
11268 {\cf17 namespace }Catch \{\par
11269     {\cf17 enum class} XmlFormatting \{\par
11270         None = 0x00,\par
11271         Indent = 0x01,\par
11272         Newline = 0x02,\par
11273     \};\par
11274 \par
11275     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);\par
11276     XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);\par
11277 \par
11284     {\cf17 class }XmlEncode \{\par
11285     {\cf17 public}:\par
11286         {\cf17 enum} ForWhat \{ ForTextNodes, ForAttributes \};\par
11287 \par
11288         XmlEncode( StringRef str, ForWhat forWhat = ForTextNodes );\par
11289 \par
11290         {\cf18 void} encodeTo( std::ostream& os ) {\cf17 const};\par
11291 \par
11292         {\cf17 friend} std::ostream& operator << ( std::ostream& os, XmlEncode {\cf17 const}& xmlEncode );\par
11293 \par
11294     {\cf17 private}:\par
11295         StringRef m_str;\par
11296         ForWhat m_forWhat;\par
11297     \};\par
11298 \par
11299     {\cf17 class }XmlWriter \{\par
11300     {\cf17 public}:\par
11301 \par
11302         {\cf17 class }ScopedElement \{\par
11303         {\cf17 public}:\par
11304             ScopedElement( XmlWriter* writer, XmlFormatting fmt );\par
11305 \par
11306             ScopedElement( ScopedElement&& other ) {\cf17 noexcept};\par
11307             ScopedElement& operator=( ScopedElement&& other ) {\cf17 noexcept};\par
11308 \par
11309             ~ScopedElement();\par
11310 \par
11311             ScopedElement&\par
11312             writeText( StringRef text,\par
11313                        XmlFormatting fmt = XmlFormatting::Newline |\par
11314                                            XmlFormatting::Indent );\par
11315 \par
11316             ScopedElement& writeAttribute( StringRef name,\par
11317                                            StringRef attribute );\par
11318             {\cf17 template} <{\cf17 typename} T,\par
11319                       {\cf20 // Without this SFINAE, this overload is a better match}\par
11320                       {\cf20 // for `std::string`, `char const*`, `char const[N]` args.}\par
11321                       {\cf20 // While it would still work, it would cause code bloat}\par
11322                       {\cf20 // and multiple iteration over the strings}\par
11323                       {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
11324                           !std::is_convertible<T, StringRef>::value>>\par
11325             ScopedElement& writeAttribute( StringRef name,\par
11326                                            T {\cf17 const}& attribute ) \{\par
11327                 m_writer->writeAttribute( name, attribute );\par
11328                 {\cf19 return} *{\cf17 this};\par
11329             \}\par
11330 \par
11331         {\cf17 private}:\par
11332             XmlWriter* m_writer = {\cf17 nullptr};\par
11333             XmlFormatting m_fmt;\par
11334         \};\par
11335 \par
11336         XmlWriter( std::ostream& os );\par
11337         ~XmlWriter();\par
11338 \par
11339         XmlWriter( XmlWriter {\cf17 const}& ) = {\cf17 delete};\par
11340         XmlWriter& operator=( XmlWriter {\cf17 const}& ) = {\cf17 delete};\par
11341 \par
11342         XmlWriter& startElement( std::string {\cf17 const}& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);\par
11343 \par
11344         ScopedElement scopedElement( std::string {\cf17 const}& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);\par
11345 \par
11346         XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);\par
11347 \par
11349         XmlWriter& writeAttribute( StringRef name, StringRef attribute );\par
11350 \par
11352         XmlWriter& writeAttribute( StringRef name, {\cf18 bool} attribute );\par
11353 \par
11355         XmlWriter& writeAttribute( StringRef name, {\cf18 char} {\cf17 const}* attribute );\par
11356 \par
11359         {\cf17 template} <{\cf17 typename} T,\par
11360                   {\cf20 // Without this SFINAE, this overload is a better match}\par
11361                   {\cf20 // for `std::string`, `char const*`, `char const[N]` args.}\par
11362                   {\cf20 // While it would still work, it would cause code bloat}\par
11363                   {\cf20 // and multiple iteration over the strings}\par
11364                   {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
11365                       !std::is_convertible<T, StringRef>::value>>\par
11366         XmlWriter& writeAttribute( StringRef name, T {\cf17 const}& attribute ) \{\par
11367             ReusableStringStream rss;\par
11368             rss << attribute;\par
11369             {\cf19 return} writeAttribute( name, rss.str() );\par
11370         \}\par
11371 \par
11373         XmlWriter& writeText( StringRef text,\par
11374                               XmlFormatting fmt = XmlFormatting::Newline |\par
11375                                                   XmlFormatting::Indent );\par
11376 \par
11378         XmlWriter& writeComment( StringRef text,\par
11379                                  XmlFormatting fmt = XmlFormatting::Newline |\par
11380                                                      XmlFormatting::Indent );\par
11381 \par
11382         {\cf18 void} writeStylesheetRef( StringRef url );\par
11383 \par
11384         {\cf18 void} ensureTagClosed();\par
11385 \par
11386     {\cf17 private}:\par
11387 \par
11388         {\cf18 void} applyFormatting(XmlFormatting fmt);\par
11389 \par
11390         {\cf18 void} writeDeclaration();\par
11391 \par
11392         {\cf18 void} newlineIfNecessary();\par
11393 \par
11394         {\cf18 bool} m_tagIsOpen = {\cf17 false};\par
11395         {\cf18 bool} m_needsNewline = {\cf17 false};\par
11396         std::vector<std::string> m_tags;\par
11397         std::string m_indent;\par
11398         std::ostream& m_os;\par
11399     \};\par
11400 \par
11401 \}\par
11402 \par
11403 {\cf21 #endif }{\cf20 // CATCH_XMLWRITER_HPP_INCLUDED}\par
11404 \par
11405 \par
11418 {\cf21 #ifndef CATCH_MATCHERS_ALL_HPP_INCLUDED}\par
11419 {\cf21 #define CATCH_MATCHERS_ALL_HPP_INCLUDED}\par
11420 \par
11421 \par
11422 \par
11423 {\cf21 #ifndef CATCH_MATCHERS_HPP_INCLUDED}\par
11424 {\cf21 #define CATCH_MATCHERS_HPP_INCLUDED}\par
11425 \par
11426 \par
11427 \par
11428 {\cf21 #ifndef CATCH_MATCHERS_IMPL_HPP_INCLUDED}\par
11429 {\cf21 #define CATCH_MATCHERS_IMPL_HPP_INCLUDED}\par
11430 \par
11431 \par
11432 {\cf21 #include <string>}\par
11433 \par
11434 {\cf17 namespace }Catch \{\par
11435 \par
11436 {\cf21 #ifdef __clang__}\par
11437 {\cf21 #    pragma clang diagnostic push}\par
11438 {\cf21 #    pragma clang diagnostic ignored "-Wsign-compare"}\par
11439 {\cf21 #    pragma clang diagnostic ignored "-Wnon-virtual-dtor"}\par
11440 {\cf21 #elif defined __GNUC__}\par
11441 {\cf21 #    pragma GCC diagnostic push}\par
11442 {\cf21 #    pragma GCC diagnostic ignored "-Wsign-compare"}\par
11443 {\cf21 #    pragma GCC diagnostic ignored "-Wnon-virtual-dtor"}\par
11444 {\cf21 #endif}\par
11445 \par
11446     {\cf17 template}<{\cf17 typename} ArgT, {\cf17 typename} MatcherT>\par
11447     {\cf17 class }MatchExpr : {\cf17 public} ITransientExpression \{\par
11448         ArgT && m_arg;\par
11449         MatcherT {\cf17 const}& m_matcher;\par
11450     {\cf17 public}:\par
11451         MatchExpr( ArgT && arg, MatcherT {\cf17 const}& matcher )\par
11452         :   ITransientExpression\{ true, matcher.match( arg ) \}, {\cf20 // not forwarding arg here on purpose}\par
11453             m_arg( CATCH_FORWARD(arg) ),\par
11454             m_matcher( matcher )\par
11455         \{\}\par
11456 \par
11457         {\cf18 void} streamReconstructedExpression( std::ostream& os ){\cf17  const override }\{\par
11458             os << Catch::Detail::stringify( m_arg )\par
11459                << {\cf23 ' '}\par
11460                << m_matcher.toString();\par
11461         \}\par
11462     \};\par
11463 \par
11464 {\cf21 #ifdef __clang__}\par
11465 {\cf21 #    pragma clang diagnostic pop}\par
11466 {\cf21 #elif defined __GNUC__}\par
11467 {\cf21 #    pragma GCC diagnostic pop}\par
11468 {\cf21 #endif}\par
11469 \par
11470 \par
11471     {\cf17 namespace }Matchers \{\par
11472         {\cf17 template} <{\cf17 typename} ArgT>\par
11473         {\cf17 class }MatcherBase;\par
11474     \}\par
11475 \par
11476     {\cf17 using }StringMatcher = Matchers::MatcherBase<std::string>;\par
11477 \par
11478     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher {\cf17 const}& matcher );\par
11479 \par
11480     {\cf17 template}<{\cf17 typename} ArgT, {\cf17 typename} MatcherT>\par
11481     {\cf17 auto} makeMatchExpr( ArgT && arg, MatcherT {\cf17 const}& matcher ) -> MatchExpr<ArgT, MatcherT> \{\par
11482         {\cf19 return} MatchExpr<ArgT, MatcherT>( CATCH_FORWARD(arg), matcher );\par
11483     \}\par
11484 \par
11485 \} {\cf20 // namespace Catch}\par
11486 \par
11487 \par
11489 {\cf21 #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \\}\par
11490 {\cf21     do \{ \\}\par
11491 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\}\par
11492 {\cf21         INTERNAL_CATCH_TRY \{ \\}\par
11493 {\cf21             catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher ) ); \\}\par
11494 {\cf21         \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\}\par
11495 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
11496 {\cf21     \} while( false )}\par
11497 \par
11498 \par
11500 {\cf21 #define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \\}\par
11501 {\cf21     do \{ \\}\par
11502 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\}\par
11503 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
11504 {\cf21             try \{ \\}\par
11505 {\cf21                 static_cast<void>(__VA_ARGS__ ); \\}\par
11506 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
11507 {\cf21             \} \\}\par
11508 {\cf21             catch( exceptionType const& ex ) \{ \\}\par
11509 {\cf21                 catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher ) ); \\}\par
11510 {\cf21             \} \\}\par
11511 {\cf21             catch( ... ) \{ \\}\par
11512 {\cf21                 catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
11513 {\cf21             \} \\}\par
11514 {\cf21         else \\}\par
11515 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
11516 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
11517 {\cf21     \} while( false )}\par
11518 \par
11519 \par
11520 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_IMPL_HPP_INCLUDED}\par
11521 \par
11522 {\cf21 #include <string>}\par
11523 {\cf21 #include <vector>}\par
11524 \par
11525 {\cf17 namespace }Catch \{\par
11526 {\cf17 namespace }Matchers \{\par
11527 \par
11528     {\cf17 class }MatcherUntypedBase \{\par
11529     {\cf17 public}:\par
11530         MatcherUntypedBase() = {\cf19 default};\par
11531 \par
11532         MatcherUntypedBase(MatcherUntypedBase {\cf17 const}&) = {\cf19 default};\par
11533         MatcherUntypedBase(MatcherUntypedBase&&) = {\cf19 default};\par
11534 \par
11535         MatcherUntypedBase& operator = (MatcherUntypedBase {\cf17 const}&) = {\cf17 delete};\par
11536         MatcherUntypedBase& operator = (MatcherUntypedBase&&) = {\cf17 delete};\par
11537 \par
11538         std::string toString() {\cf17 const};\par
11539 \par
11540     {\cf17 protected}:\par
11541         {\cf17 virtual} ~MatcherUntypedBase(); {\cf20 // = default;}\par
11542         {\cf17 virtual} std::string describe() {\cf17 const} = 0;\par
11543         {\cf17 mutable} std::string m_cachedToString;\par
11544     \};\par
11545 \par
11546 \par
11547     {\cf17 template}<{\cf17 typename} T>\par
11548     {\cf17 class }MatcherBase : {\cf17 public} MatcherUntypedBase \{\par
11549     {\cf17 public}:\par
11550         {\cf17 virtual} {\cf18 bool} match( T {\cf17 const}& arg ) {\cf17 const} = 0;\par
11551     \};\par
11552 \par
11553     {\cf17 namespace }Detail \{\par
11554 \par
11555         {\cf17 template}<{\cf17 typename} ArgT>\par
11556         {\cf17 class }MatchAllOf final : {\cf17 public} MatcherBase<ArgT> \{\par
11557             std::vector<MatcherBase<ArgT> {\cf17 const}*> m_matchers;\par
11558 \par
11559         {\cf17 public}:\par
11560             MatchAllOf() = {\cf19 default};\par
11561             MatchAllOf(MatchAllOf {\cf17 const}&) = {\cf17 delete};\par
11562             MatchAllOf& operator=(MatchAllOf {\cf17 const}&) = {\cf17 delete};\par
11563             MatchAllOf(MatchAllOf&&) = {\cf19 default};\par
11564             MatchAllOf& operator=(MatchAllOf&&) = {\cf19 default};\par
11565 \par
11566 \par
11567             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
11568                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11569                     {\cf19 if} (!matcher->match(arg))\par
11570                         {\cf19 return} {\cf17 false};\par
11571                 \}\par
11572                 {\cf19 return} {\cf17 true};\par
11573             \}\par
11574             std::string describe(){\cf17  const override }\{\par
11575                 std::string description;\par
11576                 description.reserve( 4 + m_matchers.size()*32 );\par
11577                 description += {\cf22 "( "};\par
11578                 {\cf18 bool} first = {\cf17 true};\par
11579                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11580                     {\cf19 if}( first )\par
11581                         first = {\cf17 false};\par
11582                     {\cf19 else}\par
11583                         description += {\cf22 " and "};\par
11584                     description += matcher->toString();\par
11585                 \}\par
11586                 description += {\cf22 " )"};\par
11587                 {\cf19 return} description;\par
11588             \}\par
11589 \par
11590             {\cf17 friend} MatchAllOf operator&& (MatchAllOf&& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) \{\par
11591                 lhs.m_matchers.push_back(&rhs);\par
11592                 {\cf19 return} CATCH_MOVE(lhs);\par
11593             \}\par
11594             {\cf17 friend} MatchAllOf operator&& (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAllOf&& rhs) \{\par
11595                 rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);\par
11596                 {\cf19 return} CATCH_MOVE(rhs);\par
11597             \}\par
11598         \};\par
11599 \par
11602         {\cf17 template}<{\cf17 typename} ArgT>\par
11603         MatchAllOf<ArgT> operator&& (MatchAllOf<ArgT> {\cf17 const}& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11606         {\cf17 template}<{\cf17 typename} ArgT>\par
11607         MatchAllOf<ArgT> operator&& (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAllOf<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11608 \par
11609         {\cf17 template}<{\cf17 typename} ArgT>\par
11610         {\cf17 class }MatchAnyOf final : {\cf17 public} MatcherBase<ArgT> \{\par
11611             std::vector<MatcherBase<ArgT> {\cf17 const}*> m_matchers;\par
11612         {\cf17 public}:\par
11613             MatchAnyOf() = {\cf19 default};\par
11614             MatchAnyOf(MatchAnyOf {\cf17 const}&) = {\cf17 delete};\par
11615             MatchAnyOf& operator=(MatchAnyOf {\cf17 const}&) = {\cf17 delete};\par
11616             MatchAnyOf(MatchAnyOf&&) = {\cf19 default};\par
11617             MatchAnyOf& operator=(MatchAnyOf&&) = {\cf19 default};\par
11618 \par
11619             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
11620                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11621                     {\cf19 if} (matcher->match(arg))\par
11622                         {\cf19 return} {\cf17 true};\par
11623                 \}\par
11624                 {\cf19 return} {\cf17 false};\par
11625             \}\par
11626             std::string describe(){\cf17  const override }\{\par
11627                 std::string description;\par
11628                 description.reserve( 4 + m_matchers.size()*32 );\par
11629                 description += {\cf22 "( "};\par
11630                 {\cf18 bool} first = {\cf17 true};\par
11631                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11632                     {\cf19 if}( first )\par
11633                         first = {\cf17 false};\par
11634                     {\cf19 else}\par
11635                         description += {\cf22 " or "};\par
11636                     description += matcher->toString();\par
11637                 \}\par
11638                 description += {\cf22 " )"};\par
11639                 {\cf19 return} description;\par
11640             \}\par
11641 \par
11642             {\cf17 friend} MatchAnyOf operator|| (MatchAnyOf&& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) \{\par
11643                 lhs.m_matchers.push_back(&rhs);\par
11644                 {\cf19 return} CATCH_MOVE(lhs);\par
11645             \}\par
11646             {\cf17 friend} MatchAnyOf operator|| (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAnyOf&& rhs) \{\par
11647                 rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);\par
11648                 {\cf19 return} CATCH_MOVE(rhs);\par
11649             \}\par
11650         \};\par
11651 \par
11654         {\cf17 template}<{\cf17 typename} ArgT>\par
11655         MatchAnyOf<ArgT> operator|| (MatchAnyOf<ArgT> {\cf17 const}& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11658         {\cf17 template}<{\cf17 typename} ArgT>\par
11659         MatchAnyOf<ArgT> operator|| (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAnyOf<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11660 \par
11661         {\cf17 template}<{\cf17 typename} ArgT>\par
11662         {\cf17 class }MatchNotOf final : {\cf17 public} MatcherBase<ArgT> \{\par
11663             MatcherBase<ArgT> {\cf17 const}& m_underlyingMatcher;\par
11664 \par
11665         {\cf17 public}:\par
11666             {\cf17 explicit} MatchNotOf( MatcherBase<ArgT> {\cf17 const}& underlyingMatcher ):\par
11667                 m_underlyingMatcher( underlyingMatcher )\par
11668             \{\}\par
11669 \par
11670             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
11671                 {\cf19 return} !m_underlyingMatcher.match( arg );\par
11672             \}\par
11673 \par
11674             std::string describe(){\cf17  const override }\{\par
11675                 {\cf19 return} {\cf22 "not "} + m_underlyingMatcher.toString();\par
11676             \}\par
11677         \};\par
11678 \par
11679     \} {\cf20 // namespace Detail}\par
11680 \par
11681     {\cf17 template} <{\cf17 typename} T>\par
11682     Detail::MatchAllOf<T> operator&& (MatcherBase<T> {\cf17 const}& lhs, MatcherBase<T> {\cf17 const}& rhs) \{\par
11683         {\cf19 return} Detail::MatchAllOf<T>\{\} && lhs && rhs;\par
11684     \}\par
11685     {\cf17 template} <{\cf17 typename} T>\par
11686     Detail::MatchAnyOf<T> operator|| (MatcherBase<T> {\cf17 const}& lhs, MatcherBase<T> {\cf17 const}& rhs) \{\par
11687         {\cf19 return} Detail::MatchAnyOf<T>\{\} || lhs || rhs;\par
11688     \}\par
11689 \par
11690     {\cf17 template} <{\cf17 typename} T>\par
11691     Detail::MatchNotOf<T> operator! (MatcherBase<T> {\cf17 const}& matcher) \{\par
11692         {\cf19 return} Detail::MatchNotOf<T>\{ matcher \};\par
11693     \}\par
11694 \par
11695 \par
11696 \} {\cf20 // namespace Matchers}\par
11697 \} {\cf20 // namespace Catch}\par
11698 \par
11699 \par
11700 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
11701 {\cf21   #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )}\par
11702 {\cf21   #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}\par
11703 \par
11704 {\cf21   #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11705 {\cf21   #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11706 \par
11707 {\cf21   #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}\par
11708 {\cf21   #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )}\par
11709 \par
11710 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
11711 \par
11712 {\cf21   #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)}\par
11713 {\cf21   #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
11714 \par
11715 {\cf21   #define CATCH_CHECK_THROWS_WITH( expr, matcher )                     (void)(0)}\par
11716 {\cf21   #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)}\par
11717 \par
11718 {\cf21   #define CATCH_CHECK_THAT( arg, matcher )                             (void)(0)}\par
11719 {\cf21   #define CATCH_REQUIRE_THAT( arg, matcher )                           (void)(0)}\par
11720 \par
11721 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
11722 \par
11723 {\cf21   #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )}\par
11724 {\cf21   #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}\par
11725 \par
11726 {\cf21   #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11727 {\cf21   #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11728 \par
11729 {\cf21   #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}\par
11730 {\cf21   #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )}\par
11731 \par
11732 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
11733 \par
11734 {\cf21   #define REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)}\par
11735 {\cf21   #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
11736 \par
11737 {\cf21   #define CHECK_THROWS_WITH( expr, matcher )                     (void)(0)}\par
11738 {\cf21   #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)}\par
11739 \par
11740 {\cf21   #define CHECK_THAT( arg, matcher )                             (void)(0)}\par
11741 {\cf21   #define REQUIRE_THAT( arg, matcher )                           (void)(0)}\par
11742 \par
11743 {\cf21 #endif }{\cf20 // end of user facing macro declarations}\par
11744 \par
11745 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_HPP_INCLUDED}\par
11746 \par
11747 \par
11748 {\cf21 #ifndef CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED}\par
11749 {\cf21 #define CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED}\par
11750 \par
11751 \par
11752 \par
11753 {\cf21 #ifndef CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED}\par
11754 {\cf21 #define CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED}\par
11755 \par
11756 \par
11757 {\cf21 #include <array>}\par
11758 {\cf21 #include <algorithm>}\par
11759 {\cf21 #include <string>}\par
11760 {\cf21 #include <type_traits>}\par
11761 \par
11762 {\cf17 namespace }Catch \{\par
11763 {\cf17 namespace }Matchers \{\par
11764     {\cf17 class }MatcherGenericBase : {\cf17 public} MatcherUntypedBase \{\par
11765     {\cf17 public}:\par
11766         MatcherGenericBase() = {\cf19 default};\par
11767         ~MatcherGenericBase() {\cf17 override}; {\cf20 // = default;}\par
11768 \par
11769         MatcherGenericBase(MatcherGenericBase {\cf17 const}&) = {\cf19 default};\par
11770         MatcherGenericBase(MatcherGenericBase&&) = {\cf19 default};\par
11771 \par
11772         MatcherGenericBase& operator=(MatcherGenericBase {\cf17 const}&) = {\cf17 delete};\par
11773         MatcherGenericBase& operator=(MatcherGenericBase&&) = {\cf17 delete};\par
11774     \};\par
11775 \par
11776 \par
11777     {\cf17 namespace }Detail \{\par
11778         {\cf17 template}<std::{\cf18 size_t} N, std::{\cf18 size_t} M>\par
11779         std::array<void const*, N + M> array_cat(std::array<void const*, N> && lhs, std::array<void const*, M> && rhs) \{\par
11780             std::array<void const*, N + M> arr\{\};\par
11781             std::copy_n(lhs.begin(), N, arr.begin());\par
11782             std::copy_n(rhs.begin(), M, arr.begin() + N);\par
11783             {\cf19 return} arr;\par
11784         \}\par
11785 \par
11786         {\cf17 template}<std::{\cf18 size_t} N>\par
11787         std::array<void const*, N+1> array_cat(std::array<void const*, N> && lhs, {\cf18 void} {\cf17 const}* rhs) \{\par
11788             std::array<void const*, N+1> arr\{\};\par
11789             std::copy_n(lhs.begin(), N, arr.begin());\par
11790             arr[N] = rhs;\par
11791             {\cf19 return} arr;\par
11792         \}\par
11793 \par
11794         {\cf17 template}<std::{\cf18 size_t} N>\par
11795         std::array<void const*, N+1> array_cat({\cf18 void} {\cf17 const}* lhs, std::array<void const*, N> && rhs) \{\par
11796             std::array<void const*, N + 1> arr\{ \{lhs\} \};\par
11797             std::copy_n(rhs.begin(), N, arr.begin() + 1);\par
11798             {\cf19 return} arr;\par
11799         \}\par
11800 \par
11801         {\cf17 template}<{\cf17 typename} T>\par
11802         {\cf17 using }is_generic_matcher = std::is_base_of<\par
11803             Catch::Matchers::MatcherGenericBase,\par
11804             std::remove_cv_t<std::remove_reference_t<T>>\par
11805         >;\par
11806 \par
11807         {\cf17 template}<{\cf17 typename}... Ts>\par
11808         {\cf17 using }are_generic_matchers = Catch::Detail::conjunction<is_generic_matcher<Ts>...>;\par
11809 \par
11810         {\cf17 template}<{\cf17 typename} T>\par
11811         {\cf17 using }is_matcher = std::is_base_of<\par
11812             Catch::Matchers::MatcherUntypedBase,\par
11813             std::remove_cv_t<std::remove_reference_t<T>>\par
11814         >;\par
11815 \par
11816 \par
11817         {\cf17 template}<std::{\cf18 size_t} N, {\cf17 typename} Arg>\par
11818         {\cf18 bool} match_all_of(Arg&&, std::array<void const*, N> {\cf17 const}&, std::index_sequence<>) \{\par
11819             {\cf19 return} {\cf17 true};\par
11820         \}\par
11821 \par
11822         {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... MatcherTs, std::size_t N, {\cf17 typename} Arg, std::size_t Idx, std::size_t... Indices>\par
11823         {\cf18 bool} match_all_of(Arg&& arg, std::array<void const*, N> {\cf17 const}& matchers, std::index_sequence<Idx, Indices...>) \{\par
11824             {\cf19 return} {\cf17 static_cast<}T const*{\cf17 >}(matchers[Idx])->match(arg) && match_all_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});\par
11825         \}\par
11826 \par
11827 \par
11828         {\cf17 template}<std::{\cf18 size_t} N, {\cf17 typename} Arg>\par
11829         {\cf18 bool} match_any_of(Arg&&, std::array<void const*, N> {\cf17 const}&, std::index_sequence<>) \{\par
11830             {\cf19 return} {\cf17 false};\par
11831         \}\par
11832 \par
11833         {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... MatcherTs, std::size_t N, {\cf17 typename} Arg, std::size_t Idx, std::size_t... Indices>\par
11834         {\cf18 bool} match_any_of(Arg&& arg, std::array<void const*, N> {\cf17 const}& matchers, std::index_sequence<Idx, Indices...>) \{\par
11835             {\cf19 return} {\cf17 static_cast<}T const*{\cf17 >}(matchers[Idx])->match(arg) || match_any_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});\par
11836         \}\par
11837 \par
11838         std::string describe_multi_matcher(StringRef combine, std::string {\cf17 const}* descriptions_begin, std::string {\cf17 const}* descriptions_end);\par
11839 \par
11840         {\cf17 template}<{\cf17 typename}... MatcherTs, std::size_t... Idx>\par
11841         std::string describe_multi_matcher(StringRef combine, std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...(MatcherTs)> {\cf17 const}& matchers, std::index_sequence<Idx...>) \{\par
11842             std::array<std::string, {\cf17 sizeof}...(MatcherTs)> descriptions \{\{\par
11843                 {\cf17 static_cast<}MatcherTs const*{\cf17 >}(matchers[Idx])->toString()...\par
11844             \}\};\par
11845 \par
11846             {\cf19 return} describe_multi_matcher(combine, descriptions.data(), descriptions.data() + descriptions.size());\par
11847         \}\par
11848 \par
11849 \par
11850         {\cf17 template}<{\cf17 typename}... MatcherTs>\par
11851         {\cf17 class }MatchAllOfGeneric final : {\cf17 public} MatcherGenericBase \{\par
11852         {\cf17 public}:\par
11853             MatchAllOfGeneric(MatchAllOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11854             MatchAllOfGeneric& operator=(MatchAllOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11855             MatchAllOfGeneric(MatchAllOfGeneric&&) = {\cf19 default};\par
11856             MatchAllOfGeneric& operator=(MatchAllOfGeneric&&) = {\cf19 default};\par
11857 \par
11858             MatchAllOfGeneric(MatcherTs {\cf17 const}&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}\par
11859             {\cf17 explicit} MatchAllOfGeneric(std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}\par
11860 \par
11861             {\cf17 template}<{\cf17 typename} Arg>\par
11862             {\cf18 bool} match(Arg&& arg){\cf17  const }\{\par
11863                 {\cf19 return} match_all_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11864             \}\par
11865 \par
11866             std::string describe(){\cf17  const override }\{\par
11867                 {\cf19 return} describe_multi_matcher<MatcherTs...>({\cf22 " and "}_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11868             \}\par
11869 \par
11870             {\cf20 // Has to be public to enable the concatenating operators}\par
11871             {\cf20 // below, because they are not friend of the RHS, only LHS,}\par
11872             {\cf20 // and thus cannot access private fields of RHS}\par
11873             std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...( MatcherTs )> m_matchers;\par
11874 \par
11875 \par
11877             {\cf17 template}<{\cf17 typename}... MatchersRHS>\par
11878             {\cf17 friend}\par
11879             MatchAllOfGeneric<MatcherTs..., MatchersRHS...> operator && (\par
11880                     MatchAllOfGeneric<MatcherTs...>&& lhs,\par
11881                     MatchAllOfGeneric<MatchersRHS...>&& rhs) \{\par
11882                 {\cf19 return} MatchAllOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};\par
11883             \}\par
11884 \par
11886             {\cf17 template}<{\cf17 typename} MatcherRHS>\par
11887             {\cf17 friend} std::enable_if_t<is_matcher<MatcherRHS>::value,\par
11888             MatchAllOfGeneric<MatcherTs..., MatcherRHS>> operator && (\par
11889                     MatchAllOfGeneric<MatcherTs...>&& lhs,\par
11890                     MatcherRHS {\cf17 const}& rhs) \{\par
11891                 {\cf19 return} MatchAllOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), {\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(&rhs))\};\par
11892             \}\par
11893 \par
11895             {\cf17 template}<{\cf17 typename} MatcherLHS>\par
11896             {\cf17 friend} std::enable_if_t<is_matcher<MatcherLHS>::value,\par
11897             MatchAllOfGeneric<MatcherLHS, MatcherTs...>> operator && (\par
11898                     MatcherLHS {\cf17 const}& lhs,\par
11899                     MatchAllOfGeneric<MatcherTs...>&& rhs) \{\par
11900                 {\cf19 return} MatchAllOfGeneric<MatcherLHS, MatcherTs...>\{array_cat({\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};\par
11901             \}\par
11902         \};\par
11903 \par
11904 \par
11905         {\cf17 template}<{\cf17 typename}... MatcherTs>\par
11906         {\cf17 class }MatchAnyOfGeneric final : {\cf17 public} MatcherGenericBase \{\par
11907         {\cf17 public}:\par
11908             MatchAnyOfGeneric(MatchAnyOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11909             MatchAnyOfGeneric& operator=(MatchAnyOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11910             MatchAnyOfGeneric(MatchAnyOfGeneric&&) = {\cf19 default};\par
11911             MatchAnyOfGeneric& operator=(MatchAnyOfGeneric&&) = {\cf19 default};\par
11912 \par
11913             MatchAnyOfGeneric(MatcherTs {\cf17 const}&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}\par
11914             {\cf17 explicit} MatchAnyOfGeneric(std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}\par
11915 \par
11916             {\cf17 template}<{\cf17 typename} Arg>\par
11917             {\cf18 bool} match(Arg&& arg){\cf17  const }\{\par
11918                 {\cf19 return} match_any_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11919             \}\par
11920 \par
11921             std::string describe(){\cf17  const override }\{\par
11922                 {\cf19 return} describe_multi_matcher<MatcherTs...>({\cf22 " or "}_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11923             \}\par
11924 \par
11925 \par
11926             {\cf20 // Has to be public to enable the concatenating operators}\par
11927             {\cf20 // below, because they are not friend of the RHS, only LHS,}\par
11928             {\cf20 // and thus cannot access private fields of RHS}\par
11929             std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...( MatcherTs )> m_matchers;\par
11930 \par
11932             {\cf17 template}<{\cf17 typename}... MatchersRHS>\par
11933             {\cf17 friend} MatchAnyOfGeneric<MatcherTs..., MatchersRHS...> operator || (\par
11934                     MatchAnyOfGeneric<MatcherTs...>&& lhs,\par
11935                     MatchAnyOfGeneric<MatchersRHS...>&& rhs) \{\par
11936                 {\cf19 return} MatchAnyOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};\par
11937             \}\par
11938 \par
11940             {\cf17 template}<{\cf17 typename} MatcherRHS>\par
11941             {\cf17 friend} std::enable_if_t<is_matcher<MatcherRHS>::value,\par
11942             MatchAnyOfGeneric<MatcherTs..., MatcherRHS>> operator || (\par
11943                     MatchAnyOfGeneric<MatcherTs...>&& lhs,\par
11944                     MatcherRHS {\cf17 const}& rhs) \{\par
11945                 {\cf19 return} MatchAnyOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), {\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(std::addressof(rhs)))\};\par
11946             \}\par
11947 \par
11949             {\cf17 template}<{\cf17 typename} MatcherLHS>\par
11950             {\cf17 friend} std::enable_if_t<is_matcher<MatcherLHS>::value,\par
11951             MatchAnyOfGeneric<MatcherLHS, MatcherTs...>> operator || (\par
11952                 MatcherLHS {\cf17 const}& lhs,\par
11953                 MatchAnyOfGeneric<MatcherTs...>&& rhs) \{\par
11954                 {\cf19 return} MatchAnyOfGeneric<MatcherLHS, MatcherTs...>\{array_cat({\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};\par
11955             \}\par
11956         \};\par
11957 \par
11958 \par
11959         {\cf17 template}<{\cf17 typename} MatcherT>\par
11960         {\cf17 class }MatchNotOfGeneric final : {\cf17 public} MatcherGenericBase \{\par
11961             MatcherT {\cf17 const}& m_matcher;\par
11962 \par
11963         {\cf17 public}:\par
11964             MatchNotOfGeneric(MatchNotOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11965             MatchNotOfGeneric& operator=(MatchNotOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11966             MatchNotOfGeneric(MatchNotOfGeneric&&) = {\cf19 default};\par
11967             MatchNotOfGeneric& operator=(MatchNotOfGeneric&&) = {\cf19 default};\par
11968 \par
11969             {\cf17 explicit} MatchNotOfGeneric(MatcherT {\cf17 const}& matcher) : m_matcher\{matcher\} \{\}\par
11970 \par
11971             {\cf17 template}<{\cf17 typename} Arg>\par
11972             {\cf18 bool} match(Arg&& arg){\cf17  const }\{\par
11973                 {\cf19 return} !m_matcher.match(arg);\par
11974             \}\par
11975 \par
11976             std::string describe(){\cf17  const override }\{\par
11977                 {\cf19 return} {\cf22 "not "} + m_matcher.toString();\par
11978             \}\par
11979 \par
11981             {\cf17 friend} MatcherT {\cf17 const}& operator ! (MatchNotOfGeneric<MatcherT> {\cf17 const}& matcher) \{\par
11982                 {\cf19 return} matcher.m_matcher;\par
11983             \}\par
11984         \};\par
11985     \} {\cf20 // namespace Detail}\par
11986 \par
11987 \par
11988     {\cf20 // compose only generic matchers}\par
11989     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} MatcherRHS>\par
11990     std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherRHS>>\par
11991         operator && (MatcherLHS {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
11992         {\cf19 return} \{ lhs, rhs \};\par
11993     \}\par
11994 \par
11995     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} MatcherRHS>\par
11996     std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherRHS>>\par
11997         operator || (MatcherLHS {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
11998         {\cf19 return} \{ lhs, rhs \};\par
11999     \}\par
12000 \par
12002     {\cf17 template}<{\cf17 typename} MatcherT>\par
12003     std::enable_if_t<Detail::is_generic_matcher<MatcherT>::value, Detail::MatchNotOfGeneric<MatcherT>>\par
12004         operator ! (MatcherT {\cf17 const}& matcher) \{\par
12005         {\cf19 return} Detail::MatchNotOfGeneric<MatcherT>\{matcher\};\par
12006     \}\par
12007 \par
12008 \par
12009     {\cf20 // compose mixed generic and non-generic matchers}\par
12010     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} ArgRHS>\par
12011     std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>\par
12012         operator && (MatcherLHS {\cf17 const}& lhs, MatcherBase<ArgRHS> {\cf17 const}& rhs) \{\par
12013         {\cf19 return} \{ lhs, rhs \};\par
12014     \}\par
12015 \par
12016     {\cf17 template}<{\cf17 typename} ArgLHS, {\cf17 typename} MatcherRHS>\par
12017     std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>\par
12018         operator && (MatcherBase<ArgLHS> {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
12019         {\cf19 return} \{ lhs, rhs \};\par
12020     \}\par
12021 \par
12022     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} ArgRHS>\par
12023     std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>\par
12024         operator || (MatcherLHS {\cf17 const}& lhs, MatcherBase<ArgRHS> {\cf17 const}& rhs) \{\par
12025         {\cf19 return} \{ lhs, rhs \};\par
12026     \}\par
12027 \par
12028     {\cf17 template}<{\cf17 typename} ArgLHS, {\cf17 typename} MatcherRHS>\par
12029     std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>\par
12030         operator || (MatcherBase<ArgLHS> {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
12031         {\cf19 return} \{ lhs, rhs \};\par
12032     \}\par
12033 \par
12034 \} {\cf20 // namespace Matchers}\par
12035 \} {\cf20 // namespace Catch}\par
12036 \par
12037 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED}\par
12038 \par
12039 {\cf17 namespace }Catch \{\par
12040     {\cf17 namespace }Matchers \{\par
12041 \par
12042         {\cf17 class }IsEmptyMatcher final : {\cf17 public} MatcherGenericBase \{\par
12043         {\cf17 public}:\par
12044             {\cf17 template} <{\cf17 typename} RangeLike>\par
12045             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12046 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
12047                 {\cf17 using }Catch::Detail::empty;\par
12048 {\cf21 #else}\par
12049                 {\cf17 using }std::empty;\par
12050 {\cf21 #endif}\par
12051                 {\cf19 return} empty(rng);\par
12052             \}\par
12053 \par
12054             std::string describe() {\cf17 const override};\par
12055         \};\par
12056 \par
12057         {\cf17 class }HasSizeMatcher final : {\cf17 public} MatcherGenericBase \{\par
12058             std::size_t m_target_size;\par
12059         {\cf17 public}:\par
12060             {\cf17 explicit} HasSizeMatcher(std::size_t target_size):\par
12061                 m_target_size(target_size)\par
12062             \{\}\par
12063 \par
12064             {\cf17 template} <{\cf17 typename} RangeLike>\par
12065             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12066 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
12067                 {\cf17 using }Catch::Detail::size;\par
12068 {\cf21 #else}\par
12069                 {\cf17 using }std::size;\par
12070 {\cf21 #endif}\par
12071                 {\cf19 return} size(rng) == m_target_size;\par
12072             \}\par
12073 \par
12074             std::string describe() {\cf17 const override};\par
12075         \};\par
12076 \par
12077         {\cf17 template} <{\cf17 typename} Matcher>\par
12078         {\cf17 class }SizeMatchesMatcher final : {\cf17 public} MatcherGenericBase \{\par
12079             Matcher m_matcher;\par
12080         {\cf17 public}:\par
12081             {\cf17 explicit} SizeMatchesMatcher(Matcher m):\par
12082                 m_matcher(CATCH_MOVE(m))\par
12083             \{\}\par
12084 \par
12085             {\cf17 template} <{\cf17 typename} RangeLike>\par
12086             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12087 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
12088                 {\cf17 using }Catch::Detail::size;\par
12089 {\cf21 #else}\par
12090                 {\cf17 using }std::size;\par
12091 {\cf21 #endif}\par
12092                 {\cf19 return} m_matcher.match(size(rng));\par
12093             \}\par
12094 \par
12095             std::string describe(){\cf17  const override }\{\par
12096                 {\cf19 return} {\cf22 "size matches "} + m_matcher.describe();\par
12097             \}\par
12098         \};\par
12099 \par
12100 \par
12102         IsEmptyMatcher IsEmpty();\par
12104         HasSizeMatcher SizeIs(std::size_t sz);\par
12105         {\cf17 template} <{\cf17 typename} Matcher>\par
12106         std::enable_if_t<Detail::is_matcher<Matcher>::value,\par
12107         SizeMatchesMatcher<Matcher>> SizeIs(Matcher&& m) \{\par
12108             {\cf19 return} SizeMatchesMatcher<Matcher>\{CATCH_FORWARD(m)\};\par
12109         \}\par
12110 \par
12111     \} {\cf20 // end namespace Matchers}\par
12112 \} {\cf20 // end namespace Catch}\par
12113 \par
12114 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED}\par
12115 \par
12116 \par
12117 {\cf21 #ifndef CATCH_MATCHERS_CONTAINS_HPP_INCLUDED}\par
12118 {\cf21 #define CATCH_MATCHERS_CONTAINS_HPP_INCLUDED}\par
12119 \par
12120 \par
12121 {\cf21 #include <algorithm>}\par
12122 {\cf21 #include <functional>}\par
12123 \par
12124 {\cf17 namespace }Catch \{\par
12125     {\cf17 namespace }Matchers \{\par
12127         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Equality>\par
12128         {\cf17 class }ContainsElementMatcher final : {\cf17 public} MatcherGenericBase \{\par
12129             T m_desired;\par
12130             Equality m_eq;\par
12131         {\cf17 public}:\par
12132             {\cf17 template} <{\cf17 typename} T2, {\cf17 typename} Equality2>\par
12133             ContainsElementMatcher(T2&& target, Equality2&& predicate):\par
12134                 m_desired(CATCH_FORWARD(target)),\par
12135                 m_eq(CATCH_FORWARD(predicate))\par
12136             \{\}\par
12137 \par
12138             std::string describe(){\cf17  const override }\{\par
12139                 {\cf19 return} {\cf22 "contains element "} + Catch::Detail::stringify(m_desired);\par
12140             \}\par
12141 \par
12142             {\cf17 template} <{\cf17 typename} RangeLike>\par
12143             {\cf18 bool} match( RangeLike&& rng ){\cf17  const }\{\par
12144                 {\cf19 for} ( {\cf17 auto}&& elem : rng ) \{\par
12145                     {\cf19 if} ( m_eq( elem, m_desired ) ) \{ {\cf19 return} {\cf17 true}; \}\par
12146                 \}\par
12147                 {\cf19 return} {\cf17 false};\par
12148             \}\par
12149         \};\par
12150 \par
12152         {\cf17 template} <{\cf17 typename} Matcher>\par
12153         {\cf17 class }ContainsMatcherMatcher final : {\cf17 public} MatcherGenericBase \{\par
12154             Matcher m_matcher;\par
12155         {\cf17 public}:\par
12156             {\cf20 // Note that we do a copy+move to avoid having to SFINAE this}\par
12157             {\cf20 // constructor (and also avoid some perfect forwarding failure}\par
12158             {\cf20 // cases)}\par
12159             ContainsMatcherMatcher(Matcher matcher):\par
12160                 m_matcher(CATCH_MOVE(matcher))\par
12161             \{\}\par
12162 \par
12163             {\cf17 template} <{\cf17 typename} RangeLike>\par
12164             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12165                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12166                     {\cf19 if} (m_matcher.match(elem)) \{\par
12167                         {\cf19 return} {\cf17 true};\par
12168                     \}\par
12169                 \}\par
12170                 {\cf19 return} {\cf17 false};\par
12171             \}\par
12172 \par
12173             std::string describe(){\cf17  const override }\{\par
12174                 {\cf19 return} {\cf22 "contains element matching "} + m_matcher.describe();\par
12175             \}\par
12176         \};\par
12177 \par
12183         {\cf17 template} <{\cf17 typename} T>\par
12184         std::enable_if_t<!Detail::is_matcher<T>::value,\par
12185         ContainsElementMatcher<T, std::equal_to<>>> Contains(T&& elem) \{\par
12186             {\cf19 return} \{ CATCH_FORWARD(elem), std::equal_to<>\{\} \};\par
12187         \}\par
12188 \par
12190         {\cf17 template} <{\cf17 typename} Matcher>\par
12191         std::enable_if_t<Detail::is_matcher<Matcher>::value,\par
12192         ContainsMatcherMatcher<Matcher>> Contains(Matcher&& matcher) \{\par
12193             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12194         \}\par
12195 \par
12201         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Equality>\par
12202         ContainsElementMatcher<T, Equality> Contains(T&& elem, Equality&& eq) \{\par
12203             {\cf19 return} \{ CATCH_FORWARD(elem), CATCH_FORWARD(eq) \};\par
12204         \}\par
12205 \par
12206     \}\par
12207 \}\par
12208 \par
12209 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_CONTAINS_HPP_INCLUDED}\par
12210 \par
12211 \par
12212 {\cf21 #ifndef CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED}\par
12213 {\cf21 #define CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED}\par
12214 \par
12215 \par
12216 {\cf17 namespace }Catch \{\par
12217 {\cf17 namespace }Matchers \{\par
12218 \par
12219 {\cf17 class }ExceptionMessageMatcher final : {\cf17 public} MatcherBase<std::exception> \{\par
12220     std::string m_message;\par
12221 {\cf17 public}:\par
12222 \par
12223     ExceptionMessageMatcher(std::string {\cf17 const}& message):\par
12224         m_message(message)\par
12225     \{\}\par
12226 \par
12227     {\cf18 bool} match(std::exception {\cf17 const}& ex) {\cf17 const override};\par
12228 \par
12229     std::string describe() {\cf17 const override};\par
12230 \};\par
12231 \par
12233 ExceptionMessageMatcher Message(std::string {\cf17 const}& message);\par
12234 \par
12235 {\cf17 template} <{\cf17 typename} StringMatcherType>\par
12236 {\cf17 class }ExceptionMessageMatchesMatcher final\par
12237     : {\cf17 public} MatcherBase<std::exception> \{\par
12238     StringMatcherType m_matcher;\par
12239 \par
12240 {\cf17 public}:\par
12241     ExceptionMessageMatchesMatcher( StringMatcherType matcher ):\par
12242         m_matcher( CATCH_MOVE( matcher ) ) \{\}\par
12243 \par
12244     {\cf18 bool} match( std::exception {\cf17 const}& ex ){\cf17  const override }\{\par
12245         {\cf19 return} m_matcher.match( ex.what() );\par
12246     \}\par
12247 \par
12248     std::string describe(){\cf17  const override }\{\par
12249         {\cf19 return} {\cf22 " matches \\""} + m_matcher.describe() + {\cf23 '"'};\par
12250     \}\par
12251 \};\par
12252 \par
12255 {\cf17 template} <{\cf17 typename} StringMatcherType>\par
12256 ExceptionMessageMatchesMatcher<StringMatcherType>\par
12257 MessageMatches( StringMatcherType&& matcher ) \{\par
12258     {\cf19 return} \{ CATCH_FORWARD( matcher ) \};\par
12259 \}\par
12260 \par
12261 \} {\cf20 // namespace Matchers}\par
12262 \} {\cf20 // namespace Catch}\par
12263 \par
12264 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED}\par
12265 \par
12266 \par
12267 {\cf21 #ifndef CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED}\par
12268 {\cf21 #define CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED}\par
12269 \par
12270 \par
12271 {\cf17 namespace }Catch \{\par
12272 {\cf17 namespace }Matchers \{\par
12273 \par
12274     {\cf17 namespace }Detail \{\par
12275         {\cf17 enum class} FloatingPointKind : uint8_t;\par
12276     \}\par
12277 \par
12278     {\cf17 class  }WithinAbsMatcher final : {\cf17 public} MatcherBase<double> \{\par
12279     {\cf17 public}:\par
12280         WithinAbsMatcher({\cf18 double} target, {\cf18 double} margin);\par
12281         {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
12282         std::string describe() {\cf17 const override};\par
12283     {\cf17 private}:\par
12284         {\cf18 double} m_target;\par
12285         {\cf18 double} m_margin;\par
12286     \};\par
12287 \par
12289     WithinAbsMatcher WithinAbs( {\cf18 double} target, {\cf18 double} margin );\par
12290 \par
12291 \par
12292 \par
12293     {\cf17 class }WithinUlpsMatcher final : {\cf17 public} MatcherBase<double> \{\par
12294     {\cf17 public}:\par
12295         WithinUlpsMatcher( {\cf18 double} target,\par
12296                            uint64_t ulps,\par
12297                            Detail::FloatingPointKind baseType );\par
12298         {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
12299         std::string describe() {\cf17 const override};\par
12300     {\cf17 private}:\par
12301         {\cf18 double} m_target;\par
12302         uint64_t m_ulps;\par
12303         Detail::FloatingPointKind m_type;\par
12304     \};\par
12305 \par
12307     WithinUlpsMatcher WithinULP({\cf18 double} target, uint64_t maxUlpDiff);\par
12309     WithinUlpsMatcher WithinULP({\cf18 float} target, uint64_t maxUlpDiff);\par
12310 \par
12311 \par
12312 \par
12313     {\cf20 // Given IEEE-754 format for floats and doubles, we can assume}\par
12314     {\cf20 // that float -> double promotion is lossless. Given this, we can}\par
12315     {\cf20 // assume that if we do the standard relative comparison of}\par
12316     {\cf20 // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get}\par
12317     {\cf20 // the same result if we do this for floats, as if we do this for}\par
12318     {\cf20 // doubles that were promoted from floats.}\par
12319     {\cf17 class }WithinRelMatcher final : {\cf17 public} MatcherBase<double> \{\par
12320     {\cf17 public}:\par
12321         WithinRelMatcher( {\cf18 double} target, {\cf18 double} epsilon );\par
12322         {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
12323         std::string describe() {\cf17 const override};\par
12324     {\cf17 private}:\par
12325         {\cf18 double} m_target;\par
12326         {\cf18 double} m_epsilon;\par
12327     \};\par
12328 \par
12330     WithinRelMatcher WithinRel({\cf18 double} target, {\cf18 double} eps);\par
12332     WithinRelMatcher WithinRel({\cf18 double} target);\par
12334     WithinRelMatcher WithinRel({\cf18 float} target, {\cf18 float} eps);\par
12336     WithinRelMatcher WithinRel({\cf18 float} target);\par
12337 \par
12338 \par
12339 \par
12340     {\cf17 class }IsNaNMatcher final : {\cf17 public} MatcherBase<double> \{\par
12341     {\cf17 public}:\par
12342         IsNaNMatcher() = {\cf19 default};\par
12343         {\cf18 bool} match( {\cf18 double} {\cf17 const}& matchee ) {\cf17 const override};\par
12344         std::string describe() {\cf17 const override};\par
12345     \};\par
12346 \par
12347     IsNaNMatcher IsNaN();\par
12348 \par
12349 \} {\cf20 // namespace Matchers}\par
12350 \} {\cf20 // namespace Catch}\par
12351 \par
12352 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED}\par
12353 \par
12354 \par
12355 {\cf21 #ifndef CATCH_MATCHERS_PREDICATE_HPP_INCLUDED}\par
12356 {\cf21 #define CATCH_MATCHERS_PREDICATE_HPP_INCLUDED}\par
12357 \par
12358 \par
12359 {\cf21 #include <string>}\par
12360 \par
12361 {\cf17 namespace }Catch \{\par
12362 {\cf17 namespace }Matchers \{\par
12363 \par
12364 {\cf17 namespace }Detail \{\par
12365     std::string finalizeDescription({\cf17 const} std::string& desc);\par
12366 \} {\cf20 // namespace Detail}\par
12367 \par
12368 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Predicate>\par
12369 {\cf17 class }PredicateMatcher final : {\cf17 public} MatcherBase<T> \{\par
12370     Predicate m_predicate;\par
12371     std::string m_description;\par
12372 {\cf17 public}:\par
12373 \par
12374     PredicateMatcher(Predicate&& elem, std::string {\cf17 const}& descr)\par
12375         :m_predicate(CATCH_FORWARD(elem)),\par
12376         m_description(Detail::finalizeDescription(descr))\par
12377     \{\}\par
12378 \par
12379     {\cf18 bool} match( T {\cf17 const}& item ){\cf17  const override }\{\par
12380         {\cf19 return} m_predicate(item);\par
12381     \}\par
12382 \par
12383     std::string describe(){\cf17  const override }\{\par
12384         {\cf19 return} m_description;\par
12385     \}\par
12386 \};\par
12387 \par
12393     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Pred>\par
12394     PredicateMatcher<T, Pred> Predicate(Pred&& predicate, std::string {\cf17 const}& description = {\cf22 ""}) \{\par
12395         {\cf17 static_assert}(is_callable<Pred(T)>::value, {\cf22 "Predicate not callable with argument T"});\par
12396         {\cf17 static_assert}(std::is_same<bool, FunctionReturnType<Pred, T>>::value, {\cf22 "Predicate does not return bool"});\par
12397         {\cf19 return} PredicateMatcher<T, Pred>(CATCH_FORWARD(predicate), description);\par
12398     \}\par
12399 \par
12400 \} {\cf20 // namespace Matchers}\par
12401 \} {\cf20 // namespace Catch}\par
12402 \par
12403 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_PREDICATE_HPP_INCLUDED}\par
12404 \par
12405 \par
12406 {\cf21 #ifndef CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED}\par
12407 {\cf21 #define CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED}\par
12408 \par
12409 \par
12410 {\cf17 namespace }Catch \{\par
12411     {\cf17 namespace }Matchers \{\par
12412         {\cf20 // Matcher for checking that all elements in range matches a given matcher.}\par
12413         {\cf17 template} <{\cf17 typename} Matcher>\par
12414         {\cf17 class }AllMatchMatcher final : {\cf17 public} MatcherGenericBase \{\par
12415             Matcher m_matcher;\par
12416         {\cf17 public}:\par
12417             AllMatchMatcher(Matcher matcher):\par
12418                 m_matcher(CATCH_MOVE(matcher))\par
12419             \{\}\par
12420 \par
12421             std::string describe(){\cf17  const override }\{\par
12422                 {\cf19 return} {\cf22 "all match "} + m_matcher.describe();\par
12423             \}\par
12424 \par
12425             {\cf17 template} <{\cf17 typename} RangeLike>\par
12426             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12427                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12428                     {\cf19 if} (!m_matcher.match(elem)) \{\par
12429                         {\cf19 return} {\cf17 false};\par
12430                     \}\par
12431                 \}\par
12432                 {\cf19 return} {\cf17 true};\par
12433             \}\par
12434         \};\par
12435 \par
12436         {\cf20 // Matcher for checking that no element in range matches a given matcher.}\par
12437         {\cf17 template} <{\cf17 typename} Matcher>\par
12438         {\cf17 class }NoneMatchMatcher final : {\cf17 public} MatcherGenericBase \{\par
12439             Matcher m_matcher;\par
12440         {\cf17 public}:\par
12441             NoneMatchMatcher(Matcher matcher):\par
12442                 m_matcher(CATCH_MOVE(matcher))\par
12443             \{\}\par
12444 \par
12445             std::string describe(){\cf17  const override }\{\par
12446                 {\cf19 return} {\cf22 "none match "} + m_matcher.describe();\par
12447             \}\par
12448 \par
12449             {\cf17 template} <{\cf17 typename} RangeLike>\par
12450             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12451                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12452                     {\cf19 if} (m_matcher.match(elem)) \{\par
12453                         {\cf19 return} {\cf17 false};\par
12454                     \}\par
12455                 \}\par
12456                 {\cf19 return} {\cf17 true};\par
12457             \}\par
12458         \};\par
12459 \par
12460         {\cf20 // Matcher for checking that at least one element in range matches a given matcher.}\par
12461         {\cf17 template} <{\cf17 typename} Matcher>\par
12462         {\cf17 class }AnyMatchMatcher final : {\cf17 public} MatcherGenericBase \{\par
12463             Matcher m_matcher;\par
12464         {\cf17 public}:\par
12465             AnyMatchMatcher(Matcher matcher):\par
12466                 m_matcher(CATCH_MOVE(matcher))\par
12467             \{\}\par
12468 \par
12469             std::string describe(){\cf17  const override }\{\par
12470                 {\cf19 return} {\cf22 "any match "} + m_matcher.describe();\par
12471             \}\par
12472 \par
12473             {\cf17 template} <{\cf17 typename} RangeLike>\par
12474             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12475                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12476                     {\cf19 if} (m_matcher.match(elem)) \{\par
12477                         {\cf19 return} {\cf17 true};\par
12478                     \}\par
12479                 \}\par
12480                 {\cf19 return} {\cf17 false};\par
12481             \}\par
12482         \};\par
12483 \par
12484         {\cf20 // Matcher for checking that all elements in range are true.}\par
12485         {\cf17 class }AllTrueMatcher final : {\cf17 public} MatcherGenericBase \{\par
12486         {\cf17 public}:\par
12487             std::string describe() {\cf17 const override};\par
12488 \par
12489             {\cf17 template} <{\cf17 typename} RangeLike>\par
12490             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12491                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12492                     {\cf19 if} (!elem) \{\par
12493                         {\cf19 return} {\cf17 false};\par
12494                     \}\par
12495                 \}\par
12496                 {\cf19 return} {\cf17 true};\par
12497             \}\par
12498         \};\par
12499 \par
12500         {\cf20 // Matcher for checking that no element in range is true.}\par
12501         {\cf17 class }NoneTrueMatcher final : {\cf17 public} MatcherGenericBase \{\par
12502         {\cf17 public}:\par
12503             std::string describe() {\cf17 const override};\par
12504 \par
12505             {\cf17 template} <{\cf17 typename} RangeLike>\par
12506             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12507                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12508                     {\cf19 if} (elem) \{\par
12509                         {\cf19 return} {\cf17 false};\par
12510                     \}\par
12511                 \}\par
12512                 {\cf19 return} {\cf17 true};\par
12513             \}\par
12514         \};\par
12515 \par
12516         {\cf20 // Matcher for checking that any element in range is true.}\par
12517         {\cf17 class }AnyTrueMatcher final : {\cf17 public} MatcherGenericBase \{\par
12518         {\cf17 public}:\par
12519             std::string describe() {\cf17 const override};\par
12520 \par
12521             {\cf17 template} <{\cf17 typename} RangeLike>\par
12522             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12523                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12524                     {\cf19 if} (elem) \{\par
12525                         {\cf19 return} {\cf17 true};\par
12526                     \}\par
12527                 \}\par
12528                 {\cf19 return} {\cf17 false};\par
12529             \}\par
12530         \};\par
12531 \par
12532         {\cf20 // Creates a matcher that checks whether all elements in a range match a matcher}\par
12533         {\cf17 template} <{\cf17 typename} Matcher>\par
12534         AllMatchMatcher<Matcher> AllMatch(Matcher&& matcher) \{\par
12535             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12536         \}\par
12537 \par
12538         {\cf20 // Creates a matcher that checks whether no element in a range matches a matcher.}\par
12539         {\cf17 template} <{\cf17 typename} Matcher>\par
12540         NoneMatchMatcher<Matcher> NoneMatch(Matcher&& matcher) \{\par
12541             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12542         \}\par
12543 \par
12544         {\cf20 // Creates a matcher that checks whether any element in a range matches a matcher.}\par
12545         {\cf17 template} <{\cf17 typename} Matcher>\par
12546         AnyMatchMatcher<Matcher> AnyMatch(Matcher&& matcher) \{\par
12547             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12548         \}\par
12549 \par
12550         {\cf20 // Creates a matcher that checks whether all elements in a range are true}\par
12551         AllTrueMatcher AllTrue();\par
12552 \par
12553         {\cf20 // Creates a matcher that checks whether no element in a range is true}\par
12554         NoneTrueMatcher NoneTrue();\par
12555 \par
12556         {\cf20 // Creates a matcher that checks whether any element in a range is true}\par
12557         AnyTrueMatcher AnyTrue();\par
12558     \}\par
12559 \}\par
12560 \par
12561 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED}\par
12562 \par
12563 \par
12564 {\cf21 #ifndef CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED}\par
12565 {\cf21 #define CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED}\par
12566 \par
12567 \par
12568 {\cf21 #include <algorithm>}\par
12569 {\cf21 #include <utility>}\par
12570 \par
12571 {\cf17 namespace }Catch \{\par
12572     {\cf17 namespace }Matchers \{\par
12573 \par
12578         {\cf17 template} <{\cf17 typename} TargetRangeLike, {\cf17 typename} Equality>\par
12579         {\cf17 class }RangeEqualsMatcher final : {\cf17 public} MatcherGenericBase \{\par
12580             TargetRangeLike m_desired;\par
12581             Equality m_predicate;\par
12582 \par
12583         {\cf17 public}:\par
12584             {\cf17 template} <{\cf17 typename} TargetRangeLike2, {\cf17 typename} Equality2>\par
12585             RangeEqualsMatcher( TargetRangeLike2&& range,\par
12586                                 Equality2&& predicate ):\par
12587                 m_desired( CATCH_FORWARD( range ) ),\par
12588                 m_predicate( CATCH_FORWARD( predicate ) ) \{\}\par
12589 \par
12590             {\cf17 template} <{\cf17 typename} RangeLike>\par
12591             {\cf18 bool} match( RangeLike&& rng ){\cf17  const }\{\par
12592                 {\cf17 auto} rng_start = begin( rng );\par
12593                 {\cf17 const} {\cf17 auto} rng_end = end( rng );\par
12594                 {\cf17 auto} target_start = begin( m_desired );\par
12595                 {\cf17 const} {\cf17 auto} target_end = end( m_desired );\par
12596 \par
12597                 {\cf19 while} (rng_start != rng_end && target_start != target_end) \{\par
12598                     {\cf19 if} (!m_predicate(*rng_start, *target_start)) \{\par
12599                         {\cf19 return} {\cf17 false};\par
12600                     \}\par
12601                     ++rng_start;\par
12602                     ++target_start;\par
12603                 \}\par
12604                 {\cf19 return} rng_start == rng_end && target_start == target_end;\par
12605             \}\par
12606 \par
12607             std::string describe(){\cf17  const override }\{\par
12608                 {\cf19 return} {\cf22 "elements are "} + Catch::Detail::stringify( m_desired );\par
12609             \}\par
12610         \};\par
12611 \par
12616         {\cf17 template} <{\cf17 typename} TargetRangeLike, {\cf17 typename} Equality>\par
12617         {\cf17 class }UnorderedRangeEqualsMatcher final : {\cf17 public} MatcherGenericBase \{\par
12618             TargetRangeLike m_desired;\par
12619             Equality m_predicate;\par
12620 \par
12621         {\cf17 public}:\par
12622             {\cf17 template} <{\cf17 typename} TargetRangeLike2, {\cf17 typename} Equality2>\par
12623             UnorderedRangeEqualsMatcher( TargetRangeLike2&& range,\par
12624                                          Equality2&& predicate ):\par
12625                 m_desired( CATCH_FORWARD( range ) ),\par
12626                 m_predicate( CATCH_FORWARD( predicate ) ) \{\}\par
12627 \par
12628             {\cf17 template} <{\cf17 typename} RangeLike>\par
12629             {\cf18 bool} match( RangeLike&& rng ){\cf17  const }\{\par
12630                 {\cf17 using }std::begin;\par
12631                 {\cf17 using }std::end;\par
12632                 {\cf19 return} Catch::Detail::is_permutation( begin( m_desired ),\par
12633                                                       end( m_desired ),\par
12634                                                       begin( rng ),\par
12635                                                       end( rng ),\par
12636                                                       m_predicate );\par
12637             \}\par
12638 \par
12639             std::string describe(){\cf17  const override }\{\par
12640                 {\cf19 return} {\cf22 "unordered elements are "} +\par
12641                        ::Catch::Detail::stringify( m_desired );\par
12642             \}\par
12643         \};\par
12644 \par
12651         {\cf17 template} <{\cf17 typename} RangeLike>\par
12652         std::enable_if_t<!Detail::is_matcher<RangeLike>::value,\par
12653                          RangeEqualsMatcher<RangeLike, std::equal_to<>>>\par
12654         RangeEquals( RangeLike&& range ) \{\par
12655             {\cf19 return} \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};\par
12656         \}\par
12657 \par
12664         {\cf17 template} <{\cf17 typename} RangeLike, {\cf17 typename} Equality>\par
12665         RangeEqualsMatcher<RangeLike, Equality>\par
12666         RangeEquals( RangeLike&& range, Equality&& predicate ) \{\par
12667             {\cf19 return} \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};\par
12668         \}\par
12669 \par
12676         {\cf17 template} <{\cf17 typename} RangeLike>\par
12677         std::enable_if_t<\par
12678             !Detail::is_matcher<RangeLike>::value,\par
12679             UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>\par
12680         UnorderedRangeEquals( RangeLike&& range ) \{\par
12681             {\cf19 return} \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};\par
12682         \}\par
12683 \par
12690         {\cf17 template} <{\cf17 typename} RangeLike, {\cf17 typename} Equality>\par
12691         UnorderedRangeEqualsMatcher<RangeLike, Equality>\par
12692         UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) \{\par
12693             {\cf19 return} \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};\par
12694         \}\par
12695     \} {\cf20 // namespace Matchers}\par
12696 \} {\cf20 // namespace Catch}\par
12697 \par
12698 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED}\par
12699 \par
12700 \par
12701 {\cf21 #ifndef CATCH_MATCHERS_STRING_HPP_INCLUDED}\par
12702 {\cf21 #define CATCH_MATCHERS_STRING_HPP_INCLUDED}\par
12703 \par
12704 \par
12705 {\cf21 #include <string>}\par
12706 \par
12707 {\cf17 namespace }Catch \{\par
12708 {\cf17 namespace }Matchers \{\par
12709 \par
12710     {\cf17 struct }CasedString \{\par
12711         CasedString( std::string {\cf17 const}& str, CaseSensitive caseSensitivity );\par
12712         std::string adjustString( std::string {\cf17 const}& str ) {\cf17 const};\par
12713         StringRef caseSensitivitySuffix() {\cf17 const};\par
12714 \par
12715         CaseSensitive m_caseSensitivity;\par
12716         std::string m_str;\par
12717     \};\par
12718 \par
12719     {\cf17 class }StringMatcherBase : {\cf17 public} MatcherBase<std::string> \{\par
12720     {\cf17 protected}:\par
12721         CasedString m_comparator;\par
12722         StringRef m_operation;\par
12723 \par
12724     {\cf17 public}:\par
12725         StringMatcherBase( StringRef operation,\par
12726                            CasedString {\cf17 const}& comparator );\par
12727         std::string describe() {\cf17 const override};\par
12728     \};\par
12729 \par
12730     {\cf17 class }StringEqualsMatcher final : {\cf17 public} StringMatcherBase \{\par
12731     {\cf17 public}:\par
12732         StringEqualsMatcher( CasedString {\cf17 const}& comparator );\par
12733         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12734     \};\par
12735     {\cf17 class }StringContainsMatcher final : {\cf17 public} StringMatcherBase \{\par
12736     {\cf17 public}:\par
12737         StringContainsMatcher( CasedString {\cf17 const}& comparator );\par
12738         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12739     \};\par
12740     {\cf17 class }StartsWithMatcher final : {\cf17 public} StringMatcherBase \{\par
12741     {\cf17 public}:\par
12742         StartsWithMatcher( CasedString {\cf17 const}& comparator );\par
12743         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12744     \};\par
12745     {\cf17 class }EndsWithMatcher final : {\cf17 public} StringMatcherBase \{\par
12746     {\cf17 public}:\par
12747         EndsWithMatcher( CasedString {\cf17 const}& comparator );\par
12748         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12749     \};\par
12750 \par
12751     {\cf17 class }RegexMatcher final : {\cf17 public} MatcherBase<std::string> \{\par
12752         std::string m_regex;\par
12753         CaseSensitive m_caseSensitivity;\par
12754 \par
12755     {\cf17 public}:\par
12756         RegexMatcher( std::string regex, CaseSensitive caseSensitivity );\par
12757         {\cf18 bool} match( std::string {\cf17 const}& matchee ) {\cf17 const override};\par
12758         std::string describe() {\cf17 const override};\par
12759     \};\par
12760 \par
12762     StringEqualsMatcher Equals( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12764     StringContainsMatcher ContainsSubstring( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12766     EndsWithMatcher EndsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12768     StartsWithMatcher StartsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12770     RegexMatcher Matches( std::string {\cf17 const}& regex, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12771 \par
12772 \} {\cf20 // namespace Matchers}\par
12773 \} {\cf20 // namespace Catch}\par
12774 \par
12775 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_STRING_HPP_INCLUDED}\par
12776 \par
12777 \par
12778 {\cf21 #ifndef CATCH_MATCHERS_VECTOR_HPP_INCLUDED}\par
12779 {\cf21 #define CATCH_MATCHERS_VECTOR_HPP_INCLUDED}\par
12780 \par
12781 \par
12782 {\cf21 #include <algorithm>}\par
12783 \par
12784 {\cf17 namespace }Catch \{\par
12785 {\cf17 namespace }Matchers \{\par
12786 \par
12787     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Alloc>\par
12788     {\cf17 class }VectorContainsElementMatcher final : {\cf17 public} MatcherBase<std::vector<T, Alloc>> \{\par
12789         T {\cf17 const}& m_comparator;\par
12790 \par
12791     {\cf17 public}:\par
12792         VectorContainsElementMatcher(T {\cf17 const}& comparator):\par
12793             m_comparator(comparator)\par
12794         \{\}\par
12795 \par
12796         {\cf18 bool} match(std::vector<T, Alloc> {\cf17 const}& v){\cf17  const override }\{\par
12797             {\cf19 for} ({\cf17 auto} {\cf17 const}& el : v) \{\par
12798                 {\cf19 if} (el == m_comparator) \{\par
12799                     {\cf19 return} {\cf17 true};\par
12800                 \}\par
12801             \}\par
12802             {\cf19 return} {\cf17 false};\par
12803         \}\par
12804 \par
12805         std::string describe(){\cf17  const override }\{\par
12806             {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
12807         \}\par
12808     \};\par
12809 \par
12810     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12811     {\cf17 class }ContainsMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12812         std::vector<T, AllocComp> {\cf17 const}& m_comparator;\par
12813 \par
12814     {\cf17 public}:\par
12815         ContainsMatcher(std::vector<T, AllocComp> {\cf17 const}& comparator):\par
12816             m_comparator( comparator )\par
12817         \{\}\par
12818 \par
12819         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& v){\cf17  const override }\{\par
12820             {\cf20 // !TBD: see note in EqualsMatcher}\par
12821             {\cf19 if} (m_comparator.size() > v.size())\par
12822                 {\cf19 return} {\cf17 false};\par
12823             {\cf19 for} ({\cf17 auto} {\cf17 const}& comparator : m_comparator) \{\par
12824                 {\cf17 auto} present = {\cf17 false};\par
12825                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : v) \{\par
12826                     {\cf19 if} (el == comparator) \{\par
12827                         present = {\cf17 true};\par
12828                         {\cf19 break};\par
12829                     \}\par
12830                 \}\par
12831                 {\cf19 if} (!present) \{\par
12832                     {\cf19 return} {\cf17 false};\par
12833                 \}\par
12834             \}\par
12835             {\cf19 return} {\cf17 true};\par
12836         \}\par
12837         std::string describe(){\cf17  const override }\{\par
12838             {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
12839         \}\par
12840     \};\par
12841 \par
12842     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12843     {\cf17 class }EqualsMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12844         std::vector<T, AllocComp> {\cf17 const}& m_comparator;\par
12845 \par
12846     {\cf17 public}:\par
12847         EqualsMatcher(std::vector<T, AllocComp> {\cf17 const}& comparator):\par
12848             m_comparator( comparator )\par
12849         \{\}\par
12850 \par
12851         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& v){\cf17  const override }\{\par
12852             {\cf20 // !TBD: This currently works if all elements can be compared using !=}\par
12853             {\cf20 // - a more general approach would be via a compare template that defaults}\par
12854             {\cf20 // to using !=. but could be specialised for, e.g. std::vector<T> etc}\par
12855             {\cf20 // - then just call that directly}\par
12856             {\cf19 if} ( m_comparator.size() != v.size() ) \{ {\cf19 return} {\cf17 false}; \}\par
12857             {\cf19 for} ( std::size_t i = 0; i < v.size(); ++i ) \{\par
12858                 {\cf19 if} ( !( m_comparator[i] == v[i] ) ) \{ {\cf19 return} {\cf17 false}; \}\par
12859             \}\par
12860             {\cf19 return} {\cf17 true};\par
12861         \}\par
12862         std::string describe(){\cf17  const override }\{\par
12863             {\cf19 return} {\cf22 "Equals: "} + ::Catch::Detail::stringify( m_comparator );\par
12864         \}\par
12865     \};\par
12866 \par
12867     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12868     {\cf17 class }ApproxMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12869         std::vector<T, AllocComp> {\cf17 const}& m_comparator;\par
12870         {\cf17 mutable} Catch::Approx approx = Catch::Approx::custom();\par
12871 \par
12872     {\cf17 public}:\par
12873         ApproxMatcher(std::vector<T, AllocComp> {\cf17 const}& comparator):\par
12874             m_comparator( comparator )\par
12875         \{\}\par
12876 \par
12877         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& v){\cf17  const override }\{\par
12878             {\cf19 if} (m_comparator.size() != v.size())\par
12879                 {\cf19 return} {\cf17 false};\par
12880             {\cf19 for} (std::size_t i = 0; i < v.size(); ++i)\par
12881                 {\cf19 if} (m_comparator[i] != approx(v[i]))\par
12882                     {\cf19 return} {\cf17 false};\par
12883             {\cf19 return} {\cf17 true};\par
12884         \}\par
12885         std::string describe(){\cf17  const override }\{\par
12886             {\cf19 return} {\cf22 "is approx: "} + ::Catch::Detail::stringify( m_comparator );\par
12887         \}\par
12888         template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
12889         ApproxMatcher& epsilon( T {\cf17 const}& newEpsilon ) \{\par
12890             approx.epsilon({\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon));\par
12891             {\cf19 return} *{\cf17 this};\par
12892         \}\par
12893         template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
12894         ApproxMatcher& margin( T {\cf17 const}& newMargin ) \{\par
12895             approx.margin({\cf17 static_cast<}{\cf18 double}{\cf17 >}(newMargin));\par
12896             {\cf19 return} *{\cf17 this};\par
12897         \}\par
12898         template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
12899         ApproxMatcher& scale( T {\cf17 const}& newScale ) \{\par
12900             approx.scale({\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale));\par
12901             {\cf19 return} *{\cf17 this};\par
12902         \}\par
12903     \};\par
12904 \par
12905     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12906     {\cf17 class }UnorderedEqualsMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12907         std::vector<T, AllocComp> {\cf17 const}& m_target;\par
12908 \par
12909     {\cf17 public}:\par
12910         UnorderedEqualsMatcher(std::vector<T, AllocComp> {\cf17 const}& target):\par
12911             m_target(target)\par
12912         \{\}\par
12913         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& vec){\cf17  const override }\{\par
12914             {\cf19 if} (m_target.size() != vec.size()) \{\par
12915                 {\cf19 return} {\cf17 false};\par
12916             \}\par
12917             {\cf19 return} std::is_permutation(m_target.begin(), m_target.end(), vec.begin());\par
12918         \}\par
12919 \par
12920         std::string describe(){\cf17  const override }\{\par
12921             {\cf19 return} {\cf22 "UnorderedEquals: "} + ::Catch::Detail::stringify(m_target);\par
12922         \}\par
12923     \};\par
12924 \par
12925 \par
12926     {\cf20 // The following functions create the actual matcher objects.}\par
12927     {\cf20 // This allows the types to be inferred}\par
12928 \par
12930     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12931     ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> {\cf17 const}& comparator ) \{\par
12932         {\cf19 return} ContainsMatcher<T, AllocComp, AllocMatch>(comparator);\par
12933     \}\par
12934 \par
12936     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Alloc = std::allocator<T>>\par
12937     VectorContainsElementMatcher<T, Alloc> VectorContains( T {\cf17 const}& comparator ) \{\par
12938         {\cf19 return} VectorContainsElementMatcher<T, Alloc>(comparator);\par
12939     \}\par
12940 \par
12942     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12943     EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> {\cf17 const}& comparator ) \{\par
12944         {\cf19 return} EqualsMatcher<T, AllocComp, AllocMatch>(comparator);\par
12945     \}\par
12946 \par
12948     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12949     ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> {\cf17 const}& comparator ) \{\par
12950         {\cf19 return} ApproxMatcher<T, AllocComp, AllocMatch>(comparator);\par
12951     \}\par
12952 \par
12954     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12955     UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> {\cf17 const}& target) \{\par
12956         {\cf19 return} UnorderedEqualsMatcher<T, AllocComp, AllocMatch>(target);\par
12957     \}\par
12958 \par
12959 \} {\cf20 // namespace Matchers}\par
12960 \} {\cf20 // namespace Catch}\par
12961 \par
12962 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_VECTOR_HPP_INCLUDED}\par
12963 \par
12964 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_ALL_HPP_INCLUDED}\par
12965 \par
12966 \par
12980 {\cf21 #ifndef CATCH_REPORTERS_ALL_HPP_INCLUDED}\par
12981 {\cf21 #define CATCH_REPORTERS_ALL_HPP_INCLUDED}\par
12982 \par
12983 \par
12984 \par
12985 {\cf21 #ifndef CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED}\par
12986 {\cf21 #define CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED}\par
12987 \par
12988 \par
12989 \par
12990 {\cf21 #ifndef CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED}\par
12991 {\cf21 #define CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED}\par
12992 \par
12993 \par
12994 \par
12995 {\cf21 #ifndef CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED}\par
12996 {\cf21 #define CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED}\par
12997 \par
12998 \par
12999 {\cf21 #include <map>}\par
13000 {\cf21 #include <string>}\par
13001 \par
13002 {\cf17 namespace }Catch \{\par
13003     {\cf17 class }ColourImpl;\par
13004 \par
13015     {\cf17 class }ReporterBase : {\cf17 public} IEventListener \{\par
13016     {\cf17 protected}:\par
13018         Detail::unique_ptr<IStream> m_wrapped_stream;\par
13021         std::ostream& m_stream;\par
13023         Detail::unique_ptr<ColourImpl> m_colour;\par
13025         std::map<std::string, std::string> m_customOptions;\par
13026 \par
13027     {\cf17 public}:\par
13028         ReporterBase( ReporterConfig&& config );\par
13029         ~ReporterBase() {\cf17 override}; {\cf20 // = default;}\par
13030 \par
13037         {\cf18 void} listReporters(\par
13038             std::vector<ReporterDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13045         {\cf18 void} listListeners(\par
13046             std::vector<ListenerDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13054         {\cf18 void} listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) {\cf17 override};\par
13061         {\cf18 void} listTags( std::vector<TagInfo> {\cf17 const}& tags ) {\cf17 override};\par
13062     \};\par
13063 \} {\cf20 // namespace Catch}\par
13064 \par
13065 {\cf21 #endif }{\cf20 // CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED}\par
13066 \par
13067 {\cf21 #include <vector>}\par
13068 \par
13069 {\cf17 namespace }Catch \{\par
13070 \par
13071     {\cf17 class }StreamingReporterBase : {\cf17 public} ReporterBase \{\par
13072     {\cf17 public}:\par
13073         {\cf20 // GCC5 compat: we cannot use inherited constructor, because it}\par
13074         {\cf20 //              doesn't implement backport of P0136}\par
13075         StreamingReporterBase(ReporterConfig&& _config):\par
13076             ReporterBase(CATCH_MOVE(_config))\par
13077         \{\}\par
13078         ~StreamingReporterBase() {\cf17 override};\par
13079 \par
13080         {\cf18 void} benchmarkPreparing( StringRef ){\cf17  override }\{\}\par
13081         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& ){\cf17  override }\{\}\par
13082         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& ){\cf17  override }\{\}\par
13083         {\cf18 void} benchmarkFailed( StringRef ){\cf17  override }\{\}\par
13084 \par
13085         {\cf18 void} fatalErrorEncountered( StringRef {\cf20 /*error*/} ){\cf17  override }\{\}\par
13086         {\cf18 void} noMatchingTestCases( StringRef {\cf20 /*unmatchedSpec*/} ){\cf17  override }\{\}\par
13087         {\cf18 void} reportInvalidTestSpec( StringRef {\cf20 /*invalidArgument*/} ){\cf17  override }\{\}\par
13088 \par
13089         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& _testRunInfo ) {\cf17 override};\par
13090 \par
13091         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& _testInfo){\cf17  override  }\{\par
13092             currentTestCaseInfo = &_testInfo;\par
13093         \}\par
13094         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13095         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& _sectionInfo){\cf17  override }\{\par
13096             m_sectionStack.push_back(_sectionInfo);\par
13097         \}\par
13098 \par
13099         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& ){\cf17  override }\{\}\par
13100         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& ){\cf17  override }\{\}\par
13101 \par
13102         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& {\cf20 /* _sectionStats */}){\cf17  override }\{\par
13103             m_sectionStack.pop_back();\par
13104         \}\par
13105         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13106         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& {\cf20 /* _testCaseStats */}){\cf17  override }\{\par
13107             currentTestCaseInfo = {\cf17 nullptr};\par
13108         \}\par
13109         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& {\cf20 /* _testRunStats */} ) {\cf17 override};\par
13110 \par
13111         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}&){\cf17  override }\{\par
13112             {\cf20 // Don't do anything with this by default.}\par
13113             {\cf20 // It can optionally be overridden in the derived class.}\par
13114         \}\par
13115 \par
13116     {\cf17 protected}:\par
13117         TestRunInfo currentTestRunInfo\{ {\cf22 "test run has not started yet"}_sr \};\par
13118         TestCaseInfo {\cf17 const}* currentTestCaseInfo = {\cf17 nullptr};\par
13119 \par
13121         std::vector<SectionInfo> m_sectionStack;\par
13122     \};\par
13123 \par
13124 \} {\cf20 // end namespace Catch}\par
13125 \par
13126 {\cf21 #endif }{\cf20 // CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED}\par
13127 \par
13128 {\cf21 #include <string>}\par
13129 \par
13130 {\cf17 namespace }Catch \{\par
13131 \par
13132     {\cf17 class }AutomakeReporter final : {\cf17 public} StreamingReporterBase \{\par
13133     {\cf17 public}:\par
13134         {\cf20 // GCC5 compat: we cannot use inherited constructor, because it}\par
13135         {\cf20 //              doesn't implement backport of P0136}\par
13136         AutomakeReporter(ReporterConfig&& _config):\par
13137             StreamingReporterBase(CATCH_MOVE(_config))\par
13138         \{\}\par
13139         ~AutomakeReporter() {\cf17 override};\par
13140 \par
13141         {\cf17 static} std::string getDescription() \{\par
13142             {\cf17 using namespace }std::string_literals;\par
13143             {\cf19 return} {\cf22 "Reports test results in the format of Automake .trs files"}s;\par
13144         \}\par
13145 \par
13146         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) {\cf17 override};\par
13147         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}& testInfo) {\cf17 override};\par
13148     \};\par
13149 \par
13150 \} {\cf20 // end namespace Catch}\par
13151 \par
13152 {\cf21 #endif }{\cf20 // CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED}\par
13153 \par
13154 \par
13155 {\cf21 #ifndef CATCH_REPORTER_COMPACT_HPP_INCLUDED}\par
13156 {\cf21 #define CATCH_REPORTER_COMPACT_HPP_INCLUDED}\par
13157 \par
13158 \par
13159 \par
13160 \par
13161 {\cf17 namespace }Catch \{\par
13162 \par
13163     {\cf17 class }CompactReporter final : {\cf17 public} StreamingReporterBase \{\par
13164     {\cf17 public}:\par
13165         {\cf17 using }StreamingReporterBase::StreamingReporterBase;\par
13166 \par
13167         ~CompactReporter() {\cf17 override};\par
13168 \par
13169         {\cf17 static} std::string getDescription();\par
13170 \par
13171         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13172 \par
13173         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& _testInfo ) {\cf17 override};\par
13174 \par
13175         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
13176 \par
13177         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& _sectionStats) {\cf17 override};\par
13178 \par
13179         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
13180 \par
13181     \};\par
13182 \par
13183 \} {\cf20 // end namespace Catch}\par
13184 \par
13185 {\cf21 #endif }{\cf20 // CATCH_REPORTER_COMPACT_HPP_INCLUDED}\par
13186 \par
13187 \par
13188 {\cf21 #ifndef CATCH_REPORTER_CONSOLE_HPP_INCLUDED}\par
13189 {\cf21 #define CATCH_REPORTER_CONSOLE_HPP_INCLUDED}\par
13190 \par
13191 \par
13192 {\cf17 namespace }Catch \{\par
13193     {\cf20 // Fwd decls}\par
13194     {\cf17 class }TablePrinter;\par
13195 \par
13196     {\cf17 class }ConsoleReporter final : {\cf17 public} StreamingReporterBase \{\par
13197         Detail::unique_ptr<TablePrinter> m_tablePrinter;\par
13198 \par
13199     {\cf17 public}:\par
13200         ConsoleReporter(ReporterConfig&& config);\par
13201         ~ConsoleReporter() {\cf17 override};\par
13202         {\cf17 static} std::string getDescription();\par
13203 \par
13204         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13205         {\cf18 void} reportInvalidTestSpec( StringRef arg ) {\cf17 override};\par
13206 \par
13207         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
13208 \par
13209         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
13210 \par
13211         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& _sectionInfo) {\cf17 override};\par
13212         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& _sectionStats) {\cf17 override};\par
13213 \par
13214         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13215         {\cf18 void} benchmarkStarting(BenchmarkInfo {\cf17 const}& info) {\cf17 override};\par
13216         {\cf18 void} benchmarkEnded(BenchmarkStats<> {\cf17 const}& stats) {\cf17 override};\par
13217         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13218 \par
13219         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) {\cf17 override};\par
13220         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
13221         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& _testRunInfo) {\cf17 override};\par
13222 \par
13223     {\cf17 private}:\par
13224         {\cf18 void} lazyPrint();\par
13225 \par
13226         {\cf18 void} lazyPrintWithoutClosingBenchmarkTable();\par
13227         {\cf18 void} lazyPrintRunInfo();\par
13228         {\cf18 void} printTestCaseAndSectionHeader();\par
13229 \par
13230         {\cf18 void} printClosedHeader(std::string {\cf17 const}& _name);\par
13231         {\cf18 void} printOpenHeader(std::string {\cf17 const}& _name);\par
13232 \par
13233         {\cf20 // if string has a : in first line will set indent to follow it on}\par
13234         {\cf20 // subsequent lines}\par
13235         {\cf18 void} printHeaderString(std::string {\cf17 const}& _string, std::size_t indent = 0);\par
13236 \par
13237         {\cf18 void} printTotalsDivider(Totals {\cf17 const}& totals);\par
13238 \par
13239         {\cf18 bool} m_headerPrinted = {\cf17 false};\par
13240         {\cf18 bool} m_testRunInfoPrinted = {\cf17 false};\par
13241     \};\par
13242 \par
13243 \} {\cf20 // end namespace Catch}\par
13244 \par
13245 {\cf21 #endif }{\cf20 // CATCH_REPORTER_CONSOLE_HPP_INCLUDED}\par
13246 \par
13247 \par
13248 {\cf21 #ifndef CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED}\par
13249 {\cf21 #define CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED}\par
13250 \par
13251 \par
13252 {\cf21 #include <string>}\par
13253 {\cf21 #include <vector>}\par
13254 \par
13255 {\cf17 namespace }Catch \{\par
13256 \par
13257     {\cf17 namespace }Detail \{\par
13258 \par
13260         {\cf17 class }AssertionOrBenchmarkResult \{\par
13261             {\cf20 // This should really be a variant, but this is much faster}\par
13262             {\cf20 // to write and the data layout here is already terrible}\par
13263             {\cf20 // enough that we do not have to care about the object size.}\par
13264             Optional<AssertionStats> m_assertion;\par
13265             Optional<BenchmarkStats<>> m_benchmark;\par
13266         {\cf17 public}:\par
13267             AssertionOrBenchmarkResult(AssertionStats {\cf17 const}& assertion);\par
13268             AssertionOrBenchmarkResult(BenchmarkStats<> {\cf17 const}& benchmark);\par
13269 \par
13270             {\cf18 bool} isAssertion() {\cf17 const};\par
13271             {\cf18 bool} isBenchmark() {\cf17 const};\par
13272 \par
13273             AssertionStats {\cf17 const}& asAssertion() {\cf17 const};\par
13274             BenchmarkStats<> {\cf17 const}& asBenchmark() {\cf17 const};\par
13275         \};\par
13276     \}\par
13277 \par
13298     {\cf17 class }CumulativeReporterBase : {\cf17 public} ReporterBase \{\par
13299     {\cf17 public}:\par
13300         {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ChildNodeT>\par
13301         {\cf17 struct }Node \{\par
13302             {\cf17 explicit} Node( T {\cf17 const}& _value ) : value( _value ) \{\}\par
13303 \par
13304             {\cf17 using }ChildNodes = std::vector<Detail::unique_ptr<ChildNodeT>>;\par
13305             T value;\par
13306             ChildNodes children;\par
13307         \};\par
13308         {\cf17 struct }SectionNode \{\par
13309             {\cf17 explicit} SectionNode(SectionStats {\cf17 const}& _stats) : stats(_stats) \{\}\par
13310 \par
13311             {\cf18 bool} operator == (SectionNode {\cf17 const}& other){\cf17  const }\{\par
13312                 {\cf19 return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\par
13313             \}\par
13314 \par
13315             {\cf18 bool} hasAnyAssertions() {\cf17 const};\par
13316 \par
13317             SectionStats stats;\par
13318             std::vector<Detail::unique_ptr<SectionNode>> childSections;\par
13319             std::vector<Detail::AssertionOrBenchmarkResult> assertionsAndBenchmarks;\par
13320             std::string stdOut;\par
13321             std::string stdErr;\par
13322         \};\par
13323 \par
13324 \par
13325         {\cf17 using }TestCaseNode = Node<TestCaseStats, SectionNode>;\par
13326         {\cf17 using }TestRunNode = Node<TestRunStats, TestCaseNode>;\par
13327 \par
13328         {\cf20 // GCC5 compat: we cannot use inherited constructor, because it}\par
13329         {\cf20 //              doesn't implement backport of P0136}\par
13330         CumulativeReporterBase(ReporterConfig&& _config):\par
13331             ReporterBase(CATCH_MOVE(_config))\par
13332         \{\}\par
13333         ~CumulativeReporterBase() {\cf17 override};\par
13334 \par
13335         {\cf18 void} benchmarkPreparing( StringRef ){\cf17  override }\{\}\par
13336         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& ){\cf17  override }\{\}\par
13337         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) {\cf17 override};\par
13338         {\cf18 void} benchmarkFailed( StringRef ){\cf17  override }\{\}\par
13339 \par
13340         {\cf18 void} noMatchingTestCases( StringRef ){\cf17  override }\{\}\par
13341         {\cf18 void} reportInvalidTestSpec( StringRef ){\cf17  override }\{\}\par
13342         {\cf18 void} fatalErrorEncountered( StringRef {\cf20 /*error*/} ){\cf17  override }\{\}\par
13343 \par
13344         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& ){\cf17  override }\{\}\par
13345 \par
13346         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& ){\cf17  override }\{\}\par
13347         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13348         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13349 \par
13350         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& ){\cf17  override }\{\}\par
13351 \par
13352         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13353         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13354         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13355         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) {\cf17 override};\par
13356         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) {\cf17 override};\par
13358         {\cf17 virtual} {\cf18 void} testRunEndedCumulative() = 0;\par
13359 \par
13360         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}&){\cf17  override }\{\}\par
13361 \par
13362     {\cf17 protected}:\par
13364         {\cf18 bool} m_shouldStoreSuccesfulAssertions = {\cf17 true};\par
13366         {\cf18 bool} m_shouldStoreFailedAssertions = {\cf17 true};\par
13367 \par
13368         {\cf20 // We need lazy construction here. We should probably refactor it}\par
13369         {\cf20 // later, after the events are redone.}\par
13371         Detail::unique_ptr<TestRunNode> m_testRun;\par
13372 \par
13373     {\cf17 private}:\par
13374         {\cf20 // Note: We rely on pointer identity being stable, which is why}\par
13375         {\cf20 //       we store pointers to the nodes rather than the values.}\par
13376         std::vector<Detail::unique_ptr<TestCaseNode>> m_testCases;\par
13377         {\cf20 // Root section of the _current_ test case}\par
13378         Detail::unique_ptr<SectionNode> m_rootSection;\par
13379         {\cf20 // Deepest section of the _current_ test case}\par
13380         SectionNode* m_deepestSection = {\cf17 nullptr};\par
13381         {\cf20 // Stack of _active_ sections in the _current_ test case}\par
13382         std::vector<SectionNode*> m_sectionStack;\par
13383     \};\par
13384 \par
13385 \} {\cf20 // end namespace Catch}\par
13386 \par
13387 {\cf21 #endif }{\cf20 // CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED}\par
13388 \par
13389 \par
13390 {\cf21 #ifndef CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED}\par
13391 {\cf21 #define CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED}\par
13392 \par
13393 \par
13394 {\cf17 namespace }Catch \{\par
13395 \par
13403     {\cf17 class }EventListenerBase : {\cf17 public} IEventListener \{\par
13404     {\cf17 public}:\par
13405         {\cf17 using }IEventListener::IEventListener;\par
13406 \par
13407         {\cf18 void} reportInvalidTestSpec( StringRef unmatchedSpec ) {\cf17 override};\par
13408         {\cf18 void} fatalErrorEncountered( StringRef error ) {\cf17 override};\par
13409 \par
13410         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13411         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) {\cf17 override};\par
13412         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) {\cf17 override};\par
13413         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13414 \par
13415         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) {\cf17 override};\par
13416         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13417 \par
13418         {\cf18 void} listReporters(\par
13419             std::vector<ReporterDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13420         {\cf18 void} listListeners(\par
13421             std::vector<ListenerDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13422         {\cf18 void} listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) {\cf17 override};\par
13423         {\cf18 void} listTags( std::vector<TagInfo> {\cf17 const}& tagInfos ) {\cf17 override};\par
13424 \par
13425         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13426         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) {\cf17 override};\par
13427         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13428         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}& testInfo,\par
13429                                       uint64_t partNumber ) {\cf17 override};\par
13430         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13431         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13432         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}& testCaseStats,\par
13433                                    uint64_t partNumber ) {\cf17 override};\par
13434         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) {\cf17 override};\par
13435         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) {\cf17 override};\par
13436         {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13437     \};\par
13438 \par
13439 \} {\cf20 // end namespace Catch}\par
13440 \par
13441 {\cf21 #endif }{\cf20 // CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED}\par
13442 \par
13443 \par
13444 {\cf21 #ifndef CATCH_REPORTER_HELPERS_HPP_INCLUDED}\par
13445 {\cf21 #define CATCH_REPORTER_HELPERS_HPP_INCLUDED}\par
13446 \par
13447 {\cf21 #include <iosfwd>}\par
13448 {\cf21 #include <string>}\par
13449 {\cf21 #include <vector>}\par
13450 \par
13451 \par
13452 {\cf17 namespace }Catch \{\par
13453 \par
13454     {\cf17 class }IConfig;\par
13455     {\cf17 class }TestCaseHandle;\par
13456     {\cf17 class }ColourImpl;\par
13457 \par
13458     {\cf20 // Returns double formatted as %.3f (format expected on output)}\par
13459     std::string getFormattedDuration( {\cf18 double} duration );\par
13460 \par
13462     {\cf18 bool} shouldShowDuration( IConfig {\cf17 const}& config, {\cf18 double} duration );\par
13463 \par
13464     std::string serializeFilters( std::vector<std::string> {\cf17 const}& filters );\par
13465 \par
13466     {\cf17 struct }lineOfChars \{\par
13467         {\cf18 char} c;\par
13468         {\cf17 constexpr} lineOfChars( {\cf18 char} c_ ): c( c_ ) \{\}\par
13469 \par
13470         {\cf17 friend} std::ostream& operator<<( std::ostream& out, lineOfChars value );\par
13471     \};\par
13472 \par
13481     {\cf18 void}\par
13482     defaultListReporters( std::ostream& out,\par
13483                           std::vector<ReporterDescription> {\cf17 const}& descriptions,\par
13484                           Verbosity verbosity );\par
13485 \par
13490     {\cf18 void} defaultListListeners( std::ostream& out,\par
13491                                std::vector<ListenerDescription> {\cf17 const}& descriptions );\par
13492 \par
13500     {\cf18 void} defaultListTags( std::ostream& out, std::vector<TagInfo> {\cf17 const}& tags, {\cf18 bool} isFiltered );\par
13501 \par
13511     {\cf18 void} defaultListTests( std::ostream& out,\par
13512                            ColourImpl* streamColour,\par
13513                            std::vector<TestCaseHandle> {\cf17 const}& tests,\par
13514                            {\cf18 bool} isFiltered,\par
13515                            Verbosity verbosity );\par
13516 \par
13522     {\cf18 void} printTestRunTotals( std::ostream& stream,\par
13523                       ColourImpl& streamColour,\par
13524                       Totals {\cf17 const}& totals );\par
13525 \par
13526 \} {\cf20 // end namespace Catch}\par
13527 \par
13528 {\cf21 #endif }{\cf20 // CATCH_REPORTER_HELPERS_HPP_INCLUDED}\par
13529 \par
13530 \par
13531 \par
13532 {\cf21 #ifndef CATCH_REPORTER_JSON_HPP_INCLUDED}\par
13533 {\cf21 #define CATCH_REPORTER_JSON_HPP_INCLUDED}\par
13534 \par
13535 \par
13536 {\cf21 #include <stack>}\par
13537 \par
13538 {\cf17 namespace }Catch \{\par
13539     {\cf17 class }JsonReporter : {\cf17 public} StreamingReporterBase \{\par
13540     {\cf17 public}:\par
13541         JsonReporter( ReporterConfig&& config );\par
13542 \par
13543         ~JsonReporter() {\cf17 override};\par
13544 \par
13545         {\cf17 static} std::string getDescription();\par
13546 \par
13547     {\cf17 public}: {\cf20 // StreamingReporterBase}\par
13548         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& runInfo ) {\cf17 override};\par
13549         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& runStats ) {\cf17 override};\par
13550 \par
13551         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& tcInfo ) {\cf17 override};\par
13552         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& tcStats ) {\cf17 override};\par
13553 \par
13554         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}& tcInfo,\par
13555                                       uint64_t index ) {\cf17 override};\par
13556         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}& tcStats,\par
13557                                    uint64_t index ) {\cf17 override};\par
13558 \par
13559         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13560         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13561 \par
13562         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) {\cf17 override};\par
13563         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13564 \par
13565         {\cf20 //void testRunEndedCumulative() override;}\par
13566 \par
13567         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13568         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& ) {\cf17 override};\par
13569         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& ) {\cf17 override};\par
13570         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13571 \par
13572         {\cf18 void} listReporters(\par
13573             std::vector<ReporterDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13574         {\cf18 void} listListeners(\par
13575             std::vector<ListenerDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13576         {\cf18 void} listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) {\cf17 override};\par
13577         {\cf18 void} listTags( std::vector<TagInfo> {\cf17 const}& tags ) {\cf17 override};\par
13578 \par
13579     {\cf17 private}:\par
13580         Timer m_testCaseTimer;\par
13581         {\cf17 enum class} Writer \{\par
13582             Object,\par
13583             Array\par
13584         \};\par
13585 \par
13586         JsonArrayWriter& startArray();\par
13587         JsonArrayWriter& startArray( StringRef key );\par
13588 \par
13589         JsonObjectWriter& startObject();\par
13590         JsonObjectWriter& startObject( StringRef key );\par
13591 \par
13592         {\cf18 void} endObject();\par
13593         {\cf18 void} endArray();\par
13594 \par
13595         {\cf18 bool} isInside( Writer writer );\par
13596 \par
13597         {\cf18 void} startListing();\par
13598         {\cf18 void} endListing();\par
13599 \par
13600         {\cf20 // Invariant:}\par
13601         {\cf20 // When m_writers is not empty and its top element is}\par
13602         {\cf20 // - Writer::Object, then m_objectWriters is not be empty}\par
13603         {\cf20 // - Writer::Array,  then m_arrayWriters shall not be empty}\par
13604         std::stack<JsonObjectWriter> m_objectWriters\{\};\par
13605         std::stack<JsonArrayWriter> m_arrayWriters\{\};\par
13606         std::stack<Writer> m_writers\{\};\par
13607 \par
13608         {\cf18 bool} m_startedListing = {\cf17 false};\par
13609 \par
13610         {\cf20 // std::size_t m_sectionDepth = 0;}\par
13611         {\cf20 // std::size_t m_sectionStarted = 0;}\par
13612     \};\par
13613 \} {\cf20 // namespace Catch}\par
13614 \par
13615 {\cf21 #endif }{\cf20 // CATCH_REPORTER_JSON_HPP_INCLUDED}\par
13616 \par
13617 \par
13618 {\cf21 #ifndef CATCH_REPORTER_JUNIT_HPP_INCLUDED}\par
13619 {\cf21 #define CATCH_REPORTER_JUNIT_HPP_INCLUDED}\par
13620 \par
13621 \par
13622 \par
13623 {\cf17 namespace }Catch \{\par
13624 \par
13625     {\cf17 class }JunitReporter final : {\cf17 public} CumulativeReporterBase \{\par
13626     {\cf17 public}:\par
13627         JunitReporter(ReporterConfig&& _config);\par
13628 \par
13629         {\cf17 static} std::string getDescription();\par
13630 \par
13631         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& runInfo) {\cf17 override};\par
13632 \par
13633         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testCaseInfo) {\cf17 override};\par
13634         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
13635 \par
13636         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
13637 \par
13638         {\cf18 void} testRunEndedCumulative() {\cf17 override};\par
13639 \par
13640     {\cf17 private}:\par
13641         {\cf18 void} writeRun(TestRunNode {\cf17 const}& testRunNode, {\cf18 double} suiteTime);\par
13642 \par
13643         {\cf18 void} writeTestCase(TestCaseNode {\cf17 const}& testCaseNode);\par
13644 \par
13645         {\cf18 void} writeSection( std::string {\cf17 const}& className,\par
13646                            std::string {\cf17 const}& rootName,\par
13647                            SectionNode {\cf17 const}& sectionNode,\par
13648                            {\cf18 bool} testOkToFail );\par
13649 \par
13650         {\cf18 void} writeAssertions(SectionNode {\cf17 const}& sectionNode);\par
13651         {\cf18 void} writeAssertion(AssertionStats {\cf17 const}& stats);\par
13652 \par
13653         XmlWriter xml;\par
13654         Timer suiteTimer;\par
13655         std::string stdOutForSuite;\par
13656         std::string stdErrForSuite;\par
13657         {\cf18 unsigned} {\cf18 int} unexpectedExceptions = 0;\par
13658         {\cf18 bool} m_okToFail = {\cf17 false};\par
13659     \};\par
13660 \par
13661 \} {\cf20 // end namespace Catch}\par
13662 \par
13663 {\cf21 #endif }{\cf20 // CATCH_REPORTER_JUNIT_HPP_INCLUDED}\par
13664 \par
13665 \par
13666 {\cf21 #ifndef CATCH_REPORTER_MULTI_HPP_INCLUDED}\par
13667 {\cf21 #define CATCH_REPORTER_MULTI_HPP_INCLUDED}\par
13668 \par
13669 \par
13670 {\cf17 namespace }Catch \{\par
13671 \par
13672     {\cf17 class }MultiReporter final : {\cf17 public} IEventListener \{\par
13673         {\cf20 /*}\par
13674 {\cf20          * Stores all added reporters and listeners}\par
13675 {\cf20          *}\par
13676 {\cf20          * All Listeners are stored before all reporters, and individual}\par
13677 {\cf20          * listeners/reporters are stored in order of insertion.}\par
13678 {\cf20          */}\par
13679         std::vector<IEventListenerPtr> m_reporterLikes;\par
13680         {\cf18 bool} m_haveNoncapturingReporters = {\cf17 false};\par
13681 \par
13682         {\cf20 // Keep track of how many listeners we have already inserted,}\par
13683         {\cf20 // so that we can insert them into the main vector at the right place}\par
13684         {\cf18 size_t} m_insertedListeners = 0;\par
13685 \par
13686         {\cf18 void} updatePreferences(IEventListener {\cf17 const}& reporterish);\par
13687 \par
13688     {\cf17 public}:\par
13689         {\cf17 using }IEventListener::IEventListener;\par
13690 \par
13691         {\cf18 void} addListener( IEventListenerPtr&& listener );\par
13692         {\cf18 void} addReporter( IEventListenerPtr&& reporter );\par
13693 \par
13694     {\cf17 public}: {\cf20 // IEventListener}\par
13695 \par
13696         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13697         {\cf18 void} fatalErrorEncountered( StringRef error ) {\cf17 override};\par
13698         {\cf18 void} reportInvalidTestSpec( StringRef arg ) {\cf17 override};\par
13699 \par
13700         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13701         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) {\cf17 override};\par
13702         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) {\cf17 override};\par
13703         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13704 \par
13705         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) {\cf17 override};\par
13706         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13707         {\cf18 void} testCasePartialStarting(TestCaseInfo {\cf17 const}& testInfo, uint64_t partNumber) {\cf17 override};\par
13708         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13709         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) {\cf17 override};\par
13710 \par
13711         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13712         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13713         {\cf18 void} testCasePartialEnded(TestCaseStats {\cf17 const}& testStats, uint64_t partNumber) {\cf17 override};\par
13714         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) {\cf17 override};\par
13715         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) {\cf17 override};\par
13716 \par
13717         {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13718 \par
13719         {\cf18 void} listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) {\cf17 override};\par
13720         {\cf18 void} listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) {\cf17 override};\par
13721         {\cf18 void} listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) {\cf17 override};\par
13722         {\cf18 void} listTags(std::vector<TagInfo> {\cf17 const}& tags) {\cf17 override};\par
13723 \par
13724 \par
13725     \};\par
13726 \par
13727 \} {\cf20 // end namespace Catch}\par
13728 \par
13729 {\cf21 #endif }{\cf20 // CATCH_REPORTER_MULTI_HPP_INCLUDED}\par
13730 \par
13731 \par
13732 {\cf21 #ifndef CATCH_REPORTER_REGISTRARS_HPP_INCLUDED}\par
13733 {\cf21 #define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED}\par
13734 \par
13735 \par
13736 {\cf21 #include <type_traits>}\par
13737 \par
13738 {\cf17 namespace }Catch \{\par
13739 \par
13740     {\cf17 namespace }Detail \{\par
13741 \par
13742         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
13743         {\cf17 struct }has_description : std::false_type \{\};\par
13744 \par
13745         {\cf17 template} <{\cf17 typename} T>\par
13746         {\cf17 struct }has_description<\par
13747             T,\par
13748             void_t<decltype( T::getDescription() )>>\par
13749             : std::true_type \{\};\par
13750 \par
13753         {\cf18 void} registerReporterImpl( std::string {\cf17 const}& name,\par
13754                                    IReporterFactoryPtr reporterPtr );\par
13756         {\cf18 void} registerListenerImpl( Detail::unique_ptr<EventListenerFactory> listenerFactory );\par
13757     \} {\cf20 // namespace Detail}\par
13758 \par
13759     {\cf17 class }IEventListener;\par
13760     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
13761 \par
13762     {\cf17 template} <{\cf17 typename} T>\par
13763     {\cf17 class }ReporterFactory : {\cf17 public} IReporterFactory \{\par
13764 \par
13765         IEventListenerPtr create( ReporterConfig&& config ){\cf17  const override }\{\par
13766             {\cf19 return} Detail::make_unique<T>( CATCH_MOVE(config) );\par
13767         \}\par
13768 \par
13769         std::string getDescription(){\cf17  const override }\{\par
13770             {\cf19 return} T::getDescription();\par
13771         \}\par
13772     \};\par
13773 \par
13774 \par
13775     {\cf17 template}<{\cf17 typename} T>\par
13776     {\cf17 class }ReporterRegistrar \{\par
13777     {\cf17 public}:\par
13778         {\cf17 explicit} ReporterRegistrar( std::string {\cf17 const}& name ) \{\par
13779             registerReporterImpl( name,\par
13780                                   Detail::make_unique<ReporterFactory<T>>() );\par
13781         \}\par
13782     \};\par
13783 \par
13784     {\cf17 template}<{\cf17 typename} T>\par
13785     {\cf17 class }ListenerRegistrar \{\par
13786 \par
13787         {\cf17 class }TypedListenerFactory : {\cf17 public} EventListenerFactory \{\par
13788             StringRef m_listenerName;\par
13789 \par
13790             std::string getDescriptionImpl( std::true_type ){\cf17  const }\{\par
13791                 {\cf19 return} T::getDescription();\par
13792             \}\par
13793 \par
13794             std::string getDescriptionImpl( std::false_type ){\cf17  const }\{\par
13795                 {\cf19 return} {\cf22 "(No description provided)"};\par
13796             \}\par
13797 \par
13798         {\cf17 public}:\par
13799             TypedListenerFactory( StringRef listenerName ):\par
13800                 m_listenerName( listenerName ) \{\}\par
13801 \par
13802             IEventListenerPtr create( IConfig {\cf17 const}* config ){\cf17  const override }\{\par
13803                 {\cf19 return} Detail::make_unique<T>( config );\par
13804             \}\par
13805 \par
13806             StringRef getName(){\cf17  const override }\{\par
13807                 {\cf19 return} m_listenerName;\par
13808             \}\par
13809 \par
13810             std::string getDescription(){\cf17  const override }\{\par
13811                 {\cf19 return} getDescriptionImpl( Detail::has_description<T>\{\} );\par
13812             \}\par
13813         \};\par
13814 \par
13815     {\cf17 public}:\par
13816         ListenerRegistrar(StringRef listenerName) \{\par
13817             registerListenerImpl( Detail::make_unique<TypedListenerFactory>(listenerName) );\par
13818         \}\par
13819     \};\par
13820 \}\par
13821 \par
13822 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
13823 \par
13824 {\cf21 #    define CATCH_REGISTER_REPORTER( name, reporterType )                      \\}\par
13825 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\}\par
13826 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\}\par
13827 {\cf21         namespace \{                                                            \\}\par
13828 {\cf21             Catch::ReporterRegistrar<reporterType> INTERNAL_CATCH_UNIQUE_NAME( \\}\par
13829 {\cf21                 catch_internal_RegistrarFor )( name );                         \\}\par
13830 {\cf21         \}                                                                      \\}\par
13831 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
13832 \par
13833 {\cf21 #    define CATCH_REGISTER_LISTENER( listenerType )                            \\}\par
13834 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\}\par
13835 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\}\par
13836 {\cf21         namespace \{                                                            \\}\par
13837 {\cf21             Catch::ListenerRegistrar<listenerType> INTERNAL_CATCH_UNIQUE_NAME( \\}\par
13838 {\cf21                 catch_internal_RegistrarFor )( #listenerType##_catch_sr );     \\}\par
13839 {\cf21         \}                                                                      \\}\par
13840 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
13841 \par
13842 {\cf21 #else }{\cf20 // CATCH_CONFIG_DISABLE}\par
13843 \par
13844 {\cf21 #define CATCH_REGISTER_REPORTER(name, reporterType)}\par
13845 {\cf21 #define CATCH_REGISTER_LISTENER(listenerType)}\par
13846 \par
13847 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE}\par
13848 \par
13849 {\cf21 #endif }{\cf20 // CATCH_REPORTER_REGISTRARS_HPP_INCLUDED}\par
13850 \par
13851 \par
13852 {\cf21 #ifndef CATCH_REPORTER_SONARQUBE_HPP_INCLUDED}\par
13853 {\cf21 #define CATCH_REPORTER_SONARQUBE_HPP_INCLUDED}\par
13854 \par
13855 \par
13856 \par
13857 {\cf17 namespace }Catch \{\par
13858 \par
13859     {\cf17 class }SonarQubeReporter final : {\cf17 public} CumulativeReporterBase \{\par
13860     {\cf17 public}:\par
13861         SonarQubeReporter(ReporterConfig&& config)\par
13862         : CumulativeReporterBase(CATCH_MOVE(config))\par
13863         , xml(m_stream) \{\par
13864             m_preferences.shouldRedirectStdOut = {\cf17 true};\par
13865             m_preferences.shouldReportAllAssertions = {\cf17 true};\par
13866             m_shouldStoreSuccesfulAssertions = {\cf17 false};\par
13867         \}\par
13868 \par
13869         {\cf17 static} std::string getDescription() \{\par
13870             {\cf17 using namespace }std::string_literals;\par
13871             {\cf19 return} {\cf22 "Reports test results in the Generic Test Data SonarQube XML format"}s;\par
13872         \}\par
13873 \par
13874         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) {\cf17 override};\par
13875 \par
13876         {\cf18 void} testRunEndedCumulative(){\cf17  override }\{\par
13877             writeRun( *m_testRun );\par
13878             xml.endElement();\par
13879         \}\par
13880 \par
13881         {\cf18 void} writeRun( TestRunNode {\cf17 const}& runNode );\par
13882 \par
13883         {\cf18 void} writeTestFile(StringRef filename, std::vector<TestCaseNode const*> {\cf17 const}& testCaseNodes);\par
13884 \par
13885         {\cf18 void} writeTestCase(TestCaseNode {\cf17 const}& testCaseNode);\par
13886 \par
13887         {\cf18 void} writeSection(std::string {\cf17 const}& rootName, SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail);\par
13888 \par
13889         {\cf18 void} writeAssertions(SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail);\par
13890 \par
13891         {\cf18 void} writeAssertion(AssertionStats {\cf17 const}& stats, {\cf18 bool} okToFail);\par
13892 \par
13893     {\cf17 private}:\par
13894         XmlWriter xml;\par
13895     \};\par
13896 \par
13897 \par
13898 \} {\cf20 // end namespace Catch}\par
13899 \par
13900 {\cf21 #endif }{\cf20 // CATCH_REPORTER_SONARQUBE_HPP_INCLUDED}\par
13901 \par
13902 \par
13903 {\cf21 #ifndef CATCH_REPORTER_TAP_HPP_INCLUDED}\par
13904 {\cf21 #define CATCH_REPORTER_TAP_HPP_INCLUDED}\par
13905 \par
13906 \par
13907 {\cf17 namespace }Catch \{\par
13908 \par
13909     {\cf17 class }TAPReporter final : {\cf17 public} StreamingReporterBase \{\par
13910     {\cf17 public}:\par
13911         TAPReporter( ReporterConfig&& config ):\par
13912             StreamingReporterBase( CATCH_MOVE(config) ) \{\par
13913             m_preferences.shouldReportAllAssertions = {\cf17 true};\par
13914         \}\par
13915 \par
13916         {\cf17 static} std::string getDescription() \{\par
13917             {\cf17 using namespace }std::string_literals;\par
13918             {\cf19 return} {\cf22 "Reports test results in TAP format, suitable for test harnesses"}s;\par
13919         \}\par
13920 \par
13921         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13922 \par
13923         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13924 \par
13925         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
13926 \par
13927         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
13928 \par
13929     {\cf17 private}:\par
13930         std::size_t counter = 0;\par
13931     \};\par
13932 \par
13933 \} {\cf20 // end namespace Catch}\par
13934 \par
13935 {\cf21 #endif }{\cf20 // CATCH_REPORTER_TAP_HPP_INCLUDED}\par
13936 \par
13937 \par
13938 {\cf21 #ifndef CATCH_REPORTER_TEAMCITY_HPP_INCLUDED}\par
13939 {\cf21 #define CATCH_REPORTER_TEAMCITY_HPP_INCLUDED}\par
13940 \par
13941 \par
13942 {\cf21 #include <cstring>}\par
13943 \par
13944 {\cf21 #ifdef __clang__}\par
13945 {\cf21 #   pragma clang diagnostic push}\par
13946 {\cf21 #   pragma clang diagnostic ignored "-Wpadded"}\par
13947 {\cf21 #endif}\par
13948 \par
13949 {\cf17 namespace }Catch \{\par
13950 \par
13951     {\cf17 class }TeamCityReporter final : {\cf17 public} StreamingReporterBase \{\par
13952     {\cf17 public}:\par
13953         TeamCityReporter( ReporterConfig&& _config )\par
13954         :   StreamingReporterBase( CATCH_MOVE(_config) )\par
13955         \{\par
13956             m_preferences.shouldRedirectStdOut = {\cf17 true};\par
13957         \}\par
13958 \par
13959         ~TeamCityReporter() {\cf17 override};\par
13960 \par
13961         {\cf17 static} std::string getDescription() \{\par
13962             {\cf17 using namespace }std::string_literals;\par
13963             {\cf19 return} {\cf22 "Reports test results as TeamCity service messages"}s;\par
13964         \}\par
13965 \par
13966         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& runInfo ) {\cf17 override};\par
13967         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& runStats ) {\cf17 override};\par
13968 \par
13969 \par
13970         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
13971 \par
13972         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& sectionInfo){\cf17  override }\{\par
13973             m_headerPrintedForThisSection = {\cf17 false};\par
13974             StreamingReporterBase::sectionStarting( sectionInfo );\par
13975         \}\par
13976 \par
13977         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testInfo) {\cf17 override};\par
13978 \par
13979         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
13980 \par
13981     {\cf17 private}:\par
13982         {\cf18 void} printSectionHeader(std::ostream& os);\par
13983 \par
13984         {\cf18 bool} m_headerPrintedForThisSection = {\cf17 false};\par
13985         Timer m_testTimer;\par
13986     \};\par
13987 \par
13988 \} {\cf20 // end namespace Catch}\par
13989 \par
13990 {\cf21 #ifdef __clang__}\par
13991 {\cf21 #   pragma clang diagnostic pop}\par
13992 {\cf21 #endif}\par
13993 \par
13994 {\cf21 #endif }{\cf20 // CATCH_REPORTER_TEAMCITY_HPP_INCLUDED}\par
13995 \par
13996 \par
13997 {\cf21 #ifndef CATCH_REPORTER_XML_HPP_INCLUDED}\par
13998 {\cf21 #define CATCH_REPORTER_XML_HPP_INCLUDED}\par
13999 \par
14000 \par
14001 \par
14002 \par
14003 {\cf17 namespace }Catch \{\par
14004     {\cf17 class }XmlReporter : {\cf17 public} StreamingReporterBase \{\par
14005     {\cf17 public}:\par
14006         XmlReporter(ReporterConfig&& _config);\par
14007 \par
14008         ~XmlReporter() {\cf17 override};\par
14009 \par
14010         {\cf17 static} std::string getDescription();\par
14011 \par
14012         {\cf17 virtual} std::string getStylesheetRef() {\cf17 const};\par
14013 \par
14014         {\cf18 void} writeSourceInfo(SourceLineInfo {\cf17 const}& sourceInfo);\par
14015 \par
14016     {\cf17 public}: {\cf20 // StreamingReporterBase}\par
14017 \par
14018         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& testInfo) {\cf17 override};\par
14019 \par
14020         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testInfo) {\cf17 override};\par
14021 \par
14022         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& sectionInfo) {\cf17 override};\par
14023 \par
14024         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
14025 \par
14026         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
14027 \par
14028         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& sectionStats) {\cf17 override};\par
14029 \par
14030         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
14031 \par
14032         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& testRunStats) {\cf17 override};\par
14033 \par
14034         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
14035         {\cf18 void} benchmarkStarting(BenchmarkInfo {\cf17 const}&) {\cf17 override};\par
14036         {\cf18 void} benchmarkEnded(BenchmarkStats<> {\cf17 const}&) {\cf17 override};\par
14037         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
14038 \par
14039         {\cf18 void} listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) {\cf17 override};\par
14040         {\cf18 void} listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) {\cf17 override};\par
14041         {\cf18 void} listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) {\cf17 override};\par
14042         {\cf18 void} listTags(std::vector<TagInfo> {\cf17 const}& tags) {\cf17 override};\par
14043 \par
14044     {\cf17 private}:\par
14045         Timer m_testCaseTimer;\par
14046         XmlWriter m_xml;\par
14047         {\cf18 int} m_sectionDepth = 0;\par
14048     \};\par
14049 \par
14050 \} {\cf20 // end namespace Catch}\par
14051 \par
14052 {\cf21 #endif }{\cf20 // CATCH_REPORTER_XML_HPP_INCLUDED}\par
14053 \par
14054 {\cf21 #endif }{\cf20 // CATCH_REPORTERS_ALL_HPP_INCLUDED}\par
14055 \par
14056 {\cf21 #endif }{\cf20 // CATCH_ALL_HPP_INCLUDED}\par
14057 {\cf21 #endif }{\cf20 // CATCH_AMALGAMATED_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo test/EmprestimoTest.cpp\par \pard\plain 
{\tc\tcl2 \v test/EmprestimoTest.cpp}
{\xe \v test/EmprestimoTest.cpp}
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "catch_amalgamated.cpp"}\par
{\f2 #include "Emprestimo.h"}\par
{\f2 #include "Usuario.h"}\par
{\f2 #include "Livro.h"}\par
{\f2 #include <sstream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_MAIN}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Teste da classe Emprestimo")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Teste da classe EmprestimoLivros")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v CATCH_CONFIG_MAIN\:EmprestimoTest.cpp}
{\xe \v EmprestimoTest.cpp\:CATCH_CONFIG_MAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_MAIN}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v TEST_CASE\:EmprestimoTest.cpp}
{\xe \v EmprestimoTest.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Teste da classe Emprestimo" )}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11                                         \{\par
12     Usuario usuario(1, {\cf22 "Bruno"}, {\cf22 "123456789"});\par
13     Livro livro(1, {\cf22 "Primeiros Passos em C++"}, {\cf22 "Lippman"}, {\cf22 "Inform\'E1tica"});\par
14 \par
15     Emprestimo emprestimo(1, usuario, livro, {\cf22 "2024-08-01"}, {\cf22 "2024-08-15"});\par
16 \par
17     SECTION({\cf22 "Teste de getters"}) \{\par
18         REQUIRE(emprestimo.getId() == 1);\par
19         REQUIRE(emprestimo.getUsuario().getNome() == {\cf22 "Bruno"});\par
20         REQUIRE(emprestimo.getLivro().getTitulo() == {\cf22 "Primeiros Passos em C++"});\par
21         REQUIRE(emprestimo.getDataEmprestimo() == {\cf22 "2024-08-01"});\par
22         REQUIRE(emprestimo.getDataDevolucao() == {\cf22 "2024-08-15"});\par
23         REQUIRE(emprestimo.getMulta() == 0);\par
24     \}\par
25 \par
26     SECTION({\cf22 "Teste de setters"}) \{\par
27         emprestimo.setDataDevolucao({\cf22 "2024-08-20"});\par
28         emprestimo.setMulta(50.0);\par
29 \par
30         REQUIRE(emprestimo.getDataDevolucao() == {\cf22 "2024-08-20"});\par
31         REQUIRE(emprestimo.getMulta() == 50.0);\par
32     \}\par
33 \}\par
}
}
{\xe \v TEST_CASE\:EmprestimoTest.cpp}
{\xe \v EmprestimoTest.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Teste da classe EmprestimoLivros" )}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 36                                               \{\par
37     Usuario usuario1(1, {\cf22 "Bruno"}, {\cf22 "123456789"});\par
38     Usuario usuario2(2, {\cf22 "Hugo"}, {\cf22 "987654321"});\par
39     Usuario usuario3(3, {\cf22 "Julio"}, {\cf22 "555555555"});\par
40     Usuario usuario4(4, {\cf22 "Carlos"}, {\cf22 "666666666"});\par
41 \par
42     Livro livro1(1, {\cf22 "Primeiros Passos em C++"}, {\cf22 "Lippman"}, {\cf22 "Inform\'E1tica"});\par
43     Livro livro2(2, {\cf22 "C\'F3digo Limpo"}, {\cf22 "Martin"}, {\cf22 "Inform\'E1tica"});\par
44 \par
45     EmprestimoLivros gerenciador;\par
46 \par
47     Emprestimo emprestimo1(1, usuario1, livro1, {\cf22 "2024-08-01"}, {\cf22 "2024-08-15"});\par
48     Emprestimo emprestimo2(2, usuario2, livro2, {\cf22 "2024-08-05"}, {\cf22 "2024-08-20"});\par
49 \par
50     SECTION({\cf22 "Registrar e consultar empr\'E9stimos"}) \{\par
51         gerenciador.registrarEmprestimo(emprestimo1);\par
52         gerenciador.registrarEmprestimo(emprestimo2);\par
53 \par
54         stringstream buffer;\par
55         streambuf* prevcoutbuf = cout.rdbuf(buffer.rdbuf());\par
56 \par
57         gerenciador.exibirRelatorioEmprestimos();\par
58 \par
59         cout.rdbuf(prevcoutbuf);\par
60         {\cf18 string} resultado = buffer.str();\par
61 \par
62         REQUIRE(resultado.find({\cf22 "ID do Emprestimo: 1"}) != string::npos);\par
63         REQUIRE(resultado.find({\cf22 "Usuario: Bruno"}) != string::npos);\par
64         REQUIRE(resultado.find({\cf22 "Livro: Primeiros Passos em C++"}) != string::npos);\par
65         REQUIRE(resultado.find({\cf22 "Data do Emprestimo: 2024-08-01"}) != string::npos);\par
66         REQUIRE(resultado.find({\cf22 "Data de Devolucao: 2024-08-15"}) != string::npos);\par
67         REQUIRE(resultado.find({\cf22 "Multa: 0"}) != string::npos);\par
68 \par
69         REQUIRE(resultado.find({\cf22 "ID do Emprestimo: 2"}) != string::npos);\par
70         REQUIRE(resultado.find({\cf22 "Usuario: Hugo"}) != string::npos);\par
71         REQUIRE(resultado.find({\cf22 "Livro: C\'F3digo Limpo"}) != string::npos);\par
72         REQUIRE(resultado.find({\cf22 "Data do Emprestimo: 2024-08-05"}) != string::npos);\par
73         REQUIRE(resultado.find({\cf22 "Data de Devolucao: 2024-08-20"}) != string::npos);\par
74         REQUIRE(resultado.find({\cf22 "Multa: 0"}) != string::npos);\par
75     \}\par
76 \par
77     SECTION({\cf22 "Aplicar multa"}) \{\par
78         gerenciador.registrarEmprestimo(emprestimo1);\par
79 \par
80         REQUIRE(gerenciador.aplicarMulta(1, 25.0) == {\cf17 true});\par
81         REQUIRE(emprestimo1.getMulta() == 25.0);\par
82 \par
83         REQUIRE(gerenciador.aplicarMulta(2, 30.0) == {\cf17 false}); \par
84     \}\par
85 \par
86     SECTION({\cf22 "Controlar prazo de devolu\'E7\'E3o"}) \{\par
87         gerenciador.registrarEmprestimo(emprestimo2);\par
88 \par
89         REQUIRE(gerenciador.controlarPrazoDevolucao(2, {\cf22 "2024-08-25"}) == {\cf17 true});\par
90         REQUIRE(emprestimo2.getDataDevolucao() == {\cf22 "2024-08-25"});\par
91 \par
92         REQUIRE(gerenciador.controlarPrazoDevolucao(3, {\cf22 "2024-08-30"}) == {\cf17 false});\par
93     \}\par
94 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia do Arquivo test/UsuarioTest.cpp\par \pard\plain 
{\tc\tcl2 \v test/UsuarioTest.cpp}
{\xe \v test/UsuarioTest.cpp}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "catch_amalgamated.cpp"}\par
{\f2 #include "Usuario.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_MAIN}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Teste da classe Usuario")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Teste da classe GerenciamentoUsuario")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es e macros\par
\pard\plain 
{\xe \v CATCH_CONFIG_MAIN\:UsuarioTest.cpp}
{\xe \v UsuarioTest.cpp\:CATCH_CONFIG_MAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_MAIN}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 
{\xe \v TEST_CASE\:UsuarioTest.cpp}
{\xe \v UsuarioTest.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Teste da classe GerenciamentoUsuario" )}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TEST_CASE\:UsuarioTest.cpp}
{\xe \v UsuarioTest.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Teste da classe Usuario" )}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 8                                      \{\par
9     Usuario usuario(1, {\cf22 "Bruno"}, {\cf22 "123456789"});\par
10 \par
11     SECTION({\cf22 "Teste de getters"}) \{\par
12         REQUIRE(usuario.getId() == 1);\par
13         REQUIRE(usuario.getNome() == {\cf22 "Bruno"});\par
14         REQUIRE(usuario.getTelefone() == {\cf22 "123456789"});\par
15     \}\par
16 \par
17     SECTION({\cf22 "Teste de setters"}) \{\par
18         usuario.setNome({\cf22 "Carlos"});\par
19         usuario.setTelefone({\cf22 "987654321"});\par
20 \par
21         REQUIRE(usuario.getNome() == {\cf22 "Carlos"});\par
22         REQUIRE(usuario.getTelefone() == {\cf22 "987654321"});\par
23     \}\par
24 \}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Sum\'E1rio\par 
\pard\plain 
{\tc \v Sum\'E1rio}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
