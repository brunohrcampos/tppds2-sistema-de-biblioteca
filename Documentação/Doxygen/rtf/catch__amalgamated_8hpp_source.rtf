{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
catch_amalgamated.hpp\par \pard\plain 
{\tc\tcl2 \v test/catch_amalgamated.hpp}
{\xe \v test/catch_amalgamated.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Ir para a documentação desse arquivo.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf20 //              Copyright Catch2 Authors}\par
3 {\cf20 // Distributed under the Boost Software License, Version 1.0.}\par
4 {\cf20 //   (See accompanying file LICENSE.txt or copy at}\par
5 {\cf20 //        https://www.boost.org/LICENSE_1_0.txt)}\par
6 \par
7 {\cf20 // SPDX-License-Identifier: BSL-1.0}\par
8 \par
9 {\cf20 //  Catch v3.6.0}\par
10 {\cf20 //  Generated: 2024-05-05 20:53:27.071502}\par
11 {\cf20 //  ----------------------------------------------------------}\par
12 {\cf20 //  This file is an amalgamation of multiple different files.}\par
13 {\cf20 //  You probably shouldn't edit it directly.}\par
14 {\cf20 //  ----------------------------------------------------------}\par
15 {\cf21 #ifndef CATCH_AMALGAMATED_HPP_INCLUDED}\par
16 {\cf21 #define CATCH_AMALGAMATED_HPP_INCLUDED}\par
17 \par
18 \par
33 {\cf21 #ifndef CATCH_ALL_HPP_INCLUDED}\par
34 {\cf21 #define CATCH_ALL_HPP_INCLUDED}\par
35 \par
36 \par
37 \par
51 {\cf21 #ifndef CATCH_BENCHMARK_ALL_HPP_INCLUDED}\par
52 {\cf21 #define CATCH_BENCHMARK_ALL_HPP_INCLUDED}\par
53 \par
54 \par
55 \par
56 {\cf20 // Adapted from donated nonius code.}\par
57 \par
58 {\cf21 #ifndef CATCH_BENCHMARK_HPP_INCLUDED}\par
59 {\cf21 #define CATCH_BENCHMARK_HPP_INCLUDED}\par
60 \par
61 \par
62 \par
63 {\cf21 #ifndef CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}\par
64 {\cf21 #define CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}\par
65 \par
66 {\cf20 // Detect a number of compiler features - by compiler}\par
67 {\cf20 // The following features are defined:}\par
68 {\cf20 //}\par
69 {\cf20 // CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?}\par
70 {\cf20 // CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?}\par
71 {\cf20 // CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?}\par
72 {\cf20 // ****************}\par
73 {\cf20 // Note to maintainers: if new toggles are added please document them}\par
74 {\cf20 // in configuration.md, too}\par
75 {\cf20 // ****************}\par
76 \par
77 {\cf20 // In general each macro has a _NO_<feature name> form}\par
78 {\cf20 // (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.}\par
79 {\cf20 // Many features, at point of detection, define an _INTERNAL_ macro, so they}\par
80 {\cf20 // can be combined, en-mass, with the _NO_ forms later.}\par
81 \par
82 \par
83 \par
84 {\cf21 #ifndef CATCH_PLATFORM_HPP_INCLUDED}\par
85 {\cf21 #define CATCH_PLATFORM_HPP_INCLUDED}\par
86 \par
87 {\cf20 // See e.g.:}\par
88 {\cf20 // https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-18.1/TargetConditionals.h.auto.html}\par
89 {\cf21 #ifdef __APPLE__}\par
90 {\cf21 #  ifndef __has_extension}\par
91 {\cf21 #    define __has_extension(x) 0}\par
92 {\cf21 #  endif}\par
93 {\cf21 #  include <TargetConditionals.h>}\par
94 {\cf21 #  if (defined(TARGET_OS_OSX) && TARGET_OS_OSX == 1) || \\}\par
95 {\cf21       (defined(TARGET_OS_MAC) && TARGET_OS_MAC == 1)}\par
96 {\cf21 #    define CATCH_PLATFORM_MAC}\par
97 {\cf21 #  elif (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE == 1)}\par
98 {\cf21 #    define CATCH_PLATFORM_IPHONE}\par
99 {\cf21 #  endif}\par
100 \par
101 {\cf21 #elif defined(linux) || defined(__linux) || defined(__linux__)}\par
102 {\cf21 #  define CATCH_PLATFORM_LINUX}\par
103 \par
104 {\cf21 #elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)}\par
105 {\cf21 #  define CATCH_PLATFORM_WINDOWS}\par
106 \par
107 {\cf21 #  if defined( WINAPI_FAMILY ) && ( WINAPI_FAMILY == WINAPI_FAMILY_APP )}\par
108 {\cf21 #      define CATCH_PLATFORM_WINDOWS_UWP}\par
109 {\cf21 #  endif}\par
110 \par
111 {\cf21 #elif defined(__ORBIS__) || defined(__PROSPERO__)}\par
112 {\cf21 #  define CATCH_PLATFORM_PLAYSTATION}\par
113 \par
114 {\cf21 #endif}\par
115 \par
116 {\cf21 #endif }{\cf20 // CATCH_PLATFORM_HPP_INCLUDED}\par
117 \par
118 {\cf21 #ifdef __cplusplus}\par
119 \par
120 {\cf21 #  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)}\par
121 {\cf21 #    define CATCH_CPP17_OR_GREATER}\par
122 {\cf21 #  endif}\par
123 \par
124 {\cf21 #  if (__cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)}\par
125 {\cf21 #    define CATCH_CPP20_OR_GREATER}\par
126 {\cf21 #  endif}\par
127 \par
128 {\cf21 #endif}\par
129 \par
130 {\cf20 // Only GCC compiler should be used in this block, so other compilers trying to}\par
131 {\cf20 // mask themselves as GCC should be ignored.}\par
132 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && !defined(__CUDACC__) && !defined(__LCC__) && !defined(__NVCOMPILER)}\par
133 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "GCC diagnostic push" )}\par
134 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "GCC diagnostic pop" )}\par
135 \par
136 {\cf20 // This only works on GCC 9+. so we have to also add a global suppression of Wparentheses}\par
137 {\cf20 // for older versions of GCC.}\par
138 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
139 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wparentheses\\"" )}\par
140 \par
141 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
142 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wunused-result\\"" )}\par
143 \par
144 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
145 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wunused-variable\\"" )}\par
146 \par
147 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
148 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wuseless-cast\\"" )}\par
149 \par
150 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS \\}\par
151 {\cf21          _Pragma( "GCC diagnostic ignored \\"-Wshadow\\"" )}\par
152 \par
153 {\cf21 #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)}\par
154 \par
155 {\cf21 #endif}\par
156 \par
157 {\cf21 #if defined(__NVCOMPILER)}\par
158 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "diag push" )}\par
159 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "diag pop" )}\par
160 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "diag_suppress declared_but_not_referenced" )}\par
161 {\cf21 #endif}\par
162 \par
163 {\cf21 #if defined(__CUDACC__) && !defined(__clang__)}\par
164 {\cf21 #  ifdef __NVCC_DIAG_PRAGMA_SUPPORT__}\par
165 {\cf20 // New pragmas introduced in CUDA 11.5+}\par
166 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "nv_diagnostic push" )}\par
167 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "nv_diagnostic pop" )}\par
168 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "nv_diag_suppress 177" )}\par
169 {\cf21 #  else}\par
170 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "diag_suppress 177" )}\par
171 {\cf21 #  endif}\par
172 {\cf21 #endif}\par
173 \par
174 {\cf20 // clang-cl defines _MSC_VER as well as __clang__, which could cause the}\par
175 {\cf20 // start/stop internal suppression macros to be double defined.}\par
176 {\cf21 #if defined(__clang__) && !defined(_MSC_VER)}\par
177 \par
178 {\cf21 #    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "clang diagnostic push" )}\par
179 {\cf21 #    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "clang diagnostic pop" )}\par
180 \par
181 {\cf21 #endif }{\cf20 // __clang__ && !_MSC_VER}\par
182 \par
183 {\cf21 #if defined(__clang__)}\par
184 \par
185 {\cf20 // As of this writing, IBM XL's implementation of __builtin_constant_p has a bug}\par
186 {\cf20 // which results in calls to destructors being emitted for each temporary,}\par
187 {\cf20 // without a matching initialization. In practice, this can result in something}\par
188 {\cf20 // like `std::string::~string` being called on an uninitialized value.}\par
189 {\cf20 //}\par
190 {\cf20 // For example, this code will likely segfault under IBM XL:}\par
191 {\cf20 // ```}\par
192 {\cf20 // REQUIRE(std::string("12") + "34" == "1234")}\par
193 {\cf20 // ```}\par
194 {\cf20 //}\par
195 {\cf20 // Similarly, NVHPC's implementation of `__builtin_constant_p` has a bug which}\par
196 {\cf20 // results in calls to the immediately evaluated lambda expressions to be}\par
197 {\cf20 // reported as unevaluated lambdas.}\par
198 {\cf20 // https://developer.nvidia.com/nvidia_bug/3321845.}\par
199 {\cf20 //}\par
200 {\cf20 // Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.}\par
201 {\cf21 #  if !defined(__ibmxl__) && !defined(__CUDACC__) && !defined( __NVCOMPILER )}\par
202 {\cf21 #    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) }{\cf20 /* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */}{\cf21 }\par
203 {\cf21 #  endif}\par
204 \par
205 \par
206 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
207 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wexit-time-destructors\\"" ) \\}\par
208 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wglobal-constructors\\"")}\par
209 \par
210 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
211 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wparentheses\\"" )}\par
212 \par
213 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
214 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wunused-variable\\"" )}\par
215 \par
216 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
217 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wgnu-zero-variadic-macro-arguments\\"" )}\par
218 \par
219 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
220 {\cf21          _Pragma( "clang diagnostic ignored \\"-Wunused-template\\"" )}\par
221 \par
222 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
223 {\cf21         _Pragma( "clang diagnostic ignored \\"-Wcomma\\"" )}\par
224 \par
225 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS \\}\par
226 {\cf21         _Pragma( "clang diagnostic ignored \\"-Wshadow\\"" )}\par
227 \par
228 {\cf21 #endif }{\cf20 // __clang__}\par
229 \par
230 \par
232 {\cf20 // We know some environments not to support full POSIX signals}\par
233 {\cf21 #if defined( CATCH_PLATFORM_WINDOWS ) ||                                       \\}\par
234 {\cf21     defined( CATCH_PLATFORM_PLAYSTATION ) ||                                   \\}\par
235 {\cf21     defined( __CYGWIN__ ) ||                                                   \\}\par
236 {\cf21     defined( __QNX__ ) ||                                                      \\}\par
237 {\cf21     defined( __EMSCRIPTEN__ ) ||                                               \\}\par
238 {\cf21     defined( __DJGPP__ ) ||                                                    \\}\par
239 {\cf21     defined( __OS400__ )}\par
240 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS}\par
241 {\cf21 #else}\par
242 {\cf21 #    define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS}\par
243 {\cf21 #endif}\par
244 \par
246 {\cf20 // Assume that some platforms do not support getenv.}\par
247 {\cf21 #if defined( CATCH_PLATFORM_WINDOWS_UWP ) ||                                   \\}\par
248 {\cf21     defined( CATCH_PLATFORM_PLAYSTATION ) ||                                   \\}\par
249 {\cf21     defined( _GAMING_XBOX )}\par
250 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_GETENV}\par
251 {\cf21 #else}\par
252 {\cf21 #    define CATCH_INTERNAL_CONFIG_GETENV}\par
253 {\cf21 #endif}\par
254 \par
256 {\cf20 // Android somehow still does not support std::to_string}\par
257 {\cf21 #if defined(__ANDROID__)}\par
258 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING}\par
259 {\cf21 #endif}\par
260 \par
262 {\cf20 // Not all Windows environments support SEH properly}\par
263 {\cf21 #if defined(__MINGW32__)}\par
264 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH}\par
265 {\cf21 #endif}\par
266 \par
268 {\cf20 // PS4}\par
269 {\cf21 #if defined(__ORBIS__)}\par
270 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE}\par
271 {\cf21 #endif}\par
272 \par
274 {\cf20 // Cygwin}\par
275 {\cf21 #ifdef __CYGWIN__}\par
276 \par
277 {\cf20 // Required for some versions of Cygwin to declare gettimeofday}\par
278 {\cf20 // see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin}\par
279 {\cf21 #   define _BSD_SOURCE}\par
280 {\cf20 // some versions of cygwin (most) do not support std::to_string. Use the libstd check.}\par
281 {\cf20 // https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813}\par
282 {\cf21 # if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \\}\par
283 {\cf21            && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))}\par
284 \par
285 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING}\par
286 \par
287 {\cf21 # endif}\par
288 {\cf21 #endif }{\cf20 // __CYGWIN__}\par
289 \par
291 {\cf20 // Visual C++}\par
292 {\cf21 #if defined(_MSC_VER)}\par
293 \par
294 {\cf20 // We want to defer to nvcc-specific warning suppression if we are compiled}\par
295 {\cf20 // with nvcc masquerading for MSVC.}\par
296 {\cf21 #    if !defined( __CUDACC__ )}\par
297 {\cf21 #        define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
298 {\cf21             __pragma( warning( push ) )}\par
299 {\cf21 #        define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
300 {\cf21             __pragma( warning( pop ) )}\par
301 {\cf21 #    endif}\par
302 \par
303 {\cf20 // Universal Windows platform does not support SEH}\par
304 {\cf20 // Or console colours (or console at all...)}\par
305 {\cf21 #  if defined(CATCH_PLATFORM_WINDOWS_UWP)}\par
306 {\cf21 #    define CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32}\par
307 {\cf21 #  else}\par
308 {\cf21 #    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH}\par
309 {\cf21 #  endif}\par
310 \par
311 {\cf20 // MSVC traditional preprocessor needs some workaround for __VA_ARGS__}\par
312 {\cf20 // _MSVC_TRADITIONAL == 0 means new conformant preprocessor}\par
313 {\cf20 // _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor}\par
314 {\cf21 #  if !defined(__clang__) }{\cf20 // Handle Clang masquerading for msvc}\par
315 {\cf21 #    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)}\par
316 {\cf21 #      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
317 {\cf21 #    endif }{\cf20 // MSVC_TRADITIONAL}\par
318 {\cf21 #  endif }{\cf20 // __clang__}\par
319 \par
320 {\cf21 #endif }{\cf20 // _MSC_VER}\par
321 \par
322 {\cf21 #if defined(_REENTRANT) || defined(_MSC_VER)}\par
323 {\cf20 // Enable async processing, as -pthread is specified or no additional linking is required}\par
324 {\cf21 # define CATCH_INTERNAL_CONFIG_USE_ASYNC}\par
325 {\cf21 #endif }{\cf20 // _MSC_VER}\par
326 \par
328 {\cf20 // Check if we are compiled with -fno-exceptions or equivalent}\par
329 {\cf21 #if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)}\par
330 {\cf21 #  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED}\par
331 {\cf21 #endif}\par
332 \par
333 \par
335 {\cf20 // Embarcadero C++Build}\par
336 {\cf21 #if defined(__BORLANDC__)}\par
337 {\cf21     #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN}\par
338 {\cf21 #endif}\par
339 \par
341 \par
342 {\cf20 // RTX is a special version of Windows that is real time.}\par
343 {\cf20 // This means that it is detected as Windows, but does not provide}\par
344 {\cf20 // the same set of capabilities as real Windows does.}\par
345 {\cf21 #if defined(UNDER_RTSS) || defined(RTX64_BUILD)}\par
346 {\cf21     #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH}\par
347 {\cf21     #define CATCH_INTERNAL_CONFIG_NO_ASYNC}\par
348 {\cf21     #define CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32}\par
349 {\cf21 #endif}\par
350 \par
351 {\cf21 #if !defined(_GLIBCXX_USE_C99_MATH_TR1)}\par
352 {\cf21 #define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER}\par
353 {\cf21 #endif}\par
354 \par
355 {\cf20 // Various stdlib support checks that require __has_include}\par
356 {\cf21 #if defined(__has_include)}\par
357   {\cf20 // Check if string_view is available and usable}\par
358 {\cf21   #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)}\par
359 {\cf21   #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW}\par
360 {\cf21   #endif}\par
361 \par
362   {\cf20 // Check if optional is available and usable}\par
363 {\cf21   #  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)}\par
364 {\cf21   #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL}\par
365 {\cf21   #  endif }{\cf20 // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)}\par
366 \par
367   {\cf20 // Check if byte is available and usable}\par
368 {\cf21   #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)}\par
369 {\cf21   #    include <cstddef>}\par
370 {\cf21   #    if defined(__cpp_lib_byte) && (__cpp_lib_byte > 0)}\par
371 {\cf21   #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE}\par
372 {\cf21   #    endif}\par
373 {\cf21   #  endif }{\cf20 // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)}\par
374 \par
375   {\cf20 // Check if variant is available and usable}\par
376 {\cf21   #  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)}\par
377 {\cf21   #    if defined(__clang__) && (__clang_major__ < 8)}\par
378          {\cf20 // work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852}\par
379          {\cf20 // fix should be in clang 8, workaround in libstdc++ 8.2}\par
380 {\cf21   #      include <ciso646>}\par
381 {\cf21   #      if defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)}\par
382 {\cf21   #        define CATCH_CONFIG_NO_CPP17_VARIANT}\par
383 {\cf21   #      else}\par
384 {\cf21   #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT}\par
385 {\cf21   #      endif }{\cf20 // defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)}\par
386 {\cf21   #    else}\par
387 {\cf21   #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT}\par
388 {\cf21   #    endif }{\cf20 // defined(__clang__) && (__clang_major__ < 8)}\par
389 {\cf21   #  endif }{\cf20 // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)}\par
390 {\cf21 #endif }{\cf20 // defined(__has_include)}\par
391 \par
392 \par
393 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH) && !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)}\par
394 {\cf21 #   define CATCH_CONFIG_WINDOWS_SEH}\par
395 {\cf21 #endif}\par
396 {\cf20 // This is set by default, because we assume that unix compilers are posix-signal-compatible by default.}\par
397 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)}\par
398 {\cf21 #   define CATCH_CONFIG_POSIX_SIGNALS}\par
399 {\cf21 #endif}\par
400 \par
401 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_GETENV) && !defined(CATCH_INTERNAL_CONFIG_NO_GETENV) && !defined(CATCH_CONFIG_NO_GETENV) && !defined(CATCH_CONFIG_GETENV)}\par
402 {\cf21 #   define CATCH_CONFIG_GETENV}\par
403 {\cf21 #endif}\par
404 \par
405 {\cf21 #if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_CPP11_TO_STRING)}\par
406 {\cf21 #    define CATCH_CONFIG_CPP11_TO_STRING}\par
407 {\cf21 #endif}\par
408 \par
409 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_CPP17_OPTIONAL)}\par
410 {\cf21 #  define CATCH_CONFIG_CPP17_OPTIONAL}\par
411 {\cf21 #endif}\par
412 \par
413 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)}\par
414 {\cf21 #  define CATCH_CONFIG_CPP17_STRING_VIEW}\par
415 {\cf21 #endif}\par
416 \par
417 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) && !defined(CATCH_CONFIG_NO_CPP17_VARIANT) && !defined(CATCH_CONFIG_CPP17_VARIANT)}\par
418 {\cf21 #  define CATCH_CONFIG_CPP17_VARIANT}\par
419 {\cf21 #endif}\par
420 \par
421 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) && !defined(CATCH_CONFIG_NO_CPP17_BYTE) && !defined(CATCH_CONFIG_CPP17_BYTE)}\par
422 {\cf21 #  define CATCH_CONFIG_CPP17_BYTE}\par
423 {\cf21 #endif}\par
424 \par
425 \par
426 {\cf21 #if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)}\par
427 {\cf21 #  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE}\par
428 {\cf21 #endif}\par
429 \par
430 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) && !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NEW_CAPTURE)}\par
431 {\cf21 #  define CATCH_CONFIG_NEW_CAPTURE}\par
432 {\cf21 #endif}\par
433 \par
434 {\cf21 #if !defined( CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED ) && \\}\par
435 {\cf21     !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS ) &&          \\}\par
436 {\cf21     !defined( CATCH_CONFIG_NO_DISABLE_EXCEPTIONS )}\par
437 {\cf21 #  define CATCH_CONFIG_DISABLE_EXCEPTIONS}\par
438 {\cf21 #endif}\par
439 \par
440 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_POLYFILL_ISNAN)}\par
441 {\cf21 #  define CATCH_CONFIG_POLYFILL_ISNAN}\par
442 {\cf21 #endif}\par
443 \par
444 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  && !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) && !defined(CATCH_CONFIG_NO_USE_ASYNC) && !defined(CATCH_CONFIG_USE_ASYNC)}\par
445 {\cf21 #  define CATCH_CONFIG_USE_ASYNC}\par
446 {\cf21 #endif}\par
447 \par
448 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)}\par
449 {\cf21 #  define CATCH_CONFIG_GLOBAL_NEXTAFTER}\par
450 {\cf21 #endif}\par
451 \par
452 \par
453 {\cf20 // Even if we do not think the compiler has that warning, we still have}\par
454 {\cf20 // to provide a macro that can be used by the code.}\par
455 {\cf21 #if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)}\par
456 {\cf21 #   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION}\par
457 {\cf21 #endif}\par
458 {\cf21 #if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)}\par
459 {\cf21 #   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
460 {\cf21 #endif}\par
461 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)}\par
462 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS}\par
463 {\cf21 #endif}\par
464 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)}\par
465 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS}\par
466 {\cf21 #endif}\par
467 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT)}\par
468 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT}\par
469 {\cf21 #endif}\par
470 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS)}\par
471 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS}\par
472 {\cf21 #endif}\par
473 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS)}\par
474 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS}\par
475 {\cf21 #endif}\par
476 {\cf21 #if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)}\par
477 {\cf21 #   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS}\par
478 {\cf21 #endif}\par
479 {\cf21 #if !defined( CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS )}\par
480 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}\par
481 {\cf21 #endif}\par
482 {\cf21 #if !defined( CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS )}\par
483 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS}\par
484 {\cf21 #endif}\par
485 {\cf21 #if !defined( CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS )}\par
486 {\cf21 #    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS}\par
487 {\cf21 #endif}\par
488 \par
489 \par
490 {\cf20 // The goal of this macro is to avoid evaluation of the arguments, but}\par
491 {\cf20 // still have the compiler warn on problems inside...}\par
492 {\cf21 #if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)}\par
493 {\cf21 #   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)}\par
494 {\cf21 #endif}\par
495 \par
496 {\cf21 #if defined(__APPLE__) && defined(__apple_build_version__) && (__clang_major__ < 10)}\par
497 {\cf21 #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}\par
498 {\cf21 #elif defined(__clang__) && (__clang_major__ < 5)}\par
499 {\cf21 #   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS}\par
500 {\cf21 #endif}\par
501 \par
502 \par
503 {\cf21 #if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
504 {\cf21 #define CATCH_TRY if ((true))}\par
505 {\cf21 #define CATCH_CATCH_ALL if ((false))}\par
506 {\cf21 #define CATCH_CATCH_ANON(type) if ((false))}\par
507 {\cf21 #else}\par
508 {\cf21 #define CATCH_TRY try}\par
509 {\cf21 #define CATCH_CATCH_ALL catch (...)}\par
510 {\cf21 #define CATCH_CATCH_ANON(type) catch (type)}\par
511 {\cf21 #endif}\par
512 \par
513 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)}\par
514 {\cf21 #define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
515 {\cf21 #endif}\par
516 \par
517 {\cf21 #if defined( CATCH_PLATFORM_WINDOWS ) &&       \\}\par
518 {\cf21     !defined( CATCH_CONFIG_COLOUR_WIN32 ) && \\}\par
519 {\cf21     !defined( CATCH_CONFIG_NO_COLOUR_WIN32 ) && \\}\par
520 {\cf21     !defined( CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32 )}\par
521 {\cf21 #    define CATCH_CONFIG_COLOUR_WIN32}\par
522 {\cf21 #endif}\par
523 \par
524 {\cf21 #if defined( CATCH_CONFIG_SHARED_LIBRARY ) && defined( _MSC_VER ) && \\}\par
525 {\cf21     !defined( CATCH_CONFIG_STATIC )}\par
526 {\cf21 #    ifdef Catch2_EXPORTS}\par
527 {\cf21 #        define CATCH_EXPORT }{\cf20 //__declspec( dllexport ) // not needed}\par
528 {\cf21 #    else}\par
529 {\cf21 #        define CATCH_EXPORT __declspec( dllimport )}\par
530 {\cf21 #    endif}\par
531 {\cf21 #else}\par
532 {\cf21 #    define CATCH_EXPORT}\par
533 {\cf21 #endif}\par
534 \par
535 {\cf21 #endif }{\cf20 // CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED}\par
536 \par
537 \par
538 {\cf21 #ifndef CATCH_CONTEXT_HPP_INCLUDED}\par
539 {\cf21 #define CATCH_CONTEXT_HPP_INCLUDED}\par
540 \par
541 \par
542 {\cf17 namespace }Catch \{\par
543 \par
544     {\cf17 class }IResultCapture;\par
545     {\cf17 class }IConfig;\par
546 \par
547     {\cf17 class }Context \{\par
548         IConfig {\cf17 const}* m_config = {\cf17 nullptr};\par
549         IResultCapture* m_resultCapture = {\cf17 nullptr};\par
550 \par
551         CATCH_EXPORT {\cf17 static} Context* currentContext;\par
552         {\cf17 friend} Context& getCurrentMutableContext();\par
553         {\cf17 friend} Context {\cf17 const}& getCurrentContext();\par
554         {\cf17 static} {\cf18 void} createContext();\par
555         {\cf17 friend} {\cf18 void} cleanUpContext();\par
556 \par
557     {\cf17 public}:\par
558         IResultCapture* getResultCapture(){\cf17  const }\{ {\cf19 return} m_resultCapture; \}\par
559         IConfig {\cf17 const}* getConfig(){\cf17  const }\{ {\cf19 return} m_config; \}\par
560         {\cf18 void} setResultCapture( IResultCapture* resultCapture );\par
561         {\cf18 void} setConfig( IConfig {\cf17 const}* config );\par
562     \};\par
563 \par
564     Context& getCurrentMutableContext();\par
565 \par
566     {\cf17 inline} Context {\cf17 const}& getCurrentContext() \{\par
567         {\cf20 // We duplicate the logic from `getCurrentMutableContext` here,}\par
568         {\cf20 // to avoid paying the call overhead in debug mode.}\par
569         {\cf19 if} ( !Context::currentContext ) \{ Context::createContext(); \}\par
570         {\cf20 // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)}\par
571         {\cf19 return} *Context::currentContext;\par
572     \}\par
573 \par
574     {\cf18 void} cleanUpContext();\par
575 \par
576     {\cf17 class }SimplePcg32;\par
577     SimplePcg32& sharedRng();\par
578 \}\par
579 \par
580 {\cf21 #endif }{\cf20 // CATCH_CONTEXT_HPP_INCLUDED}\par
581 \par
582 \par
583 {\cf21 #ifndef CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}\par
584 {\cf21 #define CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}\par
585 \par
586 {\cf21 #include <type_traits>}\par
587 \par
589 {\cf21 #define CATCH_MOVE(...) static_cast<std::remove_reference_t<decltype(__VA_ARGS__)>&&>(__VA_ARGS__)}\par
590 \par
592 {\cf21 #define CATCH_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)}\par
593 \par
594 {\cf21 #endif }{\cf20 // CATCH_MOVE_AND_FORWARD_HPP_INCLUDED}\par
595 \par
596 \par
597 {\cf21 #ifndef CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}\par
598 {\cf21 #define CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}\par
599 \par
600 {\cf17 namespace }Catch \{\par
601 \par
603     {\cf17 struct }TestFailureException\{\};\par
605     {\cf17 struct }TestSkipException \{\};\par
606 \par
612     [[noreturn]] {\cf18 void} throw_test_failure_exception();\par
613 \par
619     [[noreturn]] {\cf18 void} throw_test_skip_exception();\par
620 \par
621 \} {\cf20 // namespace Catch}\par
622 \par
623 {\cf21 #endif }{\cf20 // CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED}\par
624 \par
625 \par
626 {\cf21 #ifndef CATCH_UNIQUE_NAME_HPP_INCLUDED}\par
627 {\cf21 #define CATCH_UNIQUE_NAME_HPP_INCLUDED}\par
628 \par
629 \par
630 \par
631 \par
641 {\cf21 #ifndef CATCH_CONFIG_COUNTER_HPP_INCLUDED}\par
642 {\cf21 #define CATCH_CONFIG_COUNTER_HPP_INCLUDED}\par
643 \par
644 \par
645 {\cf21 #if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )}\par
646 {\cf21     #define CATCH_INTERNAL_CONFIG_COUNTER}\par
647 {\cf21 #endif}\par
648 \par
649 {\cf21 #if defined( CATCH_INTERNAL_CONFIG_COUNTER ) && \\}\par
650 {\cf21     !defined( CATCH_CONFIG_NO_COUNTER ) && \\}\par
651 {\cf21     !defined( CATCH_CONFIG_COUNTER )}\par
652 {\cf21 #    define CATCH_CONFIG_COUNTER}\par
653 {\cf21 #endif}\par
654 \par
655 \par
656 {\cf21 #endif }{\cf20 // CATCH_CONFIG_COUNTER_HPP_INCLUDED}\par
657 {\cf21 #define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line}\par
658 {\cf21 #define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )}\par
659 {\cf21 #ifdef CATCH_CONFIG_COUNTER}\par
660 {\cf21 #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )}\par
661 {\cf21 #else}\par
662 {\cf21 #  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )}\par
663 {\cf21 #endif}\par
664 \par
665 {\cf21 #endif }{\cf20 // CATCH_UNIQUE_NAME_HPP_INCLUDED}\par
666 \par
667 \par
668 {\cf21 #ifndef CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}\par
669 {\cf21 #define CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}\par
670 \par
671 {\cf21 #include <string>}\par
672 {\cf21 #include <chrono>}\par
673 \par
674 \par
675 \par
676 {\cf21 #ifndef CATCH_STRINGREF_HPP_INCLUDED}\par
677 {\cf21 #define CATCH_STRINGREF_HPP_INCLUDED}\par
678 \par
679 {\cf21 #include <cstddef>}\par
680 {\cf21 #include <string>}\par
681 {\cf21 #include <iosfwd>}\par
682 {\cf21 #include <cassert>}\par
683 \par
684 {\cf21 #include <cstring>}\par
685 \par
686 {\cf17 namespace }Catch \{\par
687 \par
691     {\cf17 class }StringRef \{\par
692     {\cf17 public}:\par
693         {\cf17 using }size_type = std::size_t;\par
694         {\cf17 using }const_iterator = {\cf17 const} {\cf18 char}*;\par
695 \par
696         {\cf17 static} {\cf17 constexpr} size_type npos\{ {\cf17 static_cast<}size_type{\cf17 >}( -1 ) \};\par
697 \par
698     {\cf17 private}:\par
699         {\cf17 static} {\cf17 constexpr} {\cf18 char} {\cf17 const}* {\cf17 const} s_empty = {\cf22 ""};\par
700 \par
701         {\cf18 char} {\cf17 const}* m_start = s_empty;\par
702         size_type m_size = 0;\par
703 \par
704     {\cf17 public}: {\cf20 // construction}\par
705         {\cf17 constexpr} StringRef() noexcept = default;\par
706 \par
707         StringRef( {\cf18 char} const* rawChars ) noexcept;\par
708 \par
709         constexpr StringRef( {\cf18 char} const* rawChars, size_type size ) noexcept\par
710         :   m_start( rawChars ),\par
711             m_size( size )\par
712         \{\}\par
713 \par
714         StringRef( std::string {\cf17 const}& stdString ) noexcept\par
715         :   m_start( stdString.c_str() ),\par
716             m_size( stdString.size() )\par
717         \{\}\par
718 \par
719         {\cf17 explicit} {\cf17 operator} std::string(){\cf17  const }\{\par
720             {\cf19 return} std::string(m_start, m_size);\par
721         \}\par
722 \par
723     {\cf17 public}: {\cf20 // operators}\par
724         {\cf17 auto} operator == ( StringRef other ) {\cf17 const} {\cf17 noexcept} -> {\cf18 bool} \{\par
725             {\cf19 return} m_size == other.m_size\par
726                 && (std::memcmp( m_start, other.m_start, m_size ) == 0);\par
727         \}\par
728         {\cf17 auto} operator != (StringRef other) {\cf17 const} {\cf17 noexcept} -> {\cf18 bool} \{\par
729             {\cf19 return} !(*{\cf17 this} == other);\par
730         \}\par
731 \par
732         {\cf17 constexpr} {\cf17 auto} operator[] ( size_type index ) {\cf17 const} {\cf17 noexcept} -> {\cf18 char} \{\par
733             assert(index < m_size);\par
734             {\cf19 return} m_start[index];\par
735         \}\par
736 \par
737         {\cf18 bool} operator<(StringRef rhs) {\cf17 const} {\cf17 noexcept};\par
738 \par
739     {\cf17 public}: {\cf20 // named queries}\par
740         {\cf17 constexpr} {\cf17 auto} empty() const noexcept -> {\cf18 bool} \{\par
741             {\cf19 return} m_size == 0;\par
742         \}\par
743         {\cf17 constexpr} {\cf17 auto} size() const noexcept -> size_type \{\par
744             {\cf19 return} m_size;\par
745         \}\par
746 \par
747         {\cf20 // Returns a substring of [start, start + length).}\par
748         {\cf20 // If start + length > size(), then the substring is [start, size()).}\par
749         {\cf20 // If start > size(), then the substring is empty.}\par
750         {\cf17 constexpr} StringRef substr(size_type start, size_type length) {\cf17 const} {\cf17 noexcept} \{\par
751             {\cf19 if} (start < m_size) \{\par
752                 {\cf17 const} {\cf17 auto} shortened_size = m_size - start;\par
753                 {\cf19 return} StringRef(m_start + start, (shortened_size < length) ? shortened_size : length);\par
754             \} {\cf19 else} \{\par
755                 {\cf19 return} StringRef();\par
756             \}\par
757         \}\par
758 \par
759         {\cf20 // Returns the current start pointer. May not be null-terminated.}\par
760         {\cf17 constexpr} {\cf18 char} {\cf17 const}* data() const noexcept \{\par
761             {\cf19 return} m_start;\par
762         \}\par
763 \par
764         {\cf17 constexpr} const_iterator begin(){\cf17  const }\{ {\cf19 return} m_start; \}\par
765         {\cf17 constexpr} const_iterator end(){\cf17  const }\{ {\cf19 return} m_start + m_size; \}\par
766 \par
767 \par
768         {\cf17 friend} std::string& operator += (std::string& lhs, StringRef rhs);\par
769         {\cf17 friend} std::ostream& operator << (std::ostream& os, StringRef str);\par
770         {\cf17 friend} std::string operator+(StringRef lhs, StringRef rhs);\par
771 \par
778         {\cf18 int} compare( StringRef rhs ) {\cf17 const};\par
779     \};\par
780 \par
781 \par
782     {\cf17 constexpr} {\cf17 auto} {\cf17 operator} {\cf22 ""}_sr( {\cf18 char} {\cf17 const}* rawChars, std::size_t size ) {\cf17 noexcept} -> StringRef \{\par
783         {\cf19 return} StringRef( rawChars, size );\par
784     \}\par
785 \} {\cf20 // namespace Catch}\par
786 \par
787 {\cf17 constexpr} {\cf17 auto} {\cf17 operator} {\cf22 ""}_catch_sr( {\cf18 char} {\cf17 const}* rawChars, std::size_t size ) {\cf17 noexcept} -> Catch::StringRef \{\par
788     {\cf19 return} Catch::StringRef( rawChars, size );\par
789 \}\par
790 \par
791 {\cf21 #endif }{\cf20 // CATCH_STRINGREF_HPP_INCLUDED}\par
792 \par
793 \par
794 {\cf21 #ifndef CATCH_RESULT_TYPE_HPP_INCLUDED}\par
795 {\cf21 #define CATCH_RESULT_TYPE_HPP_INCLUDED}\par
796 \par
797 {\cf17 namespace }Catch \{\par
798 \par
799     {\cf20 // ResultWas::OfType enum}\par
800     {\cf17 struct }ResultWas \{ {\cf17 enum} OfType \{\par
801         Unknown = -1,\par
802         Ok = 0,\par
803         Info = 1,\par
804         Warning = 2,\par
805         {\cf20 // TODO: Should explicit skip be considered "not OK" (cf. isOk)? I.e., should it have the failure bit?}\par
806         ExplicitSkip = 4,\par
807 \par
808         FailureBit = 0x10,\par
809 \par
810         ExpressionFailed = FailureBit | 1,\par
811         ExplicitFailure = FailureBit | 2,\par
812 \par
813         Exception = 0x100 | FailureBit,\par
814 \par
815         ThrewException = Exception | 1,\par
816         DidntThrowException = Exception | 2,\par
817 \par
818         FatalErrorCondition = 0x200 | FailureBit\par
819 \par
820     \}; \};\par
821 \par
822     {\cf18 bool} isOk( ResultWas::OfType resultType );\par
823     {\cf18 bool} isJustInfo( {\cf18 int} flags );\par
824 \par
825 \par
826     {\cf20 // ResultDisposition::Flags enum}\par
827     {\cf17 struct }ResultDisposition \{ {\cf17 enum} Flags \{\par
828         Normal = 0x01,\par
829 \par
830         ContinueOnFailure = 0x02,   {\cf20 // Failures fail test, but execution continues}\par
831         FalseTest = 0x04,           {\cf20 // Prefix expression with !}\par
832         SuppressFail = 0x08         {\cf20 // Failures are reported but do not fail the test}\par
833     \}; \};\par
834 \par
835     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );\par
836 \par
837     {\cf18 bool} shouldContinueOnFailure( {\cf18 int} flags );\par
838     {\cf17 inline} {\cf18 bool} isFalseTest( {\cf18 int} flags ) \{ {\cf19 return} ( flags & ResultDisposition::FalseTest ) != 0; \}\par
839     {\cf18 bool} shouldSuppressFailure( {\cf18 int} flags );\par
840 \par
841 \} {\cf20 // end namespace Catch}\par
842 \par
843 {\cf21 #endif }{\cf20 // CATCH_RESULT_TYPE_HPP_INCLUDED}\par
844 \par
845 \par
846 {\cf21 #ifndef CATCH_UNIQUE_PTR_HPP_INCLUDED}\par
847 {\cf21 #define CATCH_UNIQUE_PTR_HPP_INCLUDED}\par
848 \par
849 {\cf21 #include <cassert>}\par
850 {\cf21 #include <type_traits>}\par
851 \par
852 \par
853 {\cf17 namespace }Catch \{\par
854 {\cf17 namespace }Detail \{\par
860     {\cf17 template} <{\cf17 typename} T>\par
861     {\cf17 class }unique_ptr \{\par
862         T* m_ptr;\par
863     {\cf17 public}:\par
864         {\cf17 constexpr} unique_ptr(std::nullptr_t = {\cf17 nullptr}):\par
865             m_ptr\{\}\par
866         \{\}\par
867         {\cf17 explicit} {\cf17 constexpr} unique_ptr(T* ptr):\par
868             m_ptr(ptr)\par
869         \{\}\par
870 \par
871         template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>\par
872         unique_ptr(unique_ptr<U>&& from):\par
873             m_ptr(from.release())\par
874         \{\}\par
875 \par
876         template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>\par
877         unique_ptr& operator=(unique_ptr<U>&& from) \{\par
878             reset(from.release());\par
879 \par
880             {\cf19 return} *{\cf17 this};\par
881         \}\par
882 \par
883         unique_ptr(unique_ptr {\cf17 const}&) = {\cf17 delete};\par
884         unique_ptr& operator=(unique_ptr {\cf17 const}&) = {\cf17 delete};\par
885 \par
886         unique_ptr(unique_ptr&& rhs) {\cf17 noexcept}:\par
887             m_ptr(rhs.m_ptr) \{\par
888             rhs.m_ptr = {\cf17 nullptr};\par
889         \}\par
890         unique_ptr& operator=(unique_ptr&& rhs) {\cf17 noexcept} \{\par
891             reset(rhs.release());\par
892 \par
893             {\cf19 return} *{\cf17 this};\par
894         \}\par
895 \par
896         ~unique_ptr() \{\par
897             {\cf17 delete} m_ptr;\par
898         \}\par
899 \par
900         T& operator*() \{\par
901             assert(m_ptr);\par
902             {\cf19 return} *m_ptr;\par
903         \}\par
904         T {\cf17 const}& operator*(){\cf17  const }\{\par
905             assert(m_ptr);\par
906             {\cf19 return} *m_ptr;\par
907         \}\par
908         T* operator->() noexcept \{\par
909             assert(m_ptr);\par
910             {\cf19 return} m_ptr;\par
911         \}\par
912         T {\cf17 const}* operator->() const noexcept \{\par
913             assert(m_ptr);\par
914             {\cf19 return} m_ptr;\par
915         \}\par
916 \par
917         T* get() \{ {\cf19 return} m_ptr; \}\par
918         T {\cf17 const}* get(){\cf17  const }\{ {\cf19 return} m_ptr; \}\par
919 \par
920         {\cf18 void} reset(T* ptr = {\cf17 nullptr}) \{\par
921             {\cf17 delete} m_ptr;\par
922             m_ptr = ptr;\par
923         \}\par
924 \par
925         T* release() \{\par
926             {\cf17 auto} temp = m_ptr;\par
927             m_ptr = {\cf17 nullptr};\par
928             {\cf19 return} temp;\par
929         \}\par
930 \par
931         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
932             {\cf19 return} m_ptr;\par
933         \}\par
934 \par
935         {\cf17 friend} {\cf18 void} swap(unique_ptr& lhs, unique_ptr& rhs) \{\par
936             {\cf17 auto} temp = lhs.m_ptr;\par
937             lhs.m_ptr = rhs.m_ptr;\par
938             rhs.m_ptr = temp;\par
939         \}\par
940     \};\par
941 \par
943     {\cf17 template} <{\cf17 typename} T>\par
944     {\cf17 class }unique_ptr<T[]>;\par
945 \par
946     {\cf17 template} <{\cf17 typename} T, {\cf17 typename}... Args>\par
947     unique_ptr<T> make_unique(Args&&... args) \{\par
948         {\cf19 return} unique_ptr<T>({\cf17 new} T(CATCH_FORWARD(args)...));\par
949     \}\par
950 \par
951 \par
952 \} {\cf20 // end namespace Detail}\par
953 \} {\cf20 // end namespace Catch}\par
954 \par
955 {\cf21 #endif }{\cf20 // CATCH_UNIQUE_PTR_HPP_INCLUDED}\par
956 \par
957 \par
958 {\cf21 #ifndef CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}\par
959 {\cf21 #define CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}\par
960 \par
961 \par
962 \par
963 {\cf20 // Adapted from donated nonius code.}\par
964 \par
965 {\cf21 #ifndef CATCH_CLOCK_HPP_INCLUDED}\par
966 {\cf21 #define CATCH_CLOCK_HPP_INCLUDED}\par
967 \par
968 {\cf21 #include <chrono>}\par
969 \par
970 {\cf17 namespace }Catch \{\par
971     {\cf17 namespace }Benchmark \{\par
972         {\cf17 using }IDuration = std::chrono::nanoseconds;\par
973         {\cf17 using }FDuration = std::chrono::duration<double, std::nano>;\par
974 \par
975         {\cf17 template} <{\cf17 typename} Clock>\par
976         {\cf17 using }TimePoint = {\cf17 typename} Clock::time_point;\par
977 \par
978         {\cf17 using }default_clock = std::chrono::steady_clock;\par
979     \} {\cf20 // namespace Benchmark}\par
980 \} {\cf20 // namespace Catch}\par
981 \par
982 {\cf21 #endif }{\cf20 // CATCH_CLOCK_HPP_INCLUDED}\par
983 \par
984 {\cf17 namespace }Catch \{\par
985 \par
986     {\cf20 // We cannot forward declare the type with default template argument}\par
987     {\cf20 // multiple times, so it is split out into a separate header so that}\par
988     {\cf20 // we can prevent multiple declarations in dependees}\par
989     {\cf17 template} <{\cf17 typename} Duration = Benchmark::FDuration>\par
990     {\cf17 struct }BenchmarkStats;\par
991 \par
992 \} {\cf20 // end namespace Catch}\par
993 \par
994 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED}\par
995 \par
996 {\cf17 namespace }Catch \{\par
997 \par
998     {\cf17 class }AssertionResult;\par
999     {\cf17 struct }AssertionInfo;\par
1000     {\cf17 struct }SectionInfo;\par
1001     {\cf17 struct }SectionEndInfo;\par
1002     {\cf17 struct }MessageInfo;\par
1003     {\cf17 struct }MessageBuilder;\par
1004     {\cf17 struct }Counts;\par
1005     {\cf17 struct }AssertionReaction;\par
1006     {\cf17 struct }SourceLineInfo;\par
1007 \par
1008     {\cf17 class }ITransientExpression;\par
1009     {\cf17 class }IGeneratorTracker;\par
1010 \par
1011     {\cf17 struct }BenchmarkInfo;\par
1012 \par
1013     {\cf17 namespace }Generators \{\par
1014         {\cf17 class }GeneratorUntypedBase;\par
1015         {\cf17 using }GeneratorBasePtr = Catch::Detail::unique_ptr<GeneratorUntypedBase>;\par
1016     \}\par
1017 \par
1018 \par
1019     {\cf17 class }IResultCapture \{\par
1020     {\cf17 public}:\par
1021         {\cf17 virtual} ~IResultCapture();\par
1022 \par
1023         {\cf17 virtual} {\cf18 void} notifyAssertionStarted( AssertionInfo {\cf17 const}& info ) = 0;\par
1024         {\cf17 virtual} {\cf18 bool} sectionStarted( StringRef sectionName,\par
1025                                      SourceLineInfo {\cf17 const}& sectionLineInfo,\par
1026                                      Counts& assertions ) = 0;\par
1027         {\cf17 virtual} {\cf18 void} sectionEnded( SectionEndInfo&& endInfo ) = 0;\par
1028         {\cf17 virtual} {\cf18 void} sectionEndedEarly( SectionEndInfo&& endInfo ) = 0;\par
1029 \par
1030         {\cf17 virtual} IGeneratorTracker*\par
1031         acquireGeneratorTracker( StringRef generatorName,\par
1032                                  SourceLineInfo {\cf17 const}& lineInfo ) = 0;\par
1033         {\cf17 virtual} IGeneratorTracker*\par
1034         createGeneratorTracker( StringRef generatorName,\par
1035                                 SourceLineInfo lineInfo,\par
1036                                 Generators::GeneratorBasePtr&& generator ) = 0;\par
1037 \par
1038         {\cf17 virtual} {\cf18 void} benchmarkPreparing( StringRef name ) = 0;\par
1039         {\cf17 virtual} {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) = 0;\par
1040         {\cf17 virtual} {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& stats ) = 0;\par
1041         {\cf17 virtual} {\cf18 void} benchmarkFailed( StringRef error ) = 0;\par
1042 \par
1043         {\cf17 virtual} {\cf18 void} pushScopedMessage( MessageInfo {\cf17 const}& message ) = 0;\par
1044         {\cf17 virtual} {\cf18 void} popScopedMessage( MessageInfo {\cf17 const}& message ) = 0;\par
1045 \par
1046         {\cf17 virtual} {\cf18 void} emplaceUnscopedMessage( MessageBuilder&& builder ) = 0;\par
1047 \par
1048         {\cf17 virtual} {\cf18 void} handleFatalErrorCondition( StringRef message ) = 0;\par
1049 \par
1050         {\cf17 virtual} {\cf18 void} handleExpr\par
1051                 (   AssertionInfo {\cf17 const}& info,\par
1052                     ITransientExpression {\cf17 const}& expr,\par
1053                     AssertionReaction& reaction ) = 0;\par
1054         {\cf17 virtual} {\cf18 void} handleMessage\par
1055                 (   AssertionInfo {\cf17 const}& info,\par
1056                     ResultWas::OfType resultType,\par
1057                     StringRef message,\par
1058                     AssertionReaction& reaction ) = 0;\par
1059         {\cf17 virtual} {\cf18 void} handleUnexpectedExceptionNotThrown\par
1060                 (   AssertionInfo {\cf17 const}& info,\par
1061                     AssertionReaction& reaction ) = 0;\par
1062         {\cf17 virtual} {\cf18 void} handleUnexpectedInflightException\par
1063                 (   AssertionInfo {\cf17 const}& info,\par
1064                     std::string&& message,\par
1065                     AssertionReaction& reaction ) = 0;\par
1066         {\cf17 virtual} {\cf18 void} handleIncomplete\par
1067                 (   AssertionInfo {\cf17 const}& info ) = 0;\par
1068         {\cf17 virtual} {\cf18 void} handleNonExpr\par
1069                 (   AssertionInfo {\cf17 const} &info,\par
1070                     ResultWas::OfType resultType,\par
1071                     AssertionReaction &reaction ) = 0;\par
1072 \par
1073 \par
1074 \par
1075         {\cf17 virtual} {\cf18 bool} lastAssertionPassed() = 0;\par
1076         {\cf17 virtual} {\cf18 void} assertionPassed() = 0;\par
1077 \par
1078         {\cf20 // Deprecated, do not use:}\par
1079         {\cf17 virtual} std::string getCurrentTestName() {\cf17 const} = 0;\par
1080         {\cf17 virtual} {\cf17 const} AssertionResult* getLastResult() {\cf17 const} = 0;\par
1081         {\cf17 virtual} {\cf18 void} exceptionEarlyReported() = 0;\par
1082     \};\par
1083 \par
1084     IResultCapture& getResultCapture();\par
1085 \}\par
1086 \par
1087 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_CAPTURE_HPP_INCLUDED}\par
1088 \par
1089 \par
1090 {\cf21 #ifndef CATCH_INTERFACES_CONFIG_HPP_INCLUDED}\par
1091 {\cf21 #define CATCH_INTERFACES_CONFIG_HPP_INCLUDED}\par
1092 \par
1093 \par
1094 \par
1095 {\cf21 #ifndef CATCH_NONCOPYABLE_HPP_INCLUDED}\par
1096 {\cf21 #define CATCH_NONCOPYABLE_HPP_INCLUDED}\par
1097 \par
1098 {\cf17 namespace }Catch \{\par
1099     {\cf17 namespace }Detail \{\par
1100 \par
1102         {\cf17 class }NonCopyable \{\par
1103             NonCopyable( NonCopyable {\cf17 const}& ) = {\cf17 delete};\par
1104             NonCopyable( NonCopyable&& ) = {\cf17 delete};\par
1105             NonCopyable& operator=( NonCopyable {\cf17 const}& ) = {\cf17 delete};\par
1106             NonCopyable& operator=( NonCopyable&& ) = {\cf17 delete};\par
1107 \par
1108         {\cf17 protected}:\par
1109             NonCopyable() noexcept = default;\par
1110         \};\par
1111 \par
1112     \} {\cf20 // namespace Detail}\par
1113 \} {\cf20 // namespace Catch}\par
1114 \par
1115 {\cf21 #endif }{\cf20 // CATCH_NONCOPYABLE_HPP_INCLUDED}\par
1116 \par
1117 {\cf21 #include <chrono>}\par
1118 {\cf21 #include <iosfwd>}\par
1119 {\cf21 #include <string>}\par
1120 {\cf21 #include <vector>}\par
1121 \par
1122 {\cf17 namespace }Catch \{\par
1123 \par
1124     {\cf17 enum class} Verbosity \{\par
1125         Quiet = 0,\par
1126         Normal,\par
1127         High\par
1128     \};\par
1129 \par
1130     {\cf17 struct }WarnAbout \{ {\cf17 enum} What \{\par
1131         Nothing = 0x00,\par
1133         NoAssertions = 0x01,\par
1135         UnmatchedTestSpec = 0x02,\par
1136     \}; \};\par
1137 \par
1138     {\cf17 enum class} ShowDurations \{\par
1139         DefaultForReporter,\par
1140         Always,\par
1141         Never\par
1142     \};\par
1143     {\cf17 enum class} TestRunOrder \{\par
1144         Declared,\par
1145         LexicographicallySorted,\par
1146         Randomized\par
1147     \};\par
1148     {\cf17 enum class} ColourMode : std::uint8_t \{\par
1150         PlatformDefault,\par
1152         ANSI,\par
1154         Win32,\par
1156         None\par
1157     \};\par
1158     {\cf17 struct }WaitForKeypress \{ {\cf17 enum} When \{\par
1159         Never,\par
1160         BeforeStart = 1,\par
1161         BeforeExit = 2,\par
1162         BeforeStartAndExit = BeforeStart | BeforeExit\par
1163     \}; \};\par
1164 \par
1165     {\cf17 class }TestSpec;\par
1166     {\cf17 class }IStream;\par
1167 \par
1168     {\cf17 class }IConfig : {\cf17 public} Detail::NonCopyable \{\par
1169     {\cf17 public}:\par
1170         {\cf17 virtual} ~IConfig();\par
1171 \par
1172         {\cf17 virtual} {\cf18 bool} allowThrows() {\cf17 const} = 0;\par
1173         {\cf17 virtual} StringRef name() {\cf17 const} = 0;\par
1174         {\cf17 virtual} {\cf18 bool} includeSuccessfulResults() {\cf17 const} = 0;\par
1175         {\cf17 virtual} {\cf18 bool} shouldDebugBreak() {\cf17 const} = 0;\par
1176         {\cf17 virtual} {\cf18 bool} warnAboutMissingAssertions() {\cf17 const} = 0;\par
1177         {\cf17 virtual} {\cf18 bool} warnAboutUnmatchedTestSpecs() {\cf17 const} = 0;\par
1178         {\cf17 virtual} {\cf18 bool} zeroTestsCountAsSuccess() {\cf17 const} = 0;\par
1179         {\cf17 virtual} {\cf18 int} abortAfter() {\cf17 const} = 0;\par
1180         {\cf17 virtual} {\cf18 bool} showInvisibles() {\cf17 const} = 0;\par
1181         {\cf17 virtual} ShowDurations showDurations() {\cf17 const} = 0;\par
1182         {\cf17 virtual} {\cf18 double} minDuration() {\cf17 const} = 0;\par
1183         {\cf17 virtual} TestSpec {\cf17 const}& testSpec() {\cf17 const} = 0;\par
1184         {\cf17 virtual} {\cf18 bool} hasTestFilters() {\cf17 const} = 0;\par
1185         {\cf17 virtual} std::vector<std::string> {\cf17 const}& getTestsOrTags() {\cf17 const} = 0;\par
1186         {\cf17 virtual} TestRunOrder runOrder() {\cf17 const} = 0;\par
1187         {\cf17 virtual} uint32_t rngSeed() {\cf17 const} = 0;\par
1188         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} shardCount() {\cf17 const} = 0;\par
1189         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} shardIndex() {\cf17 const} = 0;\par
1190         {\cf17 virtual} ColourMode defaultColourMode() {\cf17 const} = 0;\par
1191         {\cf17 virtual} std::vector<std::string> {\cf17 const}& getSectionsToRun() {\cf17 const} = 0;\par
1192         {\cf17 virtual} Verbosity verbosity() {\cf17 const} = 0;\par
1193 \par
1194         {\cf17 virtual} {\cf18 bool} skipBenchmarks() {\cf17 const} = 0;\par
1195         {\cf17 virtual} {\cf18 bool} benchmarkNoAnalysis() {\cf17 const} = 0;\par
1196         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} benchmarkSamples() {\cf17 const} = 0;\par
1197         {\cf17 virtual} {\cf18 double} benchmarkConfidenceInterval() {\cf17 const} = 0;\par
1198         {\cf17 virtual} {\cf18 unsigned} {\cf18 int} benchmarkResamples() {\cf17 const} = 0;\par
1199         {\cf17 virtual} std::chrono::milliseconds benchmarkWarmupTime() {\cf17 const} = 0;\par
1200     \};\par
1201 \}\par
1202 \par
1203 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_CONFIG_HPP_INCLUDED}\par
1204 \par
1205 \par
1206 {\cf21 #ifndef CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}\par
1207 {\cf21 #define CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}\par
1208 \par
1209 \par
1210 {\cf21 #include <string>}\par
1211 \par
1212 {\cf17 namespace }Catch \{\par
1213 \par
1214     {\cf17 class }TestCaseHandle;\par
1215     {\cf17 struct }TestCaseInfo;\par
1216     {\cf17 class }ITestCaseRegistry;\par
1217     {\cf17 class }IExceptionTranslatorRegistry;\par
1218     {\cf17 class }IExceptionTranslator;\par
1219     {\cf17 class }ReporterRegistry;\par
1220     {\cf17 class }IReporterFactory;\par
1221     {\cf17 class }ITagAliasRegistry;\par
1222     {\cf17 class }ITestInvoker;\par
1223     {\cf17 class }IMutableEnumValuesRegistry;\par
1224     {\cf17 struct }SourceLineInfo;\par
1225 \par
1226     {\cf17 class }StartupExceptionRegistry;\par
1227     {\cf17 class }EventListenerFactory;\par
1228 \par
1229     {\cf17 using }IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;\par
1230 \par
1231     {\cf17 class }IRegistryHub \{\par
1232     {\cf17 public}:\par
1233         {\cf17 virtual} ~IRegistryHub(); {\cf20 // = default}\par
1234 \par
1235         {\cf17 virtual} ReporterRegistry {\cf17 const}& getReporterRegistry() {\cf17 const} = 0;\par
1236         {\cf17 virtual} ITestCaseRegistry {\cf17 const}& getTestCaseRegistry() {\cf17 const} = 0;\par
1237         {\cf17 virtual} ITagAliasRegistry {\cf17 const}& getTagAliasRegistry() {\cf17 const} = 0;\par
1238         {\cf17 virtual} IExceptionTranslatorRegistry {\cf17 const}& getExceptionTranslatorRegistry() {\cf17 const} = 0;\par
1239 \par
1240 \par
1241         {\cf17 virtual} StartupExceptionRegistry {\cf17 const}& getStartupExceptionRegistry() {\cf17 const} = 0;\par
1242     \};\par
1243 \par
1244     {\cf17 class }IMutableRegistryHub \{\par
1245     {\cf17 public}:\par
1246         {\cf17 virtual} ~IMutableRegistryHub(); {\cf20 // = default}\par
1247         {\cf17 virtual} {\cf18 void} registerReporter( std::string {\cf17 const}& name, IReporterFactoryPtr factory ) = 0;\par
1248         {\cf17 virtual} {\cf18 void} registerListener( Detail::unique_ptr<EventListenerFactory> factory ) = 0;\par
1249         {\cf17 virtual} {\cf18 void} registerTest(Detail::unique_ptr<TestCaseInfo>&& testInfo, Detail::unique_ptr<ITestInvoker>&& invoker) = 0;\par
1250         {\cf17 virtual} {\cf18 void} registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator ) = 0;\par
1251         {\cf17 virtual} {\cf18 void} registerTagAlias( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo ) = 0;\par
1252         {\cf17 virtual} {\cf18 void} registerStartupException() noexcept = 0;\par
1253         virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;\par
1254     \};\par
1255 \par
1256     IRegistryHub const& getRegistryHub();\par
1257     IMutableRegistryHub& getMutableRegistryHub();\par
1258     {\cf18 void} cleanUp();\par
1259     std::{\cf18 string} translateActiveException();\par
1260 \par
1261 \}\par
1262 \par
1263 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED}\par
1264 \par
1265 \par
1266 {\cf21 #ifndef CATCH_BENCHMARK_STATS_HPP_INCLUDED}\par
1267 {\cf21 #define CATCH_BENCHMARK_STATS_HPP_INCLUDED}\par
1268 \par
1269 \par
1270 \par
1271 {\cf20 // Adapted from donated nonius code.}\par
1272 \par
1273 {\cf21 #ifndef CATCH_ESTIMATE_HPP_INCLUDED}\par
1274 {\cf21 #define CATCH_ESTIMATE_HPP_INCLUDED}\par
1275 \par
1276 {\cf17 namespace }Catch \{\par
1277     {\cf17 namespace }Benchmark \{\par
1278         {\cf17 template} <{\cf17 typename} Type>\par
1279         {\cf17 struct }Estimate \{\par
1280             Type point;\par
1281             Type lower_bound;\par
1282             Type upper_bound;\par
1283             {\cf18 double} confidence_interval;\par
1284         \};\par
1285     \} {\cf20 // namespace Benchmark}\par
1286 \} {\cf20 // namespace Catch}\par
1287 \par
1288 {\cf21 #endif }{\cf20 // CATCH_ESTIMATE_HPP_INCLUDED}\par
1289 \par
1290 \par
1291 {\cf20 // Adapted from donated nonius code.}\par
1292 \par
1293 {\cf21 #ifndef CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED}\par
1294 {\cf21 #define CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED}\par
1295 \par
1296 {\cf17 namespace }Catch \{\par
1297     {\cf17 namespace }Benchmark \{\par
1298         {\cf17 struct }OutlierClassification \{\par
1299             {\cf18 int} samples_seen = 0;\par
1300             {\cf18 int} low_severe = 0;     {\cf20 // more than 3 times IQR below Q1}\par
1301             {\cf18 int} low_mild = 0;       {\cf20 // 1.5 to 3 times IQR below Q1}\par
1302             {\cf18 int} high_mild = 0;      {\cf20 // 1.5 to 3 times IQR above Q3}\par
1303             {\cf18 int} high_severe = 0;    {\cf20 // more than 3 times IQR above Q3}\par
1304 \par
1305             {\cf18 int} total(){\cf17  const }\{\par
1306                 {\cf19 return} low_severe + low_mild + high_mild + high_severe;\par
1307             \}\par
1308         \};\par
1309     \} {\cf20 // namespace Benchmark}\par
1310 \} {\cf20 // namespace Catch}\par
1311 \par
1312 {\cf21 #endif }{\cf20 // CATCH_OUTLIERS_CLASSIFICATION_HPP_INCLUDED}\par
1313 {\cf20 // The fwd decl & default specialization needs to be seen by VS2017 before}\par
1314 {\cf20 // BenchmarkStats itself, or VS2017 will report compilation error.}\par
1315 \par
1316 {\cf21 #include <string>}\par
1317 {\cf21 #include <vector>}\par
1318 \par
1319 {\cf17 namespace }Catch \{\par
1320 \par
1321     {\cf17 struct }BenchmarkInfo \{\par
1322         std::string name;\par
1323         {\cf18 double} estimatedDuration;\par
1324         {\cf18 int} iterations;\par
1325         {\cf18 unsigned} {\cf18 int} samples;\par
1326         {\cf18 unsigned} {\cf18 int} resamples;\par
1327         {\cf18 double} clockResolution;\par
1328         {\cf18 double} clockCost;\par
1329     \};\par
1330 \par
1331     {\cf20 // We need to keep template parameter for backwards compatibility,}\par
1332     {\cf20 // but we also do not want to use the template paraneter.}\par
1333     {\cf17 template} <{\cf17 class} Dummy>\par
1334     {\cf17 struct }BenchmarkStats \{\par
1335         BenchmarkInfo info;\par
1336 \par
1337         std::vector<Benchmark::FDuration> samples;\par
1338         Benchmark::Estimate<Benchmark::FDuration> mean;\par
1339         Benchmark::Estimate<Benchmark::FDuration> standardDeviation;\par
1340         Benchmark::OutlierClassification outliers;\par
1341         {\cf18 double} outlierVariance;\par
1342     \};\par
1343 \par
1344 \par
1345 \} {\cf20 // end namespace Catch}\par
1346 \par
1347 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_STATS_HPP_INCLUDED}\par
1348 \par
1349 \par
1350 {\cf20 // Adapted from donated nonius code.}\par
1351 \par
1352 {\cf21 #ifndef CATCH_ENVIRONMENT_HPP_INCLUDED}\par
1353 {\cf21 #define CATCH_ENVIRONMENT_HPP_INCLUDED}\par
1354 \par
1355 \par
1356 {\cf17 namespace }Catch \{\par
1357     {\cf17 namespace }Benchmark \{\par
1358         {\cf17 struct }EnvironmentEstimate \{\par
1359             FDuration mean;\par
1360             OutlierClassification outliers;\par
1361         \};\par
1362         {\cf17 struct }Environment \{\par
1363             EnvironmentEstimate clock_resolution;\par
1364             EnvironmentEstimate clock_cost;\par
1365         \};\par
1366     \} {\cf20 // namespace Benchmark}\par
1367 \} {\cf20 // namespace Catch}\par
1368 \par
1369 {\cf21 #endif }{\cf20 // CATCH_ENVIRONMENT_HPP_INCLUDED}\par
1370 \par
1371 \par
1372 {\cf20 // Adapted from donated nonius code.}\par
1373 \par
1374 {\cf21 #ifndef CATCH_EXECUTION_PLAN_HPP_INCLUDED}\par
1375 {\cf21 #define CATCH_EXECUTION_PLAN_HPP_INCLUDED}\par
1376 \par
1377 \par
1378 \par
1379 {\cf20 // Adapted from donated nonius code.}\par
1380 \par
1381 {\cf21 #ifndef CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}\par
1382 {\cf21 #define CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}\par
1383 \par
1384 \par
1385 \par
1386 {\cf20 // Adapted from donated nonius code.}\par
1387 \par
1388 {\cf21 #ifndef CATCH_CHRONOMETER_HPP_INCLUDED}\par
1389 {\cf21 #define CATCH_CHRONOMETER_HPP_INCLUDED}\par
1390 \par
1391 \par
1392 \par
1393 {\cf20 // Adapted from donated nonius code.}\par
1394 \par
1395 {\cf21 #ifndef CATCH_OPTIMIZER_HPP_INCLUDED}\par
1396 {\cf21 #define CATCH_OPTIMIZER_HPP_INCLUDED}\par
1397 \par
1398 {\cf21 #if defined(_MSC_VER) || defined(__IAR_SYSTEMS_ICC__)}\par
1399 {\cf21 #   include <atomic>} {\cf20 // atomic_thread_fence}\par
1400 {\cf21 #endif}\par
1401 \par
1402 \par
1403 {\cf21 #include <type_traits>}\par
1404 \par
1405 {\cf17 namespace }Catch \{\par
1406     {\cf17 namespace }Benchmark \{\par
1407 {\cf21 #if defined(__GNUC__) || defined(__clang__)}\par
1408         {\cf17 template} <{\cf17 typename} T>\par
1409         {\cf17 inline} {\cf18 void} keep_memory(T* p) \{\par
1410             {\cf17 asm} {\cf17 volatile}({\cf22 ""} : : {\cf22 "g"}(p) : {\cf22 "memory"});\par
1411         \}\par
1412         {\cf17 inline} {\cf18 void} keep_memory() \{\par
1413             {\cf17 asm} {\cf17 volatile}({\cf22 ""} : : : {\cf22 "memory"});\par
1414         \}\par
1415 \par
1416         {\cf17 namespace }Detail \{\par
1417             {\cf17 inline} {\cf18 void} optimizer_barrier() \{ keep_memory(); \}\par
1418         \} {\cf20 // namespace Detail}\par
1419 {\cf21 #elif defined(_MSC_VER) || defined(__IAR_SYSTEMS_ICC__)}\par
1420 \par
1421 {\cf21 #if defined(_MSVC_VER)}\par
1422 {\cf21 #pragma optimize("", off)}\par
1423 {\cf21 #elif defined(__IAR_SYSTEMS_ICC__)}\par
1424 {\cf20 // For IAR the pragma only affects the following function}\par
1425 {\cf21 #pragma optimize=disable}\par
1426 {\cf21 #endif}\par
1427         {\cf17 template} <{\cf17 typename} T>\par
1428         {\cf17 inline} {\cf18 void} keep_memory(T* p) \{\par
1429             {\cf20 // thanks @milleniumbug}\par
1430             *{\cf17 reinterpret_cast<}{\cf18 char} volatile*{\cf17 >}(p) = *{\cf17 reinterpret_cast<}{\cf18 char} {\cf17 const }volatile*{\cf17 >}(p);\par
1431         \}\par
1432         {\cf20 // TODO equivalent keep_memory()}\par
1433 {\cf21 #if defined(_MSVC_VER)}\par
1434 {\cf21 #pragma optimize("", on)}\par
1435 {\cf21 #endif}\par
1436 \par
1437         {\cf17 namespace }Detail \{\par
1438             {\cf17 inline} {\cf18 void} optimizer_barrier() \{\par
1439                 std::atomic_thread_fence(std::memory_order_seq_cst);\par
1440             \}\par
1441         \} {\cf20 // namespace Detail}\par
1442 \par
1443 {\cf21 #endif}\par
1444 \par
1445         {\cf17 template} <{\cf17 typename} T>\par
1446         {\cf17 inline} {\cf18 void} deoptimize_value(T&& x) \{\par
1447             keep_memory(&x);\par
1448         \}\par
1449 \par
1450         {\cf17 template} <{\cf17 typename} Fn, {\cf17 typename}... Args>\par
1451         {\cf17 inline} {\cf17 auto} invoke_deoptimized(Fn&& fn, Args&&... args) -> std::enable_if_t<!std::is_same<void, {\cf17 decltype}(fn(args...))>::value> \{\par
1452             deoptimize_value(CATCH_FORWARD(fn) (CATCH_FORWARD(args)...));\par
1453         \}\par
1454 \par
1455         {\cf17 template} <{\cf17 typename} Fn, {\cf17 typename}... Args>\par
1456         {\cf17 inline} {\cf17 auto} invoke_deoptimized(Fn&& fn, Args&&... args) -> std::enable_if_t<std::is_same<void, {\cf17 decltype}(fn(args...))>::value> \{\par
1457             CATCH_FORWARD((fn)) (CATCH_FORWARD(args)...);\par
1458         \}\par
1459     \} {\cf20 // namespace Benchmark}\par
1460 \} {\cf20 // namespace Catch}\par
1461 \par
1462 {\cf21 #endif }{\cf20 // CATCH_OPTIMIZER_HPP_INCLUDED}\par
1463 \par
1464 \par
1465 {\cf21 #ifndef CATCH_META_HPP_INCLUDED}\par
1466 {\cf21 #define CATCH_META_HPP_INCLUDED}\par
1467 \par
1468 {\cf21 #include <type_traits>}\par
1469 \par
1470 {\cf17 namespace }Catch \{\par
1471     {\cf17 template} <{\cf17 typename}>\par
1472     {\cf17 struct }true_given : std::true_type \{\};\par
1473 \par
1474     {\cf17 struct }is_callable_tester \{\par
1475         {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1476         {\cf17 static} true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> test({\cf18 int});\par
1477         {\cf17 template} <{\cf17 typename}...>\par
1478         {\cf17 static} std::false_type test(...);\par
1479     \};\par
1480 \par
1481     {\cf17 template} <{\cf17 typename} T>\par
1482     {\cf17 struct }is_callable;\par
1483 \par
1484     {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1485     {\cf17 struct }is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) \{\};\par
1486 \par
1487 \par
1488 {\cf21 #if defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703}\par
1489     {\cf20 // std::result_of is deprecated in C++17 and removed in C++20. Hence, it is}\par
1490     {\cf20 // replaced with std::invoke_result here.}\par
1491     {\cf17 template} <{\cf17 typename} Func, {\cf17 typename}... U>\par
1492     {\cf17 using }FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U...>>>;\par
1493 {\cf21 #else}\par
1494     {\cf17 template} <{\cf17 typename} Func, {\cf17 typename}... U>\par
1495     {\cf17 using }FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::result_of_t<Func(U...)>>>;\par
1496 {\cf21 #endif}\par
1497 \par
1498 \} {\cf20 // namespace Catch}\par
1499 \par
1500 {\cf17 namespace }mpl_\{\par
1501     {\cf17 struct }na;\par
1502 \}\par
1503 \par
1504 {\cf21 #endif }{\cf20 // CATCH_META_HPP_INCLUDED}\par
1505 \par
1506 {\cf17 namespace }Catch \{\par
1507     {\cf17 namespace }Benchmark \{\par
1508         {\cf17 namespace }Detail \{\par
1509             {\cf17 struct }ChronometerConcept \{\par
1510                 {\cf17 virtual} {\cf18 void} start() = 0;\par
1511                 {\cf17 virtual} {\cf18 void} finish() = 0;\par
1512                 {\cf17 virtual} ~ChronometerConcept(); {\cf20 // = default;}\par
1513 \par
1514                 ChronometerConcept() = {\cf19 default};\par
1515                 ChronometerConcept(ChronometerConcept {\cf17 const}&) = {\cf19 default};\par
1516                 ChronometerConcept& operator=(ChronometerConcept {\cf17 const}&) = {\cf19 default};\par
1517             \};\par
1518             {\cf17 template} <{\cf17 typename} Clock>\par
1519             {\cf17 struct }ChronometerModel final : {\cf17 public} ChronometerConcept \{\par
1520                 {\cf18 void} start(){\cf17  override }\{ started = Clock::now(); \}\par
1521                 {\cf18 void} finish(){\cf17  override }\{ finished = Clock::now(); \}\par
1522 \par
1523                 IDuration elapsed(){\cf17  const }\{\par
1524                     {\cf19 return} std::chrono::duration_cast<std::chrono::nanoseconds>(\par
1525                         finished - started );\par
1526                 \}\par
1527 \par
1528                 TimePoint<Clock> started;\par
1529                 TimePoint<Clock> finished;\par
1530             \};\par
1531         \} {\cf20 // namespace Detail}\par
1532 \par
1533         {\cf17 struct }Chronometer \{\par
1534         {\cf17 public}:\par
1535             {\cf17 template} <{\cf17 typename} Fun>\par
1536             {\cf18 void} measure(Fun&& fun) \{ measure(CATCH_FORWARD(fun), is_callable<Fun({\cf18 int})>()); \}\par
1537 \par
1538             {\cf18 int} runs(){\cf17  const }\{ {\cf19 return} repeats; \}\par
1539 \par
1540             Chronometer(Detail::ChronometerConcept& meter, {\cf18 int} repeats_)\par
1541                 : impl(&meter)\par
1542                 , repeats(repeats_) \{\}\par
1543 \par
1544         {\cf17 private}:\par
1545             {\cf17 template} <{\cf17 typename} Fun>\par
1546             {\cf18 void} measure(Fun&& fun, std::false_type) \{\par
1547                 measure([&fun]({\cf18 int}) \{ {\cf19 return} fun(); \}, std::true_type());\par
1548             \}\par
1549 \par
1550             {\cf17 template} <{\cf17 typename} Fun>\par
1551             {\cf18 void} measure(Fun&& fun, std::true_type) \{\par
1552                 Detail::optimizer_barrier();\par
1553                 impl->start();\par
1554                 {\cf19 for} ({\cf18 int} i = 0; i < repeats; ++i) invoke_deoptimized(fun, i);\par
1555                 impl->finish();\par
1556                 Detail::optimizer_barrier();\par
1557             \}\par
1558 \par
1559             Detail::ChronometerConcept* impl;\par
1560             {\cf18 int} repeats;\par
1561         \};\par
1562     \} {\cf20 // namespace Benchmark}\par
1563 \} {\cf20 // namespace Catch}\par
1564 \par
1565 {\cf21 #endif }{\cf20 // CATCH_CHRONOMETER_HPP_INCLUDED}\par
1566 \par
1567 {\cf21 #include <type_traits>}\par
1568 \par
1569 {\cf17 namespace }Catch \{\par
1570     {\cf17 namespace }Benchmark \{\par
1571         {\cf17 namespace }Detail \{\par
1572             {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U>\par
1573             {\cf17 struct }is_related\par
1574                 : std::is_same<std::decay_t<T>, std::decay_t<U>> \{\};\par
1575 \par
1583             {\cf17 struct }BenchmarkFunction \{\par
1584             {\cf17 private}:\par
1585                 {\cf17 struct }callable \{\par
1586                     {\cf17 virtual} {\cf18 void} call(Chronometer meter) {\cf17 const} = 0;\par
1587                     {\cf17 virtual} Catch::Detail::unique_ptr<callable> clone() {\cf17 const} = 0;\par
1588                     {\cf17 virtual} ~callable(); {\cf20 // = default;}\par
1589 \par
1590                     callable() = {\cf19 default};\par
1591                     callable(callable {\cf17 const}&) = {\cf19 default};\par
1592                     callable& operator=(callable {\cf17 const}&) = {\cf19 default};\par
1593                 \};\par
1594                 {\cf17 template} <{\cf17 typename} Fun>\par
1595                 {\cf17 struct }model : {\cf17 public} callable \{\par
1596                     model(Fun&& fun_) : fun(CATCH_MOVE(fun_)) \{\}\par
1597                     model(Fun {\cf17 const}& fun_) : fun(fun_) \{\}\par
1598 \par
1599                     Catch::Detail::unique_ptr<callable> clone(){\cf17  const override }\{\par
1600                         {\cf19 return} Catch::Detail::make_unique<model<Fun>>( *this );\par
1601                     \}\par
1602 \par
1603                     {\cf18 void} call(Chronometer meter){\cf17  const override }\{\par
1604                         call(meter, is_callable<Fun(Chronometer)>());\par
1605                     \}\par
1606                     {\cf18 void} call(Chronometer meter, std::true_type){\cf17  const }\{\par
1607                         fun(meter);\par
1608                     \}\par
1609                     {\cf18 void} call(Chronometer meter, std::false_type){\cf17  const }\{\par
1610                         meter.measure(fun);\par
1611                     \}\par
1612 \par
1613                     Fun fun;\par
1614                 \};\par
1615 \par
1616                 {\cf17 struct }do_nothing \{ {\cf18 void} operator()(){\cf17  const }\{\} \};\par
1617 \par
1618                 {\cf17 template} <{\cf17 typename} T>\par
1619                 BenchmarkFunction(model<T>* c) : f(c) \{\}\par
1620 \par
1621             {\cf17 public}:\par
1622                 BenchmarkFunction()\par
1623                     : f(new model<do_nothing>\{ \{\} \}) \{\}\par
1624 \par
1625                 {\cf17 template} <{\cf17 typename} Fun,\par
1626                     std::enable_if_t<!is_related<Fun, BenchmarkFunction>::value, {\cf18 int}> = 0>\par
1627                     BenchmarkFunction(Fun&& fun)\par
1628                     : f(new model<std::decay_t<Fun>>(CATCH_FORWARD(fun))) \{\}\par
1629 \par
1630                 BenchmarkFunction( BenchmarkFunction&& that ) {\cf17 noexcept}:\par
1631                     f( CATCH_MOVE( that.f ) ) \{\}\par
1632 \par
1633                 BenchmarkFunction(BenchmarkFunction {\cf17 const}& that)\par
1634                     : f(that.f->clone()) \{\}\par
1635 \par
1636                 BenchmarkFunction&\par
1637                 operator=( BenchmarkFunction&& that ) {\cf17 noexcept} \{\par
1638                     f = CATCH_MOVE( that.f );\par
1639                     {\cf19 return} *{\cf17 this};\par
1640                 \}\par
1641 \par
1642                 BenchmarkFunction& operator=(BenchmarkFunction {\cf17 const}& that) \{\par
1643                     f = that.f->clone();\par
1644                     {\cf19 return} *{\cf17 this};\par
1645                 \}\par
1646 \par
1647                 {\cf18 void} operator()(Chronometer meter){\cf17  const }\{ f->call(meter); \}\par
1648 \par
1649             {\cf17 private}:\par
1650                 Catch::Detail::unique_ptr<callable> f;\par
1651             \};\par
1652         \} {\cf20 // namespace Detail}\par
1653     \} {\cf20 // namespace Benchmark}\par
1654 \} {\cf20 // namespace Catch}\par
1655 \par
1656 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED}\par
1657 \par
1658 \par
1659 {\cf20 // Adapted from donated nonius code.}\par
1660 \par
1661 {\cf21 #ifndef CATCH_REPEAT_HPP_INCLUDED}\par
1662 {\cf21 #define CATCH_REPEAT_HPP_INCLUDED}\par
1663 \par
1664 {\cf21 #include <type_traits>}\par
1665 \par
1666 {\cf17 namespace }Catch \{\par
1667     {\cf17 namespace }Benchmark \{\par
1668         {\cf17 namespace }Detail \{\par
1669             {\cf17 template} <{\cf17 typename} Fun>\par
1670             {\cf17 struct }repeater \{\par
1671                 {\cf18 void} operator()({\cf18 int} k){\cf17  const }\{\par
1672                     {\cf19 for} ({\cf18 int} i = 0; i < k; ++i) \{\par
1673                         fun();\par
1674                     \}\par
1675                 \}\par
1676                 Fun fun;\par
1677             \};\par
1678             {\cf17 template} <{\cf17 typename} Fun>\par
1679             repeater<std::decay_t<Fun>> repeat(Fun&& fun) \{\par
1680                 {\cf19 return} \{ CATCH_FORWARD(fun) \};\par
1681             \}\par
1682         \} {\cf20 // namespace Detail}\par
1683     \} {\cf20 // namespace Benchmark}\par
1684 \} {\cf20 // namespace Catch}\par
1685 \par
1686 {\cf21 #endif }{\cf20 // CATCH_REPEAT_HPP_INCLUDED}\par
1687 \par
1688 \par
1689 {\cf20 // Adapted from donated nonius code.}\par
1690 \par
1691 {\cf21 #ifndef CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}\par
1692 {\cf21 #define CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}\par
1693 \par
1694 \par
1695 \par
1696 {\cf20 // Adapted from donated nonius code.}\par
1697 \par
1698 {\cf21 #ifndef CATCH_MEASURE_HPP_INCLUDED}\par
1699 {\cf21 #define CATCH_MEASURE_HPP_INCLUDED}\par
1700 \par
1701 \par
1702 \par
1703 {\cf20 // Adapted from donated nonius code.}\par
1704 \par
1705 {\cf21 #ifndef CATCH_COMPLETE_INVOKE_HPP_INCLUDED}\par
1706 {\cf21 #define CATCH_COMPLETE_INVOKE_HPP_INCLUDED}\par
1707 \par
1708 \par
1709 {\cf17 namespace }Catch \{\par
1710     {\cf17 namespace }Benchmark \{\par
1711         {\cf17 namespace }Detail \{\par
1712             {\cf17 template} <{\cf17 typename} T>\par
1713             {\cf17 struct }CompleteType \{ {\cf17 using }type = T; \};\par
1714             {\cf17 template} <>\par
1715             {\cf17 struct }CompleteType<void> \{ {\cf17 struct }type \{\}; \};\par
1716 \par
1717             {\cf17 template} <{\cf17 typename} T>\par
1718             {\cf17 using }CompleteType_t = {\cf17 typename} CompleteType<T>::type;\par
1719 \par
1720             {\cf17 template} <{\cf17 typename} Result>\par
1721             {\cf17 struct }CompleteInvoker \{\par
1722                 {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1723                 {\cf17 static} Result invoke(Fun&& fun, Args&&... args) \{\par
1724                     {\cf19 return} CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);\par
1725                 \}\par
1726             \};\par
1727             {\cf17 template} <>\par
1728             {\cf17 struct }CompleteInvoker<void> \{\par
1729                 {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1730                 {\cf17 static} CompleteType_t<void> invoke(Fun&& fun, Args&&... args) \{\par
1731                     CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);\par
1732                     {\cf19 return} \{\};\par
1733                 \}\par
1734             \};\par
1735 \par
1736             {\cf20 // invoke and not return void :(}\par
1737             {\cf17 template} <{\cf17 typename} Fun, {\cf17 typename}... Args>\par
1738             CompleteType_t<FunctionReturnType<Fun, Args...>> complete_invoke(Fun&& fun, Args&&... args) \{\par
1739                 {\cf19 return} CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(CATCH_FORWARD(fun), CATCH_FORWARD(args)...);\par
1740             \}\par
1741 \par
1742         \} {\cf20 // namespace Detail}\par
1743 \par
1744         {\cf17 template} <{\cf17 typename} Fun>\par
1745         Detail::CompleteType_t<FunctionReturnType<Fun>> user_code(Fun&& fun) \{\par
1746             {\cf19 return} Detail::complete_invoke(CATCH_FORWARD(fun));\par
1747         \}\par
1748     \} {\cf20 // namespace Benchmark}\par
1749 \} {\cf20 // namespace Catch}\par
1750 \par
1751 {\cf21 #endif }{\cf20 // CATCH_COMPLETE_INVOKE_HPP_INCLUDED}\par
1752 \par
1753 \par
1754 {\cf20 // Adapted from donated nonius code.}\par
1755 \par
1756 {\cf21 #ifndef CATCH_TIMING_HPP_INCLUDED}\par
1757 {\cf21 #define CATCH_TIMING_HPP_INCLUDED}\par
1758 \par
1759 \par
1760 {\cf21 #include <type_traits>}\par
1761 \par
1762 {\cf17 namespace }Catch \{\par
1763     {\cf17 namespace }Benchmark \{\par
1764         {\cf17 template} <{\cf17 typename} Result>\par
1765         {\cf17 struct }Timing \{\par
1766             IDuration elapsed;\par
1767             Result result;\par
1768             {\cf18 int} iterations;\par
1769         \};\par
1770         {\cf17 template} <{\cf17 typename} Func, {\cf17 typename}... Args>\par
1771         {\cf17 using }TimingOf = Timing<Detail::CompleteType_t<FunctionReturnType<Func, Args...>>>;\par
1772     \} {\cf20 // namespace Benchmark}\par
1773 \} {\cf20 // namespace Catch}\par
1774 \par
1775 {\cf21 #endif }{\cf20 // CATCH_TIMING_HPP_INCLUDED}\par
1776 \par
1777 {\cf17 namespace }Catch \{\par
1778     {\cf17 namespace }Benchmark \{\par
1779         {\cf17 namespace }Detail \{\par
1780             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun, {\cf17 typename}... Args>\par
1781             TimingOf<Fun, Args...> measure(Fun&& fun, Args&&... args) \{\par
1782                 {\cf17 auto} start = Clock::now();\par
1783                 {\cf17 auto}&& r = Detail::complete_invoke(fun, CATCH_FORWARD(args)...);\par
1784                 {\cf17 auto} end = Clock::now();\par
1785                 {\cf17 auto} delta = end - start;\par
1786                 {\cf19 return} \{ delta, CATCH_FORWARD(r), 1 \};\par
1787             \}\par
1788         \} {\cf20 // namespace Detail}\par
1789     \} {\cf20 // namespace Benchmark}\par
1790 \} {\cf20 // namespace Catch}\par
1791 \par
1792 {\cf21 #endif }{\cf20 // CATCH_MEASURE_HPP_INCLUDED}\par
1793 \par
1794 {\cf21 #include <type_traits>}\par
1795 \par
1796 {\cf17 namespace }Catch \{\par
1797     {\cf17 namespace }Benchmark \{\par
1798         {\cf17 namespace }Detail \{\par
1799             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1800             TimingOf<Fun, int> measure_one(Fun&& fun, {\cf18 int} iters, std::false_type) \{\par
1801                 {\cf19 return} Detail::measure<Clock>(fun, iters);\par
1802             \}\par
1803             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1804             TimingOf<Fun, Chronometer> measure_one(Fun&& fun, {\cf18 int} iters, std::true_type) \{\par
1805                 Detail::ChronometerModel<Clock> meter;\par
1806                 {\cf17 auto}&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));\par
1807 \par
1808                 {\cf19 return} \{ meter.elapsed(), CATCH_MOVE(result), iters \};\par
1809             \}\par
1810 \par
1811             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1812             {\cf17 using }run_for_at_least_argument_t = std::conditional_t<is_callable<Fun(Chronometer)>::value, Chronometer, {\cf18 int}>;\par
1813 \par
1814 \par
1815             [[noreturn]]\par
1816             {\cf18 void} throw_optimized_away_error();\par
1817 \par
1818             {\cf17 template} <{\cf17 typename} Clock, {\cf17 typename} Fun>\par
1819             TimingOf<Fun, run_for_at_least_argument_t<Clock, Fun>>\par
1820                 run_for_at_least(IDuration how_long,\par
1821                                  {\cf17 const} {\cf18 int} initial_iterations,\par
1822                                  Fun&& fun) \{\par
1823                 {\cf17 auto} iters = initial_iterations;\par
1824                 {\cf19 while} (iters < (1 << 30)) \{\par
1825                     {\cf17 auto}&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());\par
1826 \par
1827                     {\cf19 if} (Timing.elapsed >= how_long) \{\par
1828                         {\cf19 return} \{ Timing.elapsed, CATCH_MOVE(Timing.result), iters \};\par
1829                     \}\par
1830                     iters *= 2;\par
1831                 \}\par
1832                 throw_optimized_away_error();\par
1833             \}\par
1834         \} {\cf20 // namespace Detail}\par
1835     \} {\cf20 // namespace Benchmark}\par
1836 \} {\cf20 // namespace Catch}\par
1837 \par
1838 {\cf21 #endif }{\cf20 // CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED}\par
1839 \par
1840 {\cf21 #include <vector>}\par
1841 \par
1842 {\cf17 namespace }Catch \{\par
1843     {\cf17 namespace }Benchmark \{\par
1844         {\cf17 struct }ExecutionPlan \{\par
1845             {\cf18 int} iterations_per_sample;\par
1846             FDuration estimated_duration;\par
1847             Detail::BenchmarkFunction benchmark;\par
1848             FDuration warmup_time;\par
1849             {\cf18 int} warmup_iterations;\par
1850 \par
1851             {\cf17 template} <{\cf17 typename} Clock>\par
1852             std::vector<FDuration> run({\cf17 const} IConfig &cfg, Environment env){\cf17  const }\{\par
1853                 {\cf20 // warmup a bit}\par
1854                 Detail::run_for_at_least<Clock>(\par
1855                     std::chrono::duration_cast<IDuration>( warmup_time ),\par
1856                     warmup_iterations,\par
1857                     Detail::repeat( []() \{ {\cf19 return} Clock::now(); \} )\par
1858                 );\par
1859 \par
1860                 std::vector<FDuration> times;\par
1861                 {\cf17 const} {\cf17 auto} num_samples = cfg.benchmarkSamples();\par
1862                 times.reserve( num_samples );\par
1863                 {\cf19 for} ( {\cf18 size_t} i = 0; i < num_samples; ++i ) \{\par
1864                     Detail::ChronometerModel<Clock> model;\par
1865                     this->benchmark( Chronometer( model, iterations_per_sample ) );\par
1866                     {\cf17 auto} sample_time = model.elapsed() - env.clock_cost.mean;\par
1867                     {\cf19 if} ( sample_time < FDuration::zero() ) \{\par
1868                         sample_time = FDuration::zero();\par
1869                     \}\par
1870                     times.push_back(sample_time / iterations_per_sample);\par
1871                 \}\par
1872                 {\cf19 return} times;\par
1873             \}\par
1874         \};\par
1875     \} {\cf20 // namespace Benchmark}\par
1876 \} {\cf20 // namespace Catch}\par
1877 \par
1878 {\cf21 #endif }{\cf20 // CATCH_EXECUTION_PLAN_HPP_INCLUDED}\par
1879 \par
1880 \par
1881 {\cf20 // Adapted from donated nonius code.}\par
1882 \par
1883 {\cf21 #ifndef CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}\par
1884 {\cf21 #define CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}\par
1885 \par
1886 \par
1887 \par
1888 {\cf20 // Adapted from donated nonius code.}\par
1889 \par
1890 {\cf21 #ifndef CATCH_STATS_HPP_INCLUDED}\par
1891 {\cf21 #define CATCH_STATS_HPP_INCLUDED}\par
1892 \par
1893 \par
1894 {\cf21 #include <vector>}\par
1895 \par
1896 {\cf17 namespace }Catch \{\par
1897     {\cf17 namespace }Benchmark \{\par
1898         {\cf17 namespace }Detail \{\par
1899             {\cf17 using }sample = std::vector<double>;\par
1900 \par
1901             {\cf18 double} weighted_average_quantile( {\cf18 int} k,\par
1902                                               {\cf18 int} q,\par
1903                                               {\cf18 double}* first,\par
1904                                               {\cf18 double}* last );\par
1905 \par
1906             OutlierClassification\par
1907             classify_outliers( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last );\par
1908 \par
1909             {\cf18 double} mean( {\cf18 double} {\cf17 const}* first, {\cf18 double} {\cf17 const}* last );\par
1910 \par
1911             {\cf18 double} normal_cdf( {\cf18 double} x );\par
1912 \par
1913             {\cf18 double} erfc_inv({\cf18 double} x);\par
1914 \par
1915             {\cf18 double} normal_quantile({\cf18 double} p);\par
1916 \par
1917             Estimate<double>\par
1918             bootstrap( {\cf18 double} confidence_level,\par
1919                        {\cf18 double}* first,\par
1920                        {\cf18 double}* last,\par
1921                        sample {\cf17 const}& resample,\par
1922                        {\cf18 double} ( *estimator )( {\cf18 double} {\cf17 const}*, {\cf18 double} {\cf17 const}* ) );\par
1923 \par
1924             {\cf17 struct }bootstrap_analysis \{\par
1925                 Estimate<double> mean;\par
1926                 Estimate<double> standard_deviation;\par
1927                 {\cf18 double} outlier_variance;\par
1928             \};\par
1929 \par
1930             bootstrap_analysis analyse_samples({\cf18 double} confidence_level,\par
1931                                                {\cf18 unsigned} {\cf18 int} n_resamples,\par
1932                                                {\cf18 double}* first,\par
1933                                                {\cf18 double}* last);\par
1934         \} {\cf20 // namespace Detail}\par
1935     \} {\cf20 // namespace Benchmark}\par
1936 \} {\cf20 // namespace Catch}\par
1937 \par
1938 {\cf21 #endif }{\cf20 // CATCH_STATS_HPP_INCLUDED}\par
1939 \par
1940 {\cf21 #include <algorithm>}\par
1941 {\cf21 #include <vector>}\par
1942 {\cf21 #include <cmath>}\par
1943 \par
1944 {\cf17 namespace }Catch \{\par
1945     {\cf17 namespace }Benchmark \{\par
1946         {\cf17 namespace }Detail \{\par
1947             {\cf17 template} <{\cf17 typename} Clock>\par
1948             std::vector<double> resolution({\cf18 int} k) \{\par
1949                 std::vector<TimePoint<Clock>> times;\par
1950                 times.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k + 1));\par
1951                 {\cf19 for} ( {\cf18 int} i = 0; i < k + 1; ++i ) \{\par
1952                     times.push_back( Clock::now() );\par
1953                 \}\par
1954 \par
1955                 std::vector<double> deltas;\par
1956                 deltas.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k));\par
1957                 {\cf19 for} ( {\cf18 size_t} idx = 1; idx < times.size(); ++idx ) \{\par
1958                     deltas.push_back( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(\par
1959                         ( times[idx] - times[idx - 1] ).count() ) );\par
1960                 \}\par
1961 \par
1962                 {\cf19 return} deltas;\par
1963             \}\par
1964 \par
1965             {\cf17 constexpr} {\cf17 auto} warmup_iterations = 10000;\par
1966             {\cf17 constexpr} {\cf17 auto} warmup_time = std::chrono::milliseconds(100);\par
1967             {\cf17 constexpr} {\cf17 auto} minimum_ticks = 1000;\par
1968             {\cf17 constexpr} {\cf17 auto} warmup_seed = 10000;\par
1969             {\cf17 constexpr} {\cf17 auto} clock_resolution_estimation_time = std::chrono::milliseconds(500);\par
1970             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_time_limit = std::chrono::seconds(1);\par
1971             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_tick_limit = 100000;\par
1972             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_time = std::chrono::milliseconds(10);\par
1973             {\cf17 constexpr} {\cf17 auto} clock_cost_estimation_iterations = 10000;\par
1974 \par
1975             {\cf17 template} <{\cf17 typename} Clock>\par
1976             {\cf18 int} warmup() \{\par
1977                 {\cf19 return} run_for_at_least<Clock>(warmup_time, warmup_seed, &resolution<Clock>)\par
1978                     .iterations;\par
1979             \}\par
1980             {\cf17 template} <{\cf17 typename} Clock>\par
1981             EnvironmentEstimate estimate_clock_resolution({\cf18 int} iterations) \{\par
1982                 {\cf17 auto} r = run_for_at_least<Clock>(clock_resolution_estimation_time, iterations, &resolution<Clock>)\par
1983                     .result;\par
1984                 {\cf19 return} \{\par
1985                     FDuration(mean(r.data(), r.data() + r.size())),\par
1986                     classify_outliers(r.data(), r.data() + r.size()),\par
1987                 \};\par
1988             \}\par
1989             {\cf17 template} <{\cf17 typename} Clock>\par
1990             EnvironmentEstimate estimate_clock_cost(FDuration resolution) \{\par
1991                 {\cf17 auto} time_limit = (std::min)(\par
1992                     resolution * clock_cost_estimation_tick_limit,\par
1993                     FDuration(clock_cost_estimation_time_limit));\par
1994                 {\cf17 auto} time_clock = []({\cf18 int} k) \{\par
1995                     {\cf19 return} Detail::measure<Clock>([k] \{\par
1996                         {\cf19 for} ({\cf18 int} i = 0; i < k; ++i) \{\par
1997                             {\cf17 volatile} {\cf17 auto} ignored = Clock::now();\par
1998                             (void)ignored;\par
1999                         \}\par
2000                     \}).elapsed;\par
2001                 \};\par
2002                 time_clock(1);\par
2003                 {\cf18 int} iters = clock_cost_estimation_iterations;\par
2004                 {\cf17 auto}&& r = run_for_at_least<Clock>(clock_cost_estimation_time, iters, time_clock);\par
2005                 std::vector<double> times;\par
2006                 {\cf18 int} nsamples = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::ceil(time_limit / r.elapsed));\par
2007                 times.reserve({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(nsamples));\par
2008                 {\cf19 for} ( {\cf18 int} s = 0; s < nsamples; ++s ) \{\par
2009                     times.push_back( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(\par
2010                         ( time_clock( r.iterations ) / r.iterations )\par
2011                             .count() ) );\par
2012                 \}\par
2013                 {\cf19 return} \{\par
2014                     FDuration(mean(times.data(), times.data() + times.size())),\par
2015                     classify_outliers(times.data(), times.data() + times.size()),\par
2016                 \};\par
2017             \}\par
2018 \par
2019             {\cf17 template} <{\cf17 typename} Clock>\par
2020             Environment measure_environment() \{\par
2021 {\cf21 #if defined(__clang__)}\par
2022 {\cf21 #    pragma clang diagnostic push}\par
2023 {\cf21 #    pragma clang diagnostic ignored "-Wexit-time-destructors"}\par
2024 {\cf21 #endif}\par
2025                 {\cf17 static} Catch::Detail::unique_ptr<Environment> env;\par
2026 {\cf21 #if defined(__clang__)}\par
2027 {\cf21 #    pragma clang diagnostic pop}\par
2028 {\cf21 #endif}\par
2029                 {\cf19 if} (env) \{\par
2030                     {\cf19 return} *env;\par
2031                 \}\par
2032 \par
2033                 {\cf17 auto} iters = Detail::warmup<Clock>();\par
2034                 {\cf17 auto} resolution = Detail::estimate_clock_resolution<Clock>(iters);\par
2035                 {\cf17 auto} cost = Detail::estimate_clock_cost<Clock>(resolution.mean);\par
2036 \par
2037                 env = Catch::Detail::make_unique<Environment>( Environment\{resolution, cost\} );\par
2038                 {\cf19 return} *env;\par
2039             \}\par
2040         \} {\cf20 // namespace Detail}\par
2041     \} {\cf20 // namespace Benchmark}\par
2042 \} {\cf20 // namespace Catch}\par
2043 \par
2044 {\cf21 #endif }{\cf20 // CATCH_ESTIMATE_CLOCK_HPP_INCLUDED}\par
2045 \par
2046 \par
2047 {\cf20 // Adapted from donated nonius code.}\par
2048 \par
2049 {\cf21 #ifndef CATCH_ANALYSE_HPP_INCLUDED}\par
2050 {\cf21 #define CATCH_ANALYSE_HPP_INCLUDED}\par
2051 \par
2052 \par
2053 \par
2054 {\cf20 // Adapted from donated nonius code.}\par
2055 \par
2056 {\cf21 #ifndef CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}\par
2057 {\cf21 #define CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}\par
2058 \par
2059 \par
2060 {\cf21 #include <vector>}\par
2061 \par
2062 {\cf17 namespace }Catch \{\par
2063     {\cf17 namespace }Benchmark \{\par
2064         {\cf17 struct }SampleAnalysis \{\par
2065             std::vector<FDuration> samples;\par
2066             Estimate<FDuration> mean;\par
2067             Estimate<FDuration> standard_deviation;\par
2068             OutlierClassification outliers;\par
2069             {\cf18 double} outlier_variance;\par
2070         \};\par
2071     \} {\cf20 // namespace Benchmark}\par
2072 \} {\cf20 // namespace Catch}\par
2073 \par
2074 {\cf21 #endif }{\cf20 // CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED}\par
2075 \par
2076 \par
2077 {\cf17 namespace }Catch \{\par
2078     {\cf17 class }IConfig;\par
2079 \par
2080     {\cf17 namespace }Benchmark \{\par
2081         {\cf17 namespace }Detail \{\par
2082             SampleAnalysis analyse({\cf17 const} IConfig &cfg, FDuration* first, FDuration* last);\par
2083         \} {\cf20 // namespace Detail}\par
2084     \} {\cf20 // namespace Benchmark}\par
2085 \} {\cf20 // namespace Catch}\par
2086 \par
2087 {\cf21 #endif }{\cf20 // CATCH_ANALYSE_HPP_INCLUDED}\par
2088 \par
2089 {\cf21 #include <algorithm>}\par
2090 {\cf21 #include <chrono>}\par
2091 {\cf21 #include <exception>}\par
2092 {\cf21 #include <string>}\par
2093 {\cf21 #include <cmath>}\par
2094 \par
2095 {\cf17 namespace }Catch \{\par
2096     {\cf17 namespace }Benchmark \{\par
2097         {\cf17 struct }Benchmark \{\par
2098             Benchmark(std::string&& benchmarkName)\par
2099                 : name(CATCH_MOVE(benchmarkName)) \{\}\par
2100 \par
2101             {\cf17 template} <{\cf17 class} FUN>\par
2102             Benchmark(std::string&& benchmarkName , FUN &&func)\par
2103                 : fun(CATCH_MOVE(func)), name(CATCH_MOVE(benchmarkName)) \{\}\par
2104 \par
2105             {\cf17 template} <{\cf17 typename} Clock>\par
2106             ExecutionPlan prepare({\cf17 const} IConfig &cfg, Environment env){\cf17  const }\{\par
2107                 {\cf17 auto} min_time = env.clock_resolution.mean * Detail::minimum_ticks;\par
2108                 {\cf17 auto} run_time = std::max(min_time, std::chrono::duration_cast<{\cf17 decltype}(min_time)>(cfg.benchmarkWarmupTime()));\par
2109                 {\cf17 auto}&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<IDuration>(run_time), 1, fun);\par
2110                 {\cf18 int} new_iters = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(std::ceil(min_time * test.iterations / test.elapsed));\par
2111                 {\cf19 return} \{ new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FDuration>(cfg.benchmarkWarmupTime()), Detail::warmup_iterations \};\par
2112             \}\par
2113 \par
2114             {\cf17 template} <{\cf17 typename} Clock = default_clock>\par
2115             {\cf18 void} run() \{\par
2116                 {\cf17 static_assert}( Clock::is_steady,\par
2117                                {\cf22 "Benchmarking clock should be steady"} );\par
2118                 {\cf17 auto} {\cf17 const}* cfg = getCurrentContext().getConfig();\par
2119 \par
2120                 {\cf17 auto} env = Detail::measure_environment<Clock>();\par
2121 \par
2122                 getResultCapture().benchmarkPreparing(name);\par
2123                 CATCH_TRY\{\par
2124                     {\cf17 auto} plan = user_code([&] \{\par
2125                         {\cf19 return} prepare<Clock>(*cfg, env);\par
2126                     \});\par
2127 \par
2128                     BenchmarkInfo info \{\par
2129                         CATCH_MOVE(name),\par
2130                         plan.estimated_duration.count(),\par
2131                         plan.iterations_per_sample,\par
2132                         cfg->benchmarkSamples(),\par
2133                         cfg->benchmarkResamples(),\par
2134                         env.clock_resolution.mean.count(),\par
2135                         env.clock_cost.mean.count()\par
2136                     \};\par
2137 \par
2138                     getResultCapture().benchmarkStarting(info);\par
2139 \par
2140                     {\cf17 auto} samples = user_code([&] \{\par
2141                         {\cf19 return} plan.template run<Clock>(*cfg, env);\par
2142                     \});\par
2143 \par
2144                     {\cf17 auto} analysis = Detail::analyse(*cfg, samples.data(), samples.data() + samples.size());\par
2145                     BenchmarkStats<> stats\{ CATCH_MOVE(info), CATCH_MOVE(analysis.samples), analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance \};\par
2146                     getResultCapture().benchmarkEnded(stats);\par
2147                 \} CATCH_CATCH_ANON (TestFailureException {\cf17 const}&) \{\par
2148                     getResultCapture().benchmarkFailed({\cf22 "Benchmark failed due to failed assertion"}_sr);\par
2149                 \} CATCH_CATCH_ALL\{\par
2150                     getResultCapture().benchmarkFailed(translateActiveException());\par
2151                     {\cf20 // We let the exception go further up so that the}\par
2152                     {\cf20 // test case is marked as failed.}\par
2153                     std::rethrow_exception(std::current_exception());\par
2154                 \}\par
2155             \}\par
2156 \par
2157             {\cf20 // sets lambda to be used in fun *and* executes benchmark!}\par
2158             template <typename Fun, std::enable_if_t<!Detail::is_related<Fun, Benchmark>::value, {\cf18 int}> = 0>\par
2159                 Benchmark & operator=(Fun func) \{\par
2160                 {\cf17 auto} {\cf17 const}* cfg = getCurrentContext().getConfig();\par
2161                 {\cf19 if} (!cfg->skipBenchmarks()) \{\par
2162                     fun = Detail::BenchmarkFunction(func);\par
2163                     run();\par
2164                 \}\par
2165                 {\cf19 return} *{\cf17 this};\par
2166             \}\par
2167 \par
2168             {\cf17 explicit} {\cf17 operator} bool() \{\par
2169                 {\cf19 return} {\cf17 true};\par
2170             \}\par
2171 \par
2172         {\cf17 private}:\par
2173             Detail::BenchmarkFunction fun;\par
2174             std::string name;\par
2175         \};\par
2176     \}\par
2177 \} {\cf20 // namespace Catch}\par
2178 \par
2179 {\cf21 #define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1}\par
2180 {\cf21 #define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2}\par
2181 \par
2182 {\cf21 #define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\\}\par
2183 {\cf21     if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\}\par
2184 {\cf21         BenchmarkName = [&](int benchmarkIndex)}\par
2185 \par
2186 {\cf21 #define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\\}\par
2187 {\cf21     if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \\}\par
2188 {\cf21         BenchmarkName = [&]}\par
2189 \par
2190 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL)}\par
2191 \par
2192 {\cf21 #define CATCH_BENCHMARK(...) \\}\par
2193 {\cf21     INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))}\par
2194 {\cf21 #define CATCH_BENCHMARK_ADVANCED(name) \\}\par
2195 {\cf21     INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)}\par
2196 \par
2197 {\cf21 #else}\par
2198 \par
2199 {\cf21 #define BENCHMARK(...) \\}\par
2200 {\cf21     INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))}\par
2201 {\cf21 #define BENCHMARK_ADVANCED(name) \\}\par
2202 {\cf21     INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)}\par
2203 \par
2204 {\cf21 #endif}\par
2205 \par
2206 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_HPP_INCLUDED}\par
2207 \par
2208 \par
2209 {\cf20 // Adapted from donated nonius code.}\par
2210 \par
2211 {\cf21 #ifndef CATCH_CONSTRUCTOR_HPP_INCLUDED}\par
2212 {\cf21 #define CATCH_CONSTRUCTOR_HPP_INCLUDED}\par
2213 \par
2214 \par
2215 {\cf21 #include <type_traits>}\par
2216 \par
2217 {\cf17 namespace }Catch \{\par
2218     {\cf17 namespace }Benchmark \{\par
2219         {\cf17 namespace }Detail \{\par
2220             {\cf17 template} <{\cf17 typename} T, {\cf18 bool} Destruct>\par
2221             {\cf17 struct }ObjectStorage\par
2222             \{\par
2223                 ObjectStorage() = {\cf19 default};\par
2224 \par
2225                 ObjectStorage({\cf17 const} ObjectStorage& other)\par
2226                 \{\par
2227                     {\cf17 new}(&data) T(other.stored_object());\par
2228                 \}\par
2229 \par
2230                 ObjectStorage(ObjectStorage&& other)\par
2231                 \{\par
2232                     {\cf17 new}(data) T(CATCH_MOVE(other.stored_object()));\par
2233                 \}\par
2234 \par
2235                 ~ObjectStorage() \{ destruct_on_exit<T>(); \}\par
2236 \par
2237                 {\cf17 template} <{\cf17 typename}... Args>\par
2238                 {\cf18 void} construct(Args&&... args)\par
2239                 \{\par
2240                     {\cf17 new} (data) T(CATCH_FORWARD(args)...);\par
2241                 \}\par
2242 \par
2243                 {\cf17 template} <{\cf18 bool} AllowManualDestruction = !Destruct>\par
2244                 std::enable_if_t<AllowManualDestruction> destruct()\par
2245                 \{\par
2246                     stored_object().~T();\par
2247                 \}\par
2248 \par
2249             {\cf17 private}:\par
2250                 {\cf20 // If this is a constructor benchmark, destruct the underlying object}\par
2251                 {\cf17 template} <{\cf17 typename} U>\par
2252                 {\cf18 void} destruct_on_exit(std::enable_if_t<Destruct, U>* = {\cf17 nullptr}) \{ destruct<true>(); \}\par
2253                 {\cf20 // Otherwise, don't}\par
2254                 {\cf17 template} <{\cf17 typename} U>\par
2255                 {\cf18 void} destruct_on_exit(std::enable_if_t<!Destruct, U>* = {\cf17 nullptr}) \{ \}\par
2256 \par
2257 {\cf21 #if defined( __GNUC__ ) && __GNUC__ <= 6}\par
2258 {\cf21 #    pragma GCC diagnostic push}\par
2259 {\cf21 #    pragma GCC diagnostic ignored "-Wstrict-aliasing"}\par
2260 {\cf21 #endif}\par
2261                 T& stored_object() \{ {\cf19 return} *{\cf17 reinterpret_cast<}T*{\cf17 >}( data ); \}\par
2262 \par
2263                 T {\cf17 const}& stored_object(){\cf17  const }\{\par
2264                     {\cf19 return} *{\cf17 reinterpret_cast<}T const*{\cf17 >}( data );\par
2265                 \}\par
2266 {\cf21 #if defined( __GNUC__ ) && __GNUC__ <= 6}\par
2267 {\cf21 #    pragma GCC diagnostic pop}\par
2268 {\cf21 #endif}\par
2269 \par
2270                 {\cf17 alignas}( T ) {\cf18 unsigned} {\cf18 char} data[{\cf17 sizeof}( T )]\{\};\par
2271             \};\par
2272         \} {\cf20 // namespace Detail}\par
2273 \par
2274         {\cf17 template} <{\cf17 typename} T>\par
2275         {\cf17 using }storage_for = Detail::ObjectStorage<T, true>;\par
2276 \par
2277         {\cf17 template} <{\cf17 typename} T>\par
2278         {\cf17 using }destructable_object = Detail::ObjectStorage<T, false>;\par
2279     \} {\cf20 // namespace Benchmark}\par
2280 \} {\cf20 // namespace Catch}\par
2281 \par
2282 {\cf21 #endif }{\cf20 // CATCH_CONSTRUCTOR_HPP_INCLUDED}\par
2283 \par
2284 {\cf21 #endif }{\cf20 // CATCH_BENCHMARK_ALL_HPP_INCLUDED}\par
2285 \par
2286 \par
2287 {\cf21 #ifndef CATCH_APPROX_HPP_INCLUDED}\par
2288 {\cf21 #define CATCH_APPROX_HPP_INCLUDED}\par
2289 \par
2290 \par
2291 \par
2292 {\cf21 #ifndef CATCH_TOSTRING_HPP_INCLUDED}\par
2293 {\cf21 #define CATCH_TOSTRING_HPP_INCLUDED}\par
2294 \par
2295 \par
2296 {\cf21 #include <vector>}\par
2297 {\cf21 #include <cstddef>}\par
2298 {\cf21 #include <type_traits>}\par
2299 {\cf21 #include <string>}\par
2300 \par
2301 \par
2302 \par
2303 \par
2312 {\cf21 #ifndef CATCH_CONFIG_WCHAR_HPP_INCLUDED}\par
2313 {\cf21 #define CATCH_CONFIG_WCHAR_HPP_INCLUDED}\par
2314 \par
2315 \par
2316 {\cf20 // We assume that WCHAR should be enabled by default, and only disabled}\par
2317 {\cf20 // for a shortlist (so far only DJGPP) of compilers.}\par
2318 \par
2319 {\cf21 #if defined(__DJGPP__)}\par
2320 {\cf21 #  define CATCH_INTERNAL_CONFIG_NO_WCHAR}\par
2321 {\cf21 #endif }{\cf20 // __DJGPP__}\par
2322 \par
2323 {\cf21 #if !defined( CATCH_INTERNAL_CONFIG_NO_WCHAR ) && \\}\par
2324 {\cf21     !defined( CATCH_CONFIG_NO_WCHAR ) && \\}\par
2325 {\cf21     !defined( CATCH_CONFIG_WCHAR )}\par
2326 {\cf21 #    define CATCH_CONFIG_WCHAR}\par
2327 {\cf21 #endif}\par
2328 \par
2329 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WCHAR_HPP_INCLUDED}\par
2330 \par
2331 \par
2332 {\cf21 #ifndef CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}\par
2333 {\cf21 #define CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}\par
2334 \par
2335 \par
2336 {\cf21 #include <iosfwd>}\par
2337 {\cf21 #include <cstddef>}\par
2338 {\cf21 #include <ostream>}\par
2339 {\cf21 #include <string>}\par
2340 \par
2341 {\cf17 namespace }Catch \{\par
2342 \par
2343     {\cf17 class }ReusableStringStream : Detail::NonCopyable \{\par
2344         std::size_t m_index;\par
2345         std::ostream* m_oss;\par
2346     {\cf17 public}:\par
2347         ReusableStringStream();\par
2348         ~ReusableStringStream();\par
2349 \par
2351         std::string str() {\cf17 const};\par
2353         {\cf18 void} str(std::string {\cf17 const}& str);\par
2354 \par
2355 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
2356 {\cf21 #pragma GCC diagnostic push}\par
2357 {\cf20 // Old versions of GCC do not understand -Wnonnull-compare}\par
2358 {\cf21 #pragma GCC diagnostic ignored "-Wpragmas"}\par
2359 {\cf20 // Streaming a function pointer triggers Waddress and Wnonnull-compare}\par
2360 {\cf20 // on GCC, because it implicitly converts it to bool and then decides}\par
2361 {\cf20 // that the check it uses (a? true : false) is tautological and cannot}\par
2362 {\cf20 // be null...}\par
2363 {\cf21 #pragma GCC diagnostic ignored "-Waddress"}\par
2364 {\cf21 #pragma GCC diagnostic ignored "-Wnonnull-compare"}\par
2365 {\cf21 #endif}\par
2366 \par
2367         {\cf17 template}<{\cf17 typename} T>\par
2368         {\cf17 auto} operator << ( T {\cf17 const}& value ) -> ReusableStringStream& \{\par
2369             *m_oss << value;\par
2370             {\cf19 return} *{\cf17 this};\par
2371         \}\par
2372 \par
2373 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
2374 {\cf21 #pragma GCC diagnostic pop}\par
2375 {\cf21 #endif}\par
2376         {\cf17 auto} get() -> std::ostream& \{ {\cf19 return} *m_oss; \}\par
2377     \};\par
2378 \}\par
2379 \par
2380 {\cf21 #endif }{\cf20 // CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED}\par
2381 \par
2382 \par
2383 {\cf21 #ifndef CATCH_VOID_TYPE_HPP_INCLUDED}\par
2384 {\cf21 #define CATCH_VOID_TYPE_HPP_INCLUDED}\par
2385 \par
2386 \par
2387 {\cf17 namespace }Catch \{\par
2388     {\cf17 namespace }Detail \{\par
2389 \par
2390         {\cf17 template} <{\cf17 typename}...>\par
2391         {\cf17 struct }make_void \{ {\cf17 using }type = void; \};\par
2392 \par
2393         {\cf17 template} <{\cf17 typename}... Ts>\par
2394         {\cf17 using }void_t = {\cf17 typename} make_void<Ts...>::type;\par
2395 \par
2396     \} {\cf20 // namespace Detail}\par
2397 \} {\cf20 // namespace Catch}\par
2398 \par
2399 \par
2400 {\cf21 #endif }{\cf20 // CATCH_VOID_TYPE_HPP_INCLUDED}\par
2401 \par
2402 \par
2403 {\cf21 #ifndef CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
2404 {\cf21 #define CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
2405 \par
2406 \par
2407 {\cf21 #include <vector>}\par
2408 \par
2409 {\cf17 namespace }Catch \{\par
2410 \par
2411     {\cf17 namespace }Detail \{\par
2412         {\cf17 struct }EnumInfo \{\par
2413             StringRef m_name;\par
2414             std::vector<std::pair<int, StringRef>> m_values;\par
2415 \par
2416             ~EnumInfo();\par
2417 \par
2418             StringRef lookup( {\cf18 int} value ) {\cf17 const};\par
2419         \};\par
2420     \} {\cf20 // namespace Detail}\par
2421 \par
2422     {\cf17 class }IMutableEnumValuesRegistry \{\par
2423     {\cf17 public}:\par
2424         {\cf17 virtual} ~IMutableEnumValuesRegistry(); {\cf20 // = default;}\par
2425 \par
2426         {\cf17 virtual} Detail::EnumInfo {\cf17 const}& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> {\cf17 const}& values ) = 0;\par
2427 \par
2428         {\cf17 template}<{\cf17 typename} E>\par
2429         Detail::EnumInfo {\cf17 const}& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) \{\par
2430             {\cf17 static_assert}({\cf17 sizeof}(int) >= {\cf17 sizeof}(E), {\cf22 "Cannot serialize enum to int"});\par
2431             std::vector<int> intValues;\par
2432             intValues.reserve( values.size() );\par
2433             {\cf19 for}( {\cf17 auto} enumValue : values )\par
2434                 intValues.push_back( {\cf17 static_cast<}{\cf18 int}{\cf17 >}( enumValue ) );\par
2435             {\cf19 return} registerEnum( enumName, allEnums, intValues );\par
2436         \}\par
2437     \};\par
2438 \par
2439 \} {\cf20 // Catch}\par
2440 \par
2441 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
2442 \par
2443 {\cf21 #ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2444 {\cf21 #include <string_view>}\par
2445 {\cf21 #endif}\par
2446 \par
2447 {\cf21 #ifdef _MSC_VER}\par
2448 {\cf21 #pragma warning(push)}\par
2449 {\cf21 #pragma warning(disable:4180) }{\cf20 // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless}\par
2450 {\cf21 #endif}\par
2451 \par
2452 {\cf20 // We need a dummy global operator<< so we can bring it into Catch namespace later}\par
2453 {\cf17 struct }Catch_global_namespace_dummy\{\};\par
2454 std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);\par
2455 \par
2456 {\cf17 namespace }Catch \{\par
2457     {\cf20 // Bring in global namespace operator<< for ADL lookup in}\par
2458     {\cf20 // `IsStreamInsertable` below.}\par
2459     using ::operator<<;\par
2460 \par
2461     {\cf17 namespace }Detail \{\par
2462 \par
2463         {\cf17 inline} std::size_t catch_strnlen({\cf17 const} {\cf18 char} *str, std::size_t n) \{\par
2464             {\cf17 auto} ret = std::char_traits<char>::find(str, n, {\cf23 '\\0'});\par
2465             {\cf19 if} (ret != {\cf17 nullptr}) \{\par
2466                 {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(ret - str);\par
2467             \}\par
2468             {\cf19 return} n;\par
2469         \}\par
2470 \par
2471         {\cf17 constexpr} StringRef unprintableString = {\cf22 "\{?\}"}_sr;\par
2472 \par
2474         std::string convertIntoString( StringRef {\cf18 string}, {\cf18 bool} escapeInvisibles );\par
2475 \par
2478         std::string convertIntoString( StringRef {\cf18 string} );\par
2479 \par
2480         std::string rawMemoryToString( {\cf17 const} {\cf18 void} *{\cf18 object}, std::size_t size );\par
2481 \par
2482         {\cf17 template}<{\cf17 typename} T>\par
2483         std::string rawMemoryToString( {\cf17 const} T& {\cf18 object} ) \{\par
2484           {\cf19 return} rawMemoryToString( &{\cf18 object}, {\cf17 sizeof}({\cf18 object}) );\par
2485         \}\par
2486 \par
2487         {\cf17 template}<{\cf17 typename} T>\par
2488         {\cf17 class }IsStreamInsertable \{\par
2489             {\cf17 template}<{\cf17 typename} Stream, {\cf17 typename} U>\par
2490             {\cf17 static} {\cf17 auto} test({\cf18 int})\par
2491                 -> {\cf17 decltype}(std::declval<Stream&>() << std::declval<U>(), std::true_type());\par
2492 \par
2493             {\cf17 template}<{\cf17 typename}, {\cf17 typename}>\par
2494             {\cf17 static} {\cf17 auto} test(...)->std::false_type;\par
2495 \par
2496         {\cf17 public}:\par
2497             {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 decltype}(test<std::ostream, const T&>(0))::value;\par
2498         \};\par
2499 \par
2500         {\cf17 template}<{\cf17 typename} E>\par
2501         std::string convertUnknownEnumToString( E e );\par
2502 \par
2503         {\cf17 template}<{\cf17 typename} T>\par
2504         std::enable_if_t<\par
2505             !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,\par
2506         std::string> convertUnstreamable( T {\cf17 const}& ) \{\par
2507             {\cf19 return} std::string(Detail::unprintableString);\par
2508         \}\par
2509         {\cf17 template}<{\cf17 typename} T>\par
2510         std::enable_if_t<\par
2511             !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,\par
2512          std::string> convertUnstreamable(T {\cf17 const}& ex) \{\par
2513             {\cf19 return} ex.what();\par
2514         \}\par
2515 \par
2516 \par
2517         {\cf17 template}<{\cf17 typename} T>\par
2518         std::enable_if_t<\par
2519             std::is_enum<T>::value,\par
2520         std::string> convertUnstreamable( T {\cf17 const}& value ) \{\par
2521             {\cf19 return} convertUnknownEnumToString( value );\par
2522         \}\par
2523 \par
2524 {\cf21 #if defined(_MANAGED)}\par
2526         {\cf17 template}<{\cf17 typename} T>\par
2527         std::string clrReferenceToString( T^ ref ) \{\par
2528             {\cf19 if} (ref == {\cf17 nullptr})\par
2529                 {\cf19 return} std::string({\cf22 "null"});\par
2530             {\cf17 auto} bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());\par
2531             cli::pin_ptr<System::Byte> p = &bytes[0];\par
2532             {\cf19 return} std::string({\cf17 reinterpret_cast<}{\cf18 char} {\cf17 const }*{\cf17 >}(p), bytes->Length);\par
2533         \}\par
2534 {\cf21 #endif}\par
2535 \par
2536     \} {\cf20 // namespace Detail}\par
2537 \par
2538 \par
2539     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
2540     {\cf17 struct }StringMaker \{\par
2541         {\cf17 template} <{\cf17 typename} Fake = T>\par
2542         {\cf17 static}\par
2543         std::enable_if_t<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>\par
2544             convert({\cf17 const} Fake& value) \{\par
2545                 ReusableStringStream rss;\par
2546                 {\cf20 // NB: call using the function-like syntax to avoid ambiguity with}\par
2547                 {\cf20 // user-defined templated operator<< under clang.}\par
2548                 rss.operator<<(value);\par
2549                 {\cf19 return} rss.str();\par
2550         \}\par
2551 \par
2552         {\cf17 template} <{\cf17 typename} Fake = T>\par
2553         {\cf17 static}\par
2554         std::enable_if_t<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>\par
2555             convert( {\cf17 const} Fake& value ) \{\par
2556 {\cf21 #if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)}\par
2557             {\cf19 return} Detail::convertUnstreamable(value);\par
2558 {\cf21 #else}\par
2559             {\cf19 return} CATCH_CONFIG_FALLBACK_STRINGIFIER(value);\par
2560 {\cf21 #endif}\par
2561         \}\par
2562     \};\par
2563 \par
2564     {\cf17 namespace }Detail \{\par
2565 \par
2566         {\cf20 // This function dispatches all stringification requests inside of Catch.}\par
2567         {\cf20 // Should be preferably called fully qualified, like ::Catch::Detail::stringify}\par
2568         {\cf17 template} <{\cf17 typename} T>\par
2569         std::string stringify({\cf17 const} T& e) \{\par
2570             return ::Catch::StringMaker<std::remove_cv_t<std::remove_reference_t<T>>>::convert(e);\par
2571         \}\par
2572 \par
2573         {\cf17 template}<{\cf17 typename} E>\par
2574         std::string convertUnknownEnumToString( E e ) \{\par
2575             return ::Catch::Detail::stringify({\cf17 static_cast<}std::underlying_type_t<E>{\cf17 >}(e));\par
2576         \}\par
2577 \par
2578 {\cf21 #if defined(_MANAGED)}\par
2579         {\cf17 template} <{\cf17 typename} T>\par
2580         std::string stringify( T^ e ) \{\par
2581             return ::Catch::StringMaker<T^>::convert(e);\par
2582         \}\par
2583 {\cf21 #endif}\par
2584 \par
2585     \} {\cf20 // namespace Detail}\par
2586 \par
2587     {\cf20 // Some predefined specializations}\par
2588 \par
2589     {\cf17 template}<>\par
2590     {\cf17 struct }StringMaker<std::string> \{\par
2591         {\cf17 static} std::string convert({\cf17 const} std::string& str);\par
2592     \};\par
2593 \par
2594 {\cf21 #ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2595     {\cf17 template}<>\par
2596     {\cf17 struct }StringMaker<std::string_view> \{\par
2597         {\cf17 static} std::string convert(std::string_view str);\par
2598     \};\par
2599 {\cf21 #endif}\par
2600 \par
2601     {\cf17 template}<>\par
2602     {\cf17 struct }StringMaker<char const *> \{\par
2603         {\cf17 static} std::string convert({\cf18 char} {\cf17 const} * str);\par
2604     \};\par
2605     {\cf17 template}<>\par
2606     {\cf17 struct }StringMaker<char *> \{\par
2607         {\cf17 static} std::string convert({\cf18 char} * str);\par
2608     \};\par
2609 \par
2610 {\cf21 #if defined(CATCH_CONFIG_WCHAR)}\par
2611     {\cf17 template}<>\par
2612     {\cf17 struct }StringMaker<std::wstring> \{\par
2613         {\cf17 static} std::string convert({\cf17 const} std::wstring& wstr);\par
2614     \};\par
2615 \par
2616 {\cf21 # ifdef CATCH_CONFIG_CPP17_STRING_VIEW}\par
2617     {\cf17 template}<>\par
2618     {\cf17 struct }StringMaker<std::wstring_view> \{\par
2619         {\cf17 static} std::string convert(std::wstring_view str);\par
2620     \};\par
2621 {\cf21 # endif}\par
2622 \par
2623     {\cf17 template}<>\par
2624     {\cf17 struct }StringMaker<wchar_t const *> \{\par
2625         {\cf17 static} std::string convert({\cf18 wchar_t} {\cf17 const} * str);\par
2626     \};\par
2627     {\cf17 template}<>\par
2628     {\cf17 struct }StringMaker<wchar_t *> \{\par
2629         {\cf17 static} std::string convert({\cf18 wchar_t} * str);\par
2630     \};\par
2631 {\cf21 #endif }{\cf20 // CATCH_CONFIG_WCHAR}\par
2632 \par
2633     {\cf17 template}<{\cf18 size_t} SZ>\par
2634     {\cf17 struct }StringMaker<char[SZ]> \{\par
2635         {\cf17 static} std::string convert({\cf18 char} {\cf17 const}* str) \{\par
2636             {\cf19 return} Detail::convertIntoString(\par
2637                 StringRef( str, Detail::catch_strnlen( str, SZ ) ) );\par
2638         \}\par
2639     \};\par
2640     {\cf17 template}<{\cf18 size_t} SZ>\par
2641     {\cf17 struct }StringMaker<signed char[SZ]> \{\par
2642         {\cf17 static} std::string convert({\cf18 signed} {\cf18 char} {\cf17 const}* str) \{\par
2643             {\cf17 auto} reinterpreted = {\cf17 reinterpret_cast<}{\cf18 char} const*{\cf17 >}(str);\par
2644             {\cf19 return} Detail::convertIntoString(\par
2645                 StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\par
2646         \}\par
2647     \};\par
2648     {\cf17 template}<{\cf18 size_t} SZ>\par
2649     {\cf17 struct }StringMaker<unsigned char[SZ]> \{\par
2650         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 char} {\cf17 const}* str) \{\par
2651             {\cf17 auto} reinterpreted = {\cf17 reinterpret_cast<}{\cf18 char} const*{\cf17 >}(str);\par
2652             {\cf19 return} Detail::convertIntoString(\par
2653                 StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));\par
2654         \}\par
2655     \};\par
2656 \par
2657 {\cf21 #if defined(CATCH_CONFIG_CPP17_BYTE)}\par
2658     {\cf17 template}<>\par
2659     {\cf17 struct }StringMaker<std::byte> \{\par
2660         {\cf17 static} std::string convert(std::byte value);\par
2661     \};\par
2662 {\cf21 #endif }{\cf20 // defined(CATCH_CONFIG_CPP17_BYTE)}\par
2663     {\cf17 template}<>\par
2664     {\cf17 struct }StringMaker<int> \{\par
2665         {\cf17 static} std::string convert({\cf18 int} value);\par
2666     \};\par
2667     {\cf17 template}<>\par
2668     {\cf17 struct }StringMaker<long> \{\par
2669         {\cf17 static} std::string convert({\cf18 long} value);\par
2670     \};\par
2671     {\cf17 template}<>\par
2672     {\cf17 struct }StringMaker<long long> \{\par
2673         {\cf17 static} std::string convert({\cf18 long} {\cf18 long} value);\par
2674     \};\par
2675     {\cf17 template}<>\par
2676     {\cf17 struct }StringMaker<unsigned int> \{\par
2677         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 int} value);\par
2678     \};\par
2679     {\cf17 template}<>\par
2680     {\cf17 struct }StringMaker<unsigned long> \{\par
2681         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 long} value);\par
2682     \};\par
2683     {\cf17 template}<>\par
2684     {\cf17 struct }StringMaker<unsigned long long> \{\par
2685         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 long} {\cf18 long} value);\par
2686     \};\par
2687 \par
2688     {\cf17 template}<>\par
2689     {\cf17 struct }StringMaker<bool> \{\par
2690         {\cf17 static} std::string convert({\cf18 bool} b) \{\par
2691             {\cf17 using namespace }std::string_literals;\par
2692             {\cf19 return} b ? {\cf22 "true"}s : {\cf22 "false"}s;\par
2693         \}\par
2694     \};\par
2695 \par
2696     {\cf17 template}<>\par
2697     {\cf17 struct }StringMaker<char> \{\par
2698         {\cf17 static} std::string convert({\cf18 char} c);\par
2699     \};\par
2700     {\cf17 template}<>\par
2701     {\cf17 struct }StringMaker<signed char> \{\par
2702         {\cf17 static} std::string convert({\cf18 signed} {\cf18 char} value);\par
2703     \};\par
2704     {\cf17 template}<>\par
2705     {\cf17 struct }StringMaker<unsigned char> \{\par
2706         {\cf17 static} std::string convert({\cf18 unsigned} {\cf18 char} value);\par
2707     \};\par
2708 \par
2709     {\cf17 template}<>\par
2710     {\cf17 struct }StringMaker<std::nullptr_t> \{\par
2711         {\cf17 static} std::string convert(std::nullptr_t) \{\par
2712             {\cf17 using namespace }std::string_literals;\par
2713             {\cf19 return} {\cf22 "nullptr"}s;\par
2714         \}\par
2715     \};\par
2716 \par
2717     {\cf17 template}<>\par
2718     {\cf17 struct }StringMaker<float> \{\par
2719         {\cf17 static} std::string convert({\cf18 float} value);\par
2720         CATCH_EXPORT {\cf17 static} {\cf18 int} precision;\par
2721     \};\par
2722 \par
2723     {\cf17 template}<>\par
2724     {\cf17 struct }StringMaker<double> \{\par
2725         {\cf17 static} std::string convert({\cf18 double} value);\par
2726         CATCH_EXPORT {\cf17 static} {\cf18 int} precision;\par
2727     \};\par
2728 \par
2729     {\cf17 template} <{\cf17 typename} T>\par
2730     {\cf17 struct }StringMaker<T*> \{\par
2731         {\cf17 template} <{\cf17 typename} U>\par
2732         {\cf17 static} std::string convert(U* p) \{\par
2733             {\cf19 if} (p) \{\par
2734                 return ::Catch::Detail::rawMemoryToString(p);\par
2735             \} {\cf19 else} \{\par
2736                 {\cf19 return} {\cf22 "nullptr"};\par
2737             \}\par
2738         \}\par
2739     \};\par
2740 \par
2741     {\cf17 template} <{\cf17 typename} R, {\cf17 typename} C>\par
2742     {\cf17 struct }StringMaker<R C::*> \{\par
2743         {\cf17 static} std::string convert(R C::* p) \{\par
2744             {\cf19 if} (p) \{\par
2745                 return ::Catch::Detail::rawMemoryToString(p);\par
2746             \} {\cf19 else} \{\par
2747                 {\cf19 return} {\cf22 "nullptr"};\par
2748             \}\par
2749         \}\par
2750     \};\par
2751 \par
2752 {\cf21 #if defined(_MANAGED)}\par
2753     {\cf17 template} <{\cf17 typename} T>\par
2754     {\cf17 struct }StringMaker<T^> \{\par
2755         {\cf17 static} std::string convert( T^ ref ) \{\par
2756             return ::Catch::Detail::clrReferenceToString(ref);\par
2757         \}\par
2758     \};\par
2759 {\cf21 #endif}\par
2760 \par
2761     {\cf17 namespace }Detail \{\par
2762         {\cf17 template}<{\cf17 typename} InputIterator, {\cf17 typename} Sentinel = InputIterator>\par
2763         std::string rangeToString(InputIterator first, Sentinel last) \{\par
2764             ReusableStringStream rss;\par
2765             rss << {\cf22 "\{ "};\par
2766             {\cf19 if} (first != last) \{\par
2767                 rss << ::Catch::Detail::stringify(*first);\par
2768                 {\cf19 for} (++first; first != last; ++first)\par
2769                     rss << {\cf22 ", "} << ::Catch::Detail::stringify(*first);\par
2770             \}\par
2771             rss << {\cf22 " \}"};\par
2772             {\cf19 return} rss.str();\par
2773         \}\par
2774     \}\par
2775 \par
2776 \} {\cf20 // namespace Catch}\par
2777 \par
2779 {\cf20 // Separate std-lib types stringification, so it can be selectively enabled}\par
2780 {\cf20 // This means that we do not bring in their headers}\par
2781 \par
2782 {\cf21 #if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)}\par
2783 {\cf21 #  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER}\par
2784 {\cf21 #  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER}\par
2785 {\cf21 #  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER}\par
2786 {\cf21 #  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER}\par
2787 {\cf21 #endif}\par
2788 \par
2789 {\cf20 // Separate std::pair specialization}\par
2790 {\cf21 #if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)}\par
2791 {\cf21 #include <utility>}\par
2792 {\cf17 namespace }Catch \{\par
2793     {\cf17 template}<{\cf17 typename} T1, {\cf17 typename} T2>\par
2794     {\cf17 struct }StringMaker<std::pair<T1, T2> > \{\par
2795         {\cf17 static} std::string convert({\cf17 const} std::pair<T1, T2>& pair) \{\par
2796             ReusableStringStream rss;\par
2797             rss << {\cf22 "\{ "}\par
2798                 << ::Catch::Detail::stringify(pair.first)\par
2799                 << {\cf22 ", "}\par
2800                 << ::Catch::Detail::stringify(pair.second)\par
2801                 << {\cf22 " \}"};\par
2802             {\cf19 return} rss.str();\par
2803         \}\par
2804     \};\par
2805 \}\par
2806 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER}\par
2807 \par
2808 {\cf21 #if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_OPTIONAL)}\par
2809 {\cf21 #include <optional>}\par
2810 {\cf17 namespace }Catch \{\par
2811     {\cf17 template}<{\cf17 typename} T>\par
2812     {\cf17 struct }StringMaker<std::optional<T> > \{\par
2813         {\cf17 static} std::string convert({\cf17 const} std::optional<T>& optional) \{\par
2814             {\cf19 if} (optional.has_value()) \{\par
2815                 return ::Catch::Detail::stringify(*optional);\par
2816             \} {\cf19 else} \{\par
2817                 {\cf19 return} {\cf22 "\{ \}"};\par
2818             \}\par
2819         \}\par
2820     \};\par
2821     {\cf17 template} <>\par
2822     {\cf17 struct }StringMaker<std::nullopt_t> \{\par
2823         {\cf17 static} std::string convert({\cf17 const} std::nullopt_t&) \{\par
2824             {\cf19 return} {\cf22 "\{ \}"};\par
2825         \}\par
2826     \};\par
2827 \}\par
2828 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER}\par
2829 \par
2830 {\cf20 // Separate std::tuple specialization}\par
2831 {\cf21 #if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)}\par
2832 {\cf21 #include <tuple>}\par
2833 {\cf17 namespace }Catch \{\par
2834     {\cf17 namespace }Detail \{\par
2835         {\cf17 template}<\par
2836             {\cf17 typename} Tuple,\par
2837             std::size_t N = 0,\par
2838             {\cf18 bool} = (N < std::tuple_size<Tuple>::value)\par
2839             >\par
2840             {\cf17 struct} TupleElementPrinter \{\par
2841             {\cf17 static} {\cf18 void} print({\cf17 const} Tuple& tuple, std::ostream& os) \{\par
2842                 os << (N ? {\cf22 ", "} : {\cf22 " "})\par
2843                     << ::Catch::Detail::stringify(std::get<N>(tuple));\par
2844                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);\par
2845             \}\par
2846         \};\par
2847 \par
2848         {\cf17 template}<\par
2849             {\cf17 typename} Tuple,\par
2850             std::size_t N\par
2851         >\par
2852             {\cf17 struct }TupleElementPrinter<Tuple, N, false> \{\par
2853             {\cf17 static} {\cf18 void} print({\cf17 const} Tuple&, std::ostream&) \{\}\par
2854         \};\par
2855 \par
2856     \}\par
2857 \par
2858 \par
2859     {\cf17 template}<{\cf17 typename} ...Types>\par
2860     {\cf17 struct }StringMaker<std::tuple<Types...>> \{\par
2861         {\cf17 static} std::string convert({\cf17 const} std::tuple<Types...>& tuple) \{\par
2862             ReusableStringStream rss;\par
2863             rss << {\cf23 '\{'};\par
2864             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());\par
2865             rss << {\cf22 " \}"};\par
2866             {\cf19 return} rss.str();\par
2867         \}\par
2868     \};\par
2869 \}\par
2870 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER}\par
2871 \par
2872 {\cf21 #if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_VARIANT)}\par
2873 {\cf21 #include <variant>}\par
2874 {\cf17 namespace }Catch \{\par
2875     {\cf17 template}<>\par
2876     {\cf17 struct }StringMaker<std::monostate> \{\par
2877         {\cf17 static} std::string convert({\cf17 const} std::monostate&) \{\par
2878             {\cf19 return} {\cf22 "\{ \}"};\par
2879         \}\par
2880     \};\par
2881 \par
2882     {\cf17 template}<{\cf17 typename}... Elements>\par
2883     {\cf17 struct }StringMaker<std::variant<Elements...>> \{\par
2884         {\cf17 static} std::string convert({\cf17 const} std::variant<Elements...>& variant) \{\par
2885             {\cf19 if} (variant.valueless_by_exception()) \{\par
2886                 {\cf19 return} {\cf22 "\{valueless variant\}"};\par
2887             \} {\cf19 else} \{\par
2888                 {\cf19 return} std::visit(\par
2889                     []({\cf17 const} {\cf17 auto}& value) \{\par
2890                         return ::Catch::Detail::stringify(value);\par
2891                     \},\par
2892                     variant\par
2893                 );\par
2894             \}\par
2895         \}\par
2896     \};\par
2897 \}\par
2898 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER}\par
2899 \par
2900 {\cf17 namespace }Catch \{\par
2901     {\cf20 // Import begin/ end from std here}\par
2902     {\cf17 using }std::begin;\par
2903     {\cf17 using }std::end;\par
2904 \par
2905     {\cf17 namespace }Detail \{\par
2906         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
2907         {\cf17 struct }is_range_impl : std::false_type \{\};\par
2908 \par
2909         {\cf17 template} <{\cf17 typename} T>\par
2910         {\cf17 struct }is_range_impl<T, void_t<decltype(begin(std::declval<T>()))>> : std::true_type \{\};\par
2911     \} {\cf20 // namespace Detail}\par
2912 \par
2913     {\cf17 template} <{\cf17 typename} T>\par
2914     {\cf17 struct }is_range : Detail::is_range_impl<T> \{\};\par
2915 \par
2916 {\cf21 #if defined(_MANAGED) }{\cf20 // Managed types are never ranges}\par
2917     {\cf17 template} <{\cf17 typename} T>\par
2918     {\cf17 struct }is_range<T^> \{\par
2919         {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 false};\par
2920     \};\par
2921 {\cf21 #endif}\par
2922 \par
2923     {\cf17 template}<{\cf17 typename} Range>\par
2924     std::string rangeToString( Range {\cf17 const}& range ) \{\par
2925         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );\par
2926     \}\par
2927 \par
2928     {\cf20 // Handle vector<bool> specially}\par
2929     {\cf17 template}<{\cf17 typename} Allocator>\par
2930     std::string rangeToString( std::vector<bool, Allocator> {\cf17 const}& v ) \{\par
2931         ReusableStringStream rss;\par
2932         rss << {\cf22 "\{ "};\par
2933         {\cf18 bool} first = {\cf17 true};\par
2934         {\cf19 for}( {\cf18 bool} b : v ) \{\par
2935             {\cf19 if}( first )\par
2936                 first = {\cf17 false};\par
2937             {\cf19 else}\par
2938                 rss << {\cf22 ", "};\par
2939             rss << ::Catch::Detail::stringify( b );\par
2940         \}\par
2941         rss << {\cf22 " \}"};\par
2942         {\cf19 return} rss.str();\par
2943     \}\par
2944 \par
2945     {\cf17 template}<{\cf17 typename} R>\par
2946     {\cf17 struct }StringMaker<R, std::enable_if_t<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>> \{\par
2947         {\cf17 static} std::string convert( R {\cf17 const}& range ) \{\par
2948             {\cf19 return} rangeToString( range );\par
2949         \}\par
2950     \};\par
2951 \par
2952     {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} SZ>\par
2953     {\cf17 struct }StringMaker<T[SZ]> \{\par
2954         {\cf17 static} std::string convert(T {\cf17 const}(&arr)[SZ]) \{\par
2955             {\cf19 return} rangeToString(arr);\par
2956         \}\par
2957     \};\par
2958 \par
2959 \par
2960 \} {\cf20 // namespace Catch}\par
2961 \par
2962 {\cf20 // Separate std::chrono::duration specialization}\par
2963 {\cf21 #include <ctime>}\par
2964 {\cf21 #include <ratio>}\par
2965 {\cf21 #include <chrono>}\par
2966 \par
2967 \par
2968 {\cf17 namespace }Catch \{\par
2969 \par
2970 {\cf17 template} <{\cf17 class} Ratio>\par
2971 {\cf17 struct }ratio_string \{\par
2972     {\cf17 static} std::string symbol() \{\par
2973         Catch::ReusableStringStream rss;\par
2974         rss << {\cf23 '['} << Ratio::num << {\cf23 '/'}\par
2975             << Ratio::den << {\cf23 ']'};\par
2976         {\cf19 return} rss.str();\par
2977     \}\par
2978 \};\par
2979 \par
2980 {\cf17 template} <>\par
2981 {\cf17 struct }ratio_string<std::atto> \{\par
2982     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'a'}; \}\par
2983 \};\par
2984 {\cf17 template} <>\par
2985 {\cf17 struct }ratio_string<std::femto> \{\par
2986     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'f'}; \}\par
2987 \};\par
2988 {\cf17 template} <>\par
2989 {\cf17 struct }ratio_string<std::pico> \{\par
2990     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'p'}; \}\par
2991 \};\par
2992 {\cf17 template} <>\par
2993 {\cf17 struct }ratio_string<std::nano> \{\par
2994     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'n'}; \}\par
2995 \};\par
2996 {\cf17 template} <>\par
2997 {\cf17 struct }ratio_string<std::micro> \{\par
2998     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'u'}; \}\par
2999 \};\par
3000 {\cf17 template} <>\par
3001 {\cf17 struct }ratio_string<std::milli> \{\par
3002     {\cf17 static} {\cf18 char} symbol() \{ {\cf19 return} {\cf23 'm'}; \}\par
3003 \};\par
3004 \par
3006     {\cf20 // std::chrono::duration specializations}\par
3007     {\cf17 template}<{\cf17 typename} Value, {\cf17 typename} Ratio>\par
3008     {\cf17 struct }StringMaker<std::chrono::duration<Value, Ratio>> \{\par
3009         {\cf17 static} std::string convert(std::chrono::duration<Value, Ratio> {\cf17 const}& duration) \{\par
3010             ReusableStringStream rss;\par
3011             rss << duration.count() << {\cf23 ' '} << ratio_string<Ratio>::symbol() << {\cf23 's'};\par
3012             {\cf19 return} rss.str();\par
3013         \}\par
3014     \};\par
3015     {\cf17 template}<{\cf17 typename} Value>\par
3016     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<1>>> \{\par
3017         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<1>> {\cf17 const}& duration) \{\par
3018             ReusableStringStream rss;\par
3019             rss << duration.count() << {\cf22 " s"};\par
3020             {\cf19 return} rss.str();\par
3021         \}\par
3022     \};\par
3023     {\cf17 template}<{\cf17 typename} Value>\par
3024     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<60>>> \{\par
3025         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<60>> {\cf17 const}& duration) \{\par
3026             ReusableStringStream rss;\par
3027             rss << duration.count() << {\cf22 " m"};\par
3028             {\cf19 return} rss.str();\par
3029         \}\par
3030     \};\par
3031     {\cf17 template}<{\cf17 typename} Value>\par
3032     {\cf17 struct }StringMaker<std::chrono::duration<Value, std::ratio<3600>>> \{\par
3033         {\cf17 static} std::string convert(std::chrono::duration<Value, std::ratio<3600>> {\cf17 const}& duration) \{\par
3034             ReusableStringStream rss;\par
3035             rss << duration.count() << {\cf22 " h"};\par
3036             {\cf19 return} rss.str();\par
3037         \}\par
3038     \};\par
3039 \par
3041     {\cf20 // std::chrono::time_point specialization}\par
3042     {\cf20 // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>}\par
3043     {\cf17 template}<{\cf17 typename} Clock, {\cf17 typename} Duration>\par
3044     {\cf17 struct }StringMaker<std::chrono::time_point<Clock, Duration>> \{\par
3045         {\cf17 static} std::string convert(std::chrono::time_point<Clock, Duration> {\cf17 const}& time_point) \{\par
3046             return ::Catch::Detail::stringify(time_point.time_since_epoch()) + {\cf22 " since epoch"};\par
3047         \}\par
3048     \};\par
3049     {\cf20 // std::chrono::time_point<system_clock> specialization}\par
3050     {\cf17 template}<{\cf17 typename} Duration>\par
3051     {\cf17 struct }StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> \{\par
3052         {\cf17 static} std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> {\cf17 const}& time_point) \{\par
3053             {\cf17 auto} converted = std::chrono::system_clock::to_time_t(time_point);\par
3054 \par
3055 {\cf21 #ifdef _MSC_VER}\par
3056             std::tm timeInfo = \{\};\par
3057             gmtime_s(&timeInfo, &converted);\par
3058 {\cf21 #else}\par
3059             std::tm* timeInfo = std::gmtime(&converted);\par
3060 {\cf21 #endif}\par
3061 \par
3062             {\cf17 auto} {\cf17 const} timeStampSize = {\cf17 sizeof}({\cf22 "2017-01-16T17:06:45Z"});\par
3063             {\cf18 char} timeStamp[timeStampSize];\par
3064             {\cf17 const} {\cf18 char} * {\cf17 const} fmt = {\cf22 "%Y-%m-%dT%H:%M:%SZ"};\par
3065 \par
3066 {\cf21 #ifdef _MSC_VER}\par
3067             std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\par
3068 {\cf21 #else}\par
3069             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);\par
3070 {\cf21 #endif}\par
3071             {\cf19 return} std::string(timeStamp, timeStampSize - 1);\par
3072         \}\par
3073     \};\par
3074 \}\par
3075 \par
3076 \par
3077 {\cf21 #define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \\}\par
3078 {\cf21 namespace Catch \{ \\}\par
3079 {\cf21     template<> struct StringMaker<enumName> \{ \\}\par
3080 {\cf21         static std::string convert( enumName value ) \{ \\}\par
3081 {\cf21             static const auto& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, \{ __VA_ARGS__ \} ); \\}\par
3082 {\cf21             return static_cast<std::string>(enumInfo.lookup( static_cast<int>( value ) )); \\}\par
3083 {\cf21         \} \\}\par
3084 {\cf21     \}; \\}\par
3085 {\cf21 \}}\par
3086 \par
3087 {\cf21 #define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )}\par
3088 \par
3089 {\cf21 #ifdef _MSC_VER}\par
3090 {\cf21 #pragma warning(pop)}\par
3091 {\cf21 #endif}\par
3092 \par
3093 {\cf21 #endif }{\cf20 // CATCH_TOSTRING_HPP_INCLUDED}\par
3094 \par
3095 {\cf21 #include <type_traits>}\par
3096 \par
3097 {\cf17 namespace }Catch \{\par
3098 \par
3099     {\cf17 class }Approx \{\par
3100     {\cf17 private}:\par
3101         {\cf18 bool} equalityComparisonImpl({\cf18 double} other) {\cf17 const};\par
3102         {\cf20 // Sets and validates the new margin (margin >= 0)}\par
3103         {\cf18 void} setMargin({\cf18 double} margin);\par
3104         {\cf20 // Sets and validates the new epsilon (0 < epsilon < 1)}\par
3105         {\cf18 void} setEpsilon({\cf18 double} epsilon);\par
3106 \par
3107     {\cf17 public}:\par
3108         {\cf17 explicit} Approx ( {\cf18 double} value );\par
3109 \par
3110         {\cf17 static} Approx custom();\par
3111 \par
3112         Approx operator-() {\cf17 const};\par
3113 \par
3114         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3115         Approx operator()( T {\cf17 const}& value ){\cf17  const }\{\par
3116             Approx approx( {\cf17 static_cast<}{\cf18 double}{\cf17 >}(value) );\par
3117             approx.m_epsilon = m_epsilon;\par
3118             approx.m_margin = m_margin;\par
3119             approx.m_scale = m_scale;\par
3120             {\cf19 return} approx;\par
3121         \}\par
3122 \par
3123         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3124         {\cf17 explicit} Approx( T {\cf17 const}& value ): Approx(static_cast<double>(value))\par
3125         \{\}\par
3126 \par
3127 \par
3128         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3129         {\cf17 friend} {\cf18 bool} operator == ( {\cf17 const} T& lhs, Approx {\cf17 const}& rhs ) \{\par
3130             {\cf17 auto} lhs_v = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs);\par
3131             {\cf19 return} rhs.equalityComparisonImpl(lhs_v);\par
3132         \}\par
3133 \par
3134         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3135         {\cf17 friend} {\cf18 bool} operator == ( Approx {\cf17 const}& lhs, {\cf17 const} T& rhs ) \{\par
3136             {\cf19 return} operator==( rhs, lhs );\par
3137         \}\par
3138 \par
3139         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3140         {\cf17 friend} {\cf18 bool} operator != ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
3141             {\cf19 return} !operator==( lhs, rhs );\par
3142         \}\par
3143 \par
3144         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3145         {\cf17 friend} {\cf18 bool} operator != ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
3146             {\cf19 return} !operator==( rhs, lhs );\par
3147         \}\par
3148 \par
3149         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3150         {\cf17 friend} {\cf18 bool} operator <= ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
3151             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) < rhs.m_value || lhs == rhs;\par
3152         \}\par
3153 \par
3154         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3155         {\cf17 friend} {\cf18 bool} operator <= ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
3156             {\cf19 return} lhs.m_value < {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
3157         \}\par
3158 \par
3159         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3160         {\cf17 friend} {\cf18 bool} operator >= ( T {\cf17 const}& lhs, Approx {\cf17 const}& rhs ) \{\par
3161             {\cf19 return} {\cf17 static_cast<}{\cf18 double}{\cf17 >}(lhs) > rhs.m_value || lhs == rhs;\par
3162         \}\par
3163 \par
3164         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3165         {\cf17 friend} {\cf18 bool} operator >= ( Approx {\cf17 const}& lhs, T {\cf17 const}& rhs ) \{\par
3166             {\cf19 return} lhs.m_value > {\cf17 static_cast<}{\cf18 double}{\cf17 >}(rhs) || lhs == rhs;\par
3167         \}\par
3168 \par
3169         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3170         Approx& epsilon( T {\cf17 const}& newEpsilon ) \{\par
3171             {\cf17 const} {\cf17 auto} epsilonAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon);\par
3172             setEpsilon(epsilonAsDouble);\par
3173             {\cf19 return} *{\cf17 this};\par
3174         \}\par
3175 \par
3176         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3177         Approx& margin( T {\cf17 const}& newMargin ) \{\par
3178             {\cf17 const} {\cf17 auto} marginAsDouble = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newMargin);\par
3179             setMargin(marginAsDouble);\par
3180             {\cf19 return} *{\cf17 this};\par
3181         \}\par
3182 \par
3183         template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
3184         Approx& scale( T {\cf17 const}& newScale ) \{\par
3185             m_scale = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale);\par
3186             {\cf19 return} *{\cf17 this};\par
3187         \}\par
3188 \par
3189         std::string toString() {\cf17 const};\par
3190 \par
3191     {\cf17 private}:\par
3192         {\cf18 double} m_epsilon;\par
3193         {\cf18 double} m_margin;\par
3194         {\cf18 double} m_scale;\par
3195         {\cf18 double} m_value;\par
3196     \};\par
3197 \par
3198 {\cf17 namespace }literals \{\par
3199     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 long} {\cf18 double} val);\par
3200     Approx {\cf17 operator} {\cf22 ""}_a({\cf18 unsigned} {\cf18 long} {\cf18 long} val);\par
3201 \} {\cf20 // end namespace literals}\par
3202 \par
3203 {\cf17 template}<>\par
3204 {\cf17 struct }StringMaker<Catch::Approx> \{\par
3205     {\cf17 static} std::string convert(Catch::Approx {\cf17 const}& value);\par
3206 \};\par
3207 \par
3208 \} {\cf20 // end namespace Catch}\par
3209 \par
3210 {\cf21 #endif }{\cf20 // CATCH_APPROX_HPP_INCLUDED}\par
3211 \par
3212 \par
3213 {\cf21 #ifndef CATCH_ASSERTION_INFO_HPP_INCLUDED}\par
3214 {\cf21 #define CATCH_ASSERTION_INFO_HPP_INCLUDED}\par
3215 \par
3216 \par
3217 \par
3218 {\cf21 #ifndef CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}\par
3219 {\cf21 #define CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}\par
3220 \par
3221 {\cf21 #include <cstddef>}\par
3222 {\cf21 #include <iosfwd>}\par
3223 \par
3224 {\cf17 namespace }Catch \{\par
3225 \par
3226     {\cf17 struct }SourceLineInfo \{\par
3227 \par
3228         SourceLineInfo() = {\cf17 delete};\par
3229         {\cf17 constexpr} SourceLineInfo( {\cf18 char} {\cf17 const}* _file, std::size_t _line ) {\cf17 noexcept}:\par
3230             file( _file ),\par
3231             line( _line )\par
3232         \{\}\par
3233 \par
3234         {\cf18 bool} operator == ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept};\par
3235         {\cf18 bool} operator < ( SourceLineInfo {\cf17 const}& other ) {\cf17 const} {\cf17 noexcept};\par
3236 \par
3237         {\cf18 char} {\cf17 const}* file;\par
3238         std::size_t line;\par
3239 \par
3240         {\cf17 friend} std::ostream& operator << (std::ostream& os, SourceLineInfo {\cf17 const}& info);\par
3241     \};\par
3242 \}\par
3243 \par
3244 {\cf21 #define CATCH_INTERNAL_LINEINFO \\}\par
3245 {\cf21     ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )}\par
3246 \par
3247 {\cf21 #endif }{\cf20 // CATCH_SOURCE_LINE_INFO_HPP_INCLUDED}\par
3248 \par
3249 {\cf17 namespace }Catch \{\par
3250 \par
3251     {\cf17 struct }AssertionInfo \{\par
3252         {\cf20 // AssertionInfo() = delete;}\par
3253 \par
3254         StringRef macroName;\par
3255         SourceLineInfo lineInfo;\par
3256         StringRef capturedExpression;\par
3257         ResultDisposition::Flags resultDisposition;\par
3258     \};\par
3259 \par
3260 \} {\cf20 // end namespace Catch}\par
3261 \par
3262 {\cf21 #endif }{\cf20 // CATCH_ASSERTION_INFO_HPP_INCLUDED}\par
3263 \par
3264 \par
3265 {\cf21 #ifndef CATCH_ASSERTION_RESULT_HPP_INCLUDED}\par
3266 {\cf21 #define CATCH_ASSERTION_RESULT_HPP_INCLUDED}\par
3267 \par
3268 \par
3269 \par
3270 {\cf21 #ifndef CATCH_LAZY_EXPR_HPP_INCLUDED}\par
3271 {\cf21 #define CATCH_LAZY_EXPR_HPP_INCLUDED}\par
3272 \par
3273 {\cf21 #include <iosfwd>}\par
3274 \par
3275 {\cf17 namespace }Catch \{\par
3276 \par
3277     {\cf17 class }ITransientExpression;\par
3278 \par
3279     {\cf17 class }LazyExpression \{\par
3280         {\cf17 friend} {\cf17 class }AssertionHandler;\par
3281         {\cf17 friend} {\cf17 struct }AssertionStats;\par
3282         {\cf17 friend} {\cf17 class }RunContext;\par
3283 \par
3284         ITransientExpression {\cf17 const}* m_transientExpression = {\cf17 nullptr};\par
3285         {\cf18 bool} m_isNegated;\par
3286     {\cf17 public}:\par
3287         LazyExpression( {\cf18 bool} isNegated ):\par
3288             m_isNegated(isNegated)\par
3289         \{\}\par
3290         LazyExpression(LazyExpression {\cf17 const}& other) = {\cf19 default};\par
3291         LazyExpression& operator = ( LazyExpression {\cf17 const}& ) = {\cf17 delete};\par
3292 \par
3293         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
3294             {\cf19 return} m_transientExpression != {\cf17 nullptr};\par
3295         \}\par
3296 \par
3297         {\cf17 friend} {\cf17 auto} operator << ( std::ostream& os, LazyExpression {\cf17 const}& lazyExpr ) -> std::ostream&;\par
3298     \};\par
3299 \par
3300 \} {\cf20 // namespace Catch}\par
3301 \par
3302 {\cf21 #endif }{\cf20 // CATCH_LAZY_EXPR_HPP_INCLUDED}\par
3303 \par
3304 {\cf21 #include <string>}\par
3305 \par
3306 {\cf17 namespace }Catch \{\par
3307 \par
3308     {\cf17 struct }AssertionResultData\par
3309     \{\par
3310         AssertionResultData() = {\cf17 delete};\par
3311 \par
3312         AssertionResultData( ResultWas::OfType _resultType, LazyExpression {\cf17 const}& _lazyExpression );\par
3313 \par
3314         std::string message;\par
3315         {\cf17 mutable} std::string reconstructedExpression;\par
3316         LazyExpression lazyExpression;\par
3317         ResultWas::OfType resultType;\par
3318 \par
3319         std::string reconstructExpression() {\cf17 const};\par
3320     \};\par
3321 \par
3322     {\cf17 class }AssertionResult \{\par
3323     {\cf17 public}:\par
3324         AssertionResult() = {\cf17 delete};\par
3325         AssertionResult( AssertionInfo {\cf17 const}& info, AssertionResultData&& data );\par
3326 \par
3327         {\cf18 bool} isOk() {\cf17 const};\par
3328         {\cf18 bool} succeeded() {\cf17 const};\par
3329         ResultWas::OfType getResultType() {\cf17 const};\par
3330         {\cf18 bool} hasExpression() {\cf17 const};\par
3331         {\cf18 bool} hasMessage() {\cf17 const};\par
3332         std::string getExpression() {\cf17 const};\par
3333         std::string getExpressionInMacro() {\cf17 const};\par
3334         {\cf18 bool} hasExpandedExpression() {\cf17 const};\par
3335         std::string getExpandedExpression() {\cf17 const};\par
3336         StringRef getMessage() {\cf17 const};\par
3337         SourceLineInfo getSourceInfo() {\cf17 const};\par
3338         StringRef getTestMacroName() {\cf17 const};\par
3339 \par
3340     {\cf20 //protected:}\par
3341         AssertionInfo m_info;\par
3342         AssertionResultData m_resultData;\par
3343     \};\par
3344 \par
3345 \} {\cf20 // end namespace Catch}\par
3346 \par
3347 {\cf21 #endif }{\cf20 // CATCH_ASSERTION_RESULT_HPP_INCLUDED}\par
3348 \par
3349 \par
3350 {\cf21 #ifndef CATCH_CONFIG_HPP_INCLUDED}\par
3351 {\cf21 #define CATCH_CONFIG_HPP_INCLUDED}\par
3352 \par
3353 \par
3354 \par
3355 {\cf21 #ifndef CATCH_TEST_SPEC_HPP_INCLUDED}\par
3356 {\cf21 #define CATCH_TEST_SPEC_HPP_INCLUDED}\par
3357 \par
3358 {\cf21 #ifdef __clang__}\par
3359 {\cf21 #pragma clang diagnostic push}\par
3360 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
3361 {\cf21 #endif}\par
3362 \par
3363 \par
3364 \par
3365 {\cf21 #ifndef CATCH_WILDCARD_PATTERN_HPP_INCLUDED}\par
3366 {\cf21 #define CATCH_WILDCARD_PATTERN_HPP_INCLUDED}\par
3367 \par
3368 \par
3369 \par
3370 {\cf21 #ifndef CATCH_CASE_SENSITIVE_HPP_INCLUDED}\par
3371 {\cf21 #define CATCH_CASE_SENSITIVE_HPP_INCLUDED}\par
3372 \par
3373 {\cf17 namespace }Catch \{\par
3374 \par
3375     {\cf17 enum class} CaseSensitive \{ Yes, No \};\par
3376 \par
3377 \} {\cf20 // namespace Catch}\par
3378 \par
3379 {\cf21 #endif }{\cf20 // CATCH_CASE_SENSITIVE_HPP_INCLUDED}\par
3380 \par
3381 {\cf21 #include <string>}\par
3382 \par
3383 {\cf17 namespace }Catch\par
3384 \{\par
3385     {\cf17 class }WildcardPattern \{\par
3386         {\cf17 enum} WildcardPosition \{\par
3387             NoWildcard = 0,\par
3388             WildcardAtStart = 1,\par
3389             WildcardAtEnd = 2,\par
3390             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd\par
3391         \};\par
3392 \par
3393     {\cf17 public}:\par
3394 \par
3395         WildcardPattern( std::string {\cf17 const}& pattern, CaseSensitive caseSensitivity );\par
3396         {\cf18 bool} matches( std::string {\cf17 const}& str ) {\cf17 const};\par
3397 \par
3398     {\cf17 private}:\par
3399         std::string normaliseString( std::string {\cf17 const}& str ) {\cf17 const};\par
3400         CaseSensitive m_caseSensitivity;\par
3401         WildcardPosition m_wildcard = NoWildcard;\par
3402         std::string m_pattern;\par
3403     \};\par
3404 \}\par
3405 \par
3406 {\cf21 #endif }{\cf20 // CATCH_WILDCARD_PATTERN_HPP_INCLUDED}\par
3407 \par
3408 {\cf21 #include <iosfwd>}\par
3409 {\cf21 #include <string>}\par
3410 {\cf21 #include <vector>}\par
3411 \par
3412 {\cf17 namespace }Catch \{\par
3413 \par
3414     {\cf17 class }IConfig;\par
3415     {\cf17 struct }TestCaseInfo;\par
3416     {\cf17 class }TestCaseHandle;\par
3417 \par
3418     {\cf17 class }TestSpec \{\par
3419 \par
3420         {\cf17 class }Pattern \{\par
3421         {\cf17 public}:\par
3422             {\cf17 explicit} Pattern( std::string {\cf17 const}& name );\par
3423             {\cf17 virtual} ~Pattern();\par
3424             {\cf17 virtual} {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const} = 0;\par
3425             std::string {\cf17 const}& name() {\cf17 const};\par
3426         {\cf17 private}:\par
3427             {\cf17 virtual} {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const} = 0;\par
3428             {\cf20 // Writes string that would be reparsed into the pattern}\par
3429             {\cf17 friend} std::ostream& operator<<(std::ostream& out,\par
3430                                             Pattern {\cf17 const}& pattern) \{\par
3431                 pattern.serializeTo( out );\par
3432                 {\cf19 return} out;\par
3433             \}\par
3434 \par
3435             std::string {\cf17 const} m_name;\par
3436         \};\par
3437 \par
3438         {\cf17 class }NamePattern : {\cf17 public} Pattern \{\par
3439         {\cf17 public}:\par
3440             {\cf17 explicit} NamePattern( std::string {\cf17 const}& name, std::string {\cf17 const}& filterString );\par
3441             {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const override};\par
3442         {\cf17 private}:\par
3443             {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const override};\par
3444 \par
3445             WildcardPattern m_wildcardPattern;\par
3446         \};\par
3447 \par
3448         {\cf17 class }TagPattern : {\cf17 public} Pattern \{\par
3449         {\cf17 public}:\par
3450             {\cf17 explicit} TagPattern( std::string {\cf17 const}& tag, std::string {\cf17 const}& filterString );\par
3451             {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const override};\par
3452         {\cf17 private}:\par
3453             {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const override};\par
3454 \par
3455             std::string m_tag;\par
3456         \};\par
3457 \par
3458         {\cf17 struct }Filter \{\par
3459             std::vector<Detail::unique_ptr<Pattern>> m_required;\par
3460             std::vector<Detail::unique_ptr<Pattern>> m_forbidden;\par
3461 \par
3464             {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const};\par
3465             {\cf17 friend} std::ostream& operator<<(std::ostream& out, Filter {\cf17 const}& f) \{\par
3466                 f.serializeTo( out );\par
3467                 {\cf19 return} out;\par
3468             \}\par
3469 \par
3470             {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const};\par
3471         \};\par
3472 \par
3473         {\cf17 static} std::string extractFilterName( Filter {\cf17 const}& filter );\par
3474 \par
3475     {\cf17 public}:\par
3476         {\cf17 struct }FilterMatch \{\par
3477             std::string name;\par
3478             std::vector<TestCaseHandle const*> tests;\par
3479         \};\par
3480         {\cf17 using }Matches = std::vector<FilterMatch>;\par
3481         {\cf17 using }vectorStrings = std::vector<std::string>;\par
3482 \par
3483         {\cf18 bool} hasFilters() {\cf17 const};\par
3484         {\cf18 bool} matches( TestCaseInfo {\cf17 const}& testCase ) {\cf17 const};\par
3485         Matches matchesByFilter( std::vector<TestCaseHandle> {\cf17 const}& testCases, IConfig {\cf17 const}& config ) {\cf17 const};\par
3486         {\cf17 const} vectorStrings & getInvalidSpecs() {\cf17 const};\par
3487 \par
3488     {\cf17 private}:\par
3489         std::vector<Filter> m_filters;\par
3490         std::vector<std::string> m_invalidSpecs;\par
3491 \par
3492         {\cf17 friend} {\cf17 class }TestSpecParser;\par
3495         {\cf18 void} serializeTo( std::ostream& out ) {\cf17 const};\par
3496         {\cf17 friend} std::ostream& operator<<(std::ostream& out,\par
3497                                         TestSpec {\cf17 const}& spec) \{\par
3498             spec.serializeTo( out );\par
3499             {\cf19 return} out;\par
3500         \}\par
3501     \};\par
3502 \}\par
3503 \par
3504 {\cf21 #ifdef __clang__}\par
3505 {\cf21 #pragma clang diagnostic pop}\par
3506 {\cf21 #endif}\par
3507 \par
3508 {\cf21 #endif }{\cf20 // CATCH_TEST_SPEC_HPP_INCLUDED}\par
3509 \par
3510 \par
3511 {\cf21 #ifndef CATCH_OPTIONAL_HPP_INCLUDED}\par
3512 {\cf21 #define CATCH_OPTIONAL_HPP_INCLUDED}\par
3513 \par
3514 \par
3515 {\cf21 #include <cassert>}\par
3516 \par
3517 {\cf17 namespace }Catch \{\par
3518 \par
3519     {\cf20 // An optional type}\par
3520     {\cf17 template}<{\cf17 typename} T>\par
3521     {\cf17 class }Optional \{\par
3522     {\cf17 public}:\par
3523         Optional(): nullableValue( nullptr ) \{\}\par
3524         ~Optional() \{ reset(); \}\par
3525 \par
3526         Optional( T {\cf17 const}& _value ):\par
3527             nullableValue( new ( storage ) T( _value ) ) \{\}\par
3528         Optional( T&& _value ):\par
3529             nullableValue( new ( storage ) T( CATCH_MOVE( _value ) ) ) \{\}\par
3530 \par
3531         Optional& operator=( T {\cf17 const}& _value ) \{\par
3532             reset();\par
3533             nullableValue = {\cf17 new} ( storage ) T( _value );\par
3534             {\cf19 return} *{\cf17 this};\par
3535         \}\par
3536         Optional& operator=( T&& _value ) \{\par
3537             reset();\par
3538             nullableValue = {\cf17 new} ( storage ) T( CATCH_MOVE( _value ) );\par
3539             {\cf19 return} *{\cf17 this};\par
3540         \}\par
3541 \par
3542         Optional( Optional {\cf17 const}& _other ):\par
3543             nullableValue( _other ? new ( storage ) T( *_other ) : nullptr ) \{\}\par
3544         Optional( Optional&& _other ):\par
3545             nullableValue( _other ? new ( storage ) T( CATCH_MOVE( *_other ) )\par
3546                                   : nullptr ) \{\}\par
3547 \par
3548         Optional& operator=( Optional {\cf17 const}& _other ) \{\par
3549             {\cf19 if} ( &_other != {\cf17 this} ) \{\par
3550                 reset();\par
3551                 {\cf19 if} ( _other ) \{ nullableValue = {\cf17 new} ( storage ) T( *_other ); \}\par
3552             \}\par
3553             {\cf19 return} *{\cf17 this};\par
3554         \}\par
3555         Optional& operator=( Optional&& _other ) \{\par
3556             {\cf19 if} ( &_other != {\cf17 this} ) \{\par
3557                 reset();\par
3558                 {\cf19 if} ( _other ) \{\par
3559                     nullableValue = {\cf17 new} ( storage ) T( CATCH_MOVE( *_other ) );\par
3560                 \}\par
3561             \}\par
3562             {\cf19 return} *{\cf17 this};\par
3563         \}\par
3564 \par
3565         {\cf18 void} reset() \{\par
3566             {\cf19 if} ( nullableValue ) \{ nullableValue->~T(); \}\par
3567             nullableValue = {\cf17 nullptr};\par
3568         \}\par
3569 \par
3570         T& operator*() \{\par
3571             assert(nullableValue);\par
3572             {\cf19 return} *nullableValue;\par
3573         \}\par
3574         T {\cf17 const}& operator*(){\cf17  const }\{\par
3575             assert(nullableValue);\par
3576             {\cf19 return} *nullableValue;\par
3577         \}\par
3578         T* operator->() \{\par
3579             assert(nullableValue);\par
3580             {\cf19 return} nullableValue;\par
3581         \}\par
3582         {\cf17 const} T* operator->(){\cf17  const }\{\par
3583             assert(nullableValue);\par
3584             {\cf19 return} nullableValue;\par
3585         \}\par
3586 \par
3587         T valueOr( T {\cf17 const}& defaultValue ){\cf17  const }\{\par
3588             {\cf19 return} nullableValue ? *nullableValue : defaultValue;\par
3589         \}\par
3590 \par
3591         {\cf18 bool} some(){\cf17  const }\{ {\cf19 return} nullableValue != {\cf17 nullptr}; \}\par
3592         {\cf18 bool} none(){\cf17  const }\{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
3593 \par
3594         {\cf18 bool} operator !(){\cf17  const }\{ {\cf19 return} nullableValue == {\cf17 nullptr}; \}\par
3595         {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
3596             {\cf19 return} some();\par
3597         \}\par
3598 \par
3599         {\cf17 friend} {\cf18 bool} operator==(Optional {\cf17 const}& a, Optional {\cf17 const}& b) \{\par
3600             {\cf19 if} (a.none() && b.none()) \{\par
3601                 {\cf19 return} {\cf17 true};\par
3602             \} {\cf19 else} {\cf19 if} (a.some() && b.some()) \{\par
3603                 {\cf19 return} *a == *b;\par
3604             \} {\cf19 else} \{\par
3605                 {\cf19 return} {\cf17 false};\par
3606             \}\par
3607         \}\par
3608         {\cf17 friend} {\cf18 bool} operator!=(Optional {\cf17 const}& a, Optional {\cf17 const}& b) \{\par
3609             {\cf19 return} !( a == b );\par
3610         \}\par
3611 \par
3612     {\cf17 private}:\par
3613         T* nullableValue;\par
3614         {\cf17 alignas}({\cf17 alignof}(T)) {\cf18 char} storage[{\cf17 sizeof}(T)];\par
3615     \};\par
3616 \par
3617 \} {\cf20 // end namespace Catch}\par
3618 \par
3619 {\cf21 #endif }{\cf20 // CATCH_OPTIONAL_HPP_INCLUDED}\par
3620 \par
3621 \par
3622 {\cf21 #ifndef CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}\par
3623 {\cf21 #define CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}\par
3624 \par
3625 {\cf21 #include <cstdint>}\par
3626 \par
3627 {\cf17 namespace }Catch \{\par
3628 \par
3629     {\cf17 enum class} GenerateFrom \{\par
3630         Time,\par
3631         RandomDevice,\par
3633         Default\par
3634     \};\par
3635 \par
3636     std::uint32_t generateRandomSeed(GenerateFrom from);\par
3637 \par
3638 \} {\cf20 // end namespace Catch}\par
3639 \par
3640 {\cf21 #endif }{\cf20 // CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED}\par
3641 \par
3642 \par
3643 {\cf21 #ifndef CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}\par
3644 {\cf21 #define CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}\par
3645 \par
3646 \par
3647 {\cf21 #include <map>}\par
3648 {\cf21 #include <string>}\par
3649 {\cf21 #include <vector>}\par
3650 \par
3651 {\cf17 namespace }Catch \{\par
3652 \par
3653     {\cf17 enum class} ColourMode : std::uint8_t;\par
3654 \par
3655     {\cf17 namespace }Detail \{\par
3657         std::vector<std::string> splitReporterSpec( StringRef reporterSpec );\par
3658 \par
3659         Optional<ColourMode> stringToColourMode( StringRef colourMode );\par
3660     \}\par
3661 \par
3670     {\cf17 class }ReporterSpec \{\par
3671         std::string m_name;\par
3672         Optional<std::string> m_outputFileName;\par
3673         Optional<ColourMode> m_colourMode;\par
3674         std::map<std::string, std::string> m_customOptions;\par
3675 \par
3676         {\cf17 friend} {\cf18 bool} operator==( ReporterSpec {\cf17 const}& lhs,\par
3677                                 ReporterSpec {\cf17 const}& rhs );\par
3678         {\cf17 friend} {\cf18 bool} operator!=( ReporterSpec {\cf17 const}& lhs,\par
3679                                 ReporterSpec {\cf17 const}& rhs ) \{\par
3680             {\cf19 return} !( lhs == rhs );\par
3681         \}\par
3682 \par
3683     {\cf17 public}:\par
3684         ReporterSpec(\par
3685             std::string name,\par
3686             Optional<std::string> outputFileName,\par
3687             Optional<ColourMode> colourMode,\par
3688             std::map<std::string, std::string> customOptions );\par
3689 \par
3690         std::string {\cf17 const}& name(){\cf17  const }\{ {\cf19 return} m_name; \}\par
3691 \par
3692         Optional<std::string> {\cf17 const}& outputFile(){\cf17  const }\{\par
3693             {\cf19 return} m_outputFileName;\par
3694         \}\par
3695 \par
3696         Optional<ColourMode> {\cf17 const}& colourMode(){\cf17  const }\{ {\cf19 return} m_colourMode; \}\par
3697 \par
3698         std::map<std::string, std::string> {\cf17 const}& customOptions(){\cf17  const }\{\par
3699             {\cf19 return} m_customOptions;\par
3700         \}\par
3701     \};\par
3702 \par
3713     Optional<ReporterSpec> parseReporterSpec( StringRef reporterSpec );\par
3714 \par
3715 \}\par
3716 \par
3717 {\cf21 #endif }{\cf20 // CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED}\par
3718 \par
3719 {\cf21 #include <chrono>}\par
3720 {\cf21 #include <map>}\par
3721 {\cf21 #include <string>}\par
3722 {\cf21 #include <vector>}\par
3723 \par
3724 {\cf17 namespace }Catch \{\par
3725 \par
3726     {\cf17 class }IStream;\par
3727 \par
3733     {\cf17 struct }ProcessedReporterSpec \{\par
3734         std::string name;\par
3735         std::string outputFilename;\par
3736         ColourMode colourMode;\par
3737         std::map<std::string, std::string> customOptions;\par
3738         {\cf17 friend} {\cf18 bool} operator==( ProcessedReporterSpec {\cf17 const}& lhs,\par
3739                                 ProcessedReporterSpec {\cf17 const}& rhs );\par
3740         {\cf17 friend} {\cf18 bool} operator!=( ProcessedReporterSpec {\cf17 const}& lhs,\par
3741                                 ProcessedReporterSpec {\cf17 const}& rhs ) \{\par
3742             {\cf19 return} !( lhs == rhs );\par
3743         \}\par
3744     \};\par
3745 \par
3746     {\cf17 struct }ConfigData \{\par
3747 \par
3748         {\cf18 bool} listTests = {\cf17 false};\par
3749         {\cf18 bool} listTags = {\cf17 false};\par
3750         {\cf18 bool} listReporters = {\cf17 false};\par
3751         {\cf18 bool} listListeners = {\cf17 false};\par
3752 \par
3753         {\cf18 bool} showSuccessfulTests = {\cf17 false};\par
3754         {\cf18 bool} shouldDebugBreak = {\cf17 false};\par
3755         {\cf18 bool} noThrow = {\cf17 false};\par
3756         {\cf18 bool} showHelp = {\cf17 false};\par
3757         {\cf18 bool} showInvisibles = {\cf17 false};\par
3758         {\cf18 bool} filenamesAsTags = {\cf17 false};\par
3759         {\cf18 bool} libIdentify = {\cf17 false};\par
3760         {\cf18 bool} allowZeroTests = {\cf17 false};\par
3761 \par
3762         {\cf18 int} abortAfter = -1;\par
3763         uint32_t rngSeed = generateRandomSeed(GenerateFrom::Default);\par
3764 \par
3765         {\cf18 unsigned} {\cf18 int} shardCount = 1;\par
3766         {\cf18 unsigned} {\cf18 int} shardIndex = 0;\par
3767 \par
3768         {\cf18 bool} skipBenchmarks = {\cf17 false};\par
3769         {\cf18 bool} benchmarkNoAnalysis = {\cf17 false};\par
3770         {\cf18 unsigned} {\cf18 int} benchmarkSamples = 100;\par
3771         {\cf18 double} benchmarkConfidenceInterval = 0.95;\par
3772         {\cf18 unsigned} {\cf18 int} benchmarkResamples = 100'000;\par
3773         std::chrono::milliseconds::rep benchmarkWarmupTime = 100;\par
3774 \par
3775         Verbosity verbosity = Verbosity::Normal;\par
3776         WarnAbout::What warnings = WarnAbout::Nothing;\par
3777         ShowDurations showDurations = ShowDurations::DefaultForReporter;\par
3778         {\cf18 double} minDuration = -1;\par
3779         TestRunOrder runOrder = TestRunOrder::Declared;\par
3780         ColourMode defaultColourMode = ColourMode::PlatformDefault;\par
3781         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;\par
3782 \par
3783         std::string defaultOutputFilename;\par
3784         std::string name;\par
3785         std::string processName;\par
3786         std::vector<ReporterSpec> reporterSpecifications;\par
3787 \par
3788         std::vector<std::string> testsOrTags;\par
3789         std::vector<std::string> sectionsToRun;\par
3790     \};\par
3791 \par
3792 \par
3793     {\cf17 class }Config : {\cf17 public} IConfig \{\par
3794     {\cf17 public}:\par
3795 \par
3796         Config() = {\cf19 default};\par
3797         Config( ConfigData {\cf17 const}& data );\par
3798         ~Config() {\cf17 override}; {\cf20 // = default in the cpp file}\par
3799 \par
3800         {\cf18 bool} listTests() {\cf17 const};\par
3801         {\cf18 bool} listTags() {\cf17 const};\par
3802         {\cf18 bool} listReporters() {\cf17 const};\par
3803         {\cf18 bool} listListeners() {\cf17 const};\par
3804 \par
3805         std::vector<ReporterSpec> {\cf17 const}& getReporterSpecs() {\cf17 const};\par
3806         std::vector<ProcessedReporterSpec> {\cf17 const}&\par
3807         getProcessedReporterSpecs() {\cf17 const};\par
3808 \par
3809         std::vector<std::string> {\cf17 const}& getTestsOrTags() {\cf17 const override};\par
3810         std::vector<std::string> {\cf17 const}& getSectionsToRun() {\cf17 const override};\par
3811 \par
3812         TestSpec {\cf17 const}& testSpec() {\cf17 const override};\par
3813         {\cf18 bool} hasTestFilters() {\cf17 const override};\par
3814 \par
3815         {\cf18 bool} showHelp() {\cf17 const};\par
3816 \par
3817         {\cf20 // IConfig interface}\par
3818         {\cf18 bool} allowThrows() {\cf17 const override};\par
3819         StringRef name() {\cf17 const override};\par
3820         {\cf18 bool} includeSuccessfulResults() {\cf17 const override};\par
3821         {\cf18 bool} warnAboutMissingAssertions() {\cf17 const override};\par
3822         {\cf18 bool} warnAboutUnmatchedTestSpecs() {\cf17 const override};\par
3823         {\cf18 bool} zeroTestsCountAsSuccess() {\cf17 const override};\par
3824         ShowDurations showDurations() {\cf17 const override};\par
3825         {\cf18 double} minDuration() {\cf17 const override};\par
3826         TestRunOrder runOrder() {\cf17 const override};\par
3827         uint32_t rngSeed() {\cf17 const override};\par
3828         {\cf18 unsigned} {\cf18 int} shardCount() {\cf17 const override};\par
3829         {\cf18 unsigned} {\cf18 int} shardIndex() {\cf17 const override};\par
3830         ColourMode defaultColourMode() {\cf17 const override};\par
3831         {\cf18 bool} shouldDebugBreak() {\cf17 const override};\par
3832         {\cf18 int} abortAfter() {\cf17 const override};\par
3833         {\cf18 bool} showInvisibles() {\cf17 const override};\par
3834         Verbosity verbosity() {\cf17 const override};\par
3835         {\cf18 bool} skipBenchmarks() {\cf17 const override};\par
3836         {\cf18 bool} benchmarkNoAnalysis() {\cf17 const override};\par
3837         {\cf18 unsigned} {\cf18 int} benchmarkSamples() {\cf17 const override};\par
3838         {\cf18 double} benchmarkConfidenceInterval() {\cf17 const override};\par
3839         {\cf18 unsigned} {\cf18 int} benchmarkResamples() {\cf17 const override};\par
3840         std::chrono::milliseconds benchmarkWarmupTime() {\cf17 const override};\par
3841 \par
3842     {\cf17 private}:\par
3843         {\cf20 // Reads Bazel env vars and applies them to the config}\par
3844         {\cf18 void} readBazelEnvVars();\par
3845 \par
3846         ConfigData m_data;\par
3847         std::vector<ProcessedReporterSpec> m_processedReporterSpecs;\par
3848         TestSpec m_testSpec;\par
3849         {\cf18 bool} m_hasTestFilters = {\cf17 false};\par
3850     \};\par
3851 \} {\cf20 // end namespace Catch}\par
3852 \par
3853 {\cf21 #endif }{\cf20 // CATCH_CONFIG_HPP_INCLUDED}\par
3854 \par
3855 \par
3856 {\cf21 #ifndef CATCH_GET_RANDOM_SEED_HPP_INCLUDED}\par
3857 {\cf21 #define CATCH_GET_RANDOM_SEED_HPP_INCLUDED}\par
3858 \par
3859 {\cf21 #include <cstdint>}\par
3860 \par
3861 {\cf17 namespace }Catch \{\par
3863     std::uint32_t getSeed();\par
3864 \}\par
3865 \par
3866 {\cf21 #endif }{\cf20 // CATCH_GET_RANDOM_SEED_HPP_INCLUDED}\par
3867 \par
3868 \par
3869 {\cf21 #ifndef CATCH_MESSAGE_HPP_INCLUDED}\par
3870 {\cf21 #define CATCH_MESSAGE_HPP_INCLUDED}\par
3871 \par
3872 \par
3873 \par
3874 \par
3886 {\cf21 #ifndef CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}\par
3887 {\cf21 #define CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}\par
3888 \par
3889 \par
3890 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_PREFIX_MESSAGES)}\par
3891 {\cf21     #define CATCH_CONFIG_PREFIX_MESSAGES}\par
3892 {\cf21 #endif}\par
3893 \par
3894 {\cf21 #endif }{\cf20 // CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED}\par
3895 \par
3896 \par
3897 {\cf21 #ifndef CATCH_STREAM_END_STOP_HPP_INCLUDED}\par
3898 {\cf21 #define CATCH_STREAM_END_STOP_HPP_INCLUDED}\par
3899 \par
3900 \par
3901 {\cf17 namespace }Catch \{\par
3902 \par
3903     {\cf20 // Use this in variadic streaming macros to allow}\par
3904     {\cf20 //    << +StreamEndStop}\par
3905     {\cf20 // as well as}\par
3906     {\cf20 //    << stuff +StreamEndStop}\par
3907     {\cf17 struct }StreamEndStop \{\par
3908         {\cf17 constexpr} StringRef operator+(){\cf17  const }\{ {\cf19 return} StringRef(); \}\par
3909 \par
3910         {\cf17 template} <{\cf17 typename} T>\par
3911         {\cf17 constexpr} {\cf17 friend} T {\cf17 const}& operator+( T {\cf17 const}& value, StreamEndStop ) \{\par
3912             {\cf19 return} value;\par
3913         \}\par
3914     \};\par
3915 \par
3916 \} {\cf20 // namespace Catch}\par
3917 \par
3918 {\cf21 #endif }{\cf20 // CATCH_STREAM_END_STOP_HPP_INCLUDED}\par
3919 \par
3920 \par
3921 {\cf21 #ifndef CATCH_MESSAGE_INFO_HPP_INCLUDED}\par
3922 {\cf21 #define CATCH_MESSAGE_INFO_HPP_INCLUDED}\par
3923 \par
3924 \par
3925 {\cf21 #include <string>}\par
3926 \par
3927 {\cf17 namespace }Catch \{\par
3928 \par
3929     {\cf17 struct }MessageInfo \{\par
3930         MessageInfo(    StringRef _macroName,\par
3931                         SourceLineInfo {\cf17 const}& _lineInfo,\par
3932                         ResultWas::OfType _type );\par
3933 \par
3934         StringRef macroName;\par
3935         std::string message;\par
3936         SourceLineInfo lineInfo;\par
3937         ResultWas::OfType type;\par
3938         {\cf18 unsigned} {\cf18 int} sequence;\par
3939 \par
3940         {\cf18 bool} operator == (MessageInfo {\cf17 const}& other){\cf17  const }\{\par
3941             {\cf19 return} sequence == other.sequence;\par
3942         \}\par
3943         {\cf18 bool} operator < (MessageInfo {\cf17 const}& other){\cf17  const }\{\par
3944             {\cf19 return} sequence < other.sequence;\par
3945         \}\par
3946     {\cf17 private}:\par
3947         {\cf17 static} {\cf18 unsigned} {\cf18 int} globalCount;\par
3948     \};\par
3949 \par
3950 \} {\cf20 // end namespace Catch}\par
3951 \par
3952 {\cf21 #endif }{\cf20 // CATCH_MESSAGE_INFO_HPP_INCLUDED}\par
3953 \par
3954 {\cf21 #include <string>}\par
3955 {\cf21 #include <vector>}\par
3956 \par
3957 {\cf17 namespace }Catch \{\par
3958 \par
3959     {\cf17 struct }SourceLineInfo;\par
3960     {\cf17 class }IResultCapture;\par
3961 \par
3962     {\cf17 struct }MessageStream \{\par
3963 \par
3964         {\cf17 template}<{\cf17 typename} T>\par
3965         MessageStream& operator << ( T {\cf17 const}& value ) \{\par
3966             m_stream << value;\par
3967             {\cf19 return} *{\cf17 this};\par
3968         \}\par
3969 \par
3970         ReusableStringStream m_stream;\par
3971     \};\par
3972 \par
3973     {\cf17 struct }MessageBuilder : MessageStream \{\par
3974         MessageBuilder( StringRef macroName,\par
3975                         SourceLineInfo {\cf17 const}& lineInfo,\par
3976                         ResultWas::OfType type ):\par
3977             m_info(macroName, lineInfo, type) \{\}\par
3978 \par
3979         {\cf17 template}<{\cf17 typename} T>\par
3980         MessageBuilder&& operator << ( T {\cf17 const}& value ) && \{\par
3981             m_stream << value;\par
3982             {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
3983         \}\par
3984 \par
3985         MessageInfo m_info;\par
3986     \};\par
3987 \par
3988     {\cf17 class }ScopedMessage \{\par
3989     {\cf17 public}:\par
3990         {\cf17 explicit} ScopedMessage( MessageBuilder&& builder );\par
3991         ScopedMessage( ScopedMessage& duplicate ) = {\cf17 delete};\par
3992         ScopedMessage( ScopedMessage&& old ) {\cf17 noexcept};\par
3993         ~ScopedMessage();\par
3994 \par
3995         MessageInfo m_info;\par
3996         {\cf18 bool} m_moved = {\cf17 false};\par
3997     \};\par
3998 \par
3999     {\cf17 class }Capturer \{\par
4000         std::vector<MessageInfo> m_messages;\par
4001         IResultCapture& m_resultCapture;\par
4002         {\cf18 size_t} m_captured = 0;\par
4003     {\cf17 public}:\par
4004         Capturer( StringRef macroName, SourceLineInfo {\cf17 const}& lineInfo, ResultWas::OfType resultType, StringRef names );\par
4005 \par
4006         Capturer(Capturer {\cf17 const}&) = {\cf17 delete};\par
4007         Capturer& operator=(Capturer {\cf17 const}&) = {\cf17 delete};\par
4008 \par
4009         ~Capturer();\par
4010 \par
4011         {\cf18 void} captureValue( {\cf18 size_t} index, std::string {\cf17 const}& value );\par
4012 \par
4013         {\cf17 template}<{\cf17 typename} T>\par
4014         {\cf18 void} captureValues( {\cf18 size_t} index, T {\cf17 const}& value ) \{\par
4015             captureValue( index, Catch::Detail::stringify( value ) );\par
4016         \}\par
4017 \par
4018         {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Ts>\par
4019         {\cf18 void} captureValues( {\cf18 size_t} index, T {\cf17 const}& value, Ts {\cf17 const}&... values ) \{\par
4020             captureValue( index, Catch::Detail::stringify(value) );\par
4021             captureValues( index+1, values... );\par
4022         \}\par
4023     \};\par
4024 \par
4025 \} {\cf20 // end namespace Catch}\par
4026 \par
4028 {\cf21 #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \\}\par
4029 {\cf21     do \{ \\}\par
4030 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \\}\par
4031 {\cf21         catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \\}\par
4032 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
4033 {\cf21     \} while( false )}\par
4034 \par
4036 {\cf21 #define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \\}\par
4037 {\cf21     Catch::Capturer varName( macroName##_catch_sr,        \\}\par
4038 {\cf21                              CATCH_INTERNAL_LINEINFO,     \\}\par
4039 {\cf21                              Catch::ResultWas::Info,      \\}\par
4040 {\cf21                              #__VA_ARGS__##_catch_sr );   \\}\par
4041 {\cf21     varName.captureValues( 0, __VA_ARGS__ )}\par
4042 \par
4044 {\cf21 #define INTERNAL_CATCH_INFO( macroName, log ) \\}\par
4045 {\cf21     const Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )}\par
4046 \par
4048 {\cf21 #define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \\}\par
4049 {\cf21     Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )}\par
4050 \par
4051 \par
4052 {\cf21 #if defined(CATCH_CONFIG_PREFIX_MESSAGES) && !defined(CATCH_CONFIG_DISABLE)}\par
4053 \par
4054 {\cf21   #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )}\par
4055 {\cf21   #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "CATCH_UNSCOPED_INFO", msg )}\par
4056 {\cf21   #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}\par
4057 {\cf21   #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CATCH_CAPTURE", __VA_ARGS__ )}\par
4058 \par
4059 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_MESSAGES) && defined(CATCH_CONFIG_DISABLE)}\par
4060 \par
4061 {\cf21   #define CATCH_INFO( msg )          (void)(0)}\par
4062 {\cf21   #define CATCH_UNSCOPED_INFO( msg ) (void)(0)}\par
4063 {\cf21   #define CATCH_WARN( msg )          (void)(0)}\par
4064 {\cf21   #define CATCH_CAPTURE( ... )       (void)(0)}\par
4065 \par
4066 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_MESSAGES) && !defined(CATCH_CONFIG_DISABLE)}\par
4067 \par
4068 {\cf21   #define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )}\par
4069 {\cf21   #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "UNSCOPED_INFO", msg )}\par
4070 {\cf21   #define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}\par
4071 {\cf21   #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CAPTURE", __VA_ARGS__ )}\par
4072 \par
4073 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_MESSAGES) && defined(CATCH_CONFIG_DISABLE)}\par
4074 \par
4075 {\cf21   #define INFO( msg )          (void)(0)}\par
4076 {\cf21   #define UNSCOPED_INFO( msg ) (void)(0)}\par
4077 {\cf21   #define WARN( msg )          (void)(0)}\par
4078 {\cf21   #define CAPTURE( ... )       (void)(0)}\par
4079 \par
4080 {\cf21 #endif }{\cf20 // end of user facing macro declarations}\par
4081 \par
4082 \par
4083 \par
4084 \par
4085 {\cf21 #endif }{\cf20 // CATCH_MESSAGE_HPP_INCLUDED}\par
4086 \par
4087 \par
4088 {\cf21 #ifndef CATCH_SECTION_INFO_HPP_INCLUDED}\par
4089 {\cf21 #define CATCH_SECTION_INFO_HPP_INCLUDED}\par
4090 \par
4091 \par
4092 \par
4093 {\cf21 #ifndef CATCH_TOTALS_HPP_INCLUDED}\par
4094 {\cf21 #define CATCH_TOTALS_HPP_INCLUDED}\par
4095 \par
4096 {\cf21 #include <cstdint>}\par
4097 \par
4098 {\cf17 namespace }Catch \{\par
4099 \par
4100     {\cf17 struct }Counts \{\par
4101         Counts operator - ( Counts {\cf17 const}& other ) {\cf17 const};\par
4102         Counts& operator += ( Counts {\cf17 const}& other );\par
4103 \par
4104         std::uint64_t total() {\cf17 const};\par
4105         {\cf18 bool} allPassed() {\cf17 const};\par
4106         {\cf18 bool} allOk() {\cf17 const};\par
4107 \par
4108         std::uint64_t passed = 0;\par
4109         std::uint64_t failed = 0;\par
4110         std::uint64_t failedButOk = 0;\par
4111         std::uint64_t skipped = 0;\par
4112     \};\par
4113 \par
4114     {\cf17 struct }Totals \{\par
4115 \par
4116         Totals operator - ( Totals {\cf17 const}& other ) {\cf17 const};\par
4117         Totals& operator += ( Totals {\cf17 const}& other );\par
4118 \par
4119         Totals delta( Totals {\cf17 const}& prevTotals ) {\cf17 const};\par
4120 \par
4121         Counts assertions;\par
4122         Counts testCases;\par
4123     \};\par
4124 \}\par
4125 \par
4126 {\cf21 #endif }{\cf20 // CATCH_TOTALS_HPP_INCLUDED}\par
4127 \par
4128 {\cf21 #include <string>}\par
4129 \par
4130 {\cf17 namespace }Catch \{\par
4131 \par
4132     {\cf17 struct }SectionInfo \{\par
4133         {\cf20 // The last argument is ignored, so that people can write}\par
4134         {\cf20 // SECTION("ShortName", "Proper description that is long") and}\par
4135         {\cf20 // still use the `-c` flag comfortably.}\par
4136         SectionInfo( SourceLineInfo {\cf17 const}& _lineInfo, std::string _name,\par
4137                     {\cf17 const} {\cf18 char}* {\cf17 const} = {\cf17 nullptr} ):\par
4138             name(CATCH_MOVE(_name)),\par
4139             lineInfo(_lineInfo)\par
4140             \{\}\par
4141 \par
4142         std::string name;\par
4143         SourceLineInfo lineInfo;\par
4144     \};\par
4145 \par
4146     {\cf17 struct }SectionEndInfo \{\par
4147         SectionInfo sectionInfo;\par
4148         Counts prevAssertions;\par
4149         {\cf18 double} durationInSeconds;\par
4150     \};\par
4151 \par
4152 \} {\cf20 // end namespace Catch}\par
4153 \par
4154 {\cf21 #endif }{\cf20 // CATCH_SECTION_INFO_HPP_INCLUDED}\par
4155 \par
4156 \par
4157 {\cf21 #ifndef CATCH_SESSION_HPP_INCLUDED}\par
4158 {\cf21 #define CATCH_SESSION_HPP_INCLUDED}\par
4159 \par
4160 \par
4161 \par
4162 {\cf21 #ifndef CATCH_COMMANDLINE_HPP_INCLUDED}\par
4163 {\cf21 #define CATCH_COMMANDLINE_HPP_INCLUDED}\par
4164 \par
4165 \par
4166 \par
4167 {\cf21 #ifndef CATCH_CLARA_HPP_INCLUDED}\par
4168 {\cf21 #define CATCH_CLARA_HPP_INCLUDED}\par
4169 \par
4170 {\cf21 #if defined( __clang__ )}\par
4171 {\cf21 #    pragma clang diagnostic push}\par
4172 {\cf21 #    pragma clang diagnostic ignored "-Wweak-vtables"}\par
4173 {\cf21 #    pragma clang diagnostic ignored "-Wshadow"}\par
4174 {\cf21 #    pragma clang diagnostic ignored "-Wdeprecated"}\par
4175 {\cf21 #endif}\par
4176 \par
4177 {\cf21 #if defined( __GNUC__ )}\par
4178 {\cf21 #    pragma GCC diagnostic push}\par
4179 {\cf21 #    pragma GCC diagnostic ignored "-Wsign-conversion"}\par
4180 {\cf21 #endif}\par
4181 \par
4182 {\cf21 #ifndef CLARA_CONFIG_OPTIONAL_TYPE}\par
4183 {\cf21 #    ifdef __has_include}\par
4184 {\cf21 #        if __has_include( <optional>) && __cplusplus >= 201703L}\par
4185 {\cf21 #            include <optional>}\par
4186 {\cf21 #            define CLARA_CONFIG_OPTIONAL_TYPE std::optional}\par
4187 {\cf21 #        endif}\par
4188 {\cf21 #    endif}\par
4189 {\cf21 #endif}\par
4190 \par
4191 \par
4192 {\cf21 #include <cassert>}\par
4193 {\cf21 #include <memory>}\par
4194 {\cf21 #include <ostream>}\par
4195 {\cf21 #include <sstream>}\par
4196 {\cf21 #include <string>}\par
4197 {\cf21 #include <type_traits>}\par
4198 {\cf21 #include <vector>}\par
4199 \par
4200 {\cf17 namespace }Catch \{\par
4201     {\cf17 namespace }Clara \{\par
4202 \par
4203         {\cf17 class }Args;\par
4204         {\cf17 class }Parser;\par
4205 \par
4206         {\cf20 // enum of result types from a parse}\par
4207         {\cf17 enum class} ParseResultType \{\par
4208             Matched,\par
4209             NoMatch,\par
4210             ShortCircuitAll,\par
4211             ShortCircuitSame\par
4212         \};\par
4213 \par
4214         {\cf17 struct }accept_many_t \{\};\par
4215         {\cf17 constexpr} accept_many_t accept_many \{\};\par
4216 \par
4217         {\cf17 namespace }Detail \{\par
4218             {\cf17 struct }fake_arg \{\par
4219                 {\cf17 template} <{\cf17 typename} T>\par
4220                 {\cf17 operator} T();\par
4221             \};\par
4222 \par
4223             {\cf17 template} <{\cf17 typename} F, {\cf17 typename} = {\cf18 void}>\par
4224             {\cf17 struct }is_unary_function : std::false_type \{\};\par
4225 \par
4226             {\cf17 template} <{\cf17 typename} F>\par
4227             {\cf17 struct }is_unary_function<\par
4228                 F,\par
4229                 Catch::Detail::void_t<decltype(\par
4230                     std::declval<F>()( fake_arg() ) )\par
4231                 >\par
4232             > : std::true_type \{\};\par
4233 \par
4234             {\cf20 // Traits for extracting arg and return type of lambdas (for single}\par
4235             {\cf20 // argument lambdas)}\par
4236             {\cf17 template} <{\cf17 typename} L>\par
4237             {\cf17 struct }UnaryLambdaTraits\par
4238                 : UnaryLambdaTraits<decltype( &L::operator() )> \{\};\par
4239 \par
4240             {\cf17 template} <{\cf17 typename} ClassT, {\cf17 typename} ReturnT, {\cf17 typename}... Args>\par
4241             {\cf17 struct }UnaryLambdaTraits<ReturnT ( ClassT::* )( Args... ) const> \{\par
4242                 {\cf17 static} {\cf17 const} {\cf18 bool} isValid = {\cf17 false};\par
4243             \};\par
4244 \par
4245             {\cf17 template} <{\cf17 typename} ClassT, {\cf17 typename} ReturnT, {\cf17 typename} ArgT>\par
4246             {\cf17 struct }UnaryLambdaTraits<ReturnT ( ClassT::* )( ArgT ) const> \{\par
4247                 {\cf17 static} {\cf17 const} {\cf18 bool} isValid = {\cf17 true};\par
4248                 {\cf17 using }ArgType = std::remove_const_t<std::remove_reference_t<ArgT>>;\par
4249                 {\cf17 using }ReturnType = ReturnT;\par
4250             \};\par
4251 \par
4252             {\cf17 class }TokenStream;\par
4253 \par
4254             {\cf20 // Wraps a token coming from a token stream. These may not directly}\par
4255             {\cf20 // correspond to strings as a single string may encode an option +}\par
4256             {\cf20 // its argument if the : or = form is used}\par
4257             {\cf17 enum class} TokenType \{ Option, Argument \};\par
4258             {\cf17 struct }Token \{\par
4259                 TokenType type;\par
4260                 StringRef token;\par
4261             \};\par
4262 \par
4263             {\cf20 // Abstracts iterators into args as a stream of tokens, with option}\par
4264             {\cf20 // arguments uniformly handled}\par
4265             {\cf17 class }TokenStream \{\par
4266                 {\cf17 using }Iterator = std::vector<StringRef>::const_iterator;\par
4267                 Iterator it;\par
4268                 Iterator itEnd;\par
4269                 std::vector<Token> m_tokenBuffer;\par
4270                 {\cf18 void} loadBuffer();\par
4271 \par
4272             {\cf17 public}:\par
4273                 {\cf17 explicit} TokenStream( Args {\cf17 const}& args );\par
4274                 TokenStream( Iterator it, Iterator itEnd );\par
4275 \par
4276                 {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
4277                     {\cf19 return} !m_tokenBuffer.empty() || it != itEnd;\par
4278                 \}\par
4279 \par
4280                 {\cf18 size_t} count(){\cf17  const }\{\par
4281                     {\cf19 return} m_tokenBuffer.size() + ( itEnd - it );\par
4282                 \}\par
4283 \par
4284                 Token operator*(){\cf17  const }\{\par
4285                     assert( !m_tokenBuffer.empty() );\par
4286                     {\cf19 return} m_tokenBuffer.front();\par
4287                 \}\par
4288 \par
4289                 Token {\cf17 const}* operator->(){\cf17  const }\{\par
4290                     assert( !m_tokenBuffer.empty() );\par
4291                     {\cf19 return} &m_tokenBuffer.front();\par
4292                 \}\par
4293 \par
4294                 TokenStream& operator++();\par
4295             \};\par
4296 \par
4298             {\cf17 enum class} ResultType \{\par
4299                 Ok,          \par
4300                 LogicError,  \par
4302                 RuntimeError \par
4303             \};\par
4304 \par
4305             {\cf17 class }ResultBase \{\par
4306             {\cf17 protected}:\par
4307                 ResultBase( ResultType type ): m_type( type ) \{\}\par
4308                 {\cf17 virtual} ~ResultBase(); {\cf20 // = default;}\par
4309 \par
4310 \par
4311                 ResultBase(ResultBase {\cf17 const}&) = {\cf19 default};\par
4312                 ResultBase& operator=(ResultBase {\cf17 const}&) = {\cf19 default};\par
4313                 ResultBase(ResultBase&&) = {\cf19 default};\par
4314                 ResultBase& operator=(ResultBase&&) = {\cf19 default};\par
4315 \par
4316                 {\cf17 virtual} {\cf18 void} enforceOk() {\cf17 const} = 0;\par
4317 \par
4318                 ResultType m_type;\par
4319             \};\par
4320 \par
4321             {\cf17 template} <{\cf17 typename} T>\par
4322             {\cf17 class }ResultValueBase : {\cf17 public} ResultBase \{\par
4323             {\cf17 public}:\par
4324                 T {\cf17 const}& value() const& \{\par
4325                     enforceOk();\par
4326                     {\cf19 return} m_value;\par
4327                 \}\par
4328                 T&& value() && \{\par
4329                     enforceOk();\par
4330                     {\cf19 return} CATCH_MOVE( m_value );\par
4331                 \}\par
4332 \par
4333             {\cf17 protected}:\par
4334                 ResultValueBase( ResultType type ): ResultBase( type ) \{\}\par
4335 \par
4336                 ResultValueBase( ResultValueBase {\cf17 const}& other ):\par
4337                     ResultBase( other ) \{\par
4338                     {\cf19 if} ( m_type == ResultType::Ok )\par
4339                         {\cf17 new} ( &m_value ) T( other.m_value );\par
4340                 \}\par
4341                 ResultValueBase( ResultValueBase&& other ):\par
4342                     ResultBase( other ) \{\par
4343                     {\cf19 if} ( m_type == ResultType::Ok )\par
4344                         {\cf17 new} ( &m_value ) T( CATCH_MOVE(other.m_value) );\par
4345                 \}\par
4346 \par
4347 \par
4348                 ResultValueBase( ResultType, T {\cf17 const}& value ):\par
4349                     ResultBase( ResultType::Ok ) \{\par
4350                     {\cf17 new} ( &m_value ) T( value );\par
4351                 \}\par
4352                 ResultValueBase( ResultType, T&& value ):\par
4353                     ResultBase( ResultType::Ok ) \{\par
4354                     {\cf17 new} ( &m_value ) T( CATCH_MOVE(value) );\par
4355                 \}\par
4356 \par
4357                 ResultValueBase& operator=( ResultValueBase {\cf17 const}& other ) \{\par
4358                     {\cf19 if} ( m_type == ResultType::Ok )\par
4359                         m_value.~T();\par
4360                     ResultBase::operator=( other );\par
4361                     {\cf19 if} ( m_type == ResultType::Ok )\par
4362                         {\cf17 new} ( &m_value ) T( other.m_value );\par
4363                     {\cf19 return} *{\cf17 this};\par
4364                 \}\par
4365                 ResultValueBase& operator=( ResultValueBase&& other ) \{\par
4366                     {\cf19 if} ( m_type == ResultType::Ok ) m_value.~T();\par
4367                     ResultBase::operator=( other );\par
4368                     {\cf19 if} ( m_type == ResultType::Ok )\par
4369                         {\cf17 new} ( &m_value ) T( CATCH_MOVE(other.m_value) );\par
4370                     {\cf19 return} *{\cf17 this};\par
4371                 \}\par
4372 \par
4373 \par
4374                 ~ResultValueBase(){\cf17  override }\{\par
4375                     {\cf19 if} ( m_type == ResultType::Ok )\par
4376                         m_value.~T();\par
4377                 \}\par
4378 \par
4379                 {\cf17 union }\{\par
4380                     T m_value;\par
4381                 \};\par
4382             \};\par
4383 \par
4384             {\cf17 template} <> {\cf17 class }ResultValueBase<void> : {\cf17 public} ResultBase \{\par
4385             {\cf17 protected}:\par
4386                 {\cf17 using }ResultBase::ResultBase;\par
4387             \};\par
4388 \par
4389             {\cf17 template} <{\cf17 typename} T = {\cf18 void}>\par
4390             {\cf17 class }BasicResult : {\cf17 public} ResultValueBase<T> \{\par
4391             {\cf17 public}:\par
4392                 {\cf17 template} <{\cf17 typename} U>\par
4393                 {\cf17 explicit} BasicResult( BasicResult<U> {\cf17 const}& other ):\par
4394                     ResultValueBase<T>( other.type() ),\par
4395                     m_errorMessage( other.errorMessage() ) \{\par
4396                     assert( type() != ResultType::Ok );\par
4397                 \}\par
4398 \par
4399                 {\cf17 template} <{\cf17 typename} U>\par
4400                 {\cf17 static} {\cf17 auto} ok( U&& value ) -> BasicResult \{\par
4401                     {\cf19 return} \{ ResultType::Ok, CATCH_FORWARD(value) \};\par
4402                 \}\par
4403                 {\cf17 static} {\cf17 auto} ok() -> BasicResult \{ {\cf19 return} \{ ResultType::Ok \}; \}\par
4404                 {\cf17 static} {\cf17 auto} logicError( std::string&& message )\par
4405                     -> BasicResult \{\par
4406                     {\cf19 return} \{ ResultType::LogicError, CATCH_MOVE(message) \};\par
4407                 \}\par
4408                 {\cf17 static} {\cf17 auto} runtimeError( std::string&& message )\par
4409                     -> BasicResult \{\par
4410                     {\cf19 return} \{ ResultType::RuntimeError, CATCH_MOVE(message) \};\par
4411                 \}\par
4412 \par
4413                 {\cf17 explicit} {\cf17 operator} bool(){\cf17  const }\{\par
4414                     {\cf19 return} m_type == ResultType::Ok;\par
4415                 \}\par
4416                 {\cf17 auto} type() const -> ResultType \{ {\cf19 return} m_type; \}\par
4417                 {\cf17 auto} errorMessage() const -> std::{\cf18 string} const& \{\par
4418                     {\cf19 return} m_errorMessage;\par
4419                 \}\par
4420 \par
4421             {\cf17 protected}:\par
4422                 {\cf18 void} enforceOk(){\cf17  const override }\{\par
4423 \par
4424                     {\cf20 // Errors shouldn't reach this point, but if they do}\par
4425                     {\cf20 // the actual error message will be in m_errorMessage}\par
4426                     assert( m_type != ResultType::LogicError );\par
4427                     assert( m_type != ResultType::RuntimeError );\par
4428                     {\cf19 if} ( m_type != ResultType::Ok )\par
4429                         std::abort();\par
4430                 \}\par
4431 \par
4432                 std::string\par
4433                     m_errorMessage; {\cf20 // Only populated if resultType is an error}\par
4434 \par
4435                 BasicResult( ResultType type,\par
4436                              std::string&& message ):\par
4437                     ResultValueBase<T>( type ), m_errorMessage( CATCH_MOVE(message) ) \{\par
4438                     assert( m_type != ResultType::Ok );\par
4439                 \}\par
4440 \par
4441                 {\cf17 using }ResultValueBase<T>::ResultValueBase;\par
4442                 {\cf17 using }ResultBase::m_type;\par
4443             \};\par
4444 \par
4445             {\cf17 class }ParseState \{\par
4446             {\cf17 public}:\par
4447                 ParseState( ParseResultType type,\par
4448                             TokenStream remainingTokens );\par
4449 \par
4450                 ParseResultType type(){\cf17  const }\{ {\cf19 return} m_type; \}\par
4451                 TokenStream {\cf17 const}& remainingTokens() const& \{\par
4452                     {\cf19 return} m_remainingTokens;\par
4453                 \}\par
4454                 TokenStream&& remainingTokens() && \{\par
4455                     {\cf19 return} CATCH_MOVE( m_remainingTokens );\par
4456                 \}\par
4457 \par
4458             {\cf17 private}:\par
4459                 ParseResultType m_type;\par
4460                 TokenStream m_remainingTokens;\par
4461             \};\par
4462 \par
4463             {\cf17 using }Result = BasicResult<void>;\par
4464             {\cf17 using }ParserResult = BasicResult<ParseResultType>;\par
4465             {\cf17 using }InternalParseResult = BasicResult<ParseState>;\par
4466 \par
4467             {\cf17 struct }HelpColumns \{\par
4468                 std::string left;\par
4469                 StringRef descriptions;\par
4470             \};\par
4471 \par
4472             {\cf17 template} <{\cf17 typename} T>\par
4473             ParserResult convertInto( std::string {\cf17 const}& source, T& target ) \{\par
4474                 std::stringstream ss( source );\par
4475                 ss >> target;\par
4476                 {\cf19 if} ( ss.fail() ) \{\par
4477                     {\cf19 return} ParserResult::runtimeError(\par
4478                         {\cf22 "Unable to convert '"} + source +\par
4479                         {\cf22 "' to destination type"} );\par
4480                 \} {\cf19 else} \{\par
4481                     {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
4482                 \}\par
4483             \}\par
4484             ParserResult convertInto( std::string {\cf17 const}& source,\par
4485                                       std::string& target );\par
4486             ParserResult convertInto( std::string {\cf17 const}& source, {\cf18 bool}& target );\par
4487 \par
4488 {\cf21 #ifdef CLARA_CONFIG_OPTIONAL_TYPE}\par
4489             {\cf17 template} <{\cf17 typename} T>\par
4490             {\cf17 auto} convertInto( std::string {\cf17 const}& source,\par
4491                               CLARA_CONFIG_OPTIONAL_TYPE<T>& target )\par
4492                 -> ParserResult \{\par
4493                 T temp;\par
4494                 {\cf17 auto} result = convertInto( source, temp );\par
4495                 {\cf19 if} ( result )\par
4496                     target = CATCH_MOVE( temp );\par
4497                 {\cf19 return} result;\par
4498             \}\par
4499 {\cf21 #endif }{\cf20 // CLARA_CONFIG_OPTIONAL_TYPE}\par
4500 \par
4501             {\cf17 struct }BoundRef : Catch::Detail::NonCopyable \{\par
4502                 {\cf17 virtual} ~BoundRef() = {\cf19 default};\par
4503                 {\cf17 virtual} {\cf18 bool} isContainer() {\cf17 const};\par
4504                 {\cf17 virtual} {\cf18 bool} isFlag() {\cf17 const};\par
4505             \};\par
4506             {\cf17 struct }BoundValueRefBase : BoundRef \{\par
4507                 {\cf17 virtual} {\cf17 auto} setValue( std::string {\cf17 const}& arg )\par
4508                     -> ParserResult = 0;\par
4509             \};\par
4510             {\cf17 struct }BoundFlagRefBase : BoundRef \{\par
4511                 {\cf17 virtual} {\cf17 auto} setFlag( {\cf18 bool} flag ) -> ParserResult = 0;\par
4512                 {\cf18 bool} isFlag() {\cf17 const override};\par
4513             \};\par
4514 \par
4515             {\cf17 template} <{\cf17 typename} T> {\cf17 struct }BoundValueRef : BoundValueRefBase \{\par
4516                 T& m_ref;\par
4517 \par
4518                 {\cf17 explicit} BoundValueRef( T& ref ): m_ref( ref ) \{\}\par
4519 \par
4520                 ParserResult setValue( std::string {\cf17 const}& arg ){\cf17  override }\{\par
4521                     {\cf19 return} convertInto( arg, m_ref );\par
4522                 \}\par
4523             \};\par
4524 \par
4525             {\cf17 template} <{\cf17 typename} T>\par
4526             {\cf17 struct }BoundValueRef<std::vector<T>> : BoundValueRefBase \{\par
4527                 std::vector<T>& m_ref;\par
4528 \par
4529                 {\cf17 explicit} BoundValueRef( std::vector<T>& ref ): m_ref( ref ) \{\}\par
4530 \par
4531                 {\cf17 auto} isContainer() const -> {\cf18 bool}{\cf17  override }\{ {\cf19 return} {\cf17 true}; \}\par
4532 \par
4533                 {\cf17 auto} setValue( std::string {\cf17 const}& arg )\par
4534                     -> ParserResult {\cf17 override} \{\par
4535                     T temp;\par
4536                     {\cf17 auto} result = convertInto( arg, temp );\par
4537                     {\cf19 if} ( result )\par
4538                         m_ref.push_back( temp );\par
4539                     {\cf19 return} result;\par
4540                 \}\par
4541             \};\par
4542 \par
4543             {\cf17 struct }BoundFlagRef : BoundFlagRefBase \{\par
4544                 {\cf18 bool}& m_ref;\par
4545 \par
4546                 {\cf17 explicit} BoundFlagRef( {\cf18 bool}& ref ): m_ref( ref ) \{\}\par
4547 \par
4548                 ParserResult setFlag( {\cf18 bool} flag ) {\cf17 override};\par
4549             \};\par
4550 \par
4551             {\cf17 template} <{\cf17 typename} ReturnType> {\cf17 struct }LambdaInvoker \{\par
4552                 {\cf17 static_assert}(\par
4553                     std::is_same<ReturnType, ParserResult>::value,\par
4554                     {\cf22 "Lambda must return void or clara::ParserResult"} );\par
4555 \par
4556                 {\cf17 template} <{\cf17 typename} L, {\cf17 typename} ArgType>\par
4557                 {\cf17 static} {\cf17 auto} invoke( L {\cf17 const}& lambda, ArgType {\cf17 const}& arg )\par
4558                     -> ParserResult \{\par
4559                     {\cf19 return} lambda( arg );\par
4560                 \}\par
4561             \};\par
4562 \par
4563             {\cf17 template} <> {\cf17 struct }LambdaInvoker<void> \{\par
4564                 {\cf17 template} <{\cf17 typename} L, {\cf17 typename} ArgType>\par
4565                 {\cf17 static} {\cf17 auto} invoke( L {\cf17 const}& lambda, ArgType {\cf17 const}& arg )\par
4566                     -> ParserResult \{\par
4567                     lambda( arg );\par
4568                     {\cf19 return} ParserResult::ok( ParseResultType::Matched );\par
4569                 \}\par
4570             \};\par
4571 \par
4572             {\cf17 template} <{\cf17 typename} ArgType, {\cf17 typename} L>\par
4573             {\cf17 auto} invokeLambda( L {\cf17 const}& lambda, std::string {\cf17 const}& arg )\par
4574                 -> ParserResult \{\par
4575                 ArgType temp\{\};\par
4576                 {\cf17 auto} result = convertInto( arg, temp );\par
4577                 {\cf19 return} !result ? result\par
4578                                : LambdaInvoker<{\cf17 typename} UnaryLambdaTraits<\par
4579                                      L>::ReturnType>::invoke( lambda, temp );\par
4580             \}\par
4581 \par
4582             {\cf17 template} <{\cf17 typename} L> {\cf17 struct }BoundLambda : BoundValueRefBase \{\par
4583                 L m_lambda;\par
4584 \par
4585                 {\cf17 static_assert}(\par
4586                     UnaryLambdaTraits<L>::isValid,\par
4587                     {\cf22 "Supplied lambda must take exactly one argument"} );\par
4588                 {\cf17 explicit} BoundLambda( L {\cf17 const}& lambda ): m_lambda( lambda ) \{\}\par
4589 \par
4590                 {\cf17 auto} setValue( std::string {\cf17 const}& arg )\par
4591                     -> ParserResult {\cf17 override} \{\par
4592                     {\cf19 return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>(\par
4593                         m_lambda, arg );\par
4594                 \}\par
4595             \};\par
4596 \par
4597             {\cf17 template} <{\cf17 typename} L> {\cf17 struct }BoundManyLambda : BoundLambda<L> \{\par
4598                 {\cf17 explicit} BoundManyLambda( L {\cf17 const}& lambda ): BoundLambda<L>( lambda ) \{\}\par
4599                 {\cf18 bool} isContainer(){\cf17  const override }\{ {\cf19 return} {\cf17 true}; \}\par
4600             \};\par
4601 \par
4602             {\cf17 template} <{\cf17 typename} L> {\cf17 struct }BoundFlagLambda : BoundFlagRefBase \{\par
4603                 L m_lambda;\par
4604 \par
4605                 {\cf17 static_assert}(\par
4606                     UnaryLambdaTraits<L>::isValid,\par
4607                     {\cf22 "Supplied lambda must take exactly one argument"} );\par
4608                 {\cf17 static_assert}(\par
4609                     std::is_same<typename UnaryLambdaTraits<L>::ArgType,\par
4610                                  {\cf18 bool}>::value,\par
4611                     {\cf22 "flags must be boolean"} );\par
4612 \par
4613                 {\cf17 explicit} BoundFlagLambda( L {\cf17 const}& lambda ):\par
4614                     m_lambda( lambda ) \{\}\par
4615 \par
4616                 {\cf17 auto} setFlag( {\cf18 bool} flag ) -> ParserResult {\cf17 override} \{\par
4617                     {\cf19 return} LambdaInvoker<{\cf17 typename} UnaryLambdaTraits<\par
4618                         L>::ReturnType>::invoke( m_lambda, flag );\par
4619                 \}\par
4620             \};\par
4621 \par
4622             {\cf17 enum class} Optionality \{ Optional, Required \};\par
4623 \par
4624             {\cf17 class }ParserBase \{\par
4625             {\cf17 public}:\par
4626                 {\cf17 virtual} ~ParserBase() = {\cf19 default};\par
4627                 {\cf17 virtual} {\cf17 auto} validate() const -> Result \{ {\cf19 return} Result::ok(); \}\par
4628                 {\cf17 virtual} {\cf17 auto} parse( std::string {\cf17 const}& exeName,\par
4629                                     TokenStream tokens ) {\cf17 const}\par
4630                     -> InternalParseResult = 0;\par
4631                 {\cf17 virtual} {\cf18 size_t} cardinality() {\cf17 const};\par
4632 \par
4633                 InternalParseResult parse( Args {\cf17 const}& args ) {\cf17 const};\par
4634             \};\par
4635 \par
4636             {\cf17 template} <{\cf17 typename} DerivedT>\par
4637             {\cf17 class }ComposableParserImpl : {\cf17 public} ParserBase \{\par
4638             {\cf17 public}:\par
4639                 {\cf17 template} <{\cf17 typename} T>\par
4640                 {\cf17 auto} operator|( T {\cf17 const}& other ) {\cf17 const} -> Parser;\par
4641             \};\par
4642 \par
4643             {\cf20 // Common code and state for Args and Opts}\par
4644             {\cf17 template} <{\cf17 typename} DerivedT>\par
4645             {\cf17 class }ParserRefImpl : {\cf17 public} ComposableParserImpl<DerivedT> \{\par
4646             {\cf17 protected}:\par
4647                 Optionality m_optionality = Optionality::Optional;\par
4648                 std::shared_ptr<BoundRef> m_ref;\par
4649                 StringRef m_hint;\par
4650                 StringRef m_description;\par
4651 \par
4652                 {\cf17 explicit} ParserRefImpl( std::shared_ptr<BoundRef> {\cf17 const}& ref ):\par
4653                     m_ref( ref ) \{\}\par
4654 \par
4655             {\cf17 public}:\par
4656                 {\cf17 template} <{\cf17 typename} LambdaT>\par
4657                 ParserRefImpl( accept_many_t,\par
4658                                LambdaT {\cf17 const}& ref,\par
4659                                StringRef hint ):\par
4660                     m_ref( std::make_shared<BoundManyLambda<LambdaT>>( ref ) ),\par
4661                     m_hint( hint ) \{\}\par
4662 \par
4663                 {\cf17 template} <{\cf17 typename} T,\par
4664                           {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4665                               !Detail::is_unary_function<T>::value>>\par
4666                 ParserRefImpl( T& ref, StringRef hint ):\par
4667                     m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),\par
4668                     m_hint( hint ) \{\}\par
4669 \par
4670                 {\cf17 template} <{\cf17 typename} LambdaT,\par
4671                           {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4672                               Detail::is_unary_function<LambdaT>::value>>\par
4673                 ParserRefImpl( LambdaT {\cf17 const}& ref, StringRef hint ):\par
4674                     m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),\par
4675                     m_hint( hint ) \{\}\par
4676 \par
4677                 DerivedT& operator()( StringRef description ) & \{\par
4678                     m_description = description;\par
4679                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4680                 \}\par
4681                 DerivedT&& operator()( StringRef description ) && \{\par
4682                     m_description = description;\par
4683                     {\cf19 return} {\cf17 static_cast<}DerivedT&&{\cf17 >}( *this );\par
4684                 \}\par
4685 \par
4686                 {\cf17 auto} optional() -> DerivedT& \{\par
4687                     m_optionality = Optionality::Optional;\par
4688                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4689                 \}\par
4690 \par
4691                 {\cf17 auto} required() -> DerivedT& \{\par
4692                     m_optionality = Optionality::Required;\par
4693                     {\cf19 return} {\cf17 static_cast<}DerivedT&{\cf17 >}( *this );\par
4694                 \}\par
4695 \par
4696                 {\cf17 auto} isOptional() const -> {\cf18 bool} \{\par
4697                     {\cf19 return} m_optionality == Optionality::Optional;\par
4698                 \}\par
4699 \par
4700                 {\cf17 auto} cardinality() const -> {\cf18 size_t}{\cf17  override }\{\par
4701                     {\cf19 if} ( m_ref->isContainer() )\par
4702                         {\cf19 return} 0;\par
4703                     {\cf19 else}\par
4704                         {\cf19 return} 1;\par
4705                 \}\par
4706 \par
4707                 StringRef hint(){\cf17  const }\{ {\cf19 return} m_hint; \}\par
4708             \};\par
4709 \par
4710         \} {\cf20 // namespace detail}\par
4711 \par
4712 \par
4713         {\cf20 // A parser for arguments}\par
4714         {\cf17 class }Arg : {\cf17 public} Detail::ParserRefImpl<Arg> \{\par
4715         {\cf17 public}:\par
4716             {\cf17 using }ParserRefImpl::ParserRefImpl;\par
4717             {\cf17 using }ParserBase::parse;\par
4718 \par
4719             Detail::InternalParseResult\par
4720                 parse(std::string {\cf17 const}&,\par
4721                       Detail::TokenStream tokens) {\cf17 const override};\par
4722         \};\par
4723 \par
4724         {\cf20 // A parser for options}\par
4725         {\cf17 class }Opt : {\cf17 public} Detail::ParserRefImpl<Opt> \{\par
4726         {\cf17 protected}:\par
4727             std::vector<StringRef> m_optNames;\par
4728 \par
4729         {\cf17 public}:\par
4730             {\cf17 template} <{\cf17 typename} LambdaT>\par
4731             {\cf17 explicit} Opt(LambdaT {\cf17 const}& ref) :\par
4732                 ParserRefImpl(\par
4733                     std::make_shared<Detail::BoundFlagLambda<LambdaT>>(ref)) \{\}\par
4734 \par
4735             {\cf17 explicit} Opt({\cf18 bool}& ref);\par
4736 \par
4737             {\cf17 template} <{\cf17 typename} LambdaT,\par
4738                       {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4739                           Detail::is_unary_function<LambdaT>::value>>\par
4740             Opt( LambdaT {\cf17 const}& ref, StringRef hint ):\par
4741                 ParserRefImpl( ref, hint ) \{\}\par
4742 \par
4743             {\cf17 template} <{\cf17 typename} LambdaT>\par
4744             Opt( accept_many_t, LambdaT {\cf17 const}& ref, StringRef hint ):\par
4745                 ParserRefImpl( accept_many, ref, hint ) \{\}\par
4746 \par
4747             {\cf17 template} <{\cf17 typename} T,\par
4748                       {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
4749                           !Detail::is_unary_function<T>::value>>\par
4750             Opt( T& ref, StringRef hint ):\par
4751                 ParserRefImpl( ref, hint ) \{\}\par
4752 \par
4753             Opt& operator[]( StringRef optName ) & \{\par
4754                 m_optNames.push_back(optName);\par
4755                 {\cf19 return} *{\cf17 this};\par
4756             \}\par
4757             Opt&& operator[]( StringRef optName ) && \{\par
4758                 m_optNames.push_back( optName );\par
4759                 {\cf19 return} CATCH_MOVE(*{\cf17 this});\par
4760             \}\par
4761 \par
4762             Detail::HelpColumns getHelpColumns() {\cf17 const};\par
4763 \par
4764             {\cf18 bool} isMatch(StringRef optToken) {\cf17 const};\par
4765 \par
4766             {\cf17 using }ParserBase::parse;\par
4767 \par
4768             Detail::InternalParseResult\par
4769                 parse(std::string {\cf17 const}&,\par
4770                       Detail::TokenStream tokens) {\cf17 const override};\par
4771 \par
4772             Detail::Result validate() {\cf17 const override};\par
4773         \};\par
4774 \par
4775         {\cf20 // Specifies the name of the executable}\par
4776         {\cf17 class }ExeName : {\cf17 public} Detail::ComposableParserImpl<ExeName> \{\par
4777             std::shared_ptr<std::string> m_name;\par
4778             std::shared_ptr<Detail::BoundValueRefBase> m_ref;\par
4779 \par
4780         {\cf17 public}:\par
4781             ExeName();\par
4782             {\cf17 explicit} ExeName(std::string& ref);\par
4783 \par
4784             {\cf17 template} <{\cf17 typename} LambdaT>\par
4785             {\cf17 explicit} ExeName(LambdaT {\cf17 const}& lambda) : ExeName() \{\par
4786                 m_ref = std::make_shared<Detail::BoundLambda<LambdaT>>(lambda);\par
4787             \}\par
4788 \par
4789             {\cf20 // The exe name is not parsed out of the normal tokens, but is}\par
4790             {\cf20 // handled specially}\par
4791             Detail::InternalParseResult\par
4792                 parse(std::string {\cf17 const}&,\par
4793                       Detail::TokenStream tokens) {\cf17 const override};\par
4794 \par
4795             std::string {\cf17 const}& name(){\cf17  const }\{ {\cf19 return} *m_name; \}\par
4796             Detail::ParserResult set(std::string {\cf17 const}& newName);\par
4797         \};\par
4798 \par
4799 \par
4800         {\cf20 // A Combined parser}\par
4801         {\cf17 class }Parser : Detail::ParserBase \{\par
4802             {\cf17 mutable} ExeName m_exeName;\par
4803             std::vector<Opt> m_options;\par
4804             std::vector<Arg> m_args;\par
4805 \par
4806         {\cf17 public}:\par
4807 \par
4808             {\cf17 auto} operator|=(ExeName {\cf17 const}& exeName) -> Parser& \{\par
4809                 m_exeName = exeName;\par
4810                 {\cf19 return} *{\cf17 this};\par
4811             \}\par
4812 \par
4813             {\cf17 auto} operator|=(Arg {\cf17 const}& arg) -> Parser& \{\par
4814                 m_args.push_back(arg);\par
4815                 {\cf19 return} *{\cf17 this};\par
4816             \}\par
4817 \par
4818             {\cf17 friend} Parser& operator|=( Parser& p, Opt {\cf17 const}& opt ) \{\par
4819                 p.m_options.push_back( opt );\par
4820                 {\cf19 return} p;\par
4821             \}\par
4822             {\cf17 friend} Parser& operator|=( Parser& p, Opt&& opt ) \{\par
4823                 p.m_options.push_back( CATCH_MOVE(opt) );\par
4824                 {\cf19 return} p;\par
4825             \}\par
4826 \par
4827             Parser& operator|=(Parser {\cf17 const}& other);\par
4828 \par
4829             {\cf17 template} <{\cf17 typename} T>\par
4830             {\cf17 friend} Parser operator|( Parser {\cf17 const}& p, T&& rhs ) \{\par
4831                 Parser temp( p );\par
4832                 temp |= rhs;\par
4833                 {\cf19 return} temp;\par
4834             \}\par
4835 \par
4836             {\cf17 template} <{\cf17 typename} T>\par
4837             {\cf17 friend} Parser operator|( Parser&& p, T&& rhs ) \{\par
4838                 p |= CATCH_FORWARD(rhs);\par
4839                 {\cf19 return} CATCH_MOVE(p);\par
4840             \}\par
4841 \par
4842             std::vector<Detail::HelpColumns> getHelpColumns() {\cf17 const};\par
4843 \par
4844             {\cf18 void} writeToStream(std::ostream& os) {\cf17 const};\par
4845 \par
4846             {\cf17 friend} {\cf17 auto} operator<<(std::ostream& os, Parser {\cf17 const}& parser)\par
4847                 -> std::ostream& \{\par
4848                 parser.writeToStream(os);\par
4849                 {\cf19 return} os;\par
4850             \}\par
4851 \par
4852             Detail::Result validate() {\cf17 const override};\par
4853 \par
4854             {\cf17 using }ParserBase::parse;\par
4855             Detail::InternalParseResult\par
4856                 parse(std::string {\cf17 const}& exeName,\par
4857                       Detail::TokenStream tokens) {\cf17 const override};\par
4858         \};\par
4859 \par
4863         {\cf17 class }Args \{\par
4864             {\cf17 friend} Detail::TokenStream;\par
4865             StringRef m_exeName;\par
4866             std::vector<StringRef> m_args;\par
4867 \par
4868         {\cf17 public}:\par
4869             Args({\cf18 int} argc, {\cf18 char} {\cf17 const}* {\cf17 const}* argv);\par
4870             {\cf20 // Helper constructor for testing}\par
4871             Args(std::initializer_list<StringRef> args);\par
4872 \par
4873             StringRef exeName(){\cf17  const }\{ {\cf19 return} m_exeName; \}\par
4874         \};\par
4875 \par
4876 \par
4877         {\cf20 // Convenience wrapper for option parser that specifies the help option}\par
4878         {\cf17 struct }Help : Opt \{\par
4879             Help({\cf18 bool}& showHelpFlag);\par
4880         \};\par
4881 \par
4882         {\cf20 // Result type for parser operation}\par
4883         {\cf17 using }Detail::ParserResult;\par
4884 \par
4885         {\cf17 namespace }Detail \{\par
4886             {\cf17 template} <{\cf17 typename} DerivedT>\par
4887             {\cf17 template} <{\cf17 typename} T>\par
4888             Parser\par
4889                 ComposableParserImpl<DerivedT>::operator|(T {\cf17 const}& other){\cf17  const }\{\par
4890                 {\cf19 return} Parser() | {\cf17 static_cast<}DerivedT const&{\cf17 >}(*this) | other;\par
4891             \}\par
4892         \}\par
4893 \par
4894     \} {\cf20 // namespace Clara}\par
4895 \} {\cf20 // namespace Catch}\par
4896 \par
4897 {\cf21 #if defined( __clang__ )}\par
4898 {\cf21 #    pragma clang diagnostic pop}\par
4899 {\cf21 #endif}\par
4900 \par
4901 {\cf21 #if defined( __GNUC__ )}\par
4902 {\cf21 #    pragma GCC diagnostic pop}\par
4903 {\cf21 #endif}\par
4904 \par
4905 {\cf21 #endif }{\cf20 // CATCH_CLARA_HPP_INCLUDED}\par
4906 \par
4907 {\cf17 namespace }Catch \{\par
4908 \par
4909     {\cf17 struct }ConfigData;\par
4910 \par
4911     Clara::Parser makeCommandLineParser( ConfigData& config );\par
4912 \par
4913 \} {\cf20 // end namespace Catch}\par
4914 \par
4915 {\cf21 #endif }{\cf20 // CATCH_COMMANDLINE_HPP_INCLUDED}\par
4916 \par
4917 {\cf17 namespace }Catch \{\par
4918 \par
4919     {\cf17 class }Session : Detail::NonCopyable \{\par
4920     {\cf17 public}:\par
4921 \par
4922         Session();\par
4923         ~Session();\par
4924 \par
4925         {\cf18 void} showHelp() {\cf17 const};\par
4926         {\cf18 void} libIdentify();\par
4927 \par
4928         {\cf18 int} applyCommandLine( {\cf18 int} argc, {\cf18 char} {\cf17 const} * {\cf17 const} * argv );\par
4929 {\cf21     #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)}\par
4930         {\cf18 int} applyCommandLine( {\cf18 int} argc, {\cf18 wchar_t} {\cf17 const} * {\cf17 const} * argv );\par
4931 {\cf21     #endif}\par
4932 \par
4933         {\cf18 void} useConfigData( ConfigData {\cf17 const}& configData );\par
4934 \par
4935         {\cf17 template}<{\cf17 typename} CharT>\par
4936         {\cf18 int} run({\cf18 int} argc, CharT {\cf17 const} * {\cf17 const} argv[]) \{\par
4937             {\cf19 if} (m_startupExceptions)\par
4938                 {\cf19 return} 1;\par
4939             {\cf18 int} returnCode = applyCommandLine(argc, argv);\par
4940             {\cf19 if} (returnCode == 0)\par
4941                 returnCode = run();\par
4942             {\cf19 return} returnCode;\par
4943         \}\par
4944 \par
4945         {\cf18 int} run();\par
4946 \par
4947         Clara::Parser {\cf17 const}& cli() {\cf17 const};\par
4948         {\cf18 void} cli( Clara::Parser {\cf17 const}& newParser );\par
4949         ConfigData& configData();\par
4950         Config& config();\par
4951     {\cf17 private}:\par
4952         {\cf18 int} runInternal();\par
4953 \par
4954         Clara::Parser m_cli;\par
4955         ConfigData m_configData;\par
4956         Detail::unique_ptr<Config> m_config;\par
4957         {\cf18 bool} m_startupExceptions = {\cf17 false};\par
4958     \};\par
4959 \par
4960 \} {\cf20 // end namespace Catch}\par
4961 \par
4962 {\cf21 #endif }{\cf20 // CATCH_SESSION_HPP_INCLUDED}\par
4963 \par
4964 \par
4965 {\cf21 #ifndef CATCH_TAG_ALIAS_HPP_INCLUDED}\par
4966 {\cf21 #define CATCH_TAG_ALIAS_HPP_INCLUDED}\par
4967 \par
4968 \par
4969 {\cf21 #include <string>}\par
4970 \par
4971 {\cf17 namespace }Catch \{\par
4972 \par
4973     {\cf17 struct }TagAlias \{\par
4974         TagAlias(std::string {\cf17 const}& _tag, SourceLineInfo _lineInfo):\par
4975             tag(_tag),\par
4976             lineInfo(_lineInfo)\par
4977         \{\}\par
4978 \par
4979         std::string tag;\par
4980         SourceLineInfo lineInfo;\par
4981     \};\par
4982 \par
4983 \} {\cf20 // end namespace Catch}\par
4984 \par
4985 {\cf21 #endif }{\cf20 // CATCH_TAG_ALIAS_HPP_INCLUDED}\par
4986 \par
4987 \par
4988 {\cf21 #ifndef CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}\par
4989 {\cf21 #define CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}\par
4990 \par
4991 \par
4992 {\cf17 namespace }Catch \{\par
4993 \par
4994     {\cf17 struct }RegistrarForTagAliases \{\par
4995         RegistrarForTagAliases( {\cf18 char} {\cf17 const}* alias, {\cf18 char} {\cf17 const}* tag, SourceLineInfo {\cf17 const}& lineInfo );\par
4996     \};\par
4997 \par
4998 \} {\cf20 // end namespace Catch}\par
4999 \par
5000 {\cf21 #define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \\}\par
5001 {\cf21     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5002 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
5003 {\cf21     namespace\{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); \} \\}\par
5004 {\cf21     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5005 \par
5006 {\cf21 #endif }{\cf20 // CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED}\par
5007 \par
5008 \par
5009 {\cf21 #ifndef CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}\par
5010 {\cf21 #define CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}\par
5011 \par
5012 {\cf20 // We need this suppression to leak, because it took until GCC 10}\par
5013 {\cf20 // for the front end to handle local suppression via _Pragma properly}\par
5014 {\cf20 // inside templates (so `TEMPLATE_TEST_CASE` and co).}\par
5015 {\cf20 // **THIS IS DIFFERENT FOR STANDARD TESTS, WHERE GCC 9 IS SUFFICIENT**}\par
5016 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ < 10}\par
5017 {\cf21 #pragma GCC diagnostic ignored "-Wparentheses"}\par
5018 {\cf21 #endif}\par
5019 \par
5020 \par
5021 \par
5022 \par
5023 {\cf21 #ifndef CATCH_TEST_MACROS_HPP_INCLUDED}\par
5024 {\cf21 #define CATCH_TEST_MACROS_HPP_INCLUDED}\par
5025 \par
5026 \par
5027 \par
5028 {\cf21 #ifndef CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}\par
5029 {\cf21 #define CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}\par
5030 \par
5031 \par
5032 \par
5033 {\cf21 #ifndef CATCH_ASSERTION_HANDLER_HPP_INCLUDED}\par
5034 {\cf21 #define CATCH_ASSERTION_HANDLER_HPP_INCLUDED}\par
5035 \par
5036 \par
5037 \par
5038 {\cf21 #ifndef CATCH_DECOMPOSER_HPP_INCLUDED}\par
5039 {\cf21 #define CATCH_DECOMPOSER_HPP_INCLUDED}\par
5040 \par
5041 \par
5042 \par
5043 {\cf21 #ifndef CATCH_COMPARE_TRAITS_HPP_INCLUDED}\par
5044 {\cf21 #define CATCH_COMPARE_TRAITS_HPP_INCLUDED}\par
5045 \par
5046 \par
5047 {\cf21 #include <type_traits>}\par
5048 \par
5049 {\cf17 namespace }Catch \{\par
5050     {\cf17 namespace }Detail \{\par
5051 \par
5052 {\cf21 #if defined( __GNUC__ ) && !defined( __clang__ )}\par
5053 {\cf21 #    pragma GCC diagnostic push}\par
5054     {\cf20 // GCC likes to complain about comparing bool with 0, in the decltype()}\par
5055     {\cf20 // that defines the comparable traits below.}\par
5056 {\cf21 #    pragma GCC diagnostic ignored "-Wbool-compare"}\par
5057     {\cf20 // "ordered comparison of pointer with integer zero" same as above,}\par
5058     {\cf20 // but it does not have a separate warning flag to suppress}\par
5059 {\cf21 #    pragma GCC diagnostic ignored "-Wextra"}\par
5060     {\cf20 // Did you know that comparing floats with `0` directly}\par
5061     {\cf20 // is super-duper dangerous in unevaluated context?}\par
5062 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
5063 {\cf21 #endif}\par
5064 \par
5065 {\cf21 #if defined( __clang__ )}\par
5066 {\cf21 #    pragma clang diagnostic push}\par
5067     {\cf20 // Did you know that comparing floats with `0` directly}\par
5068     {\cf20 // is super-duper dangerous in unevaluated context?}\par
5069 {\cf21 #    pragma clang diagnostic ignored "-Wfloat-equal"}\par
5070 {\cf21 #endif}\par
5071 \par
5072 {\cf21 #define CATCH_DEFINE_COMPARABLE_TRAIT( id, op )                               \\}\par
5073 {\cf21     template <typename, typename, typename = void>                            \\}\par
5074 {\cf21     struct is_##id##_comparable : std::false_type \{\};                         \\}\par
5075 {\cf21     template <typename T, typename U>                                         \\}\par
5076 {\cf21     struct is_##id##_comparable<                                              \\}\par
5077 {\cf21         T,                                                                    \\}\par
5078 {\cf21         U,                                                                    \\}\par
5079 {\cf21         void_t<decltype( std::declval<T>() op std::declval<U>() )>>           \\}\par
5080 {\cf21         : std::true_type \{\};                                                  \\}\par
5081 {\cf21     template <typename, typename = void>                                      \\}\par
5082 {\cf21     struct is_##id##_0_comparable : std::false_type \{\};                       \\}\par
5083 {\cf21     template <typename T>                                                     \\}\par
5084 {\cf21     struct is_##id##_0_comparable<T,                                          \\}\par
5085 {\cf21                                   void_t<decltype( std::declval<T>() op 0 )>> \\}\par
5086 {\cf21         : std::true_type \{\};}\par
5087 \par
5088         {\cf20 // We need all 6 pre-spaceship comparison ops: <, <=, >, >=, ==, !=}\par
5089         CATCH_DEFINE_COMPARABLE_TRAIT( lt, < )\par
5090         CATCH_DEFINE_COMPARABLE_TRAIT( le, <= )\par
5091         CATCH_DEFINE_COMPARABLE_TRAIT( gt, > )\par
5092         CATCH_DEFINE_COMPARABLE_TRAIT( ge, >= )\par
5093         CATCH_DEFINE_COMPARABLE_TRAIT( eq, == )\par
5094         CATCH_DEFINE_COMPARABLE_TRAIT( ne, != )\par
5095 \par
5096 {\cf21 #undef CATCH_DEFINE_COMPARABLE_TRAIT}\par
5097 \par
5098 {\cf21 #if defined( __GNUC__ ) && !defined( __clang__ )}\par
5099 {\cf21 #    pragma GCC diagnostic pop}\par
5100 {\cf21 #endif}\par
5101 {\cf21 #if defined( __clang__ )}\par
5102 {\cf21 #    pragma clang diagnostic pop}\par
5103 {\cf21 #endif}\par
5104 \par
5105 \par
5106     \} {\cf20 // namespace Detail}\par
5107 \} {\cf20 // namespace Catch}\par
5108 \par
5109 {\cf21 #endif }{\cf20 // CATCH_COMPARE_TRAITS_HPP_INCLUDED}\par
5110 \par
5111 \par
5112 {\cf21 #ifndef CATCH_LOGICAL_TRAITS_HPP_INCLUDED}\par
5113 {\cf21 #define CATCH_LOGICAL_TRAITS_HPP_INCLUDED}\par
5114 \par
5115 {\cf21 #include <type_traits>}\par
5116 \par
5117 {\cf17 namespace }Catch \{\par
5118 {\cf17 namespace }Detail \{\par
5119 \par
5120 {\cf21 #if defined( __cpp_lib_logical_traits ) && __cpp_lib_logical_traits >= 201510}\par
5121 \par
5122     {\cf17 using }std::conjunction;\par
5123     {\cf17 using }std::disjunction;\par
5124     {\cf17 using }std::negation;\par
5125 \par
5126 {\cf21 #else}\par
5127 \par
5128     {\cf17 template} <{\cf17 class}...> {\cf17 struct }conjunction : std::true_type \{\};\par
5129     {\cf17 template} <{\cf17 class} B1> {\cf17 struct }conjunction<B1> : B1 \{\};\par
5130     {\cf17 template} <{\cf17 class }B1, {\cf17 class}... Bn>\par
5131     {\cf17 struct }conjunction<B1, Bn...>\par
5132         : std::conditional_t<bool( B1::value ), conjunction<Bn...>, B1> \{\};\par
5133 \par
5134     {\cf17 template} <{\cf17 class}...> {\cf17 struct }disjunction : std::false_type \{\};\par
5135     {\cf17 template} <{\cf17 class} B1> {\cf17 struct }disjunction<B1> : B1 \{\};\par
5136     {\cf17 template} <{\cf17 class }B1, {\cf17 class}... Bn>\par
5137     {\cf17 struct }disjunction<B1, Bn...>\par
5138         : std::conditional_t<bool( B1::value ), B1, disjunction<Bn...>> \{\};\par
5139 \par
5140     {\cf17 template} <{\cf17 class} B>\par
5141     {\cf17 struct }negation : std::integral_constant<bool, !bool(B::value)> \{\};\par
5142 \par
5143 {\cf21 #endif}\par
5144 \par
5145 \} {\cf20 // namespace Detail}\par
5146 \} {\cf20 // namespace Catch}\par
5147 \par
5148 {\cf21 #endif }{\cf20 // CATCH_LOGICAL_TRAITS_HPP_INCLUDED}\par
5149 \par
5150 {\cf21 #include <type_traits>}\par
5151 {\cf21 #include <iosfwd>}\par
5152 \par
5233 {\cf21 #ifdef _MSC_VER}\par
5234 {\cf21 #pragma warning(push)}\par
5235 {\cf21 #pragma warning(disable:4389) }{\cf20 // '==' : signed/unsigned mismatch}\par
5236 {\cf21 #pragma warning(disable:4018) }{\cf20 // more "signed/unsigned mismatch"}\par
5237 {\cf21 #pragma warning(disable:4312) }{\cf20 // Converting int to T* using reinterpret_cast (issue on x64 platform)}\par
5238 {\cf21 #pragma warning(disable:4180) }{\cf20 // qualifier applied to function type has no meaning}\par
5239 {\cf21 #pragma warning(disable:4800) }{\cf20 // Forcing result to true or false}\par
5240 {\cf21 #endif}\par
5241 \par
5242 {\cf21 #ifdef __clang__}\par
5243 {\cf21 #  pragma clang diagnostic push}\par
5244 {\cf21 #  pragma clang diagnostic ignored "-Wsign-compare"}\par
5245 {\cf21 #  pragma clang diagnostic ignored "-Wnon-virtual-dtor"}\par
5246 {\cf21 #elif defined __GNUC__}\par
5247 {\cf21 #  pragma GCC diagnostic push}\par
5248 {\cf21 #  pragma GCC diagnostic ignored "-Wsign-compare"}\par
5249 {\cf21 #  pragma GCC diagnostic ignored "-Wnon-virtual-dtor"}\par
5250 {\cf21 #endif}\par
5251 \par
5252 {\cf21 #if defined(CATCH_CPP20_OR_GREATER) && __has_include(<compare>)}\par
5253 {\cf21 #  include <compare>}\par
5254 {\cf21 #    if defined( __cpp_lib_three_way_comparison ) && \\}\par
5255 {\cf21             __cpp_lib_three_way_comparison >= 201907L}\par
5256 {\cf21 #      define CATCH_CONFIG_CPP20_COMPARE_OVERLOADS}\par
5257 {\cf21 #    endif}\par
5258 {\cf21 #endif}\par
5259 \par
5260 {\cf17 namespace }Catch \{\par
5261 \par
5262     {\cf17 namespace }Detail \{\par
5263         {\cf20 // This was added in C++20, but we require only C++14 for now.}\par
5264         {\cf17 template} <{\cf17 typename} T>\par
5265         {\cf17 using }RemoveCVRef_t = std::remove_cv_t<std::remove_reference_t<T>>;\par
5266     \}\par
5267 \par
5268     {\cf20 // Note: There is nothing that stops us from extending this,}\par
5269     {\cf20 //       e.g. to `std::is_scalar`, but the more encompassing}\par
5270     {\cf20 //       traits are usually also more expensive. For now we}\par
5271     {\cf20 //       keep this as it used to be and it can be changed later.}\par
5272     {\cf17 template} <{\cf17 typename} T>\par
5273     {\cf17 struct }capture_by_value\par
5274         : std::integral_constant<bool, std::is_arithmetic<T>\{\}> \{\};\par
5275 \par
5276 {\cf21 #if defined( CATCH_CONFIG_CPP20_COMPARE_OVERLOADS )}\par
5277     {\cf17 template} <>\par
5278     {\cf17 struct }capture_by_value<std::strong_ordering> : std::true_type \{\};\par
5279     {\cf17 template} <>\par
5280     {\cf17 struct }capture_by_value<std::weak_ordering> : std::true_type \{\};\par
5281     {\cf17 template} <>\par
5282     {\cf17 struct }capture_by_value<std::partial_ordering> : std::true_type \{\};\par
5283 {\cf21 #endif}\par
5284 \par
5285     {\cf17 template} <{\cf17 typename} T>\par
5286     {\cf17 struct }always_false : std::false_type \{\};\par
5287 \par
5288     {\cf17 class }ITransientExpression \{\par
5289         {\cf18 bool} m_isBinaryExpression;\par
5290         {\cf18 bool} m_result;\par
5291 \par
5292     {\cf17 public}:\par
5293         {\cf17 constexpr} {\cf17 auto} isBinaryExpression() const -> {\cf18 bool} \{ {\cf19 return} m_isBinaryExpression; \}\par
5294         {\cf17 constexpr} {\cf17 auto} getResult() const -> {\cf18 bool} \{ {\cf19 return} m_result; \}\par
5296         {\cf17 virtual} {\cf18 void} streamReconstructedExpression( std::ostream& os ) {\cf17 const};\par
5297 \par
5298         {\cf17 constexpr} ITransientExpression( {\cf18 bool} isBinaryExpression, {\cf18 bool} result )\par
5299         :   m_isBinaryExpression( isBinaryExpression ),\par
5300             m_result( result )\par
5301         \{\}\par
5302 \par
5303         ITransientExpression() = {\cf19 default};\par
5304         ITransientExpression(ITransientExpression {\cf17 const}&) = {\cf19 default};\par
5305         ITransientExpression& operator=(ITransientExpression {\cf17 const}&) = {\cf19 default};\par
5306 \par
5307         {\cf17 friend} std::ostream& operator<<(std::ostream& out, ITransientExpression {\cf17 const}& expr) \{\par
5308             expr.streamReconstructedExpression(out);\par
5309             {\cf19 return} out;\par
5310         \}\par
5311 \par
5312     {\cf17 protected}:\par
5313         ~ITransientExpression() = {\cf19 default};\par
5314     \};\par
5315 \par
5316     {\cf18 void} formatReconstructedExpression( std::ostream &os, std::string {\cf17 const}& lhs, StringRef op, std::string {\cf17 const}& rhs );\par
5317 \par
5318     {\cf17 template}<{\cf17 typename} LhsT, {\cf17 typename} RhsT>\par
5319     {\cf17 class }BinaryExpr  : {\cf17 public} ITransientExpression \{\par
5320         LhsT m_lhs;\par
5321         StringRef m_op;\par
5322         RhsT m_rhs;\par
5323 \par
5324         {\cf18 void} streamReconstructedExpression( std::ostream &os ){\cf17  const override }\{\par
5325             formatReconstructedExpression\par
5326                     ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );\par
5327         \}\par
5328 \par
5329     {\cf17 public}:\par
5330         {\cf17 constexpr} BinaryExpr( {\cf18 bool} comparisonResult, LhsT lhs, StringRef op, RhsT rhs )\par
5331         :   ITransientExpression\{ true, comparisonResult \},\par
5332             m_lhs( lhs ),\par
5333             m_op( op ),\par
5334             m_rhs( rhs )\par
5335         \{\}\par
5336 \par
5337         {\cf17 template}<{\cf17 typename} T>\par
5338         {\cf17 auto} operator && ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5339             {\cf17 static_assert}(always_false<T>::value,\par
5340             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5341             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5342         \}\par
5343 \par
5344         {\cf17 template}<{\cf17 typename} T>\par
5345         {\cf17 auto} operator || ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5346             {\cf17 static_assert}(always_false<T>::value,\par
5347             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5348             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5349         \}\par
5350 \par
5351         {\cf17 template}<{\cf17 typename} T>\par
5352         {\cf17 auto} operator == ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5353             {\cf17 static_assert}(always_false<T>::value,\par
5354             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5355             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5356         \}\par
5357 \par
5358         {\cf17 template}<{\cf17 typename} T>\par
5359         {\cf17 auto} operator != ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5360             {\cf17 static_assert}(always_false<T>::value,\par
5361             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5362             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5363         \}\par
5364 \par
5365         {\cf17 template}<{\cf17 typename} T>\par
5366         {\cf17 auto} operator > ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5367             {\cf17 static_assert}(always_false<T>::value,\par
5368             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5369             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5370         \}\par
5371 \par
5372         {\cf17 template}<{\cf17 typename} T>\par
5373         {\cf17 auto} operator < ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5374             {\cf17 static_assert}(always_false<T>::value,\par
5375             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5376             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5377         \}\par
5378 \par
5379         {\cf17 template}<{\cf17 typename} T>\par
5380         {\cf17 auto} operator >= ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5381             {\cf17 static_assert}(always_false<T>::value,\par
5382             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5383             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5384         \}\par
5385 \par
5386         {\cf17 template}<{\cf17 typename} T>\par
5387         {\cf17 auto} operator <= ( T ) {\cf17 const} -> BinaryExpr<LhsT, RhsT const&> {\cf17 const} \{\par
5388             {\cf17 static_assert}(always_false<T>::value,\par
5389             {\cf22 "chained comparisons are not supported inside assertions, "}\par
5390             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5391         \}\par
5392     \};\par
5393 \par
5394     {\cf17 template}<{\cf17 typename} LhsT>\par
5395     {\cf17 class }UnaryExpr : {\cf17 public} ITransientExpression \{\par
5396         LhsT m_lhs;\par
5397 \par
5398         {\cf18 void} streamReconstructedExpression( std::ostream &os ){\cf17  const override }\{\par
5399             os << Catch::Detail::stringify( m_lhs );\par
5400         \}\par
5401 \par
5402     {\cf17 public}:\par
5403         {\cf17 explicit} {\cf17 constexpr} UnaryExpr( LhsT lhs )\par
5404         :   ITransientExpression\{ false, static_cast<bool>(lhs) \},\par
5405             m_lhs( lhs )\par
5406         \{\}\par
5407     \};\par
5408 \par
5409 \par
5410     {\cf17 template}<{\cf17 typename} LhsT>\par
5411     {\cf17 class }ExprLhs \{\par
5412         LhsT m_lhs;\par
5413     {\cf17 public}:\par
5414         {\cf17 explicit} {\cf17 constexpr} ExprLhs( LhsT lhs ) : m_lhs( lhs ) \{\}\par
5415 \par
5416 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( id, op )           \\}\par
5417 {\cf21     template <typename RhsT>                                                   \\}\par
5418 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5419 {\cf21         -> std::enable_if_t<                                                   \\}\par
5420 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5421 {\cf21                                 Detail::negation<capture_by_value<             \\}\par
5422 {\cf21                                     Detail::RemoveCVRef_t<RhsT>>>>::value,     \\}\par
5423 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5424 {\cf21         return \{                                                               \\}\par
5425 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5426 {\cf21     \}                                                                          \\}\par
5427 {\cf21     template <typename RhsT>                                                   \\}\par
5428 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5429 {\cf21         -> std::enable_if_t<                                                   \\}\par
5430 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5431 {\cf21                                 capture_by_value<RhsT>>::value,                \\}\par
5432 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5433 {\cf21         return \{                                                               \\}\par
5434 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5435 {\cf21     \}                                                                          \\}\par
5436 {\cf21     template <typename RhsT>                                                   \\}\par
5437 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5438 {\cf21         -> std::enable_if_t<                                                   \\}\par
5439 {\cf21             Detail::conjunction<                                               \\}\par
5440 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5441 {\cf21                 Detail::is_eq_0_comparable<LhsT>,                              \\}\par
5442 {\cf21               }{\cf20 /* We allow long because we want `ptr op NULL` to be accepted */}{\cf21  \\}\par
5443 {\cf21                 Detail::disjunction<std::is_same<RhsT, int>,                   \\}\par
5444 {\cf21                                     std::is_same<RhsT, long>>>::value,         \\}\par
5445 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5446 {\cf21         if ( rhs != 0 ) \{ throw_test_failure_exception(); \}                    \\}\par
5447 {\cf21         return \{                                                               \\}\par
5448 {\cf21             static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs \};   \\}\par
5449 {\cf21     \}                                                                          \\}\par
5450 {\cf21     template <typename RhsT>                                                   \\}\par
5451 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5452 {\cf21         -> std::enable_if_t<                                                   \\}\par
5453 {\cf21             Detail::conjunction<                                               \\}\par
5454 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5455 {\cf21                 Detail::is_eq_0_comparable<RhsT>,                              \\}\par
5456 {\cf21               }{\cf20 /* We allow long because we want `ptr op NULL` to be accepted */}{\cf21  \\}\par
5457 {\cf21                 Detail::disjunction<std::is_same<LhsT, int>,                   \\}\par
5458 {\cf21                                     std::is_same<LhsT, long>>>::value,         \\}\par
5459 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5460 {\cf21         if ( lhs.m_lhs != 0 ) \{ throw_test_failure_exception(); \}              \\}\par
5461 {\cf21         return \{ static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs \};    \\}\par
5462 {\cf21     \}}\par
5463 \par
5464         CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( eq, == )\par
5465         CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( ne, != )\par
5466 \par
5467     {\cf21 #undef CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR}\par
5468 \par
5469 \par
5470 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( id, op )         \\}\par
5471 {\cf21     template <typename RhsT>                                                   \\}\par
5472 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5473 {\cf21         -> std::enable_if_t<                                                   \\}\par
5474 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5475 {\cf21                                 Detail::negation<capture_by_value<             \\}\par
5476 {\cf21                                     Detail::RemoveCVRef_t<RhsT>>>>::value,     \\}\par
5477 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5478 {\cf21         return \{                                                               \\}\par
5479 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5480 {\cf21     \}                                                                          \\}\par
5481 {\cf21     template <typename RhsT>                                                   \\}\par
5482 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5483 {\cf21         -> std::enable_if_t<                                                   \\}\par
5484 {\cf21             Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \\}\par
5485 {\cf21                                 capture_by_value<RhsT>>::value,                \\}\par
5486 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5487 {\cf21         return \{                                                               \\}\par
5488 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5489 {\cf21     \}                                                                          \\}\par
5490 {\cf21     template <typename RhsT>                                                   \\}\par
5491 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5492 {\cf21         -> std::enable_if_t<                                                   \\}\par
5493 {\cf21             Detail::conjunction<                                               \\}\par
5494 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5495 {\cf21                 Detail::is_##id##_0_comparable<LhsT>,                          \\}\par
5496 {\cf21                 std::is_same<RhsT, int>>::value,                               \\}\par
5497 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5498 {\cf21         if ( rhs != 0 ) \{ throw_test_failure_exception(); \}                    \\}\par
5499 {\cf21         return \{                                                               \\}\par
5500 {\cf21             static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs \};   \\}\par
5501 {\cf21     \}                                                                          \\}\par
5502 {\cf21     template <typename RhsT>                                                   \\}\par
5503 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5504 {\cf21         -> std::enable_if_t<                                                   \\}\par
5505 {\cf21             Detail::conjunction<                                               \\}\par
5506 {\cf21                 Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \\}\par
5507 {\cf21                 Detail::is_##id##_0_comparable<RhsT>,                          \\}\par
5508 {\cf21                 std::is_same<LhsT, int>>::value,                               \\}\par
5509 {\cf21             BinaryExpr<LhsT, RhsT>> \{                                          \\}\par
5510 {\cf21         if ( lhs.m_lhs != 0 ) \{ throw_test_failure_exception(); \}              \\}\par
5511 {\cf21         return \{ static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs \};    \\}\par
5512 {\cf21     \}}\par
5513 \par
5514         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( lt, < )\par
5515         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( le, <= )\par
5516         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( gt, > )\par
5517         CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( ge, >= )\par
5518 \par
5519     {\cf21 #undef CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR}\par
5520 \par
5521 \par
5522 {\cf21 #define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR( op )                        \\}\par
5523 {\cf21     template <typename RhsT>                                                   \\}\par
5524 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \\}\par
5525 {\cf21         -> std::enable_if_t<                                                   \\}\par
5526 {\cf21             !capture_by_value<Detail::RemoveCVRef_t<RhsT>>::value,             \\}\par
5527 {\cf21             BinaryExpr<LhsT, RhsT const&>> \{                                   \\}\par
5528 {\cf21         return \{                                                               \\}\par
5529 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5530 {\cf21     \}                                                                          \\}\par
5531 {\cf21     template <typename RhsT>                                                   \\}\par
5532 {\cf21     constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \\}\par
5533 {\cf21         -> std::enable_if_t<capture_by_value<RhsT>::value,                     \\}\par
5534 {\cf21                             BinaryExpr<LhsT, RhsT>> \{                          \\}\par
5535 {\cf21         return \{                                                               \\}\par
5536 {\cf21             static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs \}; \\}\par
5537 {\cf21     \}}\par
5538 \par
5539         CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(|)\par
5540         CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(&)\par
5541         CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(^)\par
5542 \par
5543     {\cf21 #undef CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR}\par
5544 \par
5545         {\cf17 template}<{\cf17 typename} RhsT>\par
5546         {\cf17 friend} {\cf17 auto} operator && ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> \{\par
5547             {\cf17 static_assert}(always_false<RhsT>::value,\par
5548             {\cf22 "operator&& is not supported inside assertions, "}\par
5549             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5550         \}\par
5551 \par
5552         {\cf17 template}<{\cf17 typename} RhsT>\par
5553         {\cf17 friend} {\cf17 auto} operator || ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> \{\par
5554             {\cf17 static_assert}(always_false<RhsT>::value,\par
5555             {\cf22 "operator|| is not supported inside assertions, "}\par
5556             {\cf22 "wrap the expression inside parentheses, or decompose it"});\par
5557         \}\par
5558 \par
5559         {\cf17 constexpr} {\cf17 auto} makeUnaryExpr() const -> UnaryExpr<LhsT> \{\par
5560             {\cf19 return} UnaryExpr<LhsT>\{ m_lhs \};\par
5561         \}\par
5562     \};\par
5563 \par
5564     {\cf17 struct }Decomposer \{\par
5565         {\cf17 template} <{\cf17 typename} T,\par
5566                   std::enable_if_t<!capture_by_value<Detail::RemoveCVRef_t<T>>::value,\par
5567                       {\cf18 int}> = 0>\par
5568         {\cf17 constexpr} {\cf17 friend} {\cf17 auto} operator <= ( Decomposer &&, T && lhs ) -> ExprLhs<T const&> \{\par
5569             {\cf19 return} ExprLhs<const T&>\{ lhs \};\par
5570         \}\par
5571 \par
5572         {\cf17 template} <{\cf17 typename} T,\par
5573                   std::enable_if_t<capture_by_value<T>::value, {\cf18 int}> = 0>\par
5574         {\cf17 constexpr} {\cf17 friend} {\cf17 auto} operator <= ( Decomposer &&, T value ) -> ExprLhs<T> \{\par
5575             {\cf19 return} ExprLhs<T>\{ value \};\par
5576         \}\par
5577     \};\par
5578 \par
5579 \} {\cf20 // end namespace Catch}\par
5580 \par
5581 {\cf21 #ifdef _MSC_VER}\par
5582 {\cf21 #pragma warning(pop)}\par
5583 {\cf21 #endif}\par
5584 {\cf21 #ifdef __clang__}\par
5585 {\cf21 #  pragma clang diagnostic pop}\par
5586 {\cf21 #elif defined __GNUC__}\par
5587 {\cf21 #  pragma GCC diagnostic pop}\par
5588 {\cf21 #endif}\par
5589 \par
5590 {\cf21 #endif }{\cf20 // CATCH_DECOMPOSER_HPP_INCLUDED}\par
5591 \par
5592 {\cf21 #include <string>}\par
5593 \par
5594 {\cf17 namespace }Catch \{\par
5595 \par
5596     {\cf17 struct }AssertionReaction \{\par
5597         {\cf18 bool} shouldDebugBreak = {\cf17 false};\par
5598         {\cf18 bool} shouldThrow = {\cf17 false};\par
5599         {\cf18 bool} shouldSkip = {\cf17 false};\par
5600     \};\par
5601 \par
5602     {\cf17 class }AssertionHandler \{\par
5603         AssertionInfo m_assertionInfo;\par
5604         AssertionReaction m_reaction;\par
5605         {\cf18 bool} m_completed = {\cf17 false};\par
5606         IResultCapture& m_resultCapture;\par
5607 \par
5608     {\cf17 public}:\par
5609         AssertionHandler\par
5610             (   StringRef macroName,\par
5611                 SourceLineInfo {\cf17 const}& lineInfo,\par
5612                 StringRef capturedExpression,\par
5613                 ResultDisposition::Flags resultDisposition );\par
5614         ~AssertionHandler() \{\par
5615             {\cf19 if} ( !m_completed ) \{\par
5616                 m_resultCapture.handleIncomplete( m_assertionInfo );\par
5617             \}\par
5618         \}\par
5619 \par
5620 \par
5621         {\cf17 template}<{\cf17 typename} T>\par
5622         {\cf18 void} handleExpr( ExprLhs<T> {\cf17 const}& expr ) \{\par
5623             handleExpr( expr.makeUnaryExpr() );\par
5624         \}\par
5625         {\cf18 void} handleExpr( ITransientExpression {\cf17 const}& expr );\par
5626 \par
5627         {\cf18 void} handleMessage(ResultWas::OfType resultType, StringRef message);\par
5628 \par
5629         {\cf18 void} handleExceptionThrownAsExpected();\par
5630         {\cf18 void} handleUnexpectedExceptionNotThrown();\par
5631         {\cf18 void} handleExceptionNotThrownAsExpected();\par
5632         {\cf18 void} handleThrowingCallSkipped();\par
5633         {\cf18 void} handleUnexpectedInflightException();\par
5634 \par
5635         {\cf18 void} complete();\par
5636 \par
5637         {\cf20 // query}\par
5638         {\cf17 auto} allowThrows() const -> {\cf18 bool};\par
5639     \};\par
5640 \par
5641     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, std::{\cf18 string} const& str );\par
5642 \par
5643 \} {\cf20 // namespace Catch}\par
5644 \par
5645 {\cf21 #endif }{\cf20 // CATCH_ASSERTION_HANDLER_HPP_INCLUDED}\par
5646 \par
5647 \par
5648 {\cf21 #ifndef CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}\par
5649 {\cf21 #define CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}\par
5650 \par
5651 \par
5652 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)}\par
5653 {\cf21   #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__##_catch_sr}\par
5654 {\cf21 #else}\par
5655 {\cf21   #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"_catch_sr}\par
5656 {\cf21 #endif}\par
5657 \par
5658 {\cf21 #endif }{\cf20 // CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED}\par
5659 \par
5660 {\cf20 // We need this suppression to leak, because it took until GCC 10}\par
5661 {\cf20 // for the front end to handle local suppression via _Pragma properly}\par
5662 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ <= 9}\par
5663 {\cf21   #pragma GCC diagnostic ignored "-Wparentheses"}\par
5664 {\cf21 #endif}\par
5665 \par
5666 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
5667 \par
5668 {\cf21 #if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
5669 \par
5671 {\cf20 // Another way to speed-up compilation is to omit local try-catch for REQUIRE*}\par
5672 {\cf20 // macros.}\par
5673 {\cf21 #define INTERNAL_CATCH_TRY}\par
5674 {\cf21 #define INTERNAL_CATCH_CATCH( capturer )}\par
5675 \par
5676 {\cf21 #else }{\cf20 // CATCH_CONFIG_FAST_COMPILE}\par
5677 \par
5678 {\cf21 #define INTERNAL_CATCH_TRY try}\par
5679 {\cf21 #define INTERNAL_CATCH_CATCH( handler ) catch(...) \{ (handler).handleUnexpectedInflightException(); \}}\par
5680 \par
5681 {\cf21 #endif}\par
5682 \par
5683 {\cf21 #define INTERNAL_CATCH_REACT( handler ) handler.complete();}\par
5684 \par
5686 {\cf21 #define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \\}\par
5687 {\cf21     do \{ }{\cf20 /* NOLINT(bugprone-infinite-loop) */}{\cf21  \\}\par
5688 {\cf21         }{\cf20 /* The expression should not be evaluated, but warnings should hopefully be checked */}{\cf21  \\}\par
5689 {\cf21         CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \\}\par
5690 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
5691 {\cf21         INTERNAL_CATCH_TRY \{ \\}\par
5692 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5693 {\cf21             CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \\}\par
5694 {\cf21             catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); }{\cf20 /* NOLINT(bugprone-chained-comparison) */}{\cf21  \\}\par
5695 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5696 {\cf21         \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\}\par
5697 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5698 {\cf21     \} while( (void)0, (false) && static_cast<const bool&>( !!(__VA_ARGS__) ) ) }{\cf20 // the expression here is never evaluated at runtime but it forces the compiler to give it a look}\par
5699     {\cf20 // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.}\par
5700 \par
5702 {\cf21 #define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \\}\par
5703 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
5704 {\cf21     if( Catch::getResultCapture().lastAssertionPassed() )}\par
5705 \par
5707 {\cf21 #define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \\}\par
5708 {\cf21     INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \\}\par
5709 {\cf21     if( !Catch::getResultCapture().lastAssertionPassed() )}\par
5710 \par
5712 {\cf21 #define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \\}\par
5713 {\cf21     do \{ \\}\par
5714 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \\}\par
5715 {\cf21         try \{ \\}\par
5716 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5717 {\cf21             CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5718 {\cf21             static_cast<void>(__VA_ARGS__); \\}\par
5719 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5720 {\cf21             catchAssertionHandler.handleExceptionNotThrownAsExpected(); \\}\par
5721 {\cf21         \} \\}\par
5722 {\cf21         catch( ... ) \{ \\}\par
5723 {\cf21             catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
5724 {\cf21         \} \\}\par
5725 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5726 {\cf21     \} while( false )}\par
5727 \par
5729 {\cf21 #define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \\}\par
5730 {\cf21     do \{ \\}\par
5731 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \\}\par
5732 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5733 {\cf21             try \{ \\}\par
5734 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5735 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5736 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5737 {\cf21                 static_cast<void>(__VA_ARGS__); \\}\par
5738 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5739 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5740 {\cf21             \} \\}\par
5741 {\cf21             catch( ... ) \{ \\}\par
5742 {\cf21                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\}\par
5743 {\cf21             \} \\}\par
5744 {\cf21         else \\}\par
5745 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5746 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5747 {\cf21     \} while( false )}\par
5748 \par
5750 {\cf21 #define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \\}\par
5751 {\cf21     do \{ \\}\par
5752 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \\}\par
5753 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5754 {\cf21             try \{ \\}\par
5755 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5756 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5757 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5758 {\cf21                 static_cast<void>(expr); \\}\par
5759 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5760 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5761 {\cf21             \} \\}\par
5762 {\cf21             catch( exceptionType const& ) \{ \\}\par
5763 {\cf21                 catchAssertionHandler.handleExceptionThrownAsExpected(); \\}\par
5764 {\cf21             \} \\}\par
5765 {\cf21             catch( ... ) \{ \\}\par
5766 {\cf21                 catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
5767 {\cf21             \} \\}\par
5768 {\cf21         else \\}\par
5769 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5770 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5771 {\cf21     \} while( false )}\par
5772 \par
5773 \par
5774 \par
5776 {\cf20 // Although this is matcher-based, it can be used with just a string}\par
5777 {\cf21 #define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \\}\par
5778 {\cf21     do \{ \\}\par
5779 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\}\par
5780 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
5781 {\cf21             try \{ \\}\par
5782 {\cf21                 CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
5783 {\cf21                 CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \\}\par
5784 {\cf21                 CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \\}\par
5785 {\cf21                 static_cast<void>(__VA_ARGS__); \\}\par
5786 {\cf21                 CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
5787 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
5788 {\cf21             \} \\}\par
5789 {\cf21             catch( ... ) \{ \\}\par
5790 {\cf21                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher ); \\}\par
5791 {\cf21             \} \\}\par
5792 {\cf21         else \\}\par
5793 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
5794 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
5795 {\cf21     \} while( false )}\par
5796 \par
5797 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE}\par
5798 \par
5799 {\cf21 #endif }{\cf20 // CATCH_TEST_MACRO_IMPL_HPP_INCLUDED}\par
5800 \par
5801 \par
5802 {\cf21 #ifndef CATCH_SECTION_HPP_INCLUDED}\par
5803 {\cf21 #define CATCH_SECTION_HPP_INCLUDED}\par
5804 \par
5805 \par
5806 \par
5807 \par
5817 {\cf21 #ifndef CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}\par
5818 {\cf21 #define CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}\par
5819 \par
5820 \par
5821 {\cf21 #if defined(__clang_analyzer__) || defined(__COVERITY__)}\par
5822 {\cf21     #define CATCH_INTERNAL_CONFIG_STATIC_ANALYSIS_SUPPORT}\par
5823 {\cf21 #endif}\par
5824 \par
5825 {\cf21 #if defined( CATCH_INTERNAL_CONFIG_STATIC_ANALYSIS_SUPPORT ) && \\}\par
5826 {\cf21     !defined( CATCH_CONFIG_NO_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT ) && \\}\par
5827 {\cf21     !defined( CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT )}\par
5828 {\cf21 #    define CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT}\par
5829 {\cf21 #endif}\par
5830 \par
5831 \par
5832 {\cf21 #endif }{\cf20 // CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED}\par
5833 \par
5834 \par
5835 {\cf21 #ifndef CATCH_TIMER_HPP_INCLUDED}\par
5836 {\cf21 #define CATCH_TIMER_HPP_INCLUDED}\par
5837 \par
5838 {\cf21 #include <cstdint>}\par
5839 \par
5840 {\cf17 namespace }Catch \{\par
5841 \par
5842     {\cf17 class }Timer \{\par
5843         uint64_t m_nanoseconds = 0;\par
5844     {\cf17 public}:\par
5845         {\cf18 void} start();\par
5846         {\cf17 auto} getElapsedNanoseconds() {\cf17 const} -> uint64_t;\par
5847         {\cf17 auto} getElapsedMicroseconds() {\cf17 const} -> uint64_t;\par
5848         {\cf17 auto} getElapsedMilliseconds() {\cf17 const} -> {\cf18 unsigned} int;\par
5849         {\cf17 auto} getElapsedSeconds() {\cf17 const} -> double;\par
5850     \};\par
5851 \par
5852 \} {\cf20 // namespace Catch}\par
5853 \par
5854 {\cf21 #endif }{\cf20 // CATCH_TIMER_HPP_INCLUDED}\par
5855 \par
5856 {\cf17 namespace }Catch \{\par
5857 \par
5858     {\cf17 class }Section : Detail::NonCopyable \{\par
5859     {\cf17 public}:\par
5860         Section( SectionInfo&& info );\par
5861         Section( SourceLineInfo {\cf17 const}& _lineInfo,\par
5862                  StringRef _name,\par
5863                  {\cf17 const} {\cf18 char}* {\cf17 const} = {\cf17 nullptr} );\par
5864         ~Section();\par
5865 \par
5866         {\cf20 // This indicates whether the section should be executed or not}\par
5867         {\cf17 explicit} {\cf17 operator} bool() {\cf17 const};\par
5868 \par
5869     {\cf17 private}:\par
5870         SectionInfo m_info;\par
5871 \par
5872         Counts m_assertions;\par
5873         {\cf18 bool} m_sectionIncluded;\par
5874         Timer m_timer;\par
5875     \};\par
5876 \par
5877 \} {\cf20 // end namespace Catch}\par
5878 \par
5879 {\cf21 #if !defined(CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT)}\par
5880 {\cf21 #    define INTERNAL_CATCH_SECTION( ... )                                 \\}\par
5881 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                         \\}\par
5882 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                  \\}\par
5883 {\cf21         if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(            \\}\par
5884 {\cf21                  catch_internal_Section ) =                               \\}\par
5885 {\cf21                  Catch::Section( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \\}\par
5886 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5887 \par
5888 {\cf21 #    define INTERNAL_CATCH_DYNAMIC_SECTION( ... )                     \\}\par
5889 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                     \\}\par
5890 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS              \\}\par
5891 {\cf21         if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(        \\}\par
5892 {\cf21                  catch_internal_Section ) =                           \\}\par
5893 {\cf21                  Catch::SectionInfo(                                  \\}\par
5894 {\cf21                      CATCH_INTERNAL_LINEINFO,                         \\}\par
5895 {\cf21                      ( Catch::ReusableStringStream() << __VA_ARGS__ ) \\}\par
5896 {\cf21                          .str() ) )                                   \\}\par
5897 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5898 \par
5899 {\cf21 #else}\par
5900 \par
5901 {\cf20 // These section definitions imply that at most one section at one level}\par
5902 {\cf20 // will be intered (because only one section's __LINE__ can be equal to}\par
5903 {\cf20 // the dummy `catchInternalSectionHint` variable from `TEST_CASE`).}\par
5904 \par
5905 {\cf17 namespace }Catch \{\par
5906     {\cf17 namespace }Detail \{\par
5907         {\cf20 // Intentionally without linkage, as it should only be used as a dummy}\par
5908         {\cf20 // symbol for static analysis.}\par
5909         {\cf20 // The arguments are used as a dummy for checking warnings in the passed}\par
5910         {\cf20 // expressions.}\par
5911         {\cf18 int} GetNewSectionHint( StringRef, {\cf17 const} {\cf18 char}* {\cf17 const} = {\cf17 nullptr} );\par
5912     \} {\cf20 // namespace Detail}\par
5913 \} {\cf20 // namespace Catch}\par
5914 \par
5915 \par
5916 {\cf21 #    define INTERNAL_CATCH_SECTION( ... )                                   \\}\par
5917 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                           \\}\par
5918 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                    \\}\par
5919 {\cf21         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\}\par
5920 {\cf21         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\}\par
5921 {\cf21                  catchInternalSectionHint,                                  \\}\par
5922 {\cf21              catchInternalSectionHint =                                     \\}\par
5923 {\cf21                  Catch::Detail::GetNewSectionHint(__VA_ARGS__);             \\}\par
5924 {\cf21              catchInternalPreviousSectionHint == __LINE__ )                 \\}\par
5925 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5926 \par
5927 {\cf21 #    define INTERNAL_CATCH_DYNAMIC_SECTION( ... )                           \\}\par
5928 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                           \\}\par
5929 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                    \\}\par
5930 {\cf21         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \\}\par
5931 {\cf21         if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \\}\par
5932 {\cf21                  catchInternalSectionHint,                                  \\}\par
5933 {\cf21              catchInternalSectionHint = Catch::Detail::GetNewSectionHint(   \\}\par
5934 {\cf21                 ( Catch::ReusableStringStream() << __VA_ARGS__ ).str());    \\}\par
5935 {\cf21              catchInternalPreviousSectionHint == __LINE__ )                 \\}\par
5936 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
5937 \par
5938 {\cf21 #endif}\par
5939 \par
5940 \par
5941 {\cf21 #endif }{\cf20 // CATCH_SECTION_HPP_INCLUDED}\par
5942 \par
5943 \par
5944 {\cf21 #ifndef CATCH_TEST_REGISTRY_HPP_INCLUDED}\par
5945 {\cf21 #define CATCH_TEST_REGISTRY_HPP_INCLUDED}\par
5946 \par
5947 \par
5948 \par
5949 {\cf21 #ifndef CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}\par
5950 {\cf21 #define CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}\par
5951 \par
5952 {\cf17 namespace }Catch \{\par
5953 \par
5954     {\cf17 class }ITestInvoker \{\par
5955     {\cf17 public}:\par
5956         {\cf17 virtual} {\cf18 void} invoke() {\cf17 const} = 0;\par
5957         {\cf17 virtual} ~ITestInvoker(); {\cf20 // = default}\par
5958     \};\par
5959 \par
5960 \} {\cf20 // namespace Catch}\par
5961 \par
5962 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED}\par
5963 \par
5964 \par
5965 {\cf21 #ifndef CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}\par
5966 {\cf21 #define CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}\par
5967 \par
5968 {\cf21 #define INTERNAL_CATCH_EXPAND1( param ) INTERNAL_CATCH_EXPAND2( param )}\par
5969 {\cf21 #define INTERNAL_CATCH_EXPAND2( ... ) INTERNAL_CATCH_NO##__VA_ARGS__}\par
5970 {\cf21 #define INTERNAL_CATCH_DEF( ... ) INTERNAL_CATCH_DEF __VA_ARGS__}\par
5971 {\cf21 #define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF}\par
5972 \par
5973 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS( ... ) \\}\par
5974 {\cf21     INTERNAL_CATCH_EXPAND1( INTERNAL_CATCH_DEF __VA_ARGS__ )}\par
5975 \par
5976 {\cf21 #endif }{\cf20 // CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED}\par
5977 \par
5978 {\cf20 // GCC 5 and older do not properly handle disabling unused-variable warning}\par
5979 {\cf20 // with a _Pragma. This means that we have to leak the suppression to the}\par
5980 {\cf20 // user code as well :-(}\par
5981 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5}\par
5982 {\cf21 #pragma GCC diagnostic ignored "-Wunused-variable"}\par
5983 {\cf21 #endif}\par
5984 \par
5985 \par
5986 \par
5987 {\cf17 namespace }Catch \{\par
5988 \par
5989 {\cf17 template}<{\cf17 typename} C>\par
5990 {\cf17 class }TestInvokerAsMethod : {\cf17 public} ITestInvoker \{\par
5991     void (C::*m_testAsMethod)();\par
5992 {\cf17 public}:\par
5993     TestInvokerAsMethod( {\cf18 void} (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) \{\}\par
5994 \par
5995     {\cf18 void} invoke(){\cf17  const override }\{\par
5996         C obj;\par
5997         (obj.*m_testAsMethod)();\par
5998     \}\par
5999 \};\par
6000 \par
6001 Detail::unique_ptr<ITestInvoker> makeTestInvoker( {\cf18 void}(*testAsFunction)() );\par
6002 \par
6003 {\cf17 template}<{\cf17 typename} C>\par
6004 Detail::unique_ptr<ITestInvoker> makeTestInvoker( {\cf18 void} (C::*testAsMethod)() ) \{\par
6005     {\cf19 return} Detail::make_unique<TestInvokerAsMethod<C>>( testAsMethod );\par
6006 \}\par
6007 \par
6008 {\cf17 struct }NameAndTags \{\par
6009     {\cf17 constexpr} NameAndTags( StringRef name_ = StringRef(),\par
6010                            StringRef tags_ = StringRef() ) noexcept:\par
6011         name( name_ ), tags( tags_ ) \{\}\par
6012     StringRef name;\par
6013     StringRef tags;\par
6014 \};\par
6015 \par
6016 {\cf17 struct }AutoReg : Detail::NonCopyable \{\par
6017     AutoReg( Detail::unique_ptr<ITestInvoker> invoker, SourceLineInfo {\cf17 const}& lineInfo, StringRef classOrMethod, NameAndTags {\cf17 const}& nameAndTags ) {\cf17 noexcept};\par
6018 \};\par
6019 \par
6020 \} {\cf20 // end namespace Catch}\par
6021 \par
6022 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
6023 {\cf21     #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \\}\par
6024 {\cf21         static inline void TestName()}\par
6025 {\cf21     #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \\}\par
6026 {\cf21         namespace\{                        \\}\par
6027 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) \{ \\}\par
6028 {\cf21                 void test();              \\}\par
6029 {\cf21             \};                            \\}\par
6030 {\cf21         \}                                 \\}\par
6031 {\cf21         void TestName::test()}\par
6032 {\cf21 #endif}\par
6033 \par
6034 \par
6035 {\cf21 #if !defined(CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT)}\par
6036 \par
6038 {\cf21     #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \\}\par
6039 {\cf21         static void TestName(); \\}\par
6040 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6041 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6042 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6043 {\cf21         namespace\{ const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); \} }{\cf20 /* NOLINT */}{\cf21  \\}\par
6044 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6045 {\cf21         static void TestName()}\par
6046 {\cf21     #define INTERNAL_CATCH_TESTCASE( ... ) \\}\par
6047 {\cf21         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__ )}\par
6048 \par
6049 {\cf21 #else  }{\cf20 // ^^ !CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT | vv CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT}\par
6050 \par
6051 \par
6052 {\cf20 // Dummy registrator for the dumy test case macros}\par
6053 {\cf17 namespace }Catch \{\par
6054     {\cf17 namespace }Detail \{\par
6055         {\cf17 struct }DummyUse \{\par
6056             DummyUse( {\cf18 void} ( * )( {\cf18 int} ), Catch::NameAndTags {\cf17 const}& );\par
6057         \};\par
6058     \} {\cf20 // namespace Detail}\par
6059 \} {\cf20 // namespace Catch}\par
6060 \par
6061 {\cf20 // Note that both the presence of the argument and its exact name are}\par
6062 {\cf20 // necessary for the section support.}\par
6063 \par
6064 {\cf20 // We provide a shadowed variable so that a `SECTION` inside non-`TEST_CASE`}\par
6065 {\cf20 // tests can compile. The redefined `TEST_CASE` shadows this with param.}\par
6066 {\cf17 static} {\cf18 int} catchInternalSectionHint = 0;\par
6067 \par
6068 {\cf21 #    define INTERNAL_CATCH_TESTCASE2( fname, ... )                         \\}\par
6069 {\cf21         static void fname( int );                                          \\}\par
6070 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \\}\par
6071 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \\}\par
6072 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                   \\}\par
6073 {\cf21         static const Catch::Detail::DummyUse INTERNAL_CATCH_UNIQUE_NAME(   \\}\par
6074 {\cf21             dummyUser )( &(fname), Catch::NameAndTags\{ __VA_ARGS__ \} );    \\}\par
6075 {\cf21         CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                            \\}\par
6076 {\cf21         static void fname( [[maybe_unused]] int catchInternalSectionHint ) \\}\par
6077 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
6078 {\cf21 #    define INTERNAL_CATCH_TESTCASE( ... ) \\}\par
6079 {\cf21         INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ), __VA_ARGS__ )}\par
6080 \par
6081 \par
6082 {\cf21 #endif }{\cf20 // CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT}\par
6083 \par
6085 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\\}\par
6086 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6087 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6088 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6089 {\cf21         namespace\{ \\}\par
6090 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) \{ \\}\par
6091 {\cf21                 void test(); \\}\par
6092 {\cf21             \}; \\}\par
6093 {\cf21             const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\}\par
6094 {\cf21             Catch::makeTestInvoker( &TestName::test ),                    \\}\par
6095 {\cf21             CATCH_INTERNAL_LINEINFO,                                      \\}\par
6096 {\cf21             #ClassName##_catch_sr,                                        \\}\par
6097 {\cf21             Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
6098 {\cf21         \} \\}\par
6099 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6100 {\cf21         void TestName::test()}\par
6101 {\cf21     #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \\}\par
6102 {\cf21         INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), ClassName, __VA_ARGS__ )}\par
6103 \par
6104 \par
6106 {\cf21     #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \\}\par
6107 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6108 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6109 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6110 {\cf21         namespace \{                                                           \\}\par
6111 {\cf21         const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \\}\par
6112 {\cf21             Catch::makeTestInvoker( &QualifiedMethod ),                   \\}\par
6113 {\cf21             CATCH_INTERNAL_LINEINFO,                                      \\}\par
6114 {\cf21             "&" #QualifiedMethod##_catch_sr,                              \\}\par
6115 {\cf21             Catch::NameAndTags\{ __VA_ARGS__ \} );                          \\}\par
6116 {\cf21     \} }{\cf20 /* NOLINT */}{\cf21  \\}\par
6117 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
6118 \par
6119 \par
6121 {\cf21     #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \\}\par
6122 {\cf21         do \{ \\}\par
6123 {\cf21             CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6124 {\cf21             CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6125 {\cf21             CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6126 {\cf21             Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ __VA_ARGS__ \} ); }{\cf20 /* NOLINT */}{\cf21  \\}\par
6127 {\cf21             CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6128 {\cf21         \} while(false)}\par
6129 \par
6130 \par
6131 {\cf21 #endif }{\cf20 // CATCH_TEST_REGISTRY_HPP_INCLUDED}\par
6132 \par
6133 \par
6134 {\cf20 // All of our user-facing macros support configuration toggle, that}\par
6135 {\cf20 // forces them to be defined prefixed with CATCH_. We also like to}\par
6136 {\cf20 // support another toggle that can minimize (disable) their implementation.}\par
6137 {\cf20 // Given this, we have 4 different configuration options below}\par
6138 \par
6139 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
6140 \par
6141 {\cf21   #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6142 {\cf21   #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6143 \par
6144 {\cf21   #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6145 {\cf21   #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )}\par
6146 {\cf21   #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6147 \par
6148 {\cf21   #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6149 {\cf21   #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6150 {\cf21   #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6151 {\cf21   #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6152 {\cf21   #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6153 \par
6154 {\cf21   #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6155 {\cf21   #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}\par
6156 {\cf21   #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6157 \par
6158 {\cf21   #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )}\par
6159 {\cf21   #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6160 {\cf21   #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )}\par
6161 {\cf21   #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )}\par
6162 {\cf21   #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )}\par
6163 {\cf21   #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )}\par
6164 {\cf21   #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6165 {\cf21   #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6166 {\cf21   #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6167 {\cf21   #define CATCH_SKIP( ... ) INTERNAL_CATCH_MSG( "SKIP", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6168 \par
6169 \par
6170 {\cf21   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)}\par
6171 {\cf21     #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )}\par
6172 {\cf21     #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )}\par
6173 {\cf21     #define CATCH_STATIC_CHECK( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )}\par
6174 {\cf21     #define CATCH_STATIC_CHECK_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )}\par
6175 {\cf21   #else}\par
6176 {\cf21     #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )}\par
6177 {\cf21     #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )}\par
6178 {\cf21     #define CATCH_STATIC_CHECK( ... )       CATCH_CHECK( __VA_ARGS__ )}\par
6179 {\cf21     #define CATCH_STATIC_CHECK_FALSE( ... ) CATCH_CHECK_FALSE( __VA_ARGS__ )}\par
6180 {\cf21   #endif}\par
6181 \par
6182 \par
6183   {\cf20 // "BDD-style" convenience wrappers}\par
6184 {\cf21   #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )}\par
6185 {\cf21   #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )}\par
6186 {\cf21   #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )}\par
6187 {\cf21   #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )}\par
6188 {\cf21   #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )}\par
6189 {\cf21   #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )}\par
6190 {\cf21   #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )}\par
6191 {\cf21   #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )}\par
6192 \par
6193 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) }{\cf20 // ^^ prefixed, implemented | vv prefixed, disabled}\par
6194 \par
6195 {\cf21   #define CATCH_REQUIRE( ... )        (void)(0)}\par
6196 {\cf21   #define CATCH_REQUIRE_FALSE( ... )  (void)(0)}\par
6197 \par
6198 {\cf21   #define CATCH_REQUIRE_THROWS( ... ) (void)(0)}\par
6199 {\cf21   #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6200 {\cf21   #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)}\par
6201 \par
6202 {\cf21   #define CATCH_CHECK( ... )         (void)(0)}\par
6203 {\cf21   #define CATCH_CHECK_FALSE( ... )   (void)(0)}\par
6204 {\cf21   #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)}\par
6205 {\cf21   #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))}\par
6206 {\cf21   #define CATCH_CHECK_NOFAIL( ... )  (void)(0)}\par
6207 \par
6208 {\cf21   #define CATCH_CHECK_THROWS( ... )  (void)(0)}\par
6209 {\cf21   #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6210 {\cf21   #define CATCH_CHECK_NOTHROW( ... ) (void)(0)}\par
6211 \par
6212 {\cf21   #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6213 {\cf21   #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6214 {\cf21   #define CATCH_METHOD_AS_TEST_CASE( method, ... )}\par
6215 {\cf21   #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)}\par
6216 {\cf21   #define CATCH_SECTION( ... )}\par
6217 {\cf21   #define CATCH_DYNAMIC_SECTION( ... )}\par
6218 {\cf21   #define CATCH_FAIL( ... ) (void)(0)}\par
6219 {\cf21   #define CATCH_FAIL_CHECK( ... ) (void)(0)}\par
6220 {\cf21   #define CATCH_SUCCEED( ... ) (void)(0)}\par
6221 {\cf21   #define CATCH_SKIP( ... ) (void)(0)}\par
6222 \par
6223 {\cf21   #define CATCH_STATIC_REQUIRE( ... )       (void)(0)}\par
6224 {\cf21   #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)}\par
6225 {\cf21   #define CATCH_STATIC_CHECK( ... )       (void)(0)}\par
6226 {\cf21   #define CATCH_STATIC_CHECK_FALSE( ... ) (void)(0)}\par
6227 \par
6228   {\cf20 // "BDD-style" convenience wrappers}\par
6229 {\cf21   #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6230 {\cf21   #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), className )}\par
6231 {\cf21   #define CATCH_GIVEN( desc )}\par
6232 {\cf21   #define CATCH_AND_GIVEN( desc )}\par
6233 {\cf21   #define CATCH_WHEN( desc )}\par
6234 {\cf21   #define CATCH_AND_WHEN( desc )}\par
6235 {\cf21   #define CATCH_THEN( desc )}\par
6236 {\cf21   #define CATCH_AND_THEN( desc )}\par
6237 \par
6238 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE) }{\cf20 // ^^ prefixed, disabled | vv unprefixed, implemented}\par
6239 \par
6240 {\cf21   #define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )}\par
6241 {\cf21   #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6242 \par
6243 {\cf21   #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6244 {\cf21   #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )}\par
6245 {\cf21   #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6246 \par
6247 {\cf21   #define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6248 {\cf21   #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )}\par
6249 {\cf21   #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6250 {\cf21   #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6251 {\cf21   #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )}\par
6252 \par
6253 {\cf21   #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6254 {\cf21   #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}\par
6255 {\cf21   #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6256 \par
6257 {\cf21   #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )}\par
6258 {\cf21   #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6259 {\cf21   #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )}\par
6260 {\cf21   #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )}\par
6261 {\cf21   #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )}\par
6262 {\cf21   #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )}\par
6263 {\cf21   #define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6264 {\cf21   #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6265 {\cf21   #define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )}\par
6266 {\cf21   #define SKIP( ... ) INTERNAL_CATCH_MSG( "SKIP", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )}\par
6267 \par
6268 \par
6269 {\cf21   #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)}\par
6270 {\cf21     #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )}\par
6271 {\cf21     #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )}\par
6272 {\cf21     #define STATIC_CHECK( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )}\par
6273 {\cf21     #define STATIC_CHECK_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )}\par
6274 {\cf21   #else}\par
6275 {\cf21     #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )}\par
6276 {\cf21     #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )}\par
6277 {\cf21     #define STATIC_CHECK( ... )       CHECK( __VA_ARGS__ )}\par
6278 {\cf21     #define STATIC_CHECK_FALSE( ... ) CHECK_FALSE( __VA_ARGS__ )}\par
6279 {\cf21   #endif}\par
6280 \par
6281   {\cf20 // "BDD-style" convenience wrappers}\par
6282 {\cf21   #define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )}\par
6283 {\cf21   #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )}\par
6284 {\cf21   #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )}\par
6285 {\cf21   #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )}\par
6286 {\cf21   #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )}\par
6287 {\cf21   #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )}\par
6288 {\cf21   #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )}\par
6289 {\cf21   #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )}\par
6290 \par
6291 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) }{\cf20 // ^^ unprefixed, implemented | vv unprefixed, disabled}\par
6292 \par
6293 {\cf21   #define REQUIRE( ... )       (void)(0)}\par
6294 {\cf21   #define REQUIRE_FALSE( ... ) (void)(0)}\par
6295 \par
6296 {\cf21   #define REQUIRE_THROWS( ... ) (void)(0)}\par
6297 {\cf21   #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6298 {\cf21   #define REQUIRE_NOTHROW( ... ) (void)(0)}\par
6299 \par
6300 {\cf21   #define CHECK( ... ) (void)(0)}\par
6301 {\cf21   #define CHECK_FALSE( ... ) (void)(0)}\par
6302 {\cf21   #define CHECKED_IF( ... ) if (__VA_ARGS__)}\par
6303 {\cf21   #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))}\par
6304 {\cf21   #define CHECK_NOFAIL( ... ) (void)(0)}\par
6305 \par
6306 {\cf21   #define CHECK_THROWS( ... )  (void)(0)}\par
6307 {\cf21   #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)}\par
6308 {\cf21   #define CHECK_NOTHROW( ... ) (void)(0)}\par
6309 \par
6310 {\cf21   #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__)}\par
6311 {\cf21   #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))}\par
6312 {\cf21   #define METHOD_AS_TEST_CASE( method, ... )}\par
6313 {\cf21   #define REGISTER_TEST_CASE( Function, ... ) (void)(0)}\par
6314 {\cf21   #define SECTION( ... )}\par
6315 {\cf21   #define DYNAMIC_SECTION( ... )}\par
6316 {\cf21   #define FAIL( ... ) (void)(0)}\par
6317 {\cf21   #define FAIL_CHECK( ... ) (void)(0)}\par
6318 {\cf21   #define SUCCEED( ... ) (void)(0)}\par
6319 {\cf21   #define SKIP( ... ) (void)(0)}\par
6320 \par
6321 {\cf21   #define STATIC_REQUIRE( ... )       (void)(0)}\par
6322 {\cf21   #define STATIC_REQUIRE_FALSE( ... ) (void)(0)}\par
6323 {\cf21   #define STATIC_CHECK( ... )       (void)(0)}\par
6324 {\cf21   #define STATIC_CHECK_FALSE( ... ) (void)(0)}\par
6325 \par
6326   {\cf20 // "BDD-style" convenience wrappers}\par
6327 {\cf21   #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ) )}\par
6328 {\cf21   #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), className )}\par
6329 \par
6330 {\cf21   #define GIVEN( desc )}\par
6331 {\cf21   #define AND_GIVEN( desc )}\par
6332 {\cf21   #define WHEN( desc )}\par
6333 {\cf21   #define AND_WHEN( desc )}\par
6334 {\cf21   #define THEN( desc )}\par
6335 {\cf21   #define AND_THEN( desc )}\par
6336 \par
6337 {\cf21 #endif }{\cf20 // ^^ unprefixed, disabled}\par
6338 \par
6339 {\cf20 // end of user facing macros}\par
6340 \par
6341 {\cf21 #endif }{\cf20 // CATCH_TEST_MACROS_HPP_INCLUDED}\par
6342 \par
6343 \par
6344 {\cf21 #ifndef CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}\par
6345 {\cf21 #define CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}\par
6346 \par
6347 \par
6348 \par
6349 {\cf21 #ifndef CATCH_PREPROCESSOR_HPP_INCLUDED}\par
6350 {\cf21 #define CATCH_PREPROCESSOR_HPP_INCLUDED}\par
6351 \par
6352 \par
6353 {\cf21 #if defined(__GNUC__)}\par
6354 {\cf20 // We need to silence "empty __VA_ARGS__ warning", and using just _Pragma does not work}\par
6355 {\cf21 #pragma GCC system_header}\par
6356 {\cf21 #endif}\par
6357 \par
6358 \par
6359 {\cf21 #define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__}\par
6360 {\cf21 #define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))}\par
6361 {\cf21 #define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))}\par
6362 {\cf21 #define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))}\par
6363 {\cf21 #define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))}\par
6364 {\cf21 #define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))}\par
6365 \par
6366 {\cf21 #ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6367 {\cf21 #define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__}\par
6368 {\cf20 // MSVC needs more evaluations}\par
6369 {\cf21 #define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))}\par
6370 {\cf21 #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))}\par
6371 {\cf21 #else}\par
6372 {\cf21 #define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)}\par
6373 {\cf21 #endif}\par
6374 \par
6375 {\cf21 #define CATCH_REC_END(...)}\par
6376 {\cf21 #define CATCH_REC_OUT}\par
6377 \par
6378 {\cf21 #define CATCH_EMPTY()}\par
6379 {\cf21 #define CATCH_DEFER(id) id CATCH_EMPTY()}\par
6380 \par
6381 {\cf21 #define CATCH_REC_GET_END2() 0, CATCH_REC_END}\par
6382 {\cf21 #define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2}\par
6383 {\cf21 #define CATCH_REC_GET_END(...) CATCH_REC_GET_END1}\par
6384 {\cf21 #define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT}\par
6385 {\cf21 #define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)}\par
6386 {\cf21 #define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)}\par
6387 \par
6388 {\cf21 #define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )}\par
6389 {\cf21 #define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )}\par
6390 {\cf21 #define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )}\par
6391 \par
6392 {\cf21 #define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )}\par
6393 {\cf21 #define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )}\par
6394 {\cf21 #define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )}\par
6395 \par
6396 {\cf20 // Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,}\par
6397 {\cf20 // and passes userdata as the first parameter to each invocation,}\par
6398 {\cf20 // e.g. CATCH_REC_LIST_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)}\par
6399 {\cf21 #define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))}\par
6400 \par
6401 {\cf21 #define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))}\par
6402 \par
6403 {\cf21 #define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)}\par
6404 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6405 {\cf21 #define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__}\par
6406 {\cf21 #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))}\par
6407 {\cf21 #else}\par
6408 {\cf20 // MSVC is adding extra space and needs another indirection to expand INTERNAL_CATCH_NOINTERNAL_CATCH_DEF}\par
6409 {\cf21 #define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)}\par
6410 {\cf21 #define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__}\par
6411 {\cf21 #define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)}\par
6412 {\cf21 #endif}\par
6413 \par
6414 {\cf21 #define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__}\par
6415 {\cf21 #define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)}\par
6416 \par
6417 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6418 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())}\par
6419 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))}\par
6420 {\cf21 #else}\par
6421 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))}\par
6422 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))}\par
6423 {\cf21 #endif}\par
6424 \par
6425 {\cf21 #define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\\}\par
6426 {\cf21     CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)}\par
6427 \par
6428 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)}\par
6429 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)}\par
6430 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)}\par
6431 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)}\par
6432 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)}\par
6433 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)}\par
6434 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)}\par
6435 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)}\par
6436 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)}\par
6437 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)}\par
6438 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)}\par
6439 \par
6440 {\cf21 #define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N}\par
6441 \par
6442 {\cf21 #define INTERNAL_CATCH_TYPE_GEN\\}\par
6443 {\cf21     template<typename...> struct TypeList \{\};\\}\par
6444 {\cf21     template<typename...Ts>\\}\par
6445 {\cf21     constexpr auto get_wrapper() noexcept -> TypeList<Ts...> \{ return \{\}; \}\\}\par
6446 {\cf21     template<template<typename...> class...> struct TemplateTypeList\{\};\\}\par
6447 {\cf21     template<template<typename...> class...Cs>\\}\par
6448 {\cf21     constexpr auto get_wrapper() noexcept -> TemplateTypeList<Cs...> \{ return \{\}; \}\\}\par
6449 {\cf21     template<typename...>\\}\par
6450 {\cf21     struct append;\\}\par
6451 {\cf21     template<typename...>\\}\par
6452 {\cf21     struct rewrap;\\}\par
6453 {\cf21     template<template<typename...> class, typename...>\\}\par
6454 {\cf21     struct create;\\}\par
6455 {\cf21     template<template<typename...> class, typename>\\}\par
6456 {\cf21     struct convert;\\}\par
6457 {\cf21     \\}\par
6458 {\cf21     template<typename T> \\}\par
6459 {\cf21     struct append<T> \{ using type = T; \};\\}\par
6460 {\cf21     template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\\}\par
6461 {\cf21     struct append<L1<E1...>, L2<E2...>, Rest...> \{ using type = typename append<L1<E1...,E2...>, Rest...>::type; \};\\}\par
6462 {\cf21     template< template<typename...> class L1, typename...E1, typename...Rest>\\}\par
6463 {\cf21     struct append<L1<E1...>, TypeList<mpl_::na>, Rest...> \{ using type = L1<E1...>; \};\\}\par
6464 {\cf21     \\}\par
6465 {\cf21     template< template<typename...> class Container, template<typename...> class List, typename...elems>\\}\par
6466 {\cf21     struct rewrap<TemplateTypeList<Container>, List<elems...>> \{ using type = TypeList<Container<elems...>>; \};\\}\par
6467 {\cf21     template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\\}\par
6468 {\cf21     struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> \{ using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; \};\\}\par
6469 {\cf21     \\}\par
6470 {\cf21     template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\\}\par
6471 {\cf21     struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; \};\\}\par
6472 {\cf21     template<template <typename...> class Final, template <typename...> class List, typename...Ts>\\}\par
6473 {\cf21     struct convert<Final, List<Ts...>> \{ using type = typename append<Final<>,TypeList<Ts>...>::type; \};}\par
6474 \par
6475 {\cf21 #define INTERNAL_CATCH_NTTP_1(signature, ...)\\}\par
6476 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp\{\};\\}\par
6477 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6478 {\cf21     constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> \{ return \{\}; \} \\}\par
6479 {\cf21     template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...> struct NttpTemplateTypeList\{\};\\}\par
6480 {\cf21     template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Cs>\\}\par
6481 {\cf21     constexpr auto get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> \{ return \{\}; \} \\}\par
6482 {\cf21     \\}\par
6483 {\cf21     template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6484 {\cf21     struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> \{ using type = TypeList<Container<__VA_ARGS__>>; \};\\}\par
6485 {\cf21     template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\\}\par
6486 {\cf21     struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> \{ using type = typename append<TypeList<Container<__VA_ARGS__>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; \};\\}\par
6487 {\cf21     template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\\}\par
6488 {\cf21     struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; \};}\par
6489 \par
6490 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)}\par
6491 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\\}\par
6492 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6493 {\cf21     static void TestName()}\par
6494 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\\}\par
6495 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6496 {\cf21     static void TestName()}\par
6497 \par
6498 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)}\par
6499 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\\}\par
6500 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6501 {\cf21     static void TestName()}\par
6502 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\\}\par
6503 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6504 {\cf21     static void TestName()}\par
6505 \par
6506 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\\}\par
6507 {\cf21     template<typename Type>\\}\par
6508 {\cf21     void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\\}\par
6509 {\cf21     \{\\}\par
6510 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\}\par
6511 {\cf21     \}}\par
6512 \par
6513 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\\}\par
6514 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6515 {\cf21     void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\\}\par
6516 {\cf21     \{\\}\par
6517 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\\}\par
6518 {\cf21     \}}\par
6519 \par
6520 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\\}\par
6521 {\cf21     template<typename Type>\\}\par
6522 {\cf21     void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\}\par
6523 {\cf21     \{\\}\par
6524 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\}\par
6525 {\cf21     \}}\par
6526 \par
6527 {\cf21 #define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\\}\par
6528 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\\}\par
6529 {\cf21     void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\\}\par
6530 {\cf21     \{\\}\par
6531 {\cf21         Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\\}\par
6532 {\cf21     \}}\par
6533 \par
6534 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)}\par
6535 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\\}\par
6536 {\cf21     template<typename TestType> \\}\par
6537 {\cf21     struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> \{ \\}\par
6538 {\cf21         void test();\\}\par
6539 {\cf21     \}}\par
6540 \par
6541 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\\}\par
6542 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\}\par
6543 {\cf21     struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> \{ \\}\par
6544 {\cf21         void test();\\}\par
6545 {\cf21     \}}\par
6546 \par
6547 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)}\par
6548 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\\}\par
6549 {\cf21     template<typename TestType> \\}\par
6550 {\cf21     void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()}\par
6551 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\\}\par
6552 {\cf21     template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \\}\par
6553 {\cf21     void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()}\par
6554 \par
6555 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6556 {\cf21 #define INTERNAL_CATCH_NTTP_0}\par
6557 {\cf21 #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)}\par
6558 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)}\par
6559 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)}\par
6560 {\cf21 #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)}\par
6561 {\cf21 #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)}\par
6562 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)}\par
6563 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)}\par
6564 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)}\par
6565 {\cf21 #else}\par
6566 {\cf21 #define INTERNAL_CATCH_NTTP_0(signature)}\par
6567 {\cf21 #define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))}\par
6568 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))}\par
6569 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))}\par
6570 {\cf21 #define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))}\par
6571 {\cf21 #define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))}\par
6572 {\cf21 #define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))}\par
6573 {\cf21 #define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))}\par
6574 {\cf21 #define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))}\par
6575 {\cf21 #endif}\par
6576 \par
6577 {\cf21 #endif }{\cf20 // CATCH_PREPROCESSOR_HPP_INCLUDED}\par
6578 \par
6579 \par
6580 {\cf20 // GCC 5 and older do not properly handle disabling unused-variable warning}\par
6581 {\cf20 // with a _Pragma. This means that we have to leak the suppression to the}\par
6582 {\cf20 // user code as well :-(}\par
6583 {\cf21 #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5}\par
6584 {\cf21 #pragma GCC diagnostic ignored "-Wunused-variable"}\par
6585 {\cf21 #endif}\par
6586 \par
6587 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
6588 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \\}\par
6589 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6590 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \\}\par
6591 {\cf21         namespace\{                                                                                  \\}\par
6592 {\cf21             namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) \{                                      \\}\par
6593 {\cf21             INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6594 {\cf21         \}                                                                                           \\}\par
6595 {\cf21         \}                                                                                           \\}\par
6596 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6597 \par
6598 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6599 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\}\par
6600 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ )}\par
6601 {\cf21     #else}\par
6602 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \\}\par
6603 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )}\par
6604 {\cf21     #endif}\par
6605 \par
6606 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6607 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\}\par
6608 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )}\par
6609 {\cf21     #else}\par
6610 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \\}\par
6611 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )}\par
6612 {\cf21     #endif}\par
6613 \par
6614 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6615 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\}\par
6616 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
6617 {\cf21     #else}\par
6618 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \\}\par
6619 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )}\par
6620 {\cf21     #endif}\par
6621 \par
6622 {\cf21     #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6623 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\}\par
6624 {\cf21             INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
6625 {\cf21     #else}\par
6626 {\cf21         #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \\}\par
6627 {\cf21             INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )}\par
6628 {\cf21     #endif}\par
6629 {\cf21 #endif}\par
6630 \par
6631 \par
6633 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\\}\par
6634 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6635 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6636 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6637 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6638 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6639 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6640 {\cf21         INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6641 {\cf21         namespace \{\\}\par
6642 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\}\par
6643 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6644 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6645 {\cf21             INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6646 {\cf21             template<typename...Types> \\}\par
6647 {\cf21             struct TestName\{\\}\par
6648 {\cf21                 TestName()\{\\}\par
6649 {\cf21                     size_t index = 0;                                    \\}\par
6650 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\}; }{\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}{\cf21 \\}\par
6651 {\cf21                     using expander = size_t[]; }{\cf20 /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */}{\cf21 \\}\par
6652 {\cf21                     (void)expander\{(reg_test(Types\{\}, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index]), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6653 {\cf21                 \}\\}\par
6654 {\cf21             \};\\}\par
6655 {\cf21             static const int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6656 {\cf21             TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\}\par
6657 {\cf21             return 0;\\}\par
6658 {\cf21         \}();\\}\par
6659 {\cf21         \}\\}\par
6660 {\cf21         \}\\}\par
6661 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6662 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6663 \par
6664 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6665 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\}\par
6666 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ )}\par
6667 {\cf21 #else}\par
6668 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \\}\par
6669 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )}\par
6670 {\cf21 #endif}\par
6671 \par
6672 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6673 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\}\par
6674 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )}\par
6675 {\cf21 #else}\par
6676 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \\}\par
6677 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )}\par
6678 {\cf21 #endif}\par
6679 \par
6680 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \\}\par
6681 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \\}\par
6682 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \\}\par
6683 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \\}\par
6684 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS       \\}\par
6685 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6686 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6687 {\cf21         template<typename TestType> static void TestFuncName();       \\}\par
6688 {\cf21         namespace \{\\}\par
6689 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) \{                                     \\}\par
6690 {\cf21             INTERNAL_CATCH_TYPE_GEN                                                  \\}\par
6691 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \\}\par
6692 {\cf21             template<typename... Types>                               \\}\par
6693 {\cf21             struct TestName \{                                         \\}\par
6694 {\cf21                 void reg_tests() \{                                          \\}\par
6695 {\cf21                     size_t index = 0;                                    \\}\par
6696 {\cf21                     using expander = size_t[];                           \\}\par
6697 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))\};\\}\par
6698 {\cf21                     constexpr char const* types_list[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))\};\\}\par
6699 {\cf21                     constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\\}\par
6700 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21 \\}\par
6701 {\cf21                 \}                                                     \\}\par
6702 {\cf21             \};                                                        \\}\par
6703 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{ \\}\par
6704 {\cf21                 using TestInit = typename create<TestName, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type; \\}\par
6705 {\cf21                 TestInit t;                                           \\}\par
6706 {\cf21                 t.reg_tests();                                        \\}\par
6707 {\cf21                 return 0;                                             \\}\par
6708 {\cf21             \}();                                                      \\}\par
6709 {\cf21         \}                                                             \\}\par
6710 {\cf21         \}                                                             \\}\par
6711 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \\}\par
6712 {\cf21         template<typename TestType>                                   \\}\par
6713 {\cf21         static void TestFuncName()}\par
6714 \par
6715 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6716 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\}\par
6717 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename T,__VA_ARGS__)}\par
6718 {\cf21 #else}\par
6719 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\\}\par
6720 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename T, __VA_ARGS__ ) )}\par
6721 {\cf21 #endif}\par
6722 \par
6723 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6724 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\}\par
6725 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__)}\par
6726 {\cf21 #else}\par
6727 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\\}\par
6728 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )}\par
6729 {\cf21 #endif}\par
6730 \par
6731 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\\}\par
6732 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6733 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6734 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6735 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6736 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6737 {\cf21         template<typename TestType> static void TestFunc();       \\}\par
6738 {\cf21         namespace \{\\}\par
6739 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{\\}\par
6740 {\cf21         INTERNAL_CATCH_TYPE_GEN\\}\par
6741 {\cf21         template<typename... Types>                               \\}\par
6742 {\cf21         struct TestName \{                                         \\}\par
6743 {\cf21             void reg_tests() \{                                          \\}\par
6744 {\cf21                 size_t index = 0;                                    \\}\par
6745 {\cf21                 using expander = size_t[];                           \\}\par
6746 {\cf21                 (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21 \\}\par
6747 {\cf21             \}                                                     \\}\par
6748 {\cf21         \};\\}\par
6749 {\cf21         static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{ \\}\par
6750 {\cf21                 using TestInit = typename convert<TestName, TmplList>::type; \\}\par
6751 {\cf21                 TestInit t;                                           \\}\par
6752 {\cf21                 t.reg_tests();                                        \\}\par
6753 {\cf21                 return 0;                                             \\}\par
6754 {\cf21             \}();                                                      \\}\par
6755 {\cf21         \}\}\\}\par
6756 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \\}\par
6757 {\cf21         template<typename TestType>                                   \\}\par
6758 {\cf21         static void TestFunc()}\par
6759 \par
6760 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \\}\par
6761 {\cf21         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, TmplList )}\par
6762 \par
6763 \par
6764 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \\}\par
6765 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6766 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6767 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6768 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6769 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6770 {\cf21         namespace \{\\}\par
6771 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\}\par
6772 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6773 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6774 {\cf21             INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\\}\par
6775 {\cf21             INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6776 {\cf21             template<typename...Types> \\}\par
6777 {\cf21             struct TestNameClass\{\\}\par
6778 {\cf21                 TestNameClass()\{\\}\par
6779 {\cf21                     size_t index = 0;                                    \\}\par
6780 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)\};\\}\par
6781 {\cf21                     using expander = size_t[];\\}\par
6782 {\cf21                     (void)expander\{(reg_test(Types\{\}, #ClassName, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index]), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6783 {\cf21                 \}\\}\par
6784 {\cf21             \};\\}\par
6785 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6786 {\cf21                 TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\\}\par
6787 {\cf21                 return 0;\\}\par
6788 {\cf21         \}();\\}\par
6789 {\cf21         \}\\}\par
6790 {\cf21         \}\\}\par
6791 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6792 {\cf21         INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))}\par
6793 \par
6794 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6795 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\}\par
6796 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
6797 {\cf21 #else}\par
6798 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \\}\par
6799 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )}\par
6800 {\cf21 #endif}\par
6801 \par
6802 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6803 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\}\par
6804 {\cf21         INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
6805 {\cf21 #else}\par
6806 {\cf21     #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \\}\par
6807 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )}\par
6808 {\cf21 #endif}\par
6809 \par
6810 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\\}\par
6811 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6812 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6813 {\cf21         CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \\}\par
6814 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6815 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6816 {\cf21         template<typename TestType> \\}\par
6817 {\cf21             struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) \{ \\}\par
6818 {\cf21                 void test();\\}\par
6819 {\cf21             \};\\}\par
6820 {\cf21         namespace \{\\}\par
6821 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) \{\\}\par
6822 {\cf21             INTERNAL_CATCH_TYPE_GEN                  \\}\par
6823 {\cf21             INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\\}\par
6824 {\cf21             template<typename...Types>\\}\par
6825 {\cf21             struct TestNameClass\{\\}\par
6826 {\cf21                 void reg_tests()\{\\}\par
6827 {\cf21                     std::size_t index = 0;\\}\par
6828 {\cf21                     using expander = std::size_t[];\\}\par
6829 {\cf21                     constexpr char const* tmpl_types[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))\};\\}\par
6830 {\cf21                     constexpr char const* types_list[] = \{CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))\};\\}\par
6831 {\cf21                     constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\\}\par
6832 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags\{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6833 {\cf21                 \}\\}\par
6834 {\cf21             \};\\}\par
6835 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6836 {\cf21                 using TestInit = typename create<TestNameClass, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type;\\}\par
6837 {\cf21                 TestInit t;\\}\par
6838 {\cf21                 t.reg_tests();\\}\par
6839 {\cf21                 return 0;\\}\par
6840 {\cf21             \}(); \\}\par
6841 {\cf21         \}\\}\par
6842 {\cf21         \}\\}\par
6843 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6844 {\cf21         template<typename TestType> \\}\par
6845 {\cf21         void TestName<TestType>::test()}\par
6846 \par
6847 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6848 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\}\par
6849 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )}\par
6850 {\cf21 #else}\par
6851 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\\}\par
6852 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )}\par
6853 {\cf21 #endif}\par
6854 \par
6855 {\cf21 #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6856 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\}\par
6857 {\cf21         INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )}\par
6858 {\cf21 #else}\par
6859 {\cf21     #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\\}\par
6860 {\cf21         INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )}\par
6861 {\cf21 #endif}\par
6862 \par
6863 {\cf21     #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \\}\par
6864 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
6865 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
6866 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \\}\par
6867 {\cf21         CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \\}\par
6868 {\cf21         CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \\}\par
6869 {\cf21         template<typename TestType> \\}\par
6870 {\cf21         struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) \{ \\}\par
6871 {\cf21             void test();\\}\par
6872 {\cf21         \};\\}\par
6873 {\cf21         namespace \{\\}\par
6874 {\cf21         namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName)\{ \\}\par
6875 {\cf21             INTERNAL_CATCH_TYPE_GEN\\}\par
6876 {\cf21             template<typename...Types>\\}\par
6877 {\cf21             struct TestNameClass\{\\}\par
6878 {\cf21                 void reg_tests()\{\\}\par
6879 {\cf21                     size_t index = 0;\\}\par
6880 {\cf21                     using expander = size_t[];\\}\par
6881 {\cf21                     (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName##_catch_sr, Catch::NameAndTags\{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags \} ), index++)... \};}{\cf20 /* NOLINT */}{\cf21  \\}\par
6882 {\cf21                 \}\\}\par
6883 {\cf21             \};\\}\par
6884 {\cf21             static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = []()\{\\}\par
6885 {\cf21                 using TestInit = typename convert<TestNameClass, TmplList>::type;\\}\par
6886 {\cf21                 TestInit t;\\}\par
6887 {\cf21                 t.reg_tests();\\}\par
6888 {\cf21                 return 0;\\}\par
6889 {\cf21             \}(); \\}\par
6890 {\cf21         \}\}\\}\par
6891 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
6892 {\cf21         template<typename TestType> \\}\par
6893 {\cf21         void TestName<TestType>::test()}\par
6894 \par
6895 {\cf21 #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \\}\par
6896 {\cf21         INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, TmplList )}\par
6897 \par
6898 \par
6899 {\cf21 #endif }{\cf20 // CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED}\par
6900 \par
6901 \par
6902 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
6903 \par
6904 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6905 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6906 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )}\par
6907 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6908 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6909 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )}\par
6910 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )}\par
6911 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6912 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6913 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)}\par
6914 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6915 {\cf21   #else}\par
6916 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )}\par
6917 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6918 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6919 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6920 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )}\par
6921 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6922 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6923 {\cf21     #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6924 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )}\par
6925 {\cf21     #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6926 {\cf21   #endif}\par
6927 \par
6928 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
6929 \par
6930 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6931 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)}\par
6932 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)}\par
6933 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)}\par
6934 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )}\par
6935 {\cf21   #else}\par
6936 {\cf21     #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )}\par
6937 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )}\par
6938 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6939 {\cf21     #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6940 {\cf21   #endif}\par
6941 \par
6942   {\cf20 // When disabled, these can be shared between proper preprocessor and MSVC preprocessor}\par
6943 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6944 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6945 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6946 {\cf21   #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6947 {\cf21   #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE(__VA_ARGS__)}\par
6948 {\cf21   #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6949 \par
6950 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
6951 \par
6952 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6953 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6954 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )}\par
6955 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6956 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6957 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )}\par
6958 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )}\par
6959 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6960 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )}\par
6961 {\cf21     #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)}\par
6962 {\cf21     #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6963 {\cf21   #else}\par
6964 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )}\par
6965 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6966 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6967 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6968 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )}\par
6969 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )}\par
6970 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6971 {\cf21     #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )}\par
6972 {\cf21     #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )}\par
6973 {\cf21     #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )}\par
6974 {\cf21   #endif}\par
6975 \par
6976 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
6977 \par
6978 {\cf21   #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR}\par
6979 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)}\par
6980 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)}\par
6981 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)}\par
6982 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )}\par
6983 {\cf21   #else}\par
6984 {\cf21     #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )}\par
6985 {\cf21     #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )}\par
6986 {\cf21     #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6987 {\cf21     #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )}\par
6988 {\cf21   #endif}\par
6989 \par
6990   {\cf20 // When disabled, these can be shared between proper preprocessor and MSVC preprocessor}\par
6991 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6992 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )}\par
6993 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6994 {\cf21   #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6995 {\cf21   #define TEMPLATE_LIST_TEST_CASE( ... ) TEMPLATE_TEST_CASE(__VA_ARGS__)}\par
6996 {\cf21   #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )}\par
6997 \par
6998 {\cf21 #endif }{\cf20 // end of user facing macro declarations}\par
6999 \par
7000 \par
7001 {\cf21 #endif }{\cf20 // CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED}\par
7002 \par
7003 \par
7004 {\cf21 #ifndef CATCH_TEST_CASE_INFO_HPP_INCLUDED}\par
7005 {\cf21 #define CATCH_TEST_CASE_INFO_HPP_INCLUDED}\par
7006 \par
7007 \par
7008 \par
7009 {\cf21 #include <cstdint>}\par
7010 {\cf21 #include <string>}\par
7011 {\cf21 #include <vector>}\par
7012 \par
7013 {\cf21 #ifdef __clang__}\par
7014 {\cf21 #pragma clang diagnostic push}\par
7015 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
7016 {\cf21 #endif}\par
7017 \par
7018 {\cf17 namespace }Catch \{\par
7019 \par
7027     {\cf17 struct }Tag \{\par
7028         {\cf17 constexpr} Tag(StringRef original_):\par
7029             original(original_)\par
7030         \{\}\par
7031         StringRef original;\par
7032 \par
7033         {\cf17 friend} {\cf18 bool} operator< ( Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs );\par
7034         {\cf17 friend} {\cf18 bool} operator==( Tag {\cf17 const}& lhs, Tag {\cf17 const}& rhs );\par
7035     \};\par
7036 \par
7037     {\cf17 class }ITestInvoker;\par
7038     {\cf17 struct }NameAndTags;\par
7039 \par
7040     {\cf17 enum class} TestCaseProperties : uint8_t \{\par
7041         None = 0,\par
7042         IsHidden = 1 << 1,\par
7043         ShouldFail = 1 << 2,\par
7044         MayFail = 1 << 3,\par
7045         Throws = 1 << 4,\par
7046         NonPortable = 1 << 5,\par
7047         Benchmark = 1 << 6\par
7048     \};\par
7049 \par
7059     {\cf17 struct }TestCaseInfo : Detail::NonCopyable \{\par
7060 \par
7061         TestCaseInfo(StringRef _className,\par
7062                      NameAndTags {\cf17 const}& _nameAndTags,\par
7063                      SourceLineInfo {\cf17 const}& _lineInfo);\par
7064 \par
7065         {\cf18 bool} isHidden() {\cf17 const};\par
7066         {\cf18 bool} {\cf19 throws}() {\cf17 const};\par
7067         {\cf18 bool} okToFail() {\cf17 const};\par
7068         {\cf18 bool} expectedToFail() {\cf17 const};\par
7069 \par
7070         {\cf20 // Adds the tag(s) with test's filename (for the -# flag)}\par
7071         {\cf18 void} addFilenameTag();\par
7072 \par
7074         {\cf17 friend} {\cf18 bool} operator<( TestCaseInfo {\cf17 const}& lhs,\par
7075                                TestCaseInfo {\cf17 const}& rhs );\par
7076 \par
7077 \par
7078         std::string tagsAsString() {\cf17 const};\par
7079 \par
7080         std::string name;\par
7081         StringRef className;\par
7082     {\cf17 private}:\par
7083         std::string backingTags;\par
7084         {\cf20 // Internally we copy tags to the backing storage and then add}\par
7085         {\cf20 // refs to this storage to the tags vector.}\par
7086         {\cf18 void} internalAppendTag(StringRef tagString);\par
7087     {\cf17 public}:\par
7088         std::vector<Tag> tags;\par
7089         SourceLineInfo lineInfo;\par
7090         TestCaseProperties properties = TestCaseProperties::None;\par
7091     \};\par
7092 \par
7099     {\cf17 class }TestCaseHandle \{\par
7100         TestCaseInfo* m_info;\par
7101         ITestInvoker* m_invoker;\par
7102     {\cf17 public}:\par
7103         TestCaseHandle(TestCaseInfo* info, ITestInvoker* invoker) :\par
7104             m_info(info), m_invoker(invoker) \{\}\par
7105 \par
7106         {\cf18 void} invoke(){\cf17  const }\{\par
7107             m_invoker->invoke();\par
7108         \}\par
7109 \par
7110         TestCaseInfo {\cf17 const}& getTestCaseInfo() {\cf17 const};\par
7111     \};\par
7112 \par
7113     Detail::unique_ptr<TestCaseInfo>\par
7114     makeTestCaseInfo( StringRef className,\par
7115                       NameAndTags {\cf17 const}& nameAndTags,\par
7116                       SourceLineInfo {\cf17 const}& lineInfo );\par
7117 \}\par
7118 \par
7119 {\cf21 #ifdef __clang__}\par
7120 {\cf21 #pragma clang diagnostic pop}\par
7121 {\cf21 #endif}\par
7122 \par
7123 {\cf21 #endif }{\cf20 // CATCH_TEST_CASE_INFO_HPP_INCLUDED}\par
7124 \par
7125 \par
7126 {\cf21 #ifndef CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}\par
7127 {\cf21 #define CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}\par
7128 \par
7129 \par
7130 \par
7131 {\cf21 #ifndef CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}\par
7132 {\cf21 #define CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}\par
7133 \par
7134 \par
7135 {\cf21 #include <string>}\par
7136 {\cf21 #include <vector>}\par
7137 \par
7138 {\cf17 namespace }Catch \{\par
7139     {\cf17 using }exceptionTranslateFunction = std::string(*)();\par
7140 \par
7141     {\cf17 class }IExceptionTranslator;\par
7142     {\cf17 using }ExceptionTranslators = std::vector<Detail::unique_ptr<IExceptionTranslator const>>;\par
7143 \par
7144     {\cf17 class }IExceptionTranslator \{\par
7145     {\cf17 public}:\par
7146         {\cf17 virtual} ~IExceptionTranslator(); {\cf20 // = default}\par
7147         {\cf17 virtual} std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) {\cf17 const} = 0;\par
7148     \};\par
7149 \par
7150     {\cf17 class }IExceptionTranslatorRegistry \{\par
7151     {\cf17 public}:\par
7152         {\cf17 virtual} ~IExceptionTranslatorRegistry(); {\cf20 // = default}\par
7153         {\cf17 virtual} std::string translateActiveException() {\cf17 const} = 0;\par
7154     \};\par
7155 \par
7156 \} {\cf20 // namespace Catch}\par
7157 \par
7158 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED}\par
7159 \par
7160 {\cf21 #include <exception>}\par
7161 \par
7162 {\cf17 namespace }Catch \{\par
7163     {\cf17 namespace }Detail \{\par
7164         {\cf18 void} registerTranslatorImpl(\par
7165             Detail::unique_ptr<IExceptionTranslator>&& translator );\par
7166     \}\par
7167 \par
7168     {\cf17 class }ExceptionTranslatorRegistrar \{\par
7169         {\cf17 template}<{\cf17 typename} T>\par
7170         {\cf17 class }ExceptionTranslator : {\cf17 public} IExceptionTranslator \{\par
7171         {\cf17 public}:\par
7172 \par
7173             ExceptionTranslator( std::string(*translateFunction)( T {\cf17 const}& ) )\par
7174             : m_translateFunction( translateFunction )\par
7175             \{\}\par
7176 \par
7177             std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ){\cf17  const override }\{\par
7178 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
7179                 {\cf19 try} \{\par
7180                     {\cf19 if}( it == itEnd )\par
7181                         std::rethrow_exception(std::current_exception());\par
7182                     {\cf19 else}\par
7183                         {\cf19 return} (*it)->translate( it+1, itEnd );\par
7184                 \}\par
7185                 {\cf19 catch}( T {\cf17 const}& ex ) \{\par
7186                     {\cf19 return} m_translateFunction( ex );\par
7187                 \}\par
7188 {\cf21 #else}\par
7189                 {\cf19 return} {\cf22 "You should never get here!"};\par
7190 {\cf21 #endif}\par
7191             \}\par
7192 \par
7193         {\cf17 protected}:\par
7194             std::string(*m_translateFunction)( T {\cf17 const}& );\par
7195         \};\par
7196 \par
7197     {\cf17 public}:\par
7198         {\cf17 template}<{\cf17 typename} T>\par
7199         ExceptionTranslatorRegistrar( std::string(*translateFunction)( T {\cf17 const}& ) ) \{\par
7200             Detail::registerTranslatorImpl(\par
7201                 Detail::make_unique<ExceptionTranslator<T>>(\par
7202                     translateFunction ) );\par
7203         \}\par
7204     \};\par
7205 \par
7206 \} {\cf20 // namespace Catch}\par
7207 \par
7209 {\cf21 #define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \\}\par
7210 {\cf21     static std::string translatorName( signature ); \\}\par
7211 {\cf21     CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \\}\par
7212 {\cf21     CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \\}\par
7213 {\cf21     namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); \} \\}\par
7214 {\cf21     CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \\}\par
7215 {\cf21     static std::string translatorName( signature )}\par
7216 \par
7217 {\cf21 #define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )}\par
7218 \par
7219 {\cf21 #if defined(CATCH_CONFIG_DISABLE)}\par
7220 {\cf21     #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \\}\par
7221 {\cf21             static std::string translatorName( signature )}\par
7222 {\cf21 #endif}\par
7223 \par
7224 \par
7225 {\cf20 // This macro is always prefixed}\par
7226 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
7227 {\cf21 #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )}\par
7228 {\cf21 #else}\par
7229 {\cf21 #define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )}\par
7230 {\cf21 #endif}\par
7231 \par
7232 \par
7233 {\cf21 #endif }{\cf20 // CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED}\par
7234 \par
7235 \par
7236 {\cf21 #ifndef CATCH_VERSION_HPP_INCLUDED}\par
7237 {\cf21 #define CATCH_VERSION_HPP_INCLUDED}\par
7238 \par
7239 {\cf21 #include <iosfwd>}\par
7240 \par
7241 {\cf17 namespace }Catch \{\par
7242 \par
7243     {\cf20 // Versioning information}\par
7244     {\cf17 struct }Version \{\par
7245         Version( Version {\cf17 const}& ) = {\cf17 delete};\par
7246         Version& operator=( Version {\cf17 const}& ) = {\cf17 delete};\par
7247         Version(    {\cf18 unsigned} {\cf18 int} _majorVersion,\par
7248                     {\cf18 unsigned} {\cf18 int} _minorVersion,\par
7249                     {\cf18 unsigned} {\cf18 int} _patchNumber,\par
7250                     {\cf18 char} {\cf17 const} * {\cf17 const} _branchName,\par
7251                     {\cf18 unsigned} {\cf18 int} _buildNumber );\par
7252 \par
7253         {\cf18 unsigned} {\cf18 int} {\cf17 const} majorVersion;\par
7254         {\cf18 unsigned} {\cf18 int} {\cf17 const} minorVersion;\par
7255         {\cf18 unsigned} {\cf18 int} {\cf17 const} patchNumber;\par
7256 \par
7257         {\cf20 // buildNumber is only used if branchName is not null}\par
7258         {\cf18 char} {\cf17 const} * {\cf17 const} branchName;\par
7259         {\cf18 unsigned} {\cf18 int} {\cf17 const} buildNumber;\par
7260 \par
7261         {\cf17 friend} std::ostream& operator << ( std::ostream& os, Version {\cf17 const}& version );\par
7262     \};\par
7263 \par
7264     Version {\cf17 const}& libraryVersion();\par
7265 \}\par
7266 \par
7267 {\cf21 #endif }{\cf20 // CATCH_VERSION_HPP_INCLUDED}\par
7268 \par
7269 \par
7270 {\cf21 #ifndef CATCH_VERSION_MACROS_HPP_INCLUDED}\par
7271 {\cf21 #define CATCH_VERSION_MACROS_HPP_INCLUDED}\par
7272 \par
7273 {\cf21 #define CATCH_VERSION_MAJOR 3}\par
7274 {\cf21 #define CATCH_VERSION_MINOR 6}\par
7275 {\cf21 #define CATCH_VERSION_PATCH 0}\par
7276 \par
7277 {\cf21 #endif }{\cf20 // CATCH_VERSION_MACROS_HPP_INCLUDED}\par
7278 \par
7279 \par
7293 {\cf21 #ifndef CATCH_GENERATORS_ALL_HPP_INCLUDED}\par
7294 {\cf21 #define CATCH_GENERATORS_ALL_HPP_INCLUDED}\par
7295 \par
7296 \par
7297 \par
7298 {\cf21 #ifndef CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}\par
7299 {\cf21 #define CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}\par
7300 \par
7301 {\cf21 #include <exception>}\par
7302 \par
7303 {\cf17 namespace }Catch \{\par
7304 \par
7305     {\cf20 // Exception type to be thrown when a Generator runs into an error,}\par
7306     {\cf20 // e.g. it cannot initialize the first return value based on}\par
7307     {\cf20 // runtime information}\par
7308     {\cf17 class }GeneratorException : {\cf17 public} std::exception \{\par
7309         {\cf17 const} {\cf18 char}* {\cf17 const} m_msg = {\cf22 ""};\par
7310 \par
7311     {\cf17 public}:\par
7312         GeneratorException({\cf17 const} {\cf18 char}* msg):\par
7313             m_msg(msg)\par
7314         \{\}\par
7315 \par
7316         {\cf17 const} {\cf18 char}* what() const noexcept override final;\par
7317     \};\par
7318 \par
7319 \} {\cf20 // end namespace Catch}\par
7320 \par
7321 {\cf21 #endif }{\cf20 // CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED}\par
7322 \par
7323 \par
7324 {\cf21 #ifndef CATCH_GENERATORS_HPP_INCLUDED}\par
7325 {\cf21 #define CATCH_GENERATORS_HPP_INCLUDED}\par
7326 \par
7327 \par
7328 \par
7329 {\cf21 #ifndef CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}\par
7330 {\cf21 #define CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}\par
7331 \par
7332 \par
7333 {\cf21 #include <string>}\par
7334 \par
7335 {\cf17 namespace }Catch \{\par
7336 \par
7337     {\cf17 namespace }Generators \{\par
7338         {\cf17 class }GeneratorUntypedBase \{\par
7339             {\cf20 // Caches result from `toStringImpl`, assume that when it is an}\par
7340             {\cf20 // empty string, the cache is invalidated.}\par
7341             {\cf17 mutable} std::string m_stringReprCache;\par
7342 \par
7343             {\cf20 // Counts based on `next` returning true}\par
7344             std::size_t m_currentElementIndex = 0;\par
7345 \par
7352             {\cf17 virtual} {\cf18 bool} next() = 0;\par
7353 \par
7355             {\cf17 virtual} std::string stringifyImpl() {\cf17 const} = 0;\par
7356 \par
7357         {\cf17 public}:\par
7358             GeneratorUntypedBase() = {\cf19 default};\par
7359             {\cf20 // Generation of copy ops is deprecated (and Clang will complain)}\par
7360             {\cf20 // if there is a user destructor defined}\par
7361             GeneratorUntypedBase(GeneratorUntypedBase {\cf17 const}&) = {\cf19 default};\par
7362             GeneratorUntypedBase& operator=(GeneratorUntypedBase {\cf17 const}&) = {\cf19 default};\par
7363 \par
7364             {\cf17 virtual} ~GeneratorUntypedBase(); {\cf20 // = default;}\par
7365 \par
7376             {\cf18 bool} countedNext();\par
7377 \par
7378             std::size_t currentElementIndex(){\cf17  const }\{ {\cf19 return} m_currentElementIndex; \}\par
7379 \par
7393             StringRef currentElementAsString() {\cf17 const};\par
7394         \};\par
7395         {\cf17 using }GeneratorBasePtr = Catch::Detail::unique_ptr<GeneratorUntypedBase>;\par
7396 \par
7397     \} {\cf20 // namespace Generators}\par
7398 \par
7399     {\cf17 class }IGeneratorTracker \{\par
7400     {\cf17 public}:\par
7401         {\cf17 virtual} ~IGeneratorTracker(); {\cf20 // = default;}\par
7402         {\cf17 virtual} {\cf17 auto} hasGenerator() const -> {\cf18 bool} = 0;\par
7403         virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;\par
7404         virtual {\cf18 void} setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;\par
7405     \};\par
7406 \par
7407 \} {\cf20 // namespace Catch}\par
7408 \par
7409 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED}\par
7410 \par
7411 {\cf21 #include <vector>}\par
7412 {\cf21 #include <tuple>}\par
7413 \par
7414 {\cf17 namespace }Catch \{\par
7415 \par
7416 {\cf17 namespace }Generators \{\par
7417 \par
7418 {\cf17 namespace }Detail \{\par
7419 \par
7421     [[noreturn]]\par
7422     {\cf18 void} throw_generator_exception({\cf18 char} {\cf17 const} * msg);\par
7423 \par
7424 \} {\cf20 // end namespace detail}\par
7425 \par
7426     {\cf17 template}<{\cf17 typename} T>\par
7427     {\cf17 class }IGenerator : {\cf17 public} GeneratorUntypedBase \{\par
7428         std::string stringifyImpl(){\cf17  const override }\{\par
7429             return ::Catch::Detail::stringify( get() );\par
7430         \}\par
7431 \par
7432     {\cf17 public}:\par
7433         {\cf20 // Returns the current element of the generator}\par
7434         {\cf20 //}\par
7435         {\cf20 // \\Precondition The generator is either freshly constructed,}\par
7436         {\cf20 // or the last call to `next()` returned true}\par
7437         {\cf17 virtual} T {\cf17 const}& get() {\cf17 const} = 0;\par
7438         {\cf17 using }type = T;\par
7439     \};\par
7440 \par
7441     {\cf17 template} <{\cf17 typename} T>\par
7442     {\cf17 using }GeneratorPtr = Catch::Detail::unique_ptr<IGenerator<T>>;\par
7443 \par
7444     {\cf17 template} <{\cf17 typename} T>\par
7445     {\cf17 class }GeneratorWrapper final \{\par
7446         GeneratorPtr<T> m_generator;\par
7447     {\cf17 public}:\par
7449         GeneratorWrapper(IGenerator<T>* generator):\par
7450             m_generator(generator) \{\}\par
7451         GeneratorWrapper(GeneratorPtr<T> generator):\par
7452             m_generator(CATCH_MOVE(generator)) \{\}\par
7453 \par
7454         T {\cf17 const}& get(){\cf17  const }\{\par
7455             {\cf19 return} m_generator->get();\par
7456         \}\par
7457         {\cf18 bool} next() \{\par
7458             {\cf19 return} m_generator->countedNext();\par
7459         \}\par
7460     \};\par
7461 \par
7462 \par
7463     {\cf17 template}<{\cf17 typename} T>\par
7464     {\cf17 class }SingleValueGenerator final : {\cf17 public} IGenerator<T> \{\par
7465         T m_value;\par
7466     {\cf17 public}:\par
7467         SingleValueGenerator(T {\cf17 const}& value) :\par
7468             m_value(value)\par
7469         \{\}\par
7470         SingleValueGenerator(T&& value):\par
7471             m_value(CATCH_MOVE(value))\par
7472         \{\}\par
7473 \par
7474         T {\cf17 const}& get(){\cf17  const override }\{\par
7475             {\cf19 return} m_value;\par
7476         \}\par
7477         {\cf18 bool} next(){\cf17  override }\{\par
7478             {\cf19 return} {\cf17 false};\par
7479         \}\par
7480     \};\par
7481 \par
7482     {\cf17 template}<{\cf17 typename} T>\par
7483     {\cf17 class }FixedValuesGenerator final : {\cf17 public} IGenerator<T> \{\par
7484         {\cf17 static_assert}(!std::is_same<T, bool>::value,\par
7485             {\cf22 "FixedValuesGenerator does not support bools because of std::vector<bool>"}\par
7486             {\cf22 "specialization, use SingleValue Generator instead."});\par
7487         std::vector<T> m_values;\par
7488         {\cf18 size_t} m_idx = 0;\par
7489     {\cf17 public}:\par
7490         FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) \{\}\par
7491 \par
7492         T {\cf17 const}& get(){\cf17  const override }\{\par
7493             {\cf19 return} m_values[m_idx];\par
7494         \}\par
7495         {\cf18 bool} next(){\cf17  override }\{\par
7496             ++m_idx;\par
7497             {\cf19 return} m_idx < m_values.size();\par
7498         \}\par
7499     \};\par
7500 \par
7501     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} DecayedT = std::decay_t<T>>\par
7502     GeneratorWrapper<DecayedT> value( T&& value ) \{\par
7503         {\cf19 return} GeneratorWrapper<DecayedT>(\par
7504             Catch::Detail::make_unique<SingleValueGenerator<DecayedT>>(\par
7505                 CATCH_FORWARD( value ) ) );\par
7506     \}\par
7507     {\cf17 template} <{\cf17 typename} T>\par
7508     GeneratorWrapper<T> values(std::initializer_list<T> values) \{\par
7509         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<FixedValuesGenerator<T>>(values));\par
7510     \}\par
7511 \par
7512     {\cf17 template}<{\cf17 typename} T>\par
7513     {\cf17 class }Generators : {\cf17 public} IGenerator<T> \{\par
7514         std::vector<GeneratorWrapper<T>> m_generators;\par
7515         {\cf18 size_t} m_current = 0;\par
7516 \par
7517         {\cf18 void} add_generator( GeneratorWrapper<T>&& generator ) \{\par
7518             m_generators.emplace_back( CATCH_MOVE( generator ) );\par
7519         \}\par
7520         {\cf18 void} add_generator( T {\cf17 const}& val ) \{\par
7521             m_generators.emplace_back( value( val ) );\par
7522         \}\par
7523         {\cf18 void} add_generator( T&& val ) \{\par
7524             m_generators.emplace_back( value( CATCH_MOVE( val ) ) );\par
7525         \}\par
7526         {\cf17 template} <{\cf17 typename} U>\par
7527         std::enable_if_t<!std::is_same<std::decay_t<U>, T>::value>\par
7528         add_generator( U&& val ) \{\par
7529             add_generator( T( CATCH_FORWARD( val ) ) );\par
7530         \}\par
7531 \par
7532         {\cf17 template} <{\cf17 typename} U> {\cf18 void} add_generators( U&& valueOrGenerator ) \{\par
7533             add_generator( CATCH_FORWARD( valueOrGenerator ) );\par
7534         \}\par
7535 \par
7536         {\cf17 template} <{\cf17 typename} U, {\cf17 typename}... Gs>\par
7537         {\cf18 void} add_generators( U&& valueOrGenerator, Gs&&... moreGenerators ) \{\par
7538             add_generator( CATCH_FORWARD( valueOrGenerator ) );\par
7539             add_generators( CATCH_FORWARD( moreGenerators )... );\par
7540         \}\par
7541 \par
7542     {\cf17 public}:\par
7543         {\cf17 template} <{\cf17 typename}... Gs>\par
7544         Generators(Gs &&... moreGenerators) \{\par
7545             m_generators.reserve({\cf17 sizeof}...(Gs));\par
7546             add_generators(CATCH_FORWARD(moreGenerators)...);\par
7547         \}\par
7548 \par
7549         T {\cf17 const}& get(){\cf17  const override }\{\par
7550             {\cf19 return} m_generators[m_current].get();\par
7551         \}\par
7552 \par
7553         {\cf18 bool} next(){\cf17  override }\{\par
7554             {\cf19 if} (m_current >= m_generators.size()) \{\par
7555                 {\cf19 return} {\cf17 false};\par
7556             \}\par
7557             {\cf17 const} {\cf18 bool} current_status = m_generators[m_current].next();\par
7558             {\cf19 if} (!current_status) \{\par
7559                 ++m_current;\par
7560             \}\par
7561             {\cf19 return} m_current < m_generators.size();\par
7562         \}\par
7563     \};\par
7564 \par
7565 \par
7566     {\cf17 template} <{\cf17 typename}... Ts>\par
7567     GeneratorWrapper<std::tuple<std::decay_t<Ts>...>>\par
7568     table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) \{\par
7569         {\cf19 return} values<std::tuple<Ts...>>( tuples );\par
7570     \}\par
7571 \par
7572     {\cf20 // Tag type to signal that a generator sequence should convert arguments to a specific type}\par
7573     {\cf17 template} <{\cf17 typename} T>\par
7574     {\cf17 struct }as \{\};\par
7575 \par
7576     {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Gs>\par
7577     {\cf17 auto} makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> \{\par
7578         {\cf19 return} Generators<T>(CATCH_MOVE(generator), CATCH_FORWARD(moreGenerators)...);\par
7579     \}\par
7580     {\cf17 template}<{\cf17 typename} T>\par
7581     {\cf17 auto} makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> \{\par
7582         {\cf19 return} Generators<T>(CATCH_MOVE(generator));\par
7583     \}\par
7584     {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Gs>\par
7585     {\cf17 auto} makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<std::decay_t<T>> \{\par
7586         {\cf19 return} makeGenerators( value( CATCH_FORWARD( val ) ), CATCH_FORWARD( moreGenerators )... );\par
7587     \}\par
7588     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} U, {\cf17 typename}... Gs>\par
7589     {\cf17 auto} makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> \{\par
7590         {\cf19 return} makeGenerators( value( T( CATCH_FORWARD( val ) ) ), CATCH_FORWARD( moreGenerators )... );\par
7591     \}\par
7592 \par
7593     IGeneratorTracker* acquireGeneratorTracker( StringRef generatorName,\par
7594                                                 SourceLineInfo {\cf17 const}& lineInfo );\par
7595     IGeneratorTracker* createGeneratorTracker( StringRef generatorName,\par
7596                                                SourceLineInfo lineInfo,\par
7597                                                GeneratorBasePtr&& generator );\par
7598 \par
7599     {\cf17 template}<{\cf17 typename} L>\par
7600     {\cf17 auto} generate( StringRef generatorName, SourceLineInfo {\cf17 const}& lineInfo, L {\cf17 const}& generatorExpression ) -> {\cf17 typename} {\cf17 decltype}(generatorExpression())::type \{\par
7601         {\cf17 using }UnderlyingType = {\cf17 typename} {\cf17 decltype}(generatorExpression())::type;\par
7602 \par
7603         IGeneratorTracker* tracker = acquireGeneratorTracker( generatorName, lineInfo );\par
7604         {\cf20 // Creation of tracker is delayed after generator creation, so}\par
7605         {\cf20 // that constructing generator can fail without breaking everything.}\par
7606         {\cf19 if} (!tracker) \{\par
7607             tracker = createGeneratorTracker(\par
7608                 generatorName,\par
7609                 lineInfo,\par
7610                 Catch::Detail::make_unique<Generators<UnderlyingType>>(\par
7611                     generatorExpression() ) );\par
7612         \}\par
7613 \par
7614         {\cf17 auto} {\cf17 const}& generator = {\cf17 static_cast<}IGenerator<UnderlyingType> const&{\cf17 >}( *tracker->getGenerator() );\par
7615         {\cf19 return} generator.get();\par
7616     \}\par
7617 \par
7618 \} {\cf20 // namespace Generators}\par
7619 \} {\cf20 // namespace Catch}\par
7620 \par
7621 {\cf21 #define CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL( ... ) #__VA_ARGS__##_catch_sr}\par
7622 {\cf21 #define CATCH_INTERNAL_GENERATOR_STRINGIZE(...) CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL(__VA_ARGS__)}\par
7623 \par
7624 {\cf21 #define GENERATE( ... ) \\}\par
7625 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7626 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7627 {\cf21                                  [ ]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
7628 {\cf21 #define GENERATE_COPY( ... ) \\}\par
7629 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7630 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7631 {\cf21                                  [=]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
7632 {\cf21 #define GENERATE_REF( ... ) \\}\par
7633 {\cf21     Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \\}\par
7634 {\cf21                                  CATCH_INTERNAL_LINEINFO, \\}\par
7635 {\cf21                                  [&]\{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); \} ) }{\cf20 //NOLINT(google-build-using-namespace)}\par
7636 \par
7637 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_HPP_INCLUDED}\par
7638 \par
7639 \par
7640 {\cf21 #ifndef CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}\par
7641 {\cf21 #define CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}\par
7642 \par
7643 \par
7644 {\cf21 #include <cassert>}\par
7645 \par
7646 {\cf17 namespace }Catch \{\par
7647 {\cf17 namespace }Generators \{\par
7648 \par
7649     {\cf17 template} <{\cf17 typename} T>\par
7650     {\cf17 class }TakeGenerator final : {\cf17 public} IGenerator<T> \{\par
7651         GeneratorWrapper<T> m_generator;\par
7652         {\cf18 size_t} m_returned = 0;\par
7653         {\cf18 size_t} m_target;\par
7654     {\cf17 public}:\par
7655         TakeGenerator({\cf18 size_t} target, GeneratorWrapper<T>&& generator):\par
7656             m_generator(CATCH_MOVE(generator)),\par
7657             m_target(target)\par
7658         \{\par
7659             assert(target != 0 && {\cf22 "Empty generators are not allowed"});\par
7660         \}\par
7661         T {\cf17 const}& get(){\cf17  const override }\{\par
7662             {\cf19 return} m_generator.get();\par
7663         \}\par
7664         {\cf18 bool} next(){\cf17  override }\{\par
7665             ++m_returned;\par
7666             {\cf19 if} (m_returned >= m_target) \{\par
7667                 {\cf19 return} {\cf17 false};\par
7668             \}\par
7669 \par
7670             {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7671             {\cf20 // If the underlying generator does not contain enough values}\par
7672             {\cf20 // then we cut short as well}\par
7673             {\cf19 if} (!success) \{\par
7674                 m_returned = m_target;\par
7675             \}\par
7676             {\cf19 return} success;\par
7677         \}\par
7678     \};\par
7679 \par
7680     {\cf17 template} <{\cf17 typename} T>\par
7681     GeneratorWrapper<T> take({\cf18 size_t} target, GeneratorWrapper<T>&& generator) \{\par
7682         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<TakeGenerator<T>>(target, CATCH_MOVE(generator)));\par
7683     \}\par
7684 \par
7685 \par
7686     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Predicate>\par
7687     {\cf17 class }FilterGenerator final : {\cf17 public} IGenerator<T> \{\par
7688         GeneratorWrapper<T> m_generator;\par
7689         Predicate m_predicate;\par
7690     {\cf17 public}:\par
7691         {\cf17 template} <{\cf17 typename} P = Predicate>\par
7692         FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):\par
7693             m_generator(CATCH_MOVE(generator)),\par
7694             m_predicate(CATCH_FORWARD(pred))\par
7695         \{\par
7696             {\cf19 if} (!m_predicate(m_generator.get())) \{\par
7697                 {\cf20 // It might happen that there are no values that pass the}\par
7698                 {\cf20 // filter. In that case we throw an exception.}\par
7699                 auto has_initial_value = next();\par
7700                 if (!has_initial_value) \{\par
7701                     Detail::throw_generator_exception({\cf22 "No valid value found in filtered generator"});\par
7702                 \}\par
7703             \}\par
7704         \}\par
7705 \par
7706         T {\cf17 const}& get(){\cf17  const override }\{\par
7707             {\cf19 return} m_generator.get();\par
7708         \}\par
7709 \par
7710         {\cf18 bool} next(){\cf17  override }\{\par
7711             {\cf18 bool} success = m_generator.next();\par
7712             {\cf19 if} (!success) \{\par
7713                 {\cf19 return} {\cf17 false};\par
7714             \}\par
7715             {\cf19 while} (!m_predicate(m_generator.get()) && (success = m_generator.next()) == {\cf17 true});\par
7716             {\cf19 return} success;\par
7717         \}\par
7718     \};\par
7719 \par
7720 \par
7721     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Predicate>\par
7722     GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) \{\par
7723         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<FilterGenerator<T, Predicate>>(CATCH_FORWARD(pred), CATCH_MOVE(generator)));\par
7724     \}\par
7725 \par
7726     {\cf17 template} <{\cf17 typename} T>\par
7727     {\cf17 class }RepeatGenerator final : {\cf17 public} IGenerator<T> \{\par
7728         {\cf17 static_assert}(!std::is_same<T, bool>::value,\par
7729             {\cf22 "RepeatGenerator currently does not support bools"}\par
7730             {\cf22 "because of std::vector<bool> specialization"});\par
7731         GeneratorWrapper<T> m_generator;\par
7732         {\cf17 mutable} std::vector<T> m_returned;\par
7733         {\cf18 size_t} m_target_repeats;\par
7734         {\cf18 size_t} m_current_repeat = 0;\par
7735         {\cf18 size_t} m_repeat_index = 0;\par
7736     {\cf17 public}:\par
7737         RepeatGenerator({\cf18 size_t} repeats, GeneratorWrapper<T>&& generator):\par
7738             m_generator(CATCH_MOVE(generator)),\par
7739             m_target_repeats(repeats)\par
7740         \{\par
7741             assert(m_target_repeats > 0 && {\cf22 "Repeat generator must repeat at least once"});\par
7742         \}\par
7743 \par
7744         T {\cf17 const}& get(){\cf17  const override }\{\par
7745             {\cf19 if} (m_current_repeat == 0) \{\par
7746                 m_returned.push_back(m_generator.get());\par
7747                 {\cf19 return} m_returned.back();\par
7748             \}\par
7749             {\cf19 return} m_returned[m_repeat_index];\par
7750         \}\par
7751 \par
7752         {\cf18 bool} next(){\cf17  override }\{\par
7753             {\cf20 // There are 2 basic cases:}\par
7754             {\cf20 // 1) We are still reading the generator}\par
7755             {\cf20 // 2) We are reading our own cache}\par
7756 \par
7757             {\cf20 // In the first case, we need to poke the underlying generator.}\par
7758             {\cf20 // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache}\par
7759             {\cf19 if} (m_current_repeat == 0) \{\par
7760                 {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7761                 {\cf19 if} (!success) \{\par
7762                     ++m_current_repeat;\par
7763                 \}\par
7764                 {\cf19 return} m_current_repeat < m_target_repeats;\par
7765             \}\par
7766 \par
7767             {\cf20 // In the second case, we need to move indices forward and check that we haven't run up against the end}\par
7768             ++m_repeat_index;\par
7769             {\cf19 if} (m_repeat_index == m_returned.size()) \{\par
7770                 m_repeat_index = 0;\par
7771                 ++m_current_repeat;\par
7772             \}\par
7773             {\cf19 return} m_current_repeat < m_target_repeats;\par
7774         \}\par
7775     \};\par
7776 \par
7777     {\cf17 template} <{\cf17 typename} T>\par
7778     GeneratorWrapper<T> repeat({\cf18 size_t} repeats, GeneratorWrapper<T>&& generator) \{\par
7779         {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<RepeatGenerator<T>>(repeats, CATCH_MOVE(generator)));\par
7780     \}\par
7781 \par
7782     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U, {\cf17 typename} Func>\par
7783     {\cf17 class }MapGenerator final : {\cf17 public} IGenerator<T> \{\par
7784         {\cf20 // TBD: provide static assert for mapping function, for friendly error message}\par
7785         GeneratorWrapper<U> m_generator;\par
7786         Func m_function;\par
7787         {\cf20 // To avoid returning dangling reference, we have to save the values}\par
7788         T m_cache;\par
7789     {\cf17 public}:\par
7790         {\cf17 template} <{\cf17 typename} F2 = Func>\par
7791         MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :\par
7792             m_generator(CATCH_MOVE(generator)),\par
7793             m_function(CATCH_FORWARD(function)),\par
7794             m_cache(m_function(m_generator.get()))\par
7795         \{\}\par
7796 \par
7797         T {\cf17 const}& get(){\cf17  const override }\{\par
7798             {\cf19 return} m_cache;\par
7799         \}\par
7800         {\cf18 bool} next(){\cf17  override }\{\par
7801             {\cf17 const} {\cf17 auto} success = m_generator.next();\par
7802             {\cf19 if} (success) \{\par
7803                 m_cache = m_function(m_generator.get());\par
7804             \}\par
7805             {\cf19 return} success;\par
7806         \}\par
7807     \};\par
7808 \par
7809     {\cf17 template} <{\cf17 typename} Func, {\cf17 typename} U, {\cf17 typename} T = FunctionReturnType<Func, U>>\par
7810     GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) \{\par
7811         {\cf19 return} GeneratorWrapper<T>(\par
7812             Catch::Detail::make_unique<MapGenerator<T, U, Func>>(CATCH_FORWARD(function), CATCH_MOVE(generator))\par
7813         );\par
7814     \}\par
7815 \par
7816     {\cf17 template} <{\cf17 typename} T, {\cf17 typename} U, {\cf17 typename} Func>\par
7817     GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) \{\par
7818         {\cf19 return} GeneratorWrapper<T>(\par
7819             Catch::Detail::make_unique<MapGenerator<T, U, Func>>(CATCH_FORWARD(function), CATCH_MOVE(generator))\par
7820         );\par
7821     \}\par
7822 \par
7823     {\cf17 template} <{\cf17 typename} T>\par
7824     {\cf17 class }ChunkGenerator final : {\cf17 public} IGenerator<std::vector<T>> \{\par
7825         std::vector<T> m_chunk;\par
7826         {\cf18 size_t} m_chunk_size;\par
7827         GeneratorWrapper<T> m_generator;\par
7828         {\cf18 bool} m_used_up = {\cf17 false};\par
7829     {\cf17 public}:\par
7830         ChunkGenerator({\cf18 size_t} size, GeneratorWrapper<T> generator) :\par
7831             m_chunk_size(size), m_generator(CATCH_MOVE(generator))\par
7832         \{\par
7833             m_chunk.reserve(m_chunk_size);\par
7834             {\cf19 if} (m_chunk_size != 0) \{\par
7835                 m_chunk.push_back(m_generator.get());\par
7836                 {\cf19 for} ({\cf18 size_t} i = 1; i < m_chunk_size; ++i) \{\par
7837                     {\cf19 if} (!m_generator.next()) \{\par
7838                         Detail::throw_generator_exception({\cf22 "Not enough values to initialize the first chunk"});\par
7839                     \}\par
7840                     m_chunk.push_back(m_generator.get());\par
7841                 \}\par
7842             \}\par
7843         \}\par
7844         std::vector<T> {\cf17 const}& get(){\cf17  const override }\{\par
7845             {\cf19 return} m_chunk;\par
7846         \}\par
7847         {\cf18 bool} next(){\cf17  override }\{\par
7848             m_chunk.clear();\par
7849             {\cf19 for} ({\cf18 size_t} idx = 0; idx < m_chunk_size; ++idx) \{\par
7850                 {\cf19 if} (!m_generator.next()) \{\par
7851                     {\cf19 return} {\cf17 false};\par
7852                 \}\par
7853                 m_chunk.push_back(m_generator.get());\par
7854             \}\par
7855             {\cf19 return} {\cf17 true};\par
7856         \}\par
7857     \};\par
7858 \par
7859     {\cf17 template} <{\cf17 typename} T>\par
7860     GeneratorWrapper<std::vector<T>> chunk({\cf18 size_t} size, GeneratorWrapper<T>&& generator) \{\par
7861         {\cf19 return} GeneratorWrapper<std::vector<T>>(\par
7862             Catch::Detail::make_unique<ChunkGenerator<T>>(size, CATCH_MOVE(generator))\par
7863         );\par
7864     \}\par
7865 \par
7866 \} {\cf20 // namespace Generators}\par
7867 \} {\cf20 // namespace Catch}\par
7868 \par
7869 \par
7870 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED}\par
7871 \par
7872 \par
7873 {\cf21 #ifndef CATCH_GENERATORS_RANDOM_HPP_INCLUDED}\par
7874 {\cf21 #define CATCH_GENERATORS_RANDOM_HPP_INCLUDED}\par
7875 \par
7876 \par
7877 \par
7878 {\cf21 #ifndef CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}\par
7879 {\cf21 #define CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}\par
7880 \par
7881 {\cf21 #include <cstdint>}\par
7882 \par
7883 {\cf17 namespace }Catch \{\par
7884 \par
7885     {\cf20 // This is a simple implementation of C++11 Uniform Random Number}\par
7886     {\cf20 // Generator. It does not provide all operators, because Catch2}\par
7887     {\cf20 // does not use it, but it should behave as expected inside stdlib's}\par
7888     {\cf20 // distributions.}\par
7889     {\cf20 // The implementation is based on the PCG family (http://pcg-random.org)}\par
7890     {\cf17 class }SimplePcg32 \{\par
7891         {\cf17 using }state_type = std::uint64_t;\par
7892     {\cf17 public}:\par
7893         {\cf17 using }result_type = std::uint32_t;\par
7894         {\cf17 static} {\cf17 constexpr} result_type (min)() \{\par
7895             {\cf19 return} 0;\par
7896         \}\par
7897         {\cf17 static} {\cf17 constexpr} result_type (max)() \{\par
7898             {\cf19 return} {\cf17 static_cast<}result_type{\cf17 >}(-1);\par
7899         \}\par
7900 \par
7901         {\cf20 // Provide some default initial state for the default constructor}\par
7902         SimplePcg32():SimplePcg32(0xed743cc4U) \{\}\par
7903 \par
7904         {\cf17 explicit} SimplePcg32(result_type seed_);\par
7905 \par
7906         {\cf18 void} seed(result_type seed_);\par
7907         {\cf18 void} discard(uint64_t skip);\par
7908 \par
7909         result_type operator()();\par
7910 \par
7911     {\cf17 private}:\par
7912         {\cf17 friend} {\cf18 bool} operator==(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs);\par
7913         {\cf17 friend} {\cf18 bool} operator!=(SimplePcg32 {\cf17 const}& lhs, SimplePcg32 {\cf17 const}& rhs);\par
7914 \par
7915         {\cf20 // In theory we also need operator<< and operator>>}\par
7916         {\cf20 // In practice we do not use them, so we will skip them for now}\par
7917 \par
7918 \par
7919         std::uint64_t m_state;\par
7920         {\cf20 // This part of the state determines which "stream" of the numbers}\par
7921         {\cf20 // is chosen -- we take it as a constant for Catch2, so we only}\par
7922         {\cf20 // need to deal with seeding the main state.}\par
7923         {\cf20 // Picked by reading 8 bytes from `/dev/random` :-)}\par
7924         {\cf17 static} {\cf17 const} std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;\par
7925     \};\par
7926 \par
7927 \} {\cf20 // end namespace Catch}\par
7928 \par
7929 {\cf21 #endif }{\cf20 // CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED}\par
7930 \par
7931 \par
7932 \par
7933 {\cf21 #ifndef CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}\par
7934 {\cf21 #define CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}\par
7935 \par
7936 \par
7937 \par
7938 \par
7939 {\cf21 #ifndef CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}\par
7940 {\cf21 #define CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}\par
7941 \par
7942 {\cf21 #include <climits>}\par
7943 {\cf21 #include <cstddef>}\par
7944 {\cf21 #include <cstdint>}\par
7945 {\cf21 #include <type_traits>}\par
7946 \par
7947 {\cf20 // Note: We use the usual enable-disable-autodetect dance here even though}\par
7948 {\cf20 //       we do not support these in CMake configuration options (yet?).}\par
7949 {\cf20 //       It is highly unlikely that we will need to make these actually}\par
7950 {\cf20 //       user-configurable, but this will make it simpler if weend up needing}\par
7951 {\cf20 //       it, and it provides an escape hatch to the users who need it.}\par
7952 {\cf21 #if defined( __SIZEOF_INT128__ )}\par
7953 {\cf21 #    define CATCH_CONFIG_INTERNAL_UINT128}\par
7954 {\cf20 // Unlike GCC, MSVC does not polyfill umul as mulh + mul pair on ARM machines.}\par
7955 {\cf20 // Currently we do not bother doing this ourselves, but we could if it became}\par
7956 {\cf20 // important for perf.}\par
7957 {\cf21 #elif defined( _MSC_VER ) && defined( _M_X64 )}\par
7958 {\cf21 #    define CATCH_CONFIG_INTERNAL_MSVC_UMUL128}\par
7959 {\cf21 #endif}\par
7960 \par
7961 {\cf21 #if defined( CATCH_CONFIG_INTERNAL_UINT128 ) && \\}\par
7962 {\cf21     !defined( CATCH_CONFIG_NO_UINT128 ) &&      \\}\par
7963 {\cf21     !defined( CATCH_CONFIG_UINT128 )}\par
7964 {\cf21 #define CATCH_CONFIG_UINT128}\par
7965 {\cf21 #endif}\par
7966 \par
7967 {\cf21 #if defined( CATCH_CONFIG_INTERNAL_MSVC_UMUL128 ) && \\}\par
7968 {\cf21     !defined( CATCH_CONFIG_NO_MSVC_UMUL128 ) &&      \\}\par
7969 {\cf21     !defined( CATCH_CONFIG_MSVC_UMUL128 )}\par
7970 {\cf21 #    define CATCH_CONFIG_MSVC_UMUL128}\par
7971 {\cf21 #    include <intrin.h>}\par
7972 {\cf21 #endif}\par
7973 \par
7974 \par
7975 {\cf17 namespace }Catch \{\par
7976     {\cf17 namespace }Detail \{\par
7977 \par
7978         {\cf17 template} <std::{\cf18 size_t}>\par
7979         {\cf17 struct }SizedUnsignedType;\par
7980 {\cf21 #define SizedUnsignedTypeHelper( TYPE )        \\}\par
7981 {\cf21     template <>                                \\}\par
7982 {\cf21     struct SizedUnsignedType<sizeof( TYPE )> \{ \\}\par
7983 {\cf21         using type = TYPE;                     \\}\par
7984 {\cf21     \}}\par
7985 \par
7986         SizedUnsignedTypeHelper( std::uint8_t );\par
7987         SizedUnsignedTypeHelper( std::uint16_t );\par
7988         SizedUnsignedTypeHelper( std::uint32_t );\par
7989         SizedUnsignedTypeHelper( std::uint64_t );\par
7990 {\cf21 #undef SizedUnsignedTypeHelper}\par
7991 \par
7992         {\cf17 template} <std::{\cf18 size_t} sz>\par
7993         {\cf17 using }SizedUnsignedType_t = {\cf17 typename} SizedUnsignedType<sz>::type;\par
7994 \par
7995         {\cf17 template} <{\cf17 typename} T>\par
7996         {\cf17 using }DoubleWidthUnsignedType_t = SizedUnsignedType_t<2 * {\cf17 sizeof}( T )>;\par
7997 \par
7998         {\cf17 template} <{\cf17 typename} T>\par
7999         {\cf17 struct }ExtendedMultResult \{\par
8000             T upper;\par
8001             T lower;\par
8002             {\cf18 bool} operator==( ExtendedMultResult {\cf17 const}& rhs ){\cf17  const }\{\par
8003                 {\cf19 return} upper == rhs.upper && lower == rhs.lower;\par
8004             \}\par
8005         \};\par
8006 \par
8013         {\cf17 constexpr} ExtendedMultResult<std::uint64_t>\par
8014         extendedMultPortable(std::uint64_t lhs, std::uint64_t rhs) \{\par
8015 {\cf21 #define CarryBits( x ) ( x >> 32 )}\par
8016 {\cf21 #define Digits( x ) ( x & 0xFF'FF'FF'FF )}\par
8017             std::uint64_t lhs_low = Digits( lhs );\par
8018             std::uint64_t rhs_low = Digits( rhs );\par
8019             std::uint64_t low_low = ( lhs_low * rhs_low );\par
8020             std::uint64_t high_high = CarryBits( lhs ) * CarryBits( rhs );\par
8021 \par
8022             {\cf20 // We add in carry bits from low-low already}\par
8023             std::uint64_t high_low =\par
8024                 ( CarryBits( lhs ) * rhs_low ) + CarryBits( low_low );\par
8025             {\cf20 // Note that we can add only low bits from high_low, to avoid}\par
8026             {\cf20 // overflow with large inputs}\par
8027             std::uint64_t low_high =\par
8028                 ( lhs_low * CarryBits( rhs ) ) + Digits( high_low );\par
8029 \par
8030             {\cf19 return} \{ high_high + CarryBits( high_low ) + CarryBits( low_high ),\par
8031                      ( low_high << 32 ) | Digits( low_low ) \};\par
8032 {\cf21 #undef CarryBits}\par
8033 {\cf21 #undef Digits}\par
8034         \}\par
8035 \par
8037         {\cf17 inline} ExtendedMultResult<std::uint64_t>\par
8038         extendedMult( std::uint64_t lhs, std::uint64_t rhs ) \{\par
8039 {\cf21 #if defined( CATCH_CONFIG_UINT128 )}\par
8040             {\cf17 auto} result = __uint128_t( lhs ) * __uint128_t( rhs );\par
8041             {\cf19 return} \{ {\cf17 static_cast<}std::uint64_t{\cf17 >}( result >> 64 ),\par
8042                      {\cf17 static_cast<}std::uint64_t{\cf17 >}( result ) \};\par
8043 {\cf21 #elif defined( CATCH_CONFIG_MSVC_UMUL128 )}\par
8044             std::uint64_t high;\par
8045             std::uint64_t low = _umul128( lhs, rhs, &high );\par
8046             {\cf19 return} \{ high, low \};\par
8047 {\cf21 #else}\par
8048             {\cf19 return} extendedMultPortable( lhs, rhs );\par
8049 {\cf21 #endif}\par
8050         \}\par
8051 \par
8052 \par
8053         {\cf17 template} <{\cf17 typename} UInt>\par
8054         {\cf17 constexpr} ExtendedMultResult<UInt> extendedMult( UInt lhs, UInt rhs ) \{\par
8055             {\cf17 static_assert}( std::is_unsigned<UInt>::value,\par
8056                            {\cf22 "extendedMult can only handle unsigned integers"} );\par
8057             {\cf17 static_assert}( {\cf17 sizeof}( UInt ) < {\cf17 sizeof}( std::uint64_t ),\par
8058                            {\cf22 "Generic extendedMult can only handle types smaller "}\par
8059                            {\cf22 "than uint64_t"} );\par
8060             {\cf17 using }WideType = DoubleWidthUnsignedType_t<UInt>;\par
8061 \par
8062             {\cf17 auto} result = WideType( lhs ) * WideType( rhs );\par
8063             {\cf19 return} \{\par
8064                 {\cf17 static_cast<}UInt{\cf17 >}( result >> ( CHAR_BIT * {\cf17 sizeof}( UInt ) ) ),\par
8065                 {\cf17 static_cast<}UInt{\cf17 >}( result & UInt( -1 ) ) \};\par
8066         \}\par
8067 \par
8068 \par
8069         {\cf17 template} <{\cf17 typename} TargetType,\par
8070                   {\cf17 typename} Generator>\par
8071             std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) >= {\cf17 sizeof}(TargetType),\par
8072             TargetType> fillBitsFrom(Generator& gen) \{\par
8073             {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;\par
8074             {\cf17 static_assert}( std::is_unsigned<TargetType>::value, {\cf22 "Only unsigned integers are supported"} );\par
8075             {\cf17 static_assert}( Generator::min() == 0 &&\par
8076                            Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),\par
8077                            {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );\par
8078 \par
8079             {\cf20 // We want to return the top bits from a generator, as they are}\par
8080             {\cf20 // usually considered higher quality.}\par
8081             {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;\par
8082             {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;\par
8083 \par
8084             {\cf19 return} {\cf17 static_cast<}TargetType{\cf17 >}( gen() >>\par
8085                                             ( generated_bits - return_bits) );\par
8086         \}\par
8087 \par
8088         {\cf17 template} <{\cf17 typename} TargetType,\par
8089                   {\cf17 typename} Generator>\par
8090             std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) < {\cf17 sizeof}(TargetType),\par
8091             TargetType> fillBitsFrom(Generator& gen) \{\par
8092             {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;\par
8093             {\cf17 static_assert}( std::is_unsigned<TargetType>::value,\par
8094                            {\cf22 "Only unsigned integers are supported"} );\par
8095             {\cf17 static_assert}( Generator::min() == 0 &&\par
8096                            Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),\par
8097                            {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );\par
8098 \par
8099             {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;\par
8100             {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;\par
8101             std::size_t filled_bits = 0;\par
8102             TargetType ret = 0;\par
8103             {\cf19 do} \{\par
8104                 ret <<= generated_bits;\par
8105                 ret |= gen();\par
8106                 filled_bits += generated_bits;\par
8107             \} {\cf19 while} ( filled_bits < return_bits );\par
8108 \par
8109             {\cf19 return} ret;\par
8110         \}\par
8111 \par
8112         {\cf20 /*}\par
8113 {\cf20          * Transposes numbers into unsigned type while keeping their ordering}\par
8114 {\cf20          *}\par
8115 {\cf20          * This means that signed types are changed so that the ordering is}\par
8116 {\cf20          * [INT_MIN, ..., -1, 0, ..., INT_MAX], rather than order we would}\par
8117 {\cf20          * get by simple casting ([0, ..., INT_MAX, INT_MIN, ..., -1])}\par
8118 {\cf20          */}\par
8119         {\cf17 template} <{\cf17 typename} OriginalType, {\cf17 typename} Un{\cf18 signed}Type>\par
8120         std::enable_if_t<std::is_signed<OriginalType>::value, UnsignedType>\par
8121         transposeToNaturalOrder( UnsignedType in ) \{\par
8122             {\cf17 static_assert}(\par
8123                 {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),\par
8124                 {\cf22 "reordering requires the same sized types on both sides"} );\par
8125             {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value,\par
8126                            {\cf22 "Input type must be unsigned"} );\par
8127             {\cf20 // Assuming 2s complement (standardized in current C++), the}\par
8128             {\cf20 // positive and negative numbers are already internally ordered,}\par
8129             {\cf20 // and their difference is in the top bit. Swapping it orders}\par
8130             {\cf20 // them the desired way.}\par
8131             {\cf17 constexpr} {\cf17 auto} highest_bit =\par
8132                 UnsignedType( 1 ) << ( {\cf17 sizeof}( UnsignedType ) * CHAR_BIT - 1 );\par
8133             {\cf19 return} {\cf17 static_cast<}UnsignedType{\cf17 >}( in ^ highest_bit );\par
8134         \}\par
8135 \par
8136 \par
8137 \par
8138         {\cf17 template} <{\cf17 typename} OriginalType,\par
8139                   {\cf17 typename} UnsignedType>\par
8140         std::enable_if_t<std::is_unsigned<OriginalType>::value, UnsignedType>\par
8141             transposeToNaturalOrder(UnsignedType in) \{\par
8142             {\cf17 static_assert}(\par
8143                 {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),\par
8144                 {\cf22 "reordering requires the same sized types on both sides"} );\par
8145             {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value, {\cf22 "Input type must be unsigned"} );\par
8146             {\cf20 // No reordering is needed for unsigned -> unsigned}\par
8147             {\cf19 return} in;\par
8148         \}\par
8149     \} {\cf20 // namespace Detail}\par
8150 \} {\cf20 // namespace Catch}\par
8151 \par
8152 {\cf21 #endif }{\cf20 // CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED}\par
8153 \par
8154 {\cf17 namespace }Catch \{\par
8155 \par
8167 {\cf17 template} <{\cf17 typename} IntegerType>\par
8168 {\cf17 class }uniform_integer_distribution \{\par
8169     {\cf17 static_assert}(std::is_integral<IntegerType>::value, {\cf22 "..."});\par
8170 \par
8171     {\cf17 using }UnsignedIntegerType = Detail::SizedUnsignedType_t<{\cf17 sizeof}(IntegerType)>;\par
8172 \par
8173     {\cf20 // Only the left bound is stored, and we store it converted to its}\par
8174     {\cf20 // unsigned image. This avoids having to do the conversions inside}\par
8175     {\cf20 // the operator(), at the cost of having to do the conversion in}\par
8176     {\cf20 // the a() getter. The right bound is only needed in the b() getter,}\par
8177     {\cf20 // so we recompute it there from other stored data.}\par
8178     UnsignedIntegerType m_a;\par
8179 \par
8180     {\cf20 // How many different values are there in [a, b]. a == b => 1, can be 0 for distribution over all values in the type.}\par
8181     UnsignedIntegerType m_ab_distance;\par
8182 \par
8183     {\cf20 // We hoisted this out of the main generation function. Technically,}\par
8184     {\cf20 // this means that using this distribution will be slower than Lemire's}\par
8185     {\cf20 // algorithm if this distribution instance will be used only few times,}\par
8186     {\cf20 // but it will be faster if it is used many times. Since Catch2 uses}\par
8187     {\cf20 // distributions only to implement random generators, we assume that each}\par
8188     {\cf20 // distribution will be reused many times and this is an optimization.}\par
8189     UnsignedIntegerType m_rejection_threshold = 0;\par
8190 \par
8191     UnsignedIntegerType computeDistance(IntegerType a, IntegerType b){\cf17  const }\{\par
8192         {\cf20 // This overflows and returns 0 if a == 0 and b == TYPE_MAX.}\par
8193         {\cf20 // We handle that later when generating the number.}\par
8194         {\cf19 return} transposeTo(b) - transposeTo(a) + 1;\par
8195     \}\par
8196 \par
8197     {\cf17 static} UnsignedIntegerType computeRejectionThreshold(UnsignedIntegerType ab_distance) \{\par
8198         {\cf20 // distance == 0 means that we will return all possible values from}\par
8199         {\cf20 // the type's range, and that we shouldn't reject anything.}\par
8200         {\cf19 if} ( ab_distance == 0 ) \{ {\cf19 return} 0; \}\par
8201         {\cf19 return} ( ~ab_distance + 1 ) % ab_distance;\par
8202     \}\par
8203 \par
8204     {\cf17 static} UnsignedIntegerType transposeTo(IntegerType in) \{\par
8205         {\cf19 return} Detail::transposeToNaturalOrder<IntegerType>(\par
8206             {\cf17 static_cast<}UnsignedIntegerType{\cf17 >}( in ) );\par
8207     \}\par
8208     {\cf17 static} IntegerType transposeBack(UnsignedIntegerType in) \{\par
8209         {\cf19 return} {\cf17 static_cast<}IntegerType{\cf17 >}(\par
8210             Detail::transposeToNaturalOrder<IntegerType>(in) );\par
8211     \}\par
8212 \par
8213 {\cf17 public}:\par
8214     {\cf17 using }result_type = IntegerType;\par
8215 \par
8216     uniform_integer_distribution( IntegerType a, IntegerType b ):\par
8217         m_a( transposeTo(a) ),\par
8218         m_ab_distance( computeDistance(a, b) ),\par
8219         m_rejection_threshold( computeRejectionThreshold(m_ab_distance) ) \{\par
8220         assert( a <= b );\par
8221     \}\par
8222 \par
8223     {\cf17 template} <{\cf17 typename} Generator>\par
8224     result_type operator()( Generator& g ) \{\par
8225         {\cf20 // All possible values of result_type are valid.}\par
8226         {\cf19 if} ( m_ab_distance == 0 ) \{\par
8227             {\cf19 return} transposeBack( Detail::fillBitsFrom<UnsignedIntegerType>( g ) );\par
8228         \}\par
8229 \par
8230         {\cf17 auto} random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );\par
8231         {\cf17 auto} emul = Detail::extendedMult( random_number, m_ab_distance );\par
8232         {\cf20 // Unlike Lemire's algorithm we skip the ab_distance check, since}\par
8233         {\cf20 // we precomputed the rejection threshold, which is always tighter.}\par
8234         {\cf19 while} (emul.lower < m_rejection_threshold) \{\par
8235             random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );\par
8236             emul = Detail::extendedMult( random_number, m_ab_distance );\par
8237         \}\par
8238 \par
8239         {\cf19 return} transposeBack(m_a + emul.upper);\par
8240     \}\par
8241 \par
8242     result_type a(){\cf17  const }\{ {\cf19 return} transposeBack(m_a); \}\par
8243     result_type b(){\cf17  const }\{ {\cf19 return} transposeBack(m_ab_distance + m_a - 1); \}\par
8244 \};\par
8245 \par
8246 \} {\cf20 // end namespace Catch}\par
8247 \par
8248 {\cf21 #endif }{\cf20 // CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED}\par
8249 \par
8250 \par
8251 \par
8252 {\cf21 #ifndef CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED}\par
8253 {\cf21 #define CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED}\par
8254 \par
8255 \par
8256 \par
8257 \par
8258 {\cf21 #ifndef CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
8259 {\cf21 #define CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
8260 \par
8261 \par
8262 \par
8263 {\cf21 #ifndef CATCH_POLYFILLS_HPP_INCLUDED}\par
8264 {\cf21 #define CATCH_POLYFILLS_HPP_INCLUDED}\par
8265 \par
8266 {\cf17 namespace }Catch \{\par
8267 \par
8268     {\cf18 bool} isnan({\cf18 float} f);\par
8269     {\cf18 bool} isnan({\cf18 double} d);\par
8270 \par
8271     {\cf18 float} nextafter({\cf18 float} x, {\cf18 float} y);\par
8272     {\cf18 double} nextafter({\cf18 double} x, {\cf18 double} y);\par
8273 \par
8274 \}\par
8275 \par
8276 {\cf21 #endif }{\cf20 // CATCH_POLYFILLS_HPP_INCLUDED}\par
8277 \par
8278 {\cf21 #include <cassert>}\par
8279 {\cf21 #include <cmath>}\par
8280 {\cf21 #include <cstdint>}\par
8281 {\cf21 #include <limits>}\par
8282 {\cf21 #include <type_traits>}\par
8283 \par
8284 {\cf17 namespace }Catch \{\par
8285 \par
8286     {\cf17 namespace }Detail \{\par
8292         {\cf17 template} <{\cf17 typename} FloatType>\par
8293         FloatType gamma(FloatType a, FloatType b) \{\par
8294             {\cf17 static_assert}( std::is_floating_point<FloatType>::value,\par
8295                            {\cf22 "gamma returns the largest ULP magnitude within "}\par
8296                            {\cf22 "floating point range [a, b]. This only makes sense "}\par
8297                            {\cf22 "for floating point types"} );\par
8298             assert( a <= b );\par
8299 \par
8300             {\cf17 const} {\cf17 auto} gamma_up = Catch::nextafter( a, std::numeric_limits<FloatType>::infinity() ) - a;\par
8301             {\cf17 const} {\cf17 auto} gamma_down = b - Catch::nextafter( b, -std::numeric_limits<FloatType>::infinity() );\par
8302 \par
8303             {\cf19 return} gamma_up < gamma_down ? gamma_down : gamma_up;\par
8304         \}\par
8305 \par
8306         {\cf17 template} <{\cf17 typename} FloatingPo{\cf18 int}>\par
8307         {\cf17 struct }DistanceTypePicker;\par
8308         {\cf17 template} <>\par
8309         {\cf17 struct }DistanceTypePicker<float> \{\par
8310             {\cf17 using }type = std::uint32_t;\par
8311         \};\par
8312         {\cf17 template} <>\par
8313         {\cf17 struct }DistanceTypePicker<double> \{\par
8314             {\cf17 using }type = std::uint64_t;\par
8315         \};\par
8316 \par
8317         {\cf17 template} <{\cf17 typename} T>\par
8318         {\cf17 using }DistanceType = {\cf17 typename} DistanceTypePicker<T>::type;\par
8319 \par
8320 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8321 {\cf21 #    pragma GCC diagnostic push}\par
8322 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
8323 {\cf21 #endif}\par
8333         {\cf17 template} <{\cf17 typename} FloatType>\par
8334         DistanceType<FloatType>\par
8335         count_equidistant_floats( FloatType a, FloatType b, FloatType distance ) \{\par
8336             assert( a <= b );\par
8337             {\cf20 // We get distance as gamma for our uniform float distribution,}\par
8338             {\cf20 // so this will round perfectly.}\par
8339             {\cf17 const} {\cf17 auto} ag = a / distance;\par
8340             {\cf17 const} {\cf17 auto} bg = b / distance;\par
8341 \par
8342             {\cf17 const} {\cf17 auto} s = bg - ag;\par
8343             {\cf17 const} {\cf17 auto} err = ( std::fabs( a ) <= std::fabs( b ) )\par
8344                                  ? -ag - ( s - bg )\par
8345                                  : bg - ( s + ag );\par
8346             {\cf17 const} {\cf17 auto} ceil_s = {\cf17 static_cast<}DistanceType<FloatType>{\cf17 >}( std::ceil( s ) );\par
8347 \par
8348             {\cf19 return} ( ceil_s != s ) ? ceil_s : ceil_s + ( err > 0 );\par
8349         \}\par
8350 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8351 {\cf21 #    pragma GCC diagnostic pop}\par
8352 {\cf21 #endif}\par
8353 \par
8354     \}\par
8355 \par
8356 \} {\cf20 // end namespace Catch}\par
8357 \par
8358 {\cf21 #endif }{\cf20 // CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
8359 \par
8360 {\cf21 #include <cmath>}\par
8361 {\cf21 #include <type_traits>}\par
8362 \par
8363 {\cf17 namespace }Catch \{\par
8364 \par
8365     {\cf17 namespace }Detail \{\par
8366 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8367 {\cf21 #    pragma GCC diagnostic push}\par
8368 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
8369 {\cf21 #endif}\par
8370         {\cf20 // The issue with overflow only happens with maximal ULP and HUGE}\par
8371         {\cf20 // distance, e.g. when generating numbers in [-inf, inf] for given}\par
8372         {\cf20 // type. So we only check for the largest possible ULP in the}\par
8373         {\cf20 // type, and return something that does not overflow to inf in 1 mult.}\par
8374         {\cf17 constexpr} std::uint64_t calculate_max_steps_in_one_go({\cf18 double} gamma) \{\par
8375             {\cf19 if} ( gamma == 1.99584030953472e+292 ) \{ {\cf19 return} 9007199254740991; \}\par
8376             {\cf19 return} {\cf17 static_cast<}std::uint64_t{\cf17 >}( -1 );\par
8377         \}\par
8378         {\cf17 constexpr} std::uint32_t calculate_max_steps_in_one_go({\cf18 float} gamma) \{\par
8379             {\cf19 if} ( gamma == 2.028241e+31f ) \{ {\cf19 return} 16777215; \}\par
8380             {\cf19 return} {\cf17 static_cast<}std::uint32_t{\cf17 >}( -1 );\par
8381         \}\par
8382 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
8383 {\cf21 #    pragma GCC diagnostic pop}\par
8384 {\cf21 #endif}\par
8385     \}\par
8386 \par
8413 {\cf17 template} <{\cf17 typename} FloatType>\par
8414 {\cf17 class }uniform_floating_point_distribution \{\par
8415     {\cf17 static_assert}(std::is_floating_point<FloatType>::value, {\cf22 "..."});\par
8416     {\cf17 static_assert}(!std::is_same<FloatType, long double>::value,\par
8417                   {\cf22 "We do not support long double due to inconsistent behaviour between platforms"});\par
8418 \par
8419     {\cf17 using }WidthType = Detail::DistanceType<FloatType>;\par
8420 \par
8421     FloatType m_a, m_b;\par
8422     FloatType m_ulp_magnitude;\par
8423     WidthType m_floats_in_range;\par
8424     uniform_integer_distribution<WidthType> m_int_dist;\par
8425 \par
8426     {\cf20 // In specific cases, we can overflow into `inf` when computing the}\par
8427     {\cf20 // `steps * g` offset. To avoid this, we don't offset by more than this}\par
8428     {\cf20 // in one multiply + addition.}\par
8429     WidthType m_max_steps_in_one_go;\par
8430     {\cf20 // We don't want to do the magnitude check every call to `operator()`}\par
8431     {\cf18 bool} m_a_has_leq_magnitude;\par
8432 \par
8433 {\cf17 public}:\par
8434     {\cf17 using }result_type = FloatType;\par
8435 \par
8436     uniform_floating_point_distribution( FloatType a, FloatType b ):\par
8437         m_a( a ),\par
8438         m_b( b ),\par
8439         m_ulp_magnitude( Detail::gamma( m_a, m_b ) ),\par
8440         m_floats_in_range( Detail::count_equidistant_floats( m_a, m_b, m_ulp_magnitude ) ),\par
8441         m_int_dist(0, m_floats_in_range),\par
8442         m_max_steps_in_one_go( Detail::calculate_max_steps_in_one_go(m_ulp_magnitude)),\par
8443         m_a_has_leq_magnitude(std::fabs(m_a) <= std::fabs(m_b))\par
8444     \{\par
8445         assert( a <= b );\par
8446     \}\par
8447 \par
8448     {\cf17 template} <{\cf17 typename} Generator>\par
8449     result_type operator()( Generator& g ) \{\par
8450         WidthType steps = m_int_dist( g );\par
8451         {\cf19 if} ( m_a_has_leq_magnitude ) \{\par
8452             {\cf19 if} ( steps == m_floats_in_range ) \{ {\cf19 return} m_a; \}\par
8453             {\cf17 auto} b = m_b;\par
8454             {\cf19 while} (steps > m_max_steps_in_one_go) \{\par
8455                 b -= m_max_steps_in_one_go * m_ulp_magnitude;\par
8456                 steps -= m_max_steps_in_one_go;\par
8457             \}\par
8458             {\cf19 return} b - steps * m_ulp_magnitude;\par
8459         \} {\cf19 else} \{\par
8460             {\cf19 if} ( steps == m_floats_in_range ) \{ {\cf19 return} m_b; \}\par
8461             {\cf17 auto} a = m_a;\par
8462             {\cf19 while} (steps > m_max_steps_in_one_go) \{\par
8463                 a += m_max_steps_in_one_go * m_ulp_magnitude;\par
8464                 steps -= m_max_steps_in_one_go;\par
8465             \}\par
8466             {\cf19 return} a + steps * m_ulp_magnitude;\par
8467         \}\par
8468     \}\par
8469 \par
8470     result_type a(){\cf17  const }\{ {\cf19 return} m_a; \}\par
8471     result_type b(){\cf17  const }\{ {\cf19 return} m_b; \}\par
8472 \};\par
8473 \par
8474 \} {\cf20 // end namespace Catch}\par
8475 \par
8476 {\cf21 #endif }{\cf20 // CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED}\par
8477 \par
8478 {\cf17 namespace }Catch \{\par
8479 {\cf17 namespace }Generators \{\par
8480 {\cf17 namespace }Detail \{\par
8481     {\cf20 // Returns a suitable seed for a random floating generator based off}\par
8482     {\cf20 // the primary internal rng. It does so by taking current value from}\par
8483     {\cf20 // the rng and returning it as the seed.}\par
8484     std::uint32_t getSeed();\par
8485 \}\par
8486 \par
8487 {\cf17 template} <{\cf17 typename} Float>\par
8488 {\cf17 class }RandomFloatingGenerator final : {\cf17 public} IGenerator<Float> \{\par
8489     Catch::SimplePcg32 m_rng;\par
8490     Catch::uniform_floating_point_distribution<Float> m_dist;\par
8491     Float m_current_number;\par
8492 {\cf17 public}:\par
8493     RandomFloatingGenerator( Float a, Float b, std::uint32_t seed ):\par
8494         m_rng(seed),\par
8495         m_dist(a, b) \{\par
8496         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(next());\par
8497     \}\par
8498 \par
8499     Float {\cf17 const}& get(){\cf17  const override }\{\par
8500         {\cf19 return} m_current_number;\par
8501     \}\par
8502     {\cf18 bool} next(){\cf17  override }\{\par
8503         m_current_number = m_dist(m_rng);\par
8504         {\cf19 return} {\cf17 true};\par
8505     \}\par
8506 \};\par
8507 \par
8508 {\cf17 template} <>\par
8509 {\cf17 class }RandomFloatingGenerator<long double> final : {\cf17 public} IGenerator<long double> \{\par
8510     {\cf20 // We still rely on <random> for this specialization, but we don't}\par
8511     {\cf20 // want to drag it into the header.}\par
8512     {\cf17 struct }PImpl;\par
8513     Catch::Detail::unique_ptr<PImpl> m_pimpl;\par
8514     {\cf18 long} {\cf18 double} m_current_number;\par
8515 \par
8516 {\cf17 public}:\par
8517     RandomFloatingGenerator( {\cf18 long} {\cf18 double} a, {\cf18 long} {\cf18 double} b, std::uint32_t seed );\par
8518 \par
8519     {\cf18 long} {\cf18 double} {\cf17 const}& get(){\cf17  const override }\{ {\cf19 return} m_current_number; \}\par
8520     {\cf18 bool} next() {\cf17 override};\par
8521 \par
8522     ~RandomFloatingGenerator() {\cf17 override}; {\cf20 // = default}\par
8523 \};\par
8524 \par
8525 {\cf17 template} <{\cf17 typename} Integer>\par
8526 {\cf17 class }RandomIntegerGenerator final : {\cf17 public} IGenerator<Integer> \{\par
8527     Catch::SimplePcg32 m_rng;\par
8528     Catch::uniform_integer_distribution<Integer> m_dist;\par
8529     Integer m_current_number;\par
8530 {\cf17 public}:\par
8531     RandomIntegerGenerator( Integer a, Integer b, std::uint32_t seed ):\par
8532         m_rng(seed),\par
8533         m_dist(a, b) \{\par
8534         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(next());\par
8535     \}\par
8536 \par
8537     Integer {\cf17 const}& get(){\cf17  const override }\{\par
8538         {\cf19 return} m_current_number;\par
8539     \}\par
8540     {\cf18 bool} next(){\cf17  override }\{\par
8541         m_current_number = m_dist(m_rng);\par
8542         {\cf19 return} {\cf17 true};\par
8543     \}\par
8544 \};\par
8545 \par
8546 {\cf17 template} <{\cf17 typename} T>\par
8547 std::enable_if_t<std::is_integral<T>::value, GeneratorWrapper<T>>\par
8548 random(T a, T b) \{\par
8549     {\cf19 return} GeneratorWrapper<T>(\par
8550         Catch::Detail::make_unique<RandomIntegerGenerator<T>>(a, b, Detail::getSeed())\par
8551     );\par
8552 \}\par
8553 \par
8554 {\cf17 template} <{\cf17 typename} T>\par
8555 std::enable_if_t<std::is_floating_point<T>::value,\par
8556 GeneratorWrapper<T>>\par
8557 random(T a, T b) \{\par
8558     {\cf19 return} GeneratorWrapper<T>(\par
8559         Catch::Detail::make_unique<RandomFloatingGenerator<T>>(a, b, Detail::getSeed())\par
8560     );\par
8561 \}\par
8562 \par
8563 \par
8564 \} {\cf20 // namespace Generators}\par
8565 \} {\cf20 // namespace Catch}\par
8566 \par
8567 \par
8568 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_RANDOM_HPP_INCLUDED}\par
8569 \par
8570 \par
8571 {\cf21 #ifndef CATCH_GENERATORS_RANGE_HPP_INCLUDED}\par
8572 {\cf21 #define CATCH_GENERATORS_RANGE_HPP_INCLUDED}\par
8573 \par
8574 \par
8575 {\cf21 #include <iterator>}\par
8576 {\cf21 #include <type_traits>}\par
8577 \par
8578 {\cf17 namespace }Catch \{\par
8579 {\cf17 namespace }Generators \{\par
8580 \par
8581 \par
8582 {\cf17 template} <{\cf17 typename} T>\par
8583 {\cf17 class }RangeGenerator final : {\cf17 public} IGenerator<T> \{\par
8584     T m_current;\par
8585     T m_end;\par
8586     T m_step;\par
8587     {\cf18 bool} m_positive;\par
8588 \par
8589 {\cf17 public}:\par
8590     RangeGenerator(T {\cf17 const}& start, T {\cf17 const}& end, T {\cf17 const}& step):\par
8591         m_current(start),\par
8592         m_end(end),\par
8593         m_step(step),\par
8594         m_positive(m_step > T(0))\par
8595     \{\par
8596         assert(m_current != m_end && {\cf22 "Range start and end cannot be equal"});\par
8597         assert(m_step != T(0) && {\cf22 "Step size cannot be zero"});\par
8598         assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && {\cf22 "Step moves away from end"});\par
8599     \}\par
8600 \par
8601     RangeGenerator(T {\cf17 const}& start, T {\cf17 const}& end):\par
8602         RangeGenerator(start, end, (start < end) ? T(1) : T(-1))\par
8603     \{\}\par
8604 \par
8605     T {\cf17 const}& get(){\cf17  const override }\{\par
8606         {\cf19 return} m_current;\par
8607     \}\par
8608 \par
8609     {\cf18 bool} next(){\cf17  override }\{\par
8610         m_current += m_step;\par
8611         {\cf19 return} (m_positive) ? (m_current < m_end) : (m_current > m_end);\par
8612     \}\par
8613 \};\par
8614 \par
8615 {\cf17 template} <{\cf17 typename} T>\par
8616 GeneratorWrapper<T> range(T {\cf17 const}& start, T {\cf17 const}& end, T {\cf17 const}& step) \{\par
8617     {\cf17 static_assert}(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, {\cf22 "Type must be numeric"});\par
8618     {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end, step));\par
8619 \}\par
8620 \par
8621 {\cf17 template} <{\cf17 typename} T>\par
8622 GeneratorWrapper<T> range(T {\cf17 const}& start, T {\cf17 const}& end) \{\par
8623     {\cf17 static_assert}(std::is_integral<T>::value && !std::is_same<T, bool>::value, {\cf22 "Type must be an integer"});\par
8624     {\cf19 return} GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end));\par
8625 \}\par
8626 \par
8627 \par
8628 {\cf17 template} <{\cf17 typename} T>\par
8629 {\cf17 class }IteratorGenerator final : {\cf17 public} IGenerator<T> \{\par
8630     {\cf17 static_assert}(!std::is_same<T, bool>::value,\par
8631         {\cf22 "IteratorGenerator currently does not support bools"}\par
8632         {\cf22 "because of std::vector<bool> specialization"});\par
8633 \par
8634     std::vector<T> m_elems;\par
8635     {\cf18 size_t} m_current = 0;\par
8636 {\cf17 public}:\par
8637     {\cf17 template} <{\cf17 typename} InputIterator, {\cf17 typename} InputSentinel>\par
8638     IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) \{\par
8639         {\cf19 if} (m_elems.empty()) \{\par
8640             Detail::throw_generator_exception({\cf22 "IteratorGenerator received no valid values"});\par
8641         \}\par
8642     \}\par
8643 \par
8644     T {\cf17 const}& get(){\cf17  const override }\{\par
8645         {\cf19 return} m_elems[m_current];\par
8646     \}\par
8647 \par
8648     {\cf18 bool} next(){\cf17  override }\{\par
8649         ++m_current;\par
8650         {\cf19 return} m_current != m_elems.size();\par
8651     \}\par
8652 \};\par
8653 \par
8654 {\cf17 template} <{\cf17 typename} InputIterator,\par
8655           {\cf17 typename} InputSentinel,\par
8656           {\cf17 typename} ResultType = {\cf17 typename} std::iterator_traits<InputIterator>::value_type>\par
8657 GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) \{\par
8658     {\cf19 return} GeneratorWrapper<ResultType>(Catch::Detail::make_unique<IteratorGenerator<ResultType>>(from, to));\par
8659 \}\par
8660 \par
8661 {\cf17 template} <{\cf17 typename} Container>\par
8662 {\cf17 auto} from_range(Container {\cf17 const}& cnt) \{\par
8663     {\cf17 using }std::begin;\par
8664     {\cf17 using }std::end;\par
8665     {\cf19 return} from_range( begin( cnt ), end( cnt ) );\par
8666 \}\par
8667 \par
8668 \par
8669 \} {\cf20 // namespace Generators}\par
8670 \} {\cf20 // namespace Catch}\par
8671 \par
8672 \par
8673 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_RANGE_HPP_INCLUDED}\par
8674 \par
8675 {\cf21 #endif }{\cf20 // CATCH_GENERATORS_ALL_HPP_INCLUDED}\par
8676 \par
8677 \par
8692 {\cf21 #ifndef CATCH_INTERFACES_ALL_HPP_INCLUDED}\par
8693 {\cf21 #define CATCH_INTERFACES_ALL_HPP_INCLUDED}\par
8694 \par
8695 \par
8696 \par
8697 {\cf21 #ifndef CATCH_INTERFACES_REPORTER_HPP_INCLUDED}\par
8698 {\cf21 #define CATCH_INTERFACES_REPORTER_HPP_INCLUDED}\par
8699 \par
8700 \par
8701 \par
8702 {\cf21 #ifndef CATCH_TEST_RUN_INFO_HPP_INCLUDED}\par
8703 {\cf21 #define CATCH_TEST_RUN_INFO_HPP_INCLUDED}\par
8704 \par
8705 \par
8706 {\cf17 namespace }Catch \{\par
8707 \par
8708     {\cf17 struct }TestRunInfo \{\par
8709         {\cf17 constexpr} TestRunInfo(StringRef _name) : name(_name) \{\}\par
8710         StringRef name;\par
8711     \};\par
8712 \par
8713 \} {\cf20 // end namespace Catch}\par
8714 \par
8715 {\cf21 #endif }{\cf20 // CATCH_TEST_RUN_INFO_HPP_INCLUDED}\par
8716 \par
8717 {\cf21 #include <map>}\par
8718 {\cf21 #include <string>}\par
8719 {\cf21 #include <vector>}\par
8720 {\cf21 #include <iosfwd>}\par
8721 \par
8722 {\cf17 namespace }Catch \{\par
8723 \par
8724     {\cf17 struct }ReporterDescription;\par
8725     {\cf17 struct }ListenerDescription;\par
8726     {\cf17 struct }TagInfo;\par
8727     {\cf17 struct }TestCaseInfo;\par
8728     {\cf17 class }TestCaseHandle;\par
8729     {\cf17 class }IConfig;\par
8730     {\cf17 class }IStream;\par
8731     {\cf17 enum class} ColourMode : std::uint8_t;\par
8732 \par
8733     {\cf17 struct }ReporterConfig \{\par
8734         ReporterConfig( IConfig {\cf17 const}* _fullConfig,\par
8735                         Detail::unique_ptr<IStream> _stream,\par
8736                         ColourMode colourMode,\par
8737                         std::map<std::string, std::string> customOptions );\par
8738 \par
8739         ReporterConfig( ReporterConfig&& ) = {\cf19 default};\par
8740         ReporterConfig& operator=( ReporterConfig&& ) = {\cf19 default};\par
8741         ~ReporterConfig(); {\cf20 // = default}\par
8742 \par
8743         Detail::unique_ptr<IStream> takeStream() &&;\par
8744         IConfig {\cf17 const}* fullConfig() {\cf17 const};\par
8745         ColourMode colourMode() {\cf17 const};\par
8746         std::map<std::string, std::string> {\cf17 const}& customOptions() {\cf17 const};\par
8747 \par
8748     {\cf17 private}:\par
8749         Detail::unique_ptr<IStream> m_stream;\par
8750         IConfig {\cf17 const}* m_fullConfig;\par
8751         ColourMode m_colourMode;\par
8752         std::map<std::string, std::string> m_customOptions;\par
8753     \};\par
8754 \par
8755     {\cf17 struct }AssertionStats \{\par
8756         AssertionStats( AssertionResult {\cf17 const}& _assertionResult,\par
8757                         std::vector<MessageInfo> {\cf17 const}& _infoMessages,\par
8758                         Totals {\cf17 const}& _totals );\par
8759 \par
8760         AssertionStats( AssertionStats {\cf17 const}& )              = {\cf19 default};\par
8761         AssertionStats( AssertionStats && )                  = {\cf19 default};\par
8762         AssertionStats& operator = ( AssertionStats {\cf17 const}& ) = {\cf17 delete};\par
8763         AssertionStats& operator = ( AssertionStats && )     = {\cf17 delete};\par
8764 \par
8765         AssertionResult assertionResult;\par
8766         std::vector<MessageInfo> infoMessages;\par
8767         Totals totals;\par
8768     \};\par
8769 \par
8770     {\cf17 struct }SectionStats \{\par
8771         SectionStats(   SectionInfo&& _sectionInfo,\par
8772                         Counts {\cf17 const}& _assertions,\par
8773                         {\cf18 double} _durationInSeconds,\par
8774                         {\cf18 bool} _missingAssertions );\par
8775 \par
8776         SectionInfo sectionInfo;\par
8777         Counts assertions;\par
8778         {\cf18 double} durationInSeconds;\par
8779         {\cf18 bool} missingAssertions;\par
8780     \};\par
8781 \par
8782     {\cf17 struct }TestCaseStats \{\par
8783         TestCaseStats(  TestCaseInfo {\cf17 const}& _testInfo,\par
8784                         Totals {\cf17 const}& _totals,\par
8785                         std::string&& _stdOut,\par
8786                         std::string&& _stdErr,\par
8787                         {\cf18 bool} _aborting );\par
8788 \par
8789         TestCaseInfo {\cf17 const} * testInfo;\par
8790         Totals totals;\par
8791         std::string stdOut;\par
8792         std::string stdErr;\par
8793         {\cf18 bool} aborting;\par
8794     \};\par
8795 \par
8796     {\cf17 struct }TestRunStats \{\par
8797         TestRunStats(   TestRunInfo {\cf17 const}& _runInfo,\par
8798                         Totals {\cf17 const}& _totals,\par
8799                         {\cf18 bool} _aborting );\par
8800 \par
8801         TestRunInfo runInfo;\par
8802         Totals totals;\par
8803         {\cf18 bool} aborting;\par
8804     \};\par
8805 \par
8809     {\cf17 struct }ReporterPreferences \{\par
8812         {\cf18 bool} shouldRedirectStdOut = {\cf17 false};\par
8815         {\cf18 bool} shouldReportAllAssertions = {\cf17 false};\par
8816     \};\par
8817 \par
8830     {\cf17 class }IEventListener \{\par
8831     {\cf17 protected}:\par
8833         ReporterPreferences m_preferences;\par
8835         IConfig {\cf17 const}* m_config;\par
8836 \par
8837     {\cf17 public}:\par
8838         IEventListener( IConfig {\cf17 const}* config ): m_config( config ) \{\}\par
8839 \par
8840         {\cf17 virtual} ~IEventListener(); {\cf20 // = default;}\par
8841 \par
8842         {\cf20 // Implementing class must also provide the following static methods:}\par
8843         {\cf20 // static std::string getDescription();}\par
8844 \par
8845         ReporterPreferences {\cf17 const}& getPreferences(){\cf17  const }\{\par
8846             {\cf19 return} m_preferences;\par
8847         \}\par
8848 \par
8850         {\cf17 virtual} {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) = 0;\par
8852         {\cf17 virtual} {\cf18 void} reportInvalidTestSpec( StringRef invalidArgument ) = 0;\par
8853 \par
8859         {\cf17 virtual} {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) = 0;\par
8860 \par
8862         {\cf17 virtual} {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) = 0;\par
8864         {\cf17 virtual} {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}& testInfo, uint64_t partNumber ) = 0;\par
8866         {\cf17 virtual} {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) = 0;\par
8867 \par
8869         {\cf17 virtual} {\cf18 void} benchmarkPreparing( StringRef benchmarkName ) = 0;\par
8871         {\cf17 virtual} {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) = 0;\par
8873         {\cf17 virtual} {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) = 0;\par
8875         {\cf17 virtual} {\cf18 void} benchmarkFailed( StringRef benchmarkName ) = 0;\par
8876 \par
8878         {\cf17 virtual} {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) = 0;\par
8879 \par
8881         {\cf17 virtual} {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) = 0;\par
8882 \par
8884         {\cf17 virtual} {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) = 0;\par
8886         {\cf17 virtual} {\cf18 void} testCasePartialEnded(TestCaseStats {\cf17 const}& testCaseStats, uint64_t partNumber ) = 0;\par
8888         {\cf17 virtual} {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) = 0;\par
8894         {\cf17 virtual} {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) = 0;\par
8895 \par
8902         {\cf17 virtual} {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) = 0;\par
8903 \par
8905         {\cf17 virtual} {\cf18 void} fatalErrorEncountered( StringRef error ) = 0;\par
8906 \par
8908         {\cf17 virtual} {\cf18 void} listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) = 0;\par
8910         {\cf17 virtual} {\cf18 void} listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) = 0;\par
8912         {\cf17 virtual} {\cf18 void} listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) = 0;\par
8914         {\cf17 virtual} {\cf18 void} listTags(std::vector<TagInfo> {\cf17 const}& tags) = 0;\par
8915     \};\par
8916     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
8917 \par
8918 \} {\cf20 // end namespace Catch}\par
8919 \par
8920 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_REPORTER_HPP_INCLUDED}\par
8921 \par
8922 \par
8923 {\cf21 #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED}\par
8924 {\cf21 #define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED}\par
8925 \par
8926 \par
8927 {\cf21 #include <string>}\par
8928 \par
8929 {\cf17 namespace }Catch \{\par
8930 \par
8931     {\cf17 struct }ReporterConfig;\par
8932     {\cf17 class }IConfig;\par
8933     {\cf17 class }IEventListener;\par
8934     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
8935 \par
8936 \par
8937     {\cf17 class }IReporterFactory \{\par
8938     {\cf17 public}:\par
8939         {\cf17 virtual} ~IReporterFactory(); {\cf20 // = default}\par
8940 \par
8941         {\cf17 virtual} IEventListenerPtr\par
8942         create( ReporterConfig&& config ) {\cf17 const} = 0;\par
8943         {\cf17 virtual} std::string getDescription() {\cf17 const} = 0;\par
8944     \};\par
8945     {\cf17 using }IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;\par
8946 \par
8947     {\cf17 class }EventListenerFactory \{\par
8948     {\cf17 public}:\par
8949         {\cf17 virtual} ~EventListenerFactory(); {\cf20 // = default}\par
8950         {\cf17 virtual} IEventListenerPtr create( IConfig {\cf17 const}* config ) {\cf17 const} = 0;\par
8952         {\cf17 virtual} StringRef getName() {\cf17 const} = 0;\par
8954         {\cf17 virtual} std::string getDescription() {\cf17 const} = 0;\par
8955     \};\par
8956 \} {\cf20 // namespace Catch}\par
8957 \par
8958 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED}\par
8959 \par
8960 \par
8961 {\cf21 #ifndef CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
8962 {\cf21 #define CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
8963 \par
8964 {\cf21 #include <string>}\par
8965 \par
8966 {\cf17 namespace }Catch \{\par
8967 \par
8968     {\cf17 struct }TagAlias;\par
8969 \par
8970     {\cf17 class }ITagAliasRegistry \{\par
8971     {\cf17 public}:\par
8972         {\cf17 virtual} ~ITagAliasRegistry(); {\cf20 // = default}\par
8973         {\cf20 // Nullptr if not present}\par
8974         {\cf17 virtual} TagAlias {\cf17 const}* find( std::string {\cf17 const}& alias ) {\cf17 const} = 0;\par
8975         {\cf17 virtual} std::string expandAliases( std::string {\cf17 const}& unexpandedTestSpec ) {\cf17 const} = 0;\par
8976 \par
8977         {\cf17 static} ITagAliasRegistry {\cf17 const}& get();\par
8978     \};\par
8979 \par
8980 \} {\cf20 // end namespace Catch}\par
8981 \par
8982 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
8983 \par
8984 \par
8985 {\cf21 #ifndef CATCH_INTERFACES_TESTCASE_HPP_INCLUDED}\par
8986 {\cf21 #define CATCH_INTERFACES_TESTCASE_HPP_INCLUDED}\par
8987 \par
8988 {\cf21 #include <vector>}\par
8989 \par
8990 {\cf17 namespace }Catch \{\par
8991 \par
8992     {\cf17 struct }TestCaseInfo;\par
8993     {\cf17 class }TestCaseHandle;\par
8994     {\cf17 class }IConfig;\par
8995 \par
8996     {\cf17 class }ITestCaseRegistry \{\par
8997     {\cf17 public}:\par
8998         {\cf17 virtual} ~ITestCaseRegistry(); {\cf20 // = default}\par
8999         {\cf20 // TODO: this exists only for adding filenames to test cases -- let's expose this in a saner way later}\par
9000         {\cf17 virtual} std::vector<TestCaseInfo* > {\cf17 const}& getAllInfos() {\cf17 const} = 0;\par
9001         {\cf17 virtual} std::vector<TestCaseHandle> {\cf17 const}& getAllTests() {\cf17 const} = 0;\par
9002         {\cf17 virtual} std::vector<TestCaseHandle> {\cf17 const}& getAllTestsSorted( IConfig {\cf17 const}& config ) {\cf17 const} = 0;\par
9003     \};\par
9004 \par
9005 \}\par
9006 \par
9007 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_TESTCASE_HPP_INCLUDED}\par
9008 \par
9009 {\cf21 #endif }{\cf20 // CATCH_INTERFACES_ALL_HPP_INCLUDED}\par
9010 \par
9011 \par
9012 {\cf21 #ifndef CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED}\par
9013 {\cf21 #define CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED}\par
9014 \par
9015 \par
9016 {\cf17 namespace }Catch \{\par
9017     {\cf17 namespace }Detail \{\par
9019         {\cf17 struct }CaseInsensitiveLess \{\par
9020             {\cf18 bool} operator()( StringRef lhs,\par
9021                              StringRef rhs ) {\cf17 const};\par
9022         \};\par
9023 \par
9025         {\cf17 struct }CaseInsensitiveEqualTo \{\par
9026             {\cf18 bool} operator()( StringRef lhs,\par
9027                              StringRef rhs ) {\cf17 const};\par
9028         \};\par
9029 \par
9030     \} {\cf20 // namespace Detail}\par
9031 \} {\cf20 // namespace Catch}\par
9032 \par
9033 {\cf21 #endif }{\cf20 // CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED}\par
9034 \par
9035 \par
9036 \par
9045 {\cf21 #ifndef CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED}\par
9046 {\cf21 #define CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED}\par
9047 \par
9048 \par
9049 {\cf21 #if defined(__ANDROID__)}\par
9050 {\cf21 #    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE}\par
9051 {\cf21 #endif}\par
9052 \par
9053 \par
9054 {\cf21 #if defined( CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE ) && \\}\par
9055 {\cf21     !defined( CATCH_CONFIG_NO_ANDROID_LOGWRITE ) &&      \\}\par
9056 {\cf21     !defined( CATCH_CONFIG_ANDROID_LOGWRITE )}\par
9057 {\cf21 #    define CATCH_CONFIG_ANDROID_LOGWRITE}\par
9058 {\cf21 #endif}\par
9059 \par
9060 {\cf21 #endif }{\cf20 // CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED}\par
9061 \par
9062 \par
9063 \par
9072 {\cf21 #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
9073 {\cf21 #define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
9074 \par
9075 \par
9076 {\cf21 #if defined(_MSC_VER)}\par
9077 {\cf21 #  if _MSC_VER >= 1900 }{\cf20 // Visual Studio 2015 or newer}\par
9078 {\cf21 #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
9079 {\cf21 #  endif}\par
9080 {\cf21 #endif}\par
9081 \par
9082 \par
9083 {\cf21 #include <exception>}\par
9084 \par
9085 {\cf21 #if defined(__cpp_lib_uncaught_exceptions) \\}\par
9086 {\cf21     && !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
9087 \par
9088 {\cf21 #  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
9089 {\cf21 #endif }{\cf20 // __cpp_lib_uncaught_exceptions}\par
9090 \par
9091 \par
9092 {\cf21 #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \\}\par
9093 {\cf21     && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \\}\par
9094 {\cf21     && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)}\par
9095 \par
9096 {\cf21 #  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS}\par
9097 {\cf21 #endif}\par
9098 \par
9099 \par
9100 {\cf21 #endif }{\cf20 // CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
9101 \par
9102 \par
9103 {\cf21 #ifndef CATCH_CONSOLE_COLOUR_HPP_INCLUDED}\par
9104 {\cf21 #define CATCH_CONSOLE_COLOUR_HPP_INCLUDED}\par
9105 \par
9106 \par
9107 {\cf21 #include <iosfwd>}\par
9108 {\cf21 #include <cstdint>}\par
9109 \par
9110 {\cf17 namespace }Catch \{\par
9111 \par
9112     {\cf17 enum class} ColourMode : std::uint8_t;\par
9113     {\cf17 class }IStream;\par
9114 \par
9115     {\cf17 struct }Colour \{\par
9116         {\cf17 enum} Code \{\par
9117             None = 0,\par
9118 \par
9119             White,\par
9120             Red,\par
9121             Green,\par
9122             Blue,\par
9123             Cyan,\par
9124             Yellow,\par
9125             Grey,\par
9126 \par
9127             Bright = 0x10,\par
9128 \par
9129             BrightRed = Bright | Red,\par
9130             BrightGreen = Bright | Green,\par
9131             LightGrey = Bright | Grey,\par
9132             BrightWhite = Bright | White,\par
9133             BrightYellow = Bright | Yellow,\par
9134 \par
9135             {\cf20 // By intention}\par
9136             FileName = LightGrey,\par
9137             Warning = BrightYellow,\par
9138             ResultError = BrightRed,\par
9139             ResultSuccess = BrightGreen,\par
9140             ResultExpectedFailure = Warning,\par
9141 \par
9142             Error = BrightRed,\par
9143             Success = Green,\par
9144             Skip = LightGrey,\par
9145 \par
9146             OriginalExpression = Cyan,\par
9147             ReconstructedExpression = BrightYellow,\par
9148 \par
9149             SecondaryText = LightGrey,\par
9150             Headers = White\par
9151         \};\par
9152     \};\par
9153 \par
9154     {\cf17 class }ColourImpl \{\par
9155     {\cf17 protected}:\par
9157         IStream* m_stream;\par
9158     {\cf17 public}:\par
9159         ColourImpl( IStream* stream ): m_stream( stream ) \{\}\par
9160 \par
9163         {\cf17 class }ColourGuard \{\par
9164             ColourImpl {\cf17 const}* m_colourImpl;\par
9165             Colour::Code m_code;\par
9166             {\cf18 bool} m_engaged = {\cf17 false};\par
9167 \par
9168         {\cf17 public}:\par
9170             ColourGuard( Colour::Code code,\par
9171                          ColourImpl {\cf17 const}* colour );\par
9172 \par
9173             ColourGuard( ColourGuard {\cf17 const}& rhs ) = {\cf17 delete};\par
9174             ColourGuard& operator=( ColourGuard {\cf17 const}& rhs ) = {\cf17 delete};\par
9175 \par
9176             ColourGuard( ColourGuard&& rhs ) {\cf17 noexcept};\par
9177             ColourGuard& operator=( ColourGuard&& rhs ) {\cf17 noexcept};\par
9178 \par
9180             ~ColourGuard();\par
9181 \par
9187             ColourGuard& engage( std::ostream& stream ) &;\par
9193             ColourGuard&& engage( std::ostream& stream ) &&;\par
9194 \par
9195         {\cf17 private}:\par
9197             {\cf17 friend} std::ostream& operator<<( std::ostream& lhs,\par
9198                                              ColourGuard& guard ) \{\par
9199                 guard.engageImpl( lhs );\par
9200                 {\cf19 return} lhs;\par
9201             \}\par
9203             {\cf17 friend} std::ostream& operator<<( std::ostream& lhs,\par
9204                                             ColourGuard&& guard) \{\par
9205                 guard.engageImpl( lhs );\par
9206                 {\cf19 return} lhs;\par
9207             \}\par
9208 \par
9209             {\cf18 void} engageImpl( std::ostream& stream );\par
9210 \par
9211         \};\par
9212 \par
9213         {\cf17 virtual} ~ColourImpl(); {\cf20 // = default}\par
9220         ColourGuard guardColour( Colour::Code colourCode );\par
9221 \par
9222     {\cf17 private}:\par
9223         {\cf17 virtual} {\cf18 void} use( Colour::Code colourCode ) {\cf17 const} = 0;\par
9224     \};\par
9225 \par
9227     Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,\par
9228                                                    IStream* stream );\par
9229 \par
9231     {\cf18 bool} isColourImplAvailable( ColourMode colourSelection );\par
9232 \par
9233 \} {\cf20 // end namespace Catch}\par
9234 \par
9235 {\cf21 #endif }{\cf20 // CATCH_CONSOLE_COLOUR_HPP_INCLUDED}\par
9236 \par
9237 \par
9238 {\cf21 #ifndef CATCH_CONSOLE_WIDTH_HPP_INCLUDED}\par
9239 {\cf21 #define CATCH_CONSOLE_WIDTH_HPP_INCLUDED}\par
9240 \par
9241 {\cf20 // This include must be kept so that user's configured value for CONSOLE_WIDTH}\par
9242 {\cf20 // is used before we attempt to provide a default value}\par
9243 \par
9244 {\cf21 #ifndef CATCH_CONFIG_CONSOLE_WIDTH}\par
9245 {\cf21 #define CATCH_CONFIG_CONSOLE_WIDTH 80}\par
9246 {\cf21 #endif}\par
9247 \par
9248 {\cf21 #endif }{\cf20 // CATCH_CONSOLE_WIDTH_HPP_INCLUDED}\par
9249 \par
9250 \par
9251 {\cf21 #ifndef CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED}\par
9252 {\cf21 #define CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED}\par
9253 \par
9254 \par
9255 {\cf21 #include <cstddef>}\par
9256 {\cf21 #include <initializer_list>}\par
9257 \par
9258 {\cf20 // We want a simple polyfill over `std::empty`, `std::size` and so on}\par
9259 {\cf20 // for C++14 or C++ libraries with incomplete support.}\par
9260 {\cf20 // We also have to handle that MSVC std lib will happily provide these}\par
9261 {\cf20 // under older standards.}\par
9262 {\cf21 #if defined(CATCH_CPP17_OR_GREATER) || defined(_MSC_VER)}\par
9263 \par
9264 {\cf20 // We are already using this header either way, so there shouldn't}\par
9265 {\cf20 // be much additional overhead in including it to get the feature}\par
9266 {\cf20 // test macros}\par
9267 {\cf21 #include <string>}\par
9268 \par
9269 {\cf21 #  if !defined(__cpp_lib_nonmember_container_access)}\par
9270 {\cf21 #      define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS}\par
9271 {\cf21 #  endif}\par
9272 \par
9273 {\cf21 #else}\par
9274 {\cf21 #define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS}\par
9275 {\cf21 #endif}\par
9276 \par
9277 \par
9278 \par
9279 {\cf17 namespace }Catch \{\par
9280 {\cf17 namespace }Detail \{\par
9281 \par
9282 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
9283     {\cf17 template} <{\cf17 typename} Container>\par
9284     {\cf17 constexpr} {\cf17 auto} empty(Container {\cf17 const}& cont) -> {\cf17 decltype}(cont.empty()) \{\par
9285         {\cf19 return} cont.empty();\par
9286     \}\par
9287     {\cf17 template} <{\cf17 typename} T, std::{\cf18 size_t} N>\par
9288     {\cf17 constexpr} {\cf18 bool} empty({\cf17 const} T (&)[N]) {\cf17 noexcept} \{\par
9289         {\cf20 // GCC < 7 does not support the const T(&)[] parameter syntax}\par
9290         {\cf20 // so we have to ignore the length explicitly}\par
9291         (void)N;\par
9292         {\cf19 return} {\cf17 false};\par
9293     \}\par
9294     {\cf17 template} <{\cf17 typename} T>\par
9295     {\cf17 constexpr} {\cf18 bool} empty(std::initializer_list<T> list) {\cf17 noexcept} \{\par
9296         {\cf19 return} list.size() > 0;\par
9297     \}\par
9298 \par
9299 \par
9300     {\cf17 template} <{\cf17 typename} Container>\par
9301     {\cf17 constexpr} {\cf17 auto} size(Container {\cf17 const}& cont) -> {\cf17 decltype}(cont.size()) \{\par
9302         {\cf19 return} cont.size();\par
9303     \}\par
9304     {\cf17 template} <{\cf17 typename} T, std::{\cf18 size_t} N>\par
9305     {\cf17 constexpr} std::size_t size({\cf17 const} T(&)[N]) {\cf17 noexcept} \{\par
9306         {\cf19 return} N;\par
9307     \}\par
9308 {\cf21 #endif }{\cf20 // CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS}\par
9309 \par
9310 \} {\cf20 // end namespace Detail}\par
9311 \} {\cf20 // end namespace Catch}\par
9312 \par
9313 \par
9314 \par
9315 {\cf21 #endif }{\cf20 // CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED}\par
9316 \par
9317 \par
9318 {\cf21 #ifndef CATCH_DEBUG_CONSOLE_HPP_INCLUDED}\par
9319 {\cf21 #define CATCH_DEBUG_CONSOLE_HPP_INCLUDED}\par
9320 \par
9321 {\cf21 #include <string>}\par
9322 \par
9323 {\cf17 namespace }Catch \{\par
9324     {\cf18 void} writeToDebugConsole( std::string {\cf17 const}& text );\par
9325 \}\par
9326 \par
9327 {\cf21 #endif }{\cf20 // CATCH_DEBUG_CONSOLE_HPP_INCLUDED}\par
9328 \par
9329 \par
9330 {\cf21 #ifndef CATCH_DEBUGGER_HPP_INCLUDED}\par
9331 {\cf21 #define CATCH_DEBUGGER_HPP_INCLUDED}\par
9332 \par
9333 \par
9334 {\cf17 namespace }Catch \{\par
9335     {\cf18 bool} isDebuggerActive();\par
9336 \}\par
9337 \par
9338 {\cf21 #ifdef CATCH_PLATFORM_MAC}\par
9339 \par
9340 {\cf21     #if defined(__i386__) || defined(__x86_64__)}\par
9341 {\cf21         #define CATCH_TRAP() __asm__("int $3\\n" : : ) }{\cf20 /* NOLINT */}{\cf21 }\par
9342 {\cf21     #elif defined(__aarch64__)}\par
9343 {\cf21         #define CATCH_TRAP() __asm__(".inst 0xd43e0000")}\par
9344 {\cf21     #elif defined(__POWERPC__)}\par
9345 {\cf21         #define CATCH_TRAP() __asm__("li r0, 20\\nsc\\nnop\\nli r0, 37\\nli r4, 2\\nsc\\nnop\\n" \\}\par
9346 {\cf21         : : : "memory","r0","r3","r4" ) }{\cf20 /* NOLINT */}{\cf21 }\par
9347 {\cf21     #endif}\par
9348 \par
9349 {\cf21 #elif defined(CATCH_PLATFORM_IPHONE)}\par
9350 \par
9351     {\cf20 // use inline assembler}\par
9352 {\cf21     #if defined(__i386__) || defined(__x86_64__)}\par
9353 {\cf21         #define CATCH_TRAP()  __asm__("int $3")}\par
9354 {\cf21     #elif defined(__aarch64__)}\par
9355 {\cf21         #define CATCH_TRAP()  __asm__(".inst 0xd4200000")}\par
9356 {\cf21     #elif defined(__arm__) && !defined(__thumb__)}\par
9357 {\cf21         #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")}\par
9358 {\cf21     #elif defined(__arm__) &&  defined(__thumb__)}\par
9359 {\cf21         #define CATCH_TRAP()  __asm__(".inst 0xde01")}\par
9360 {\cf21     #endif}\par
9361 \par
9362 {\cf21 #elif defined(CATCH_PLATFORM_LINUX)}\par
9363     {\cf20 // If we can use inline assembler, do it because this allows us to break}\par
9364     {\cf20 // directly at the location of the failing check instead of breaking inside}\par
9365     {\cf20 // raise() called from it, i.e. one stack frame below.}\par
9366 {\cf21     #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))}\par
9367 {\cf21         #define CATCH_TRAP() asm volatile ("int $3") }{\cf20 /* NOLINT */}{\cf21 }\par
9368 {\cf21     #else }{\cf20 // Fall back to the generic way.}\par
9369 {\cf21         #include <signal.h>}\par
9370 \par
9371 {\cf21         #define CATCH_TRAP() raise(SIGTRAP)}\par
9372 {\cf21     #endif}\par
9373 {\cf21 #elif defined(_MSC_VER)}\par
9374 {\cf21     #define CATCH_TRAP() __debugbreak()}\par
9375 {\cf21 #elif defined(__MINGW32__)}\par
9376     {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 void} __stdcall DebugBreak();\par
9377 {\cf21     #define CATCH_TRAP() DebugBreak()}\par
9378 {\cf21 #endif}\par
9379 \par
9380 {\cf21 #ifndef CATCH_BREAK_INTO_DEBUGGER}\par
9381 {\cf21     #ifdef CATCH_TRAP}\par
9382 {\cf21         #define CATCH_BREAK_INTO_DEBUGGER() []\{ if( Catch::isDebuggerActive() ) \{ CATCH_TRAP(); \} \}()}\par
9383 {\cf21     #else}\par
9384 {\cf21         #define CATCH_BREAK_INTO_DEBUGGER() []\{\}()}\par
9385 {\cf21     #endif}\par
9386 {\cf21 #endif}\par
9387 \par
9388 {\cf21 #endif }{\cf20 // CATCH_DEBUGGER_HPP_INCLUDED}\par
9389 \par
9390 \par
9391 {\cf21 #ifndef CATCH_ENFORCE_HPP_INCLUDED}\par
9392 {\cf21 #define CATCH_ENFORCE_HPP_INCLUDED}\par
9393 \par
9394 \par
9395 {\cf21 #include <exception>}\par
9396 \par
9397 {\cf17 namespace }Catch \{\par
9398 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
9399     {\cf17 template} <{\cf17 typename} Ex>\par
9400     [[noreturn]]\par
9401     {\cf18 void} throw_exception(Ex {\cf17 const}& e) \{\par
9402         {\cf19 throw} e;\par
9403     \}\par
9404 {\cf21 #else }{\cf20 // ^^ Exceptions are enabled //  Exceptions are disabled vv}\par
9405     [[noreturn]]\par
9406     {\cf18 void} throw_exception(std::exception {\cf17 const}& e);\par
9407 {\cf21 #endif}\par
9408 \par
9409     [[noreturn]]\par
9410     {\cf18 void} throw_logic_error(std::string {\cf17 const}& msg);\par
9411     [[noreturn]]\par
9412     {\cf18 void} throw_domain_error(std::string {\cf17 const}& msg);\par
9413     [[noreturn]]\par
9414     {\cf18 void} throw_runtime_error(std::string {\cf17 const}& msg);\par
9415 \par
9416 \} {\cf20 // namespace Catch;}\par
9417 \par
9418 {\cf21 #define CATCH_MAKE_MSG(...) \\}\par
9419 {\cf21     (Catch::ReusableStringStream() << __VA_ARGS__).str()}\par
9420 \par
9421 {\cf21 #define CATCH_INTERNAL_ERROR(...) \\}\par
9422 {\cf21     Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))}\par
9423 \par
9424 {\cf21 #define CATCH_ERROR(...) \\}\par
9425 {\cf21     Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))}\par
9426 \par
9427 {\cf21 #define CATCH_RUNTIME_ERROR(...) \\}\par
9428 {\cf21     Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))}\par
9429 \par
9430 {\cf21 #define CATCH_ENFORCE( condition, ... ) \\}\par
9431 {\cf21     do\{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); \} while(false)}\par
9432 \par
9433 \par
9434 {\cf21 #endif }{\cf20 // CATCH_ENFORCE_HPP_INCLUDED}\par
9435 \par
9436 \par
9437 {\cf21 #ifndef CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
9438 {\cf21 #define CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
9439 \par
9440 \par
9441 {\cf21 #include <vector>}\par
9442 \par
9443 {\cf17 namespace }Catch \{\par
9444 \par
9445     {\cf17 namespace }Detail \{\par
9446 \par
9447         Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values );\par
9448 \par
9449         {\cf17 class }EnumValuesRegistry : {\cf17 public} IMutableEnumValuesRegistry \{\par
9450 \par
9451             std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;\par
9452 \par
9453             EnumInfo {\cf17 const}& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> {\cf17 const}& values) {\cf17 override};\par
9454         \};\par
9455 \par
9456         std::vector<StringRef> parseEnums( StringRef enums );\par
9457 \par
9458     \} {\cf20 // Detail}\par
9459 \par
9460 \} {\cf20 // Catch}\par
9461 \par
9462 {\cf21 #endif }{\cf20 // CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED}\par
9463 \par
9464 \par
9465 {\cf21 #ifndef CATCH_ERRNO_GUARD_HPP_INCLUDED}\par
9466 {\cf21 #define CATCH_ERRNO_GUARD_HPP_INCLUDED}\par
9467 \par
9468 {\cf17 namespace }Catch \{\par
9469 \par
9472     {\cf17 class }ErrnoGuard \{\par
9473     {\cf17 public}:\par
9474         {\cf20 // Keep these outlined to avoid dragging in macros from <cerrno>}\par
9475 \par
9476         ErrnoGuard();\par
9477         ~ErrnoGuard();\par
9478     {\cf17 private}:\par
9479         {\cf18 int} m_oldErrno;\par
9480     \};\par
9481 \par
9482 \}\par
9483 \par
9484 {\cf21 #endif }{\cf20 // CATCH_ERRNO_GUARD_HPP_INCLUDED}\par
9485 \par
9486 \par
9487 {\cf21 #ifndef CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED}\par
9488 {\cf21 #define CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED}\par
9489 \par
9490 \par
9491 {\cf21 #include <vector>}\par
9492 {\cf21 #include <string>}\par
9493 \par
9494 {\cf17 namespace }Catch \{\par
9495 \par
9496     {\cf17 class }ExceptionTranslatorRegistry : {\cf17 public} IExceptionTranslatorRegistry \{\par
9497     {\cf17 public}:\par
9498         ~ExceptionTranslatorRegistry() {\cf17 override};\par
9499         {\cf18 void} registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator );\par
9500         std::string translateActiveException() {\cf17 const override};\par
9501 \par
9502     {\cf17 private}:\par
9503         ExceptionTranslators m_translators;\par
9504     \};\par
9505 \}\par
9506 \par
9507 {\cf21 #endif }{\cf20 // CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED}\par
9508 \par
9509 \par
9510 {\cf21 #ifndef CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED}\par
9511 {\cf21 #define CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED}\par
9512 \par
9513 {\cf21 #include <cassert>}\par
9514 \par
9515 {\cf17 namespace }Catch \{\par
9516 \par
9527     {\cf17 class }FatalConditionHandler \{\par
9528         {\cf18 bool} m_started = {\cf17 false};\par
9529 \par
9530         {\cf20 // Install/disengage implementation for specific platform.}\par
9531         {\cf20 // Should be if-defed to work on current platform, can assume}\par
9532         {\cf20 // engage-disengage 1:1 pairing.}\par
9533         {\cf18 void} engage_platform();\par
9534         {\cf18 void} disengage_platform() noexcept;\par
9535     public:\par
9536         {\cf20 // Should also have platform-specific implementations as needed}\par
9537         FatalConditionHandler();\par
9538         ~FatalConditionHandler();\par
9539 \par
9540         {\cf18 void} engage() \{\par
9541             assert(!m_started && {\cf22 "Handler cannot be installed twice."});\par
9542             m_started = {\cf17 true};\par
9543             engage_platform();\par
9544         \}\par
9545 \par
9546         {\cf18 void} disengage() noexcept \{\par
9547             assert(m_started && {\cf22 "Handler cannot be uninstalled without being installed first"});\par
9548             m_started = {\cf17 false};\par
9549             disengage_platform();\par
9550         \}\par
9551     \};\par
9552 \par
9554     {\cf17 class }FatalConditionHandlerGuard \{\par
9555         FatalConditionHandler* m_handler;\par
9556     {\cf17 public}:\par
9557         FatalConditionHandlerGuard(FatalConditionHandler* handler):\par
9558             m_handler(handler) \{\par
9559             m_handler->engage();\par
9560         \}\par
9561         ~FatalConditionHandlerGuard() \{\par
9562             m_handler->disengage();\par
9563         \}\par
9564     \};\par
9565 \par
9566 \} {\cf20 // end namespace Catch}\par
9567 \par
9568 {\cf21 #endif }{\cf20 // CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED}\par
9569 \par
9570 \par
9571 {\cf21 #ifndef CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
9572 {\cf21 #define CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
9573 \par
9574 \par
9575 {\cf21 #include <cassert>}\par
9576 {\cf21 #include <cmath>}\par
9577 {\cf21 #include <cstdint>}\par
9578 {\cf21 #include <utility>}\par
9579 {\cf21 #include <limits>}\par
9580 \par
9581 {\cf17 namespace }Catch \{\par
9582     {\cf17 namespace }Detail \{\par
9583 \par
9584         uint32_t convertToBits({\cf18 float} f);\par
9585         uint64_t convertToBits({\cf18 double} d);\par
9586 \par
9587         {\cf20 // Used when we know we want == comparison of two doubles}\par
9588         {\cf20 // to centralize warning suppression}\par
9589         {\cf18 bool} directCompare( {\cf18 float} lhs, {\cf18 float} rhs );\par
9590         {\cf18 bool} directCompare( {\cf18 double} lhs, {\cf18 double} rhs );\par
9591 \par
9592     \} {\cf20 // end namespace Detail}\par
9593 \par
9594 \par
9595 \par
9596 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
9597 {\cf21 #    pragma GCC diagnostic push}\par
9598     {\cf20 // We do a bunch of direct compensations of floating point numbers,}\par
9599     {\cf20 // because we know what we are doing and actually do want the direct}\par
9600     {\cf20 // comparison behaviour.}\par
9601 {\cf21 #    pragma GCC diagnostic ignored "-Wfloat-equal"}\par
9602 {\cf21 #endif}\par
9603 \par
9621     {\cf17 template} <{\cf17 typename} FP>\par
9622     uint64_t ulpDistance( FP lhs, FP rhs ) \{\par
9623         assert( std::numeric_limits<FP>::is_iec559 &&\par
9624             {\cf22 "ulpDistance assumes IEEE-754 format for floating point types"} );\par
9625         assert( !Catch::isnan( lhs ) &&\par
9626                 {\cf22 "Distance between NaN and number is not meaningful"} );\par
9627         assert( !Catch::isnan( rhs ) &&\par
9628                 {\cf22 "Distance between NaN and number is not meaningful"} );\par
9629 \par
9630         {\cf20 // We want X == Y to imply 0 ULP distance even if X and Y aren't}\par
9631         {\cf20 // bit-equal (-0 and 0), or X - Y != 0 (same sign infinities).}\par
9632         {\cf19 if} ( lhs == rhs ) \{ {\cf19 return} 0; \}\par
9633 \par
9634         {\cf20 // We need a properly typed positive zero for type inference.}\par
9635         {\cf17 static} {\cf17 constexpr} FP positive_zero\{\};\par
9636 \par
9637         {\cf20 // We want to ensure that +/- 0 is always represented as positive zero}\par
9638         {\cf19 if} ( lhs == positive_zero ) \{ lhs = positive_zero; \}\par
9639         {\cf19 if} ( rhs == positive_zero ) \{ rhs = positive_zero; \}\par
9640 \par
9641         {\cf20 // If arguments have different signs, we can handle them by summing}\par
9642         {\cf20 // how far are they from 0 each.}\par
9643         {\cf19 if} ( std::signbit( lhs ) != std::signbit( rhs ) ) \{\par
9644             {\cf19 return} ulpDistance( std::abs( lhs ), positive_zero ) +\par
9645                    ulpDistance( std::abs( rhs ), positive_zero );\par
9646         \}\par
9647 \par
9648         {\cf20 // When both lhs and rhs are of the same sign, we can just}\par
9649         {\cf20 // read the numbers bitwise as integers, and then subtract them}\par
9650         {\cf20 // (assuming IEEE).}\par
9651         uint64_t lc = Detail::convertToBits( lhs );\par
9652         uint64_t rc = Detail::convertToBits( rhs );\par
9653 \par
9654         {\cf20 // The ulp distance between two numbers is symmetric, so to avoid}\par
9655         {\cf20 // dealing with overflows we want the bigger converted number on the lhs}\par
9656         {\cf19 if} ( lc < rc ) \{\par
9657             std::swap( lc, rc );\par
9658         \}\par
9659 \par
9660         {\cf19 return} lc - rc;\par
9661     \}\par
9662 \par
9663 {\cf21 #if defined( __GNUC__ ) || defined( __clang__ )}\par
9664 {\cf21 #    pragma GCC diagnostic pop}\par
9665 {\cf21 #endif}\par
9666 \par
9667 \par
9668 \} {\cf20 // end namespace Catch}\par
9669 \par
9670 {\cf21 #endif }{\cf20 // CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED}\par
9671 \par
9672 \par
9673 {\cf21 #ifndef CATCH_GETENV_HPP_INCLUDED}\par
9674 {\cf21 #define CATCH_GETENV_HPP_INCLUDED}\par
9675 \par
9676 {\cf17 namespace }Catch \{\par
9677 {\cf17 namespace }Detail \{\par
9678 \par
9680     {\cf18 char} {\cf17 const}* getEnv({\cf18 char} {\cf17 const}* varName);\par
9681 \par
9682 \}\par
9683 \}\par
9684 \par
9685 {\cf21 #endif }{\cf20 // CATCH_GETENV_HPP_INCLUDED}\par
9686 \par
9687 \par
9688 {\cf21 #ifndef CATCH_IS_PERMUTATION_HPP_INCLUDED}\par
9689 {\cf21 #define CATCH_IS_PERMUTATION_HPP_INCLUDED}\par
9690 \par
9691 {\cf21 #include <algorithm>}\par
9692 {\cf21 #include <iterator>}\par
9693 \par
9694 {\cf17 namespace }Catch \{\par
9695     {\cf17 namespace }Detail \{\par
9696 \par
9697         {\cf17 template} <{\cf17 typename} ForwardIter,\par
9698                   {\cf17 typename} Sentinel,\par
9699                   {\cf17 typename} T,\par
9700                   {\cf17 typename} Comparator>\par
9701         ForwardIter find_sentinel( ForwardIter start,\par
9702                                    Sentinel sentinel,\par
9703                                    T {\cf17 const}& value,\par
9704                                    Comparator cmp ) \{\par
9705             {\cf19 while} ( start != sentinel ) \{\par
9706                 {\cf19 if} ( cmp( *start, value ) ) \{ {\cf19 break}; \}\par
9707                 ++start;\par
9708             \}\par
9709             {\cf19 return} start;\par
9710         \}\par
9711 \par
9712         {\cf17 template} <{\cf17 typename} ForwardIter,\par
9713                   {\cf17 typename} Sentinel,\par
9714                   {\cf17 typename} T,\par
9715                   {\cf17 typename} Comparator>\par
9716         std::ptrdiff_t count_sentinel( ForwardIter start,\par
9717                                        Sentinel sentinel,\par
9718                                        T {\cf17 const}& value,\par
9719                                        Comparator cmp ) \{\par
9720             std::ptrdiff_t count = 0;\par
9721             {\cf19 while} ( start != sentinel ) \{\par
9722                 {\cf19 if} ( cmp( *start, value ) ) \{ ++count; \}\par
9723                 ++start;\par
9724             \}\par
9725             {\cf19 return} count;\par
9726         \}\par
9727 \par
9728         {\cf17 template} <{\cf17 typename} ForwardIter, {\cf17 typename} Sentinel>\par
9729         std::enable_if_t<!std::is_same<ForwardIter, Sentinel>::value,\par
9730                          std::ptrdiff_t>\par
9731         sentinel_distance( ForwardIter iter, {\cf17 const} Sentinel sentinel ) \{\par
9732             std::ptrdiff_t dist = 0;\par
9733             {\cf19 while} ( iter != sentinel ) \{\par
9734                 ++iter;\par
9735                 ++dist;\par
9736             \}\par
9737             {\cf19 return} dist;\par
9738         \}\par
9739 \par
9740         {\cf17 template} <{\cf17 typename} ForwardIter>\par
9741         std::ptrdiff_t sentinel_distance( ForwardIter first,\par
9742                                           ForwardIter last ) \{\par
9743             {\cf19 return} std::distance( first, last );\par
9744         \}\par
9745 \par
9746         {\cf17 template} <{\cf17 typename} ForwardIter1,\par
9747                   {\cf17 typename} Sentinel1,\par
9748                   {\cf17 typename} ForwardIter2,\par
9749                   {\cf17 typename} Sentinel2,\par
9750                   {\cf17 typename} Comparator>\par
9751         {\cf18 bool} check_element_counts( ForwardIter1 first_1,\par
9752                                    {\cf17 const} Sentinel1 end_1,\par
9753                                    ForwardIter2 first_2,\par
9754                                    {\cf17 const} Sentinel2 end_2,\par
9755                                    Comparator cmp ) \{\par
9756             {\cf17 auto} cursor = first_1;\par
9757             {\cf19 while} ( cursor != end_1 ) \{\par
9758                 {\cf19 if} ( find_sentinel( first_1, cursor, *cursor, cmp ) ==\par
9759                      cursor ) \{\par
9760                     {\cf20 // we haven't checked this element yet}\par
9761                     {\cf17 const} {\cf17 auto} count_in_range_2 =\par
9762                         count_sentinel( first_2, end_2, *cursor, cmp );\par
9763                     {\cf20 // Not a single instance in 2nd range, so it cannot be a}\par
9764                     {\cf20 // permutation of 1st range}\par
9765                     {\cf19 if} ( count_in_range_2 == 0 ) \{ {\cf19 return} {\cf17 false}; \}\par
9766 \par
9767                     {\cf17 const} {\cf17 auto} count_in_range_1 =\par
9768                         count_sentinel( cursor, end_1, *cursor, cmp );\par
9769                     {\cf19 if} ( count_in_range_1 != count_in_range_2 ) \{\par
9770                         {\cf19 return} {\cf17 false};\par
9771                     \}\par
9772                 \}\par
9773 \par
9774                 ++cursor;\par
9775             \}\par
9776 \par
9777             {\cf19 return} {\cf17 true};\par
9778         \}\par
9779 \par
9780         {\cf17 template} <{\cf17 typename} ForwardIter1,\par
9781                   {\cf17 typename} Sentinel1,\par
9782                   {\cf17 typename} ForwardIter2,\par
9783                   {\cf17 typename} Sentinel2,\par
9784                   {\cf17 typename} Comparator>\par
9785         {\cf18 bool} is_permutation( ForwardIter1 first_1,\par
9786                              {\cf17 const} Sentinel1 end_1,\par
9787                              ForwardIter2 first_2,\par
9788                              {\cf17 const} Sentinel2 end_2,\par
9789                              Comparator cmp ) \{\par
9790             {\cf20 // TODO: no optimization for stronger iterators, because we would also have to constrain on sentinel vs not sentinel types}\par
9791             {\cf20 // TODO: Comparator has to be "both sides", e.g. a == b => b == a}\par
9792             {\cf20 // This skips shared prefix of the two ranges}\par
9793             {\cf19 while} (first_1 != end_1 && first_2 != end_2 && cmp(*first_1, *first_2)) \{\par
9794                 ++first_1;\par
9795                 ++first_2;\par
9796             \}\par
9797 \par
9798             {\cf20 // We need to handle case where at least one of the ranges has no more elements}\par
9799             {\cf19 if} (first_1 == end_1 || first_2 == end_2) \{\par
9800                 {\cf19 return} first_1 == end_1 && first_2 == end_2;\par
9801             \}\par
9802 \par
9803             {\cf20 // pair counting is n**2, so we pay linear walk to compare the sizes first}\par
9804             {\cf17 auto} dist_1 = sentinel_distance( first_1, end_1 );\par
9805             {\cf17 auto} dist_2 = sentinel_distance( first_2, end_2 );\par
9806 \par
9807             {\cf19 if} (dist_1 != dist_2) \{ {\cf19 return} {\cf17 false}; \}\par
9808 \par
9809             {\cf20 // Since we do not try to handle stronger iterators pair (e.g.}\par
9810             {\cf20 // bidir) optimally, the only thing left to do is to check counts in}\par
9811             {\cf20 // the remaining ranges.}\par
9812             {\cf19 return} check_element_counts( first_1, end_1, first_2, end_2, cmp );\par
9813         \}\par
9814 \par
9815     \} {\cf20 // namespace Detail}\par
9816 \} {\cf20 // namespace Catch}\par
9817 \par
9818 {\cf21 #endif }{\cf20 // CATCH_IS_PERMUTATION_HPP_INCLUDED}\par
9819 \par
9820 \par
9821 {\cf21 #ifndef CATCH_ISTREAM_HPP_INCLUDED}\par
9822 {\cf21 #define CATCH_ISTREAM_HPP_INCLUDED}\par
9823 \par
9824 \par
9825 {\cf21 #include <iosfwd>}\par
9826 {\cf21 #include <cstddef>}\par
9827 {\cf21 #include <ostream>}\par
9828 {\cf21 #include <string>}\par
9829 \par
9830 {\cf17 namespace }Catch \{\par
9831 \par
9832     {\cf17 class }IStream \{\par
9833     {\cf17 public}:\par
9834         {\cf17 virtual} ~IStream(); {\cf20 // = default}\par
9835         {\cf17 virtual} std::ostream& stream() = 0;\par
9847         {\cf17 virtual} {\cf18 bool} isConsole(){\cf17  const }\{ {\cf19 return} {\cf17 false}; \}\par
9848     \};\par
9849 \par
9861     {\cf17 auto} makeStream( std::string {\cf17 const}& filename ) -> Detail::unique_ptr<IStream>;\par
9862 \par
9863 \}\par
9864 \par
9865 {\cf21 #endif }{\cf20 // CATCH_STREAM_HPP_INCLUDED}\par
9866 \par
9867 \par
9868 {\cf21 #ifndef CATCH_JSONWRITER_HPP_INCLUDED}\par
9869 {\cf21 #define CATCH_JSONWRITER_HPP_INCLUDED}\par
9870 \par
9871 \par
9872 {\cf21 #include <cstdint>}\par
9873 {\cf21 #include <sstream>}\par
9874 \par
9875 {\cf17 namespace }Catch \{\par
9876     {\cf17 class }JsonObjectWriter;\par
9877     {\cf17 class }JsonArrayWriter;\par
9878 \par
9879     {\cf17 struct }JsonUtils \{\par
9880         {\cf17 static} {\cf18 void} indent( std::ostream& os, std::uint64_t level );\par
9881         {\cf17 static} {\cf18 void} appendCommaNewline( std::ostream& os,\par
9882                                         {\cf18 bool}& should_comma,\par
9883                                         std::uint64_t level );\par
9884     \};\par
9885 \par
9886     {\cf17 class }JsonValueWriter \{\par
9887     {\cf17 public}:\par
9888         JsonValueWriter( std::ostream& os );\par
9889         JsonValueWriter( std::ostream& os, std::uint64_t indent_level );\par
9890 \par
9891         JsonObjectWriter writeObject() &&;\par
9892         JsonArrayWriter writeArray() &&;\par
9893 \par
9894         {\cf17 template} <{\cf17 typename} T>\par
9895         {\cf18 void} write( T {\cf17 const}& value ) && \{\par
9896             writeImpl( value, !std::is_arithmetic<T>::value );\par
9897         \}\par
9898         {\cf18 void} write( StringRef value ) &&;\par
9899         {\cf18 void} write( {\cf18 bool} value ) &&;\par
9900 \par
9901     {\cf17 private}:\par
9902         {\cf18 void} writeImpl( StringRef value, {\cf18 bool} quote );\par
9903 \par
9904         {\cf20 // Without this SFINAE, this overload is a better match}\par
9905         {\cf20 // for `std::string`, `char const*`, `char const[N]` args.}\par
9906         {\cf20 // While it would still work, it would cause code bloat}\par
9907         {\cf20 // and multiple iteration over the strings}\par
9908         {\cf17 template} <{\cf17 typename} T,\par
9909                   {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
9910                       !std::is_convertible<T, StringRef>::value>>\par
9911         {\cf18 void} writeImpl( T {\cf17 const}& value, {\cf18 bool} quote_value ) \{\par
9912             m_sstream << value;\par
9913             writeImpl( m_sstream.str(), quote_value );\par
9914         \}\par
9915 \par
9916         std::ostream& m_os;\par
9917         std::stringstream m_sstream;\par
9918         std::uint64_t m_indent_level;\par
9919     \};\par
9920 \par
9921     {\cf17 class }JsonObjectWriter \{\par
9922     {\cf17 public}:\par
9923         JsonObjectWriter( std::ostream& os );\par
9924         JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );\par
9925 \par
9926         JsonObjectWriter( JsonObjectWriter&& source ) {\cf17 noexcept};\par
9927         JsonObjectWriter& operator=( JsonObjectWriter&& source ) = {\cf17 delete};\par
9928 \par
9929         ~JsonObjectWriter();\par
9930 \par
9931         JsonValueWriter write( StringRef key );\par
9932 \par
9933     {\cf17 private}:\par
9934         std::ostream& m_os;\par
9935         std::uint64_t m_indent_level;\par
9936         {\cf18 bool} m_should_comma = {\cf17 false};\par
9937         {\cf18 bool} m_active = {\cf17 true};\par
9938     \};\par
9939 \par
9940     {\cf17 class }JsonArrayWriter \{\par
9941     {\cf17 public}:\par
9942         JsonArrayWriter( std::ostream& os );\par
9943         JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );\par
9944 \par
9945         JsonArrayWriter( JsonArrayWriter&& source ) {\cf17 noexcept};\par
9946         JsonArrayWriter& operator=( JsonArrayWriter&& source ) = {\cf17 delete};\par
9947 \par
9948         ~JsonArrayWriter();\par
9949 \par
9950         JsonObjectWriter writeObject();\par
9951         JsonArrayWriter writeArray();\par
9952 \par
9953         {\cf17 template} <{\cf17 typename} T>\par
9954         JsonArrayWriter& write( T {\cf17 const}& value ) \{\par
9955             {\cf19 return} writeImpl( value );\par
9956         \}\par
9957 \par
9958         JsonArrayWriter& write( {\cf18 bool} value );\par
9959 \par
9960     {\cf17 private}:\par
9961         {\cf17 template} <{\cf17 typename} T>\par
9962         JsonArrayWriter& writeImpl( T {\cf17 const}& value ) \{\par
9963             JsonUtils::appendCommaNewline(\par
9964                 m_os, m_should_comma, m_indent_level + 1 );\par
9965             JsonValueWriter\{ m_os \}.write( value );\par
9966 \par
9967             {\cf19 return} *{\cf17 this};\par
9968         \}\par
9969 \par
9970         std::ostream& m_os;\par
9971         std::uint64_t m_indent_level;\par
9972         {\cf18 bool} m_should_comma = {\cf17 false};\par
9973         {\cf18 bool} m_active = {\cf17 true};\par
9974     \};\par
9975 \par
9976 \} {\cf20 // namespace Catch}\par
9977 \par
9978 {\cf21 #endif }{\cf20 // CATCH_JSONWRITER_HPP_INCLUDED}\par
9979 \par
9980 \par
9981 {\cf21 #ifndef CATCH_LEAK_DETECTOR_HPP_INCLUDED}\par
9982 {\cf21 #define CATCH_LEAK_DETECTOR_HPP_INCLUDED}\par
9983 \par
9984 {\cf17 namespace }Catch \{\par
9985 \par
9986     {\cf17 struct }LeakDetector \{\par
9987         LeakDetector();\par
9988         ~LeakDetector();\par
9989     \};\par
9990 \par
9991 \}\par
9992 {\cf21 #endif }{\cf20 // CATCH_LEAK_DETECTOR_HPP_INCLUDED}\par
9993 \par
9994 \par
9995 {\cf21 #ifndef CATCH_LIST_HPP_INCLUDED}\par
9996 {\cf21 #define CATCH_LIST_HPP_INCLUDED}\par
9997 \par
9998 \par
9999 {\cf21 #include <set>}\par
10000 {\cf21 #include <string>}\par
10001 \par
10002 \par
10003 {\cf17 namespace }Catch \{\par
10004 \par
10005     {\cf17 class }IEventListener;\par
10006     {\cf17 class }Config;\par
10007 \par
10008 \par
10009     {\cf17 struct }ReporterDescription \{\par
10010         std::string name, description;\par
10011     \};\par
10012     {\cf17 struct }ListenerDescription \{\par
10013         StringRef name;\par
10014         std::string description;\par
10015     \};\par
10016 \par
10017     {\cf17 struct }TagInfo \{\par
10018         {\cf18 void} add(StringRef spelling);\par
10019         std::string all() {\cf17 const};\par
10020 \par
10021         std::set<StringRef> spellings;\par
10022         std::size_t count = 0;\par
10023     \};\par
10024 \par
10025     {\cf18 bool} list( IEventListener& reporter, Config {\cf17 const}& config );\par
10026 \par
10027 \} {\cf20 // end namespace Catch}\par
10028 \par
10029 {\cf21 #endif }{\cf20 // CATCH_LIST_HPP_INCLUDED}\par
10030 \par
10031 \par
10032 {\cf21 #ifndef CATCH_OUTPUT_REDIRECT_HPP_INCLUDED}\par
10033 {\cf21 #define CATCH_OUTPUT_REDIRECT_HPP_INCLUDED}\par
10034 \par
10035 \par
10036 {\cf21 #include <cstdio>}\par
10037 {\cf21 #include <iosfwd>}\par
10038 {\cf21 #include <string>}\par
10039 \par
10040 {\cf17 namespace }Catch \{\par
10041 \par
10042     {\cf17 class }RedirectedStream \{\par
10043         std::ostream& m_originalStream;\par
10044         std::ostream& m_redirectionStream;\par
10045         std::streambuf* m_prevBuf;\par
10046 \par
10047     {\cf17 public}:\par
10048         RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );\par
10049         ~RedirectedStream();\par
10050     \};\par
10051 \par
10052     {\cf17 class }RedirectedStdOut \{\par
10053         ReusableStringStream m_rss;\par
10054         RedirectedStream m_cout;\par
10055     {\cf17 public}:\par
10056         RedirectedStdOut();\par
10057         {\cf17 auto} str() const -> std::{\cf18 string};\par
10058     \};\par
10059 \par
10060     {\cf20 // StdErr has two constituent streams in C++, std::cerr and std::clog}\par
10061     {\cf20 // This means that we need to redirect 2 streams into 1 to keep proper}\par
10062     {\cf20 // order of writes}\par
10063     class RedirectedStdErr \{\par
10064         ReusableStringStream m_rss;\par
10065         RedirectedStream m_cerr;\par
10066         RedirectedStream m_clog;\par
10067     {\cf17 public}:\par
10068         RedirectedStdErr();\par
10069         {\cf17 auto} str() const -> std::{\cf18 string};\par
10070     \};\par
10071 \par
10072     class RedirectedStreams \{\par
10073     {\cf17 public}:\par
10074         RedirectedStreams(RedirectedStreams {\cf17 const}&) = {\cf17 delete};\par
10075         RedirectedStreams& operator=(RedirectedStreams {\cf17 const}&) = {\cf17 delete};\par
10076         RedirectedStreams(RedirectedStreams&&) = {\cf17 delete};\par
10077         RedirectedStreams& operator=(RedirectedStreams&&) = {\cf17 delete};\par
10078 \par
10079         RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);\par
10080         ~RedirectedStreams();\par
10081     {\cf17 private}:\par
10082         std::string& m_redirectedCout;\par
10083         std::string& m_redirectedCerr;\par
10084         RedirectedStdOut m_redirectedStdOut;\par
10085         RedirectedStdErr m_redirectedStdErr;\par
10086     \};\par
10087 \par
10088 {\cf21 #if defined(CATCH_CONFIG_NEW_CAPTURE)}\par
10089 \par
10090     {\cf20 // Windows's implementation of std::tmpfile is terrible (it tries}\par
10091     {\cf20 // to create a file inside system folder, thus requiring elevated}\par
10092     {\cf20 // privileges for the binary), so we have to use tmpnam(_s) and}\par
10093     {\cf20 // create the file ourselves there.}\par
10094     {\cf17 class }TempFile \{\par
10095     {\cf17 public}:\par
10096         TempFile(TempFile {\cf17 const}&) = {\cf17 delete};\par
10097         TempFile& operator=(TempFile {\cf17 const}&) = {\cf17 delete};\par
10098         TempFile(TempFile&&) = {\cf17 delete};\par
10099         TempFile& operator=(TempFile&&) = {\cf17 delete};\par
10100 \par
10101         TempFile();\par
10102         ~TempFile();\par
10103 \par
10104         std::FILE* getFile();\par
10105         std::string getContents();\par
10106 \par
10107     {\cf17 private}:\par
10108         std::FILE* m_file = {\cf17 nullptr};\par
10109 {\cf21     #if defined(_MSC_VER)}\par
10110         {\cf18 char} m_buffer[L_tmpnam] = \{ 0 \};\par
10111 {\cf21     #endif}\par
10112     \};\par
10113 \par
10114 \par
10115     {\cf17 class }OutputRedirect \{\par
10116     {\cf17 public}:\par
10117         OutputRedirect(OutputRedirect {\cf17 const}&) = {\cf17 delete};\par
10118         OutputRedirect& operator=(OutputRedirect {\cf17 const}&) = {\cf17 delete};\par
10119         OutputRedirect(OutputRedirect&&) = {\cf17 delete};\par
10120         OutputRedirect& operator=(OutputRedirect&&) = {\cf17 delete};\par
10121 \par
10122 \par
10123         OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);\par
10124         ~OutputRedirect();\par
10125 \par
10126     {\cf17 private}:\par
10127         {\cf18 int} m_originalStdout = -1;\par
10128         {\cf18 int} m_originalStderr = -1;\par
10129         TempFile m_stdoutFile;\par
10130         TempFile m_stderrFile;\par
10131         std::string& m_stdoutDest;\par
10132         std::string& m_stderrDest;\par
10133     \};\par
10134 \par
10135 {\cf21 #endif}\par
10136 \par
10137 \} {\cf20 // end namespace Catch}\par
10138 \par
10139 {\cf21 #endif }{\cf20 // CATCH_OUTPUT_REDIRECT_HPP_INCLUDED}\par
10140 \par
10141 \par
10142 {\cf21 #ifndef CATCH_PARSE_NUMBERS_HPP_INCLUDED}\par
10143 {\cf21 #define CATCH_PARSE_NUMBERS_HPP_INCLUDED}\par
10144 \par
10145 \par
10146 {\cf21 #include <string>}\par
10147 \par
10148 {\cf17 namespace }Catch \{\par
10149 \par
10156     Optional<unsigned int> parseUInt(std::string {\cf17 const}& input, {\cf18 int} base = 10);\par
10157 \}\par
10158 \par
10159 {\cf21 #endif }{\cf20 // CATCH_PARSE_NUMBERS_HPP_INCLUDED}\par
10160 \par
10161 \par
10162 {\cf21 #ifndef CATCH_REPORTER_REGISTRY_HPP_INCLUDED}\par
10163 {\cf21 #define CATCH_REPORTER_REGISTRY_HPP_INCLUDED}\par
10164 \par
10165 \par
10166 {\cf21 #include <map>}\par
10167 {\cf21 #include <string>}\par
10168 {\cf21 #include <vector>}\par
10169 \par
10170 {\cf17 namespace }Catch \{\par
10171 \par
10172     {\cf17 class }IEventListener;\par
10173     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
10174     {\cf17 class }IReporterFactory;\par
10175     {\cf17 using }IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;\par
10176     {\cf17 struct }ReporterConfig;\par
10177     {\cf17 class }EventListenerFactory;\par
10178 \par
10179     {\cf17 class }ReporterRegistry \{\par
10180         {\cf17 struct }ReporterRegistryImpl;\par
10181         Detail::unique_ptr<ReporterRegistryImpl> m_impl;\par
10182 \par
10183     {\cf17 public}:\par
10184         ReporterRegistry();\par
10185         ~ReporterRegistry(); {\cf20 // = default;}\par
10186 \par
10187         IEventListenerPtr create( std::string {\cf17 const}& name,\par
10188                                   ReporterConfig&& config ) {\cf17 const};\par
10189 \par
10190         {\cf18 void} registerReporter( std::string {\cf17 const}& name,\par
10191                                IReporterFactoryPtr factory );\par
10192 \par
10193         {\cf18 void}\par
10194         registerListener( Detail::unique_ptr<EventListenerFactory> factory );\par
10195 \par
10196         std::map<std::string,\par
10197                  IReporterFactoryPtr,\par
10198                  Detail::CaseInsensitiveLess> {\cf17 const}&\par
10199         getFactories() {\cf17 const};\par
10200 \par
10201         std::vector<Detail::unique_ptr<EventListenerFactory>> {\cf17 const}&\par
10202         getListeners() {\cf17 const};\par
10203     \};\par
10204 \par
10205 \} {\cf20 // end namespace Catch}\par
10206 \par
10207 {\cf21 #endif }{\cf20 // CATCH_REPORTER_REGISTRY_HPP_INCLUDED}\par
10208 \par
10209 \par
10210 {\cf21 #ifndef CATCH_RUN_CONTEXT_HPP_INCLUDED}\par
10211 {\cf21 #define CATCH_RUN_CONTEXT_HPP_INCLUDED}\par
10212 \par
10213 \par
10214 \par
10215 {\cf21 #ifndef CATCH_TEST_CASE_TRACKER_HPP_INCLUDED}\par
10216 {\cf21 #define CATCH_TEST_CASE_TRACKER_HPP_INCLUDED}\par
10217 \par
10218 \par
10219 {\cf21 #include <string>}\par
10220 {\cf21 #include <vector>}\par
10221 \par
10222 {\cf17 namespace }Catch \{\par
10223 {\cf17 namespace }TestCaseTracking \{\par
10224 \par
10225     {\cf17 struct }NameAndLocation \{\par
10226         std::string name;\par
10227         SourceLineInfo location;\par
10228 \par
10229         NameAndLocation( std::string&& _name, SourceLineInfo {\cf17 const}& _location );\par
10230         {\cf17 friend} {\cf18 bool} operator==(NameAndLocation {\cf17 const}& lhs, NameAndLocation {\cf17 const}& rhs) \{\par
10231             {\cf20 // This is a very cheap check that should have a very high hit rate.}\par
10232             {\cf20 // If we get to SourceLineInfo::operator==, we will redo it, but the}\par
10233             {\cf20 // cost of repeating is trivial at that point (we will be paying}\par
10234             {\cf20 // multiple strcmp/memcmps at that point).}\par
10235             {\cf19 if} ( lhs.location.line != rhs.location.line ) \{ {\cf19 return} {\cf17 false}; \}\par
10236             {\cf19 return} lhs.name == rhs.name && lhs.location == rhs.location;\par
10237         \}\par
10238         {\cf17 friend} {\cf18 bool} operator!=(NameAndLocation {\cf17 const}& lhs,\par
10239                                NameAndLocation {\cf17 const}& rhs) \{\par
10240             {\cf19 return} !( lhs == rhs );\par
10241         \}\par
10242     \};\par
10243 \par
10251     {\cf17 struct }NameAndLocationRef \{\par
10252         StringRef name;\par
10253         SourceLineInfo location;\par
10254 \par
10255         {\cf17 constexpr} NameAndLocationRef( StringRef name_,\par
10256                                       SourceLineInfo location_ ):\par
10257             name( name_ ), location( location_ ) \{\}\par
10258 \par
10259         {\cf17 friend} {\cf18 bool} operator==( NameAndLocation {\cf17 const}& lhs,\par
10260                                 NameAndLocationRef {\cf17 const}& rhs ) \{\par
10261             {\cf20 // This is a very cheap check that should have a very high hit rate.}\par
10262             {\cf20 // If we get to SourceLineInfo::operator==, we will redo it, but the}\par
10263             {\cf20 // cost of repeating is trivial at that point (we will be paying}\par
10264             {\cf20 // multiple strcmp/memcmps at that point).}\par
10265             {\cf19 if} ( lhs.location.line != rhs.location.line ) \{ {\cf19 return} {\cf17 false}; \}\par
10266             {\cf19 return} StringRef( lhs.name ) == rhs.name &&\par
10267                    lhs.location == rhs.location;\par
10268         \}\par
10269         {\cf17 friend} {\cf18 bool} operator==( NameAndLocationRef {\cf17 const}& lhs,\par
10270                                 NameAndLocation {\cf17 const}& rhs ) \{\par
10271             {\cf19 return} rhs == lhs;\par
10272         \}\par
10273     \};\par
10274 \par
10275     {\cf17 class }ITracker;\par
10276 \par
10277     {\cf17 using }ITrackerPtr = Catch::Detail::unique_ptr<ITracker>;\par
10278 \par
10279     {\cf17 class }ITracker \{\par
10280         NameAndLocation m_nameAndLocation;\par
10281 \par
10282         {\cf17 using }Children = std::vector<ITrackerPtr>;\par
10283 \par
10284     {\cf17 protected}:\par
10285         {\cf17 enum} CycleState \{\par
10286             NotStarted,\par
10287             Executing,\par
10288             ExecutingChildren,\par
10289             NeedsAnotherRun,\par
10290             CompletedSuccessfully,\par
10291             Failed\par
10292         \};\par
10293 \par
10294         ITracker* m_parent = {\cf17 nullptr};\par
10295         Children m_children;\par
10296         CycleState m_runState = NotStarted;\par
10297 \par
10298     {\cf17 public}:\par
10299         ITracker( NameAndLocation&& nameAndLoc, ITracker* parent ):\par
10300             m_nameAndLocation( CATCH_MOVE(nameAndLoc) ),\par
10301             m_parent( parent )\par
10302         \{\}\par
10303 \par
10304 \par
10305         {\cf20 // static queries}\par
10306         NameAndLocation {\cf17 const}& nameAndLocation(){\cf17  const }\{\par
10307             {\cf19 return} m_nameAndLocation;\par
10308         \}\par
10309         ITracker* parent(){\cf17  const }\{\par
10310             {\cf19 return} m_parent;\par
10311         \}\par
10312 \par
10313         {\cf17 virtual} ~ITracker(); {\cf20 // = default}\par
10314 \par
10315 \par
10316         {\cf20 // dynamic queries}\par
10317 \par
10319         {\cf17 virtual} {\cf18 bool} isComplete() {\cf17 const} = 0;\par
10321         {\cf18 bool} isSuccessfullyCompleted(){\cf17  const }\{\par
10322             {\cf19 return} m_runState == CompletedSuccessfully;\par
10323         \}\par
10325         {\cf18 bool} isOpen() {\cf17 const};\par
10327         {\cf18 bool} hasStarted() {\cf17 const};\par
10328 \par
10329         {\cf20 // actions}\par
10330         {\cf17 virtual} {\cf18 void} close() = 0; {\cf20 // Successfully complete}\par
10331         {\cf17 virtual} {\cf18 void} fail() = 0;\par
10332         {\cf18 void} markAsNeedingAnotherRun();\par
10333 \par
10335         {\cf18 void} addChild( ITrackerPtr&& child );\par
10341         ITracker* findChild( NameAndLocationRef {\cf17 const}& nameAndLocation );\par
10343         {\cf18 bool} hasChildren(){\cf17  const }\{\par
10344             {\cf19 return} !m_children.empty();\par
10345         \}\par
10346 \par
10347 \par
10349         {\cf18 void} openChild();\par
10350 \par
10357         {\cf17 virtual} {\cf18 bool} isSectionTracker() {\cf17 const};\par
10364         {\cf17 virtual} {\cf18 bool} isGeneratorTracker() {\cf17 const};\par
10365     \};\par
10366 \par
10367     {\cf17 class }TrackerContext \{\par
10368 \par
10369         {\cf17 enum} RunState \{\par
10370             NotStarted,\par
10371             Executing,\par
10372             CompletedCycle\par
10373         \};\par
10374 \par
10375         ITrackerPtr m_rootTracker;\par
10376         ITracker* m_currentTracker = {\cf17 nullptr};\par
10377         RunState m_runState = NotStarted;\par
10378 \par
10379     {\cf17 public}:\par
10380 \par
10381         ITracker& startRun();\par
10382 \par
10383         {\cf18 void} startCycle() \{\par
10384             m_currentTracker = m_rootTracker.get();\par
10385             m_runState = Executing;\par
10386         \}\par
10387         {\cf18 void} completeCycle();\par
10388 \par
10389         {\cf18 bool} completedCycle() {\cf17 const};\par
10390         ITracker& currentTracker() \{ {\cf19 return} *m_currentTracker; \}\par
10391         {\cf18 void} setCurrentTracker( ITracker* tracker );\par
10392     \};\par
10393 \par
10394     {\cf17 class }TrackerBase : {\cf17 public} ITracker \{\par
10395     {\cf17 protected}:\par
10396 \par
10397         TrackerContext& m_ctx;\par
10398 \par
10399     {\cf17 public}:\par
10400         TrackerBase( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );\par
10401 \par
10402         {\cf18 bool} isComplete() {\cf17 const override};\par
10403 \par
10404         {\cf18 void} open();\par
10405 \par
10406         {\cf18 void} close() {\cf17 override};\par
10407         {\cf18 void} fail() {\cf17 override};\par
10408 \par
10409     {\cf17 private}:\par
10410         {\cf18 void} moveToParent();\par
10411         {\cf18 void} moveToThis();\par
10412     \};\par
10413 \par
10414     {\cf17 class }SectionTracker : {\cf17 public} TrackerBase \{\par
10415         std::vector<StringRef> m_filters;\par
10416         {\cf20 // Note that lifetime-wise we piggy back off the name stored in the `ITracker` parent`.}\par
10417         {\cf20 // Currently it allocates owns the name, so this is safe. If it is later refactored}\par
10418         {\cf20 // to not own the name, the name still has to outlive the `ITracker` parent, so}\par
10419         {\cf20 // this should still be safe.}\par
10420         StringRef m_trimmed_name;\par
10421     {\cf17 public}:\par
10422         SectionTracker( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );\par
10423 \par
10424         {\cf18 bool} isSectionTracker() {\cf17 const override};\par
10425 \par
10426         {\cf18 bool} isComplete() {\cf17 const override};\par
10427 \par
10428         {\cf17 static} SectionTracker& acquire( TrackerContext& ctx, NameAndLocationRef {\cf17 const}& nameAndLocation );\par
10429 \par
10430         {\cf18 void} tryOpen();\par
10431 \par
10432         {\cf18 void} addInitialFilters( std::vector<std::string> {\cf17 const}& filters );\par
10433         {\cf18 void} addNextFilters( std::vector<StringRef> {\cf17 const}& filters );\par
10435         std::vector<StringRef> {\cf17 const}& getFilters(){\cf17  const }\{ {\cf19 return} m_filters; \}\par
10437         StringRef trimmedName() {\cf17 const};\par
10438     \};\par
10439 \par
10440 \} {\cf20 // namespace TestCaseTracking}\par
10441 \par
10442 {\cf17 using }TestCaseTracking::ITracker;\par
10443 {\cf17 using }TestCaseTracking::TrackerContext;\par
10444 {\cf17 using }TestCaseTracking::SectionTracker;\par
10445 \par
10446 \} {\cf20 // namespace Catch}\par
10447 \par
10448 {\cf21 #endif }{\cf20 // CATCH_TEST_CASE_TRACKER_HPP_INCLUDED}\par
10449 \par
10450 {\cf21 #include <string>}\par
10451 \par
10452 {\cf17 namespace }Catch \{\par
10453 \par
10454     {\cf17 class }IGeneratorTracker;\par
10455     {\cf17 class }IConfig;\par
10456     {\cf17 class }IEventListener;\par
10457     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
10458 \par
10460 \par
10461     {\cf17 class }RunContext final : {\cf17 public} IResultCapture \{\par
10462 \par
10463     {\cf17 public}:\par
10464         RunContext( RunContext {\cf17 const}& ) = {\cf17 delete};\par
10465         RunContext& operator =( RunContext {\cf17 const}& ) = {\cf17 delete};\par
10466 \par
10467         {\cf17 explicit} RunContext( IConfig {\cf17 const}* _config, IEventListenerPtr&& reporter );\par
10468 \par
10469         ~RunContext() {\cf17 override};\par
10470 \par
10471         Totals runTest(TestCaseHandle {\cf17 const}& testCase);\par
10472 \par
10473     {\cf17 public}: {\cf20 // IResultCapture}\par
10474 \par
10475         {\cf20 // Assertion handlers}\par
10476         {\cf18 void} handleExpr\par
10477                 (   AssertionInfo {\cf17 const}& info,\par
10478                     ITransientExpression {\cf17 const}& expr,\par
10479                     AssertionReaction& reaction ) {\cf17 override};\par
10480         {\cf18 void} handleMessage\par
10481                 (   AssertionInfo {\cf17 const}& info,\par
10482                     ResultWas::OfType resultType,\par
10483                     StringRef message,\par
10484                     AssertionReaction& reaction ) {\cf17 override};\par
10485         {\cf18 void} handleUnexpectedExceptionNotThrown\par
10486                 (   AssertionInfo {\cf17 const}& info,\par
10487                     AssertionReaction& reaction ) {\cf17 override};\par
10488         {\cf18 void} handleUnexpectedInflightException\par
10489                 (   AssertionInfo {\cf17 const}& info,\par
10490                     std::string&& message,\par
10491                     AssertionReaction& reaction ) {\cf17 override};\par
10492         {\cf18 void} handleIncomplete\par
10493                 (   AssertionInfo {\cf17 const}& info ) {\cf17 override};\par
10494         {\cf18 void} handleNonExpr\par
10495                 (   AssertionInfo {\cf17 const} &info,\par
10496                     ResultWas::OfType resultType,\par
10497                     AssertionReaction &reaction ) {\cf17 override};\par
10498 \par
10499         {\cf18 void} notifyAssertionStarted( AssertionInfo {\cf17 const}& info ) {\cf17 override};\par
10500         {\cf18 bool} sectionStarted( StringRef sectionName,\par
10501                              SourceLineInfo {\cf17 const}& sectionLineInfo,\par
10502                              Counts& assertions ) {\cf17 override};\par
10503 \par
10504         {\cf18 void} sectionEnded( SectionEndInfo&& endInfo ) {\cf17 override};\par
10505         {\cf18 void} sectionEndedEarly( SectionEndInfo&& endInfo ) {\cf17 override};\par
10506 \par
10507         IGeneratorTracker*\par
10508         acquireGeneratorTracker( StringRef generatorName,\par
10509                                  SourceLineInfo {\cf17 const}& lineInfo ) {\cf17 override};\par
10510         IGeneratorTracker* createGeneratorTracker(\par
10511             StringRef generatorName,\par
10512             SourceLineInfo lineInfo,\par
10513             Generators::GeneratorBasePtr&& generator ) {\cf17 override};\par
10514 \par
10515 \par
10516         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
10517         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& info ) {\cf17 override};\par
10518         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& stats ) {\cf17 override};\par
10519         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
10520 \par
10521         {\cf18 void} pushScopedMessage( MessageInfo {\cf17 const}& message ) {\cf17 override};\par
10522         {\cf18 void} popScopedMessage( MessageInfo {\cf17 const}& message ) {\cf17 override};\par
10523 \par
10524         {\cf18 void} emplaceUnscopedMessage( MessageBuilder&& builder ) {\cf17 override};\par
10525 \par
10526         std::string getCurrentTestName() {\cf17 const override};\par
10527 \par
10528         {\cf17 const} AssertionResult* getLastResult() {\cf17 const override};\par
10529 \par
10530         {\cf18 void} exceptionEarlyReported() {\cf17 override};\par
10531 \par
10532         {\cf18 void} handleFatalErrorCondition( StringRef message ) {\cf17 override};\par
10533 \par
10534         {\cf18 bool} lastAssertionPassed() {\cf17 override};\par
10535 \par
10536         {\cf18 void} assertionPassed() {\cf17 override};\par
10537 \par
10538     {\cf17 public}:\par
10539         {\cf20 // !TBD We need to do this another way!}\par
10540         {\cf18 bool} aborting() {\cf17 const};\par
10541 \par
10542     {\cf17 private}:\par
10543 \par
10544         {\cf18 void} runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );\par
10545         {\cf18 void} invokeActiveTestCase();\par
10546 \par
10547         {\cf18 void} resetAssertionInfo();\par
10548         {\cf18 bool} testForMissingAssertions( Counts& assertions );\par
10549 \par
10550         {\cf18 void} assertionEnded( AssertionResult&& result );\par
10551         {\cf18 void} reportExpr\par
10552                 (   AssertionInfo {\cf17 const} &info,\par
10553                     ResultWas::OfType resultType,\par
10554                     ITransientExpression {\cf17 const} *expr,\par
10555                     {\cf18 bool} negated );\par
10556 \par
10557         {\cf18 void} populateReaction( AssertionReaction& reaction );\par
10558 \par
10559     {\cf17 private}:\par
10560 \par
10561         {\cf18 void} handleUnfinishedSections();\par
10562 \par
10563         TestRunInfo m_runInfo;\par
10564         TestCaseHandle {\cf17 const}* m_activeTestCase = {\cf17 nullptr};\par
10565         ITracker* m_testCaseTracker = {\cf17 nullptr};\par
10566         Optional<AssertionResult> m_lastResult;\par
10567 \par
10568         IConfig {\cf17 const}* m_config;\par
10569         Totals m_totals;\par
10570         IEventListenerPtr m_reporter;\par
10571         std::vector<MessageInfo> m_messages;\par
10572         std::vector<ScopedMessage> m_messageScopes; {\cf20 /* Keeps owners of so-called unscoped messages. */}\par
10573         AssertionInfo m_lastAssertionInfo;\par
10574         std::vector<SectionEndInfo> m_unfinishedSections;\par
10575         std::vector<ITracker*> m_activeSections;\par
10576         TrackerContext m_trackerContext;\par
10577         FatalConditionHandler m_fatalConditionhandler;\par
10578         {\cf18 bool} m_lastAssertionPassed = {\cf17 false};\par
10579         {\cf18 bool} m_shouldReportUnexpected = {\cf17 true};\par
10580         {\cf18 bool} m_includeSuccessfulResults;\par
10581     \};\par
10582 \par
10583     {\cf18 void} seedRng(IConfig {\cf17 const}& config);\par
10584     {\cf18 unsigned} {\cf18 int} rngSeed();\par
10585 \} {\cf20 // end namespace Catch}\par
10586 \par
10587 {\cf21 #endif }{\cf20 // CATCH_RUN_CONTEXT_HPP_INCLUDED}\par
10588 \par
10589 \par
10590 {\cf21 #ifndef CATCH_SHARDING_HPP_INCLUDED}\par
10591 {\cf21 #define CATCH_SHARDING_HPP_INCLUDED}\par
10592 \par
10593 {\cf21 #include <cassert>}\par
10594 {\cf21 #include <cmath>}\par
10595 {\cf21 #include <algorithm>}\par
10596 \par
10597 {\cf17 namespace }Catch \{\par
10598 \par
10599     {\cf17 template}<{\cf17 typename} Container>\par
10600     Container createShard(Container {\cf17 const}& container, std::size_t {\cf17 const} shardCount, std::size_t {\cf17 const} shardIndex) \{\par
10601         assert(shardCount > shardIndex);\par
10602 \par
10603         {\cf19 if} (shardCount == 1) \{\par
10604             {\cf19 return} container;\par
10605         \}\par
10606 \par
10607         {\cf17 const} std::size_t totalTestCount = container.size();\par
10608 \par
10609         {\cf17 const} std::size_t shardSize = totalTestCount / shardCount;\par
10610         {\cf17 const} std::size_t leftoverTests = totalTestCount % shardCount;\par
10611 \par
10612         {\cf17 const} std::size_t startIndex = shardIndex * shardSize + (std::min)(shardIndex, leftoverTests);\par
10613         {\cf17 const} std::size_t endIndex = (shardIndex + 1) * shardSize + (std::min)(shardIndex + 1, leftoverTests);\par
10614 \par
10615         {\cf17 auto} startIterator = std::next(container.begin(), {\cf17 static_cast<}std::ptrdiff_t{\cf17 >}(startIndex));\par
10616         {\cf17 auto} endIterator = std::next(container.begin(), {\cf17 static_cast<}std::ptrdiff_t{\cf17 >}(endIndex));\par
10617 \par
10618         {\cf19 return} Container(startIterator, endIterator);\par
10619     \}\par
10620 \par
10621 \}\par
10622 \par
10623 {\cf21 #endif }{\cf20 // CATCH_SHARDING_HPP_INCLUDED}\par
10624 \par
10625 \par
10626 {\cf21 #ifndef CATCH_SINGLETONS_HPP_INCLUDED}\par
10627 {\cf21 #define CATCH_SINGLETONS_HPP_INCLUDED}\par
10628 \par
10629 {\cf17 namespace }Catch \{\par
10630 \par
10631     {\cf17 struct }ISingleton \{\par
10632         {\cf17 virtual} ~ISingleton(); {\cf20 // = default}\par
10633     \};\par
10634 \par
10635 \par
10636     {\cf18 void} addSingleton( ISingleton* singleton );\par
10637     {\cf18 void} cleanupSingletons();\par
10638 \par
10639 \par
10640     {\cf17 template}<{\cf17 typename} SingletonImplT, {\cf17 typename} InterfaceT = SingletonImplT, {\cf17 typename} MutableInterfaceT = InterfaceT>\par
10641     {\cf17 class }Singleton : SingletonImplT, {\cf17 public} ISingleton \{\par
10642 \par
10643         {\cf17 static} {\cf17 auto} getInternal() -> Singleton* \{\par
10644             {\cf17 static} Singleton* s_instance = {\cf17 nullptr};\par
10645             {\cf19 if}( !s_instance ) \{\par
10646                 s_instance = {\cf17 new} Singleton;\par
10647                 addSingleton( s_instance );\par
10648             \}\par
10649             {\cf19 return} s_instance;\par
10650         \}\par
10651 \par
10652     {\cf17 public}:\par
10653         {\cf17 static} {\cf17 auto} get() -> InterfaceT {\cf17 const}& \{\par
10654             {\cf19 return} *getInternal();\par
10655         \}\par
10656         {\cf17 static} {\cf17 auto} getMutable() -> MutableInterfaceT& \{\par
10657             {\cf19 return} *getInternal();\par
10658         \}\par
10659     \};\par
10660 \par
10661 \} {\cf20 // namespace Catch}\par
10662 \par
10663 {\cf21 #endif }{\cf20 // CATCH_SINGLETONS_HPP_INCLUDED}\par
10664 \par
10665 \par
10666 {\cf21 #ifndef CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED}\par
10667 {\cf21 #define CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED}\par
10668 \par
10669 \par
10670 {\cf21 #include <vector>}\par
10671 {\cf21 #include <exception>}\par
10672 \par
10673 {\cf17 namespace }Catch \{\par
10674 \par
10675     {\cf17 class }StartupExceptionRegistry \{\par
10676 {\cf21 #if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)}\par
10677     {\cf17 public}:\par
10678         {\cf18 void} add(std::exception_ptr {\cf17 const}& exception) {\cf17 noexcept};\par
10679         std::vector<std::exception_ptr> {\cf17 const}& getExceptions() const noexcept;\par
10680     private:\par
10681         std::vector<std::exception_ptr> m_exceptions;\par
10682 {\cf21 #endif}\par
10683     \};\par
10684 \par
10685 \} {\cf20 // end namespace Catch}\par
10686 \par
10687 {\cf21 #endif }{\cf20 // CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED}\par
10688 \par
10689 \par
10690 \par
10691 {\cf21 #ifndef CATCH_STDSTREAMS_HPP_INCLUDED}\par
10692 {\cf21 #define CATCH_STDSTREAMS_HPP_INCLUDED}\par
10693 \par
10694 {\cf21 #include <iosfwd>}\par
10695 \par
10696 {\cf17 namespace }Catch \{\par
10697 \par
10698     std::ostream& cout();\par
10699     std::ostream& cerr();\par
10700     std::ostream& clog();\par
10701 \par
10702 \} {\cf20 // namespace Catch}\par
10703 \par
10704 {\cf21 #endif}\par
10705 \par
10706 \par
10707 {\cf21 #ifndef CATCH_STRING_MANIP_HPP_INCLUDED}\par
10708 {\cf21 #define CATCH_STRING_MANIP_HPP_INCLUDED}\par
10709 \par
10710 \par
10711 {\cf21 #include <cstdint>}\par
10712 {\cf21 #include <string>}\par
10713 {\cf21 #include <iosfwd>}\par
10714 {\cf21 #include <vector>}\par
10715 \par
10716 {\cf17 namespace }Catch \{\par
10717 \par
10718     {\cf18 bool} startsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& prefix );\par
10719     {\cf18 bool} startsWith( StringRef s, {\cf18 char} prefix );\par
10720     {\cf18 bool} endsWith( std::string {\cf17 const}& s, std::string {\cf17 const}& suffix );\par
10721     {\cf18 bool} endsWith( std::string {\cf17 const}& s, {\cf18 char} suffix );\par
10722     {\cf18 bool} contains( std::string {\cf17 const}& s, std::string {\cf17 const}& infix );\par
10723     {\cf18 void} toLowerInPlace( std::string& s );\par
10724     std::string toLower( std::string {\cf17 const}& s );\par
10725     {\cf18 char} toLower( {\cf18 char} c );\par
10727     std::string trim( std::string {\cf17 const}& str );\par
10729     StringRef trim(StringRef ref);\par
10730 \par
10731     {\cf20 // !!! Be aware, returns refs into original string - make sure original string outlives them}\par
10732     std::vector<StringRef> splitStringRef( StringRef str, {\cf18 char} delimiter );\par
10733     {\cf18 bool} replaceInPlace( std::string& str, std::string {\cf17 const}& replaceThis, std::string {\cf17 const}& withThis );\par
10734 \par
10745     {\cf17 class }pluralise \{\par
10746         std::uint64_t m_count;\par
10747         StringRef m_label;\par
10748 \par
10749     {\cf17 public}:\par
10750         {\cf17 constexpr} pluralise(std::uint64_t count, StringRef label):\par
10751             m_count(count),\par
10752             m_label(label)\par
10753         \{\}\par
10754 \par
10755         {\cf17 friend} std::ostream& operator << ( std::ostream& os, pluralise {\cf17 const}& pluraliser );\par
10756     \};\par
10757 \}\par
10758 \par
10759 {\cf21 #endif }{\cf20 // CATCH_STRING_MANIP_HPP_INCLUDED}\par
10760 \par
10761 \par
10762 {\cf21 #ifndef CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
10763 {\cf21 #define CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
10764 \par
10765 \par
10766 {\cf21 #include <map>}\par
10767 {\cf21 #include <string>}\par
10768 \par
10769 {\cf17 namespace }Catch \{\par
10770     {\cf17 struct }SourceLineInfo;\par
10771 \par
10772     {\cf17 class }TagAliasRegistry : {\cf17 public} ITagAliasRegistry \{\par
10773     {\cf17 public}:\par
10774         ~TagAliasRegistry() {\cf17 override};\par
10775         TagAlias {\cf17 const}* find( std::string {\cf17 const}& alias ) {\cf17 const override};\par
10776         std::string expandAliases( std::string {\cf17 const}& unexpandedTestSpec ) {\cf17 const override};\par
10777         {\cf18 void} add( std::string {\cf17 const}& alias, std::string {\cf17 const}& tag, SourceLineInfo {\cf17 const}& lineInfo );\par
10778 \par
10779     {\cf17 private}:\par
10780         std::map<std::string, TagAlias> m_registry;\par
10781     \};\par
10782 \par
10783 \} {\cf20 // end namespace Catch}\par
10784 \par
10785 {\cf21 #endif }{\cf20 // CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED}\par
10786 \par
10787 \par
10788 {\cf21 #ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED}\par
10789 {\cf21 #define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED}\par
10790 \par
10791 {\cf21 #include <cstdint>}\par
10792 \par
10793 {\cf17 namespace }Catch \{\par
10794 \par
10795     {\cf17 struct }TestCaseInfo;\par
10796 \par
10797     {\cf17 class }TestCaseInfoHasher \{\par
10798     {\cf17 public}:\par
10799         {\cf17 using }hash_t = std::uint64_t;\par
10800         TestCaseInfoHasher( hash_t seed );\par
10801         uint32_t operator()( TestCaseInfo {\cf17 const}& t ) {\cf17 const};\par
10802 \par
10803     {\cf17 private}:\par
10804         hash_t m_seed;\par
10805     \};\par
10806 \par
10807 \} {\cf20 // namespace Catch}\par
10808 \par
10809 {\cf21 #endif }{\cf20 /* CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED */}{\cf21 }\par
10810 \par
10811 \par
10812 {\cf21 #ifndef CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED}\par
10813 {\cf21 #define CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED}\par
10814 \par
10815 \par
10816 {\cf21 #include <vector>}\par
10817 \par
10818 {\cf17 namespace }Catch \{\par
10819 \par
10820     {\cf17 class }IConfig;\par
10821     {\cf17 class }ITestInvoker;\par
10822     {\cf17 class }TestCaseHandle;\par
10823     {\cf17 class }TestSpec;\par
10824 \par
10825     std::vector<TestCaseHandle> sortTests( IConfig {\cf17 const}& config, std::vector<TestCaseHandle> {\cf17 const}& unsortedTestCases );\par
10826 \par
10827     {\cf18 bool} isThrowSafe( TestCaseHandle {\cf17 const}& testCase, IConfig {\cf17 const}& config );\par
10828 \par
10829     std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> {\cf17 const}& testCases, TestSpec {\cf17 const}& testSpec, IConfig {\cf17 const}& config );\par
10830     std::vector<TestCaseHandle> {\cf17 const}& getAllTestCasesSorted( IConfig {\cf17 const}& config );\par
10831 \par
10832     {\cf17 class }TestRegistry : {\cf17 public} ITestCaseRegistry \{\par
10833     {\cf17 public}:\par
10834         {\cf18 void} registerTest( Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker );\par
10835 \par
10836         std::vector<TestCaseInfo*> {\cf17 const}& getAllInfos() {\cf17 const override};\par
10837         std::vector<TestCaseHandle> {\cf17 const}& getAllTests() {\cf17 const override};\par
10838         std::vector<TestCaseHandle> {\cf17 const}& getAllTestsSorted( IConfig {\cf17 const}& config ) {\cf17 const override};\par
10839 \par
10840         ~TestRegistry() {\cf17 override}; {\cf20 // = default}\par
10841 \par
10842     {\cf17 private}:\par
10843         std::vector<Detail::unique_ptr<TestCaseInfo>> m_owned_test_infos;\par
10844         {\cf20 // Keeps a materialized vector for `getAllInfos`.}\par
10845         {\cf20 // We should get rid of that eventually (see interface note)}\par
10846         std::vector<TestCaseInfo*> m_viewed_test_infos;\par
10847 \par
10848         std::vector<Detail::unique_ptr<ITestInvoker>> m_invokers;\par
10849         std::vector<TestCaseHandle> m_handles;\par
10850         {\cf17 mutable} TestRunOrder m_currentSortOrder = TestRunOrder::Declared;\par
10851         {\cf17 mutable} std::vector<TestCaseHandle> m_sortedFunctions;\par
10852     \};\par
10853 \par
10855 \par
10856 \par
10857 \} {\cf20 // end namespace Catch}\par
10858 \par
10859 \par
10860 {\cf21 #endif }{\cf20 // CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED}\par
10861 \par
10862 \par
10863 {\cf21 #ifndef CATCH_TEST_SPEC_PARSER_HPP_INCLUDED}\par
10864 {\cf21 #define CATCH_TEST_SPEC_PARSER_HPP_INCLUDED}\par
10865 \par
10866 {\cf21 #ifdef __clang__}\par
10867 {\cf21 #pragma clang diagnostic push}\par
10868 {\cf21 #pragma clang diagnostic ignored "-Wpadded"}\par
10869 {\cf21 #endif}\par
10870 \par
10871 \par
10872 {\cf21 #include <vector>}\par
10873 {\cf21 #include <string>}\par
10874 \par
10875 {\cf17 namespace }Catch \{\par
10876 \par
10877     {\cf17 class }ITagAliasRegistry;\par
10878 \par
10879     {\cf17 class }TestSpecParser \{\par
10880         {\cf17 enum} Mode\{ None, Name, QuotedName, Tag, EscapedName \};\par
10881         Mode m_mode = None;\par
10882         Mode lastMode = None;\par
10883         {\cf18 bool} m_exclusion = {\cf17 false};\par
10884         std::size_t m_pos = 0;\par
10885         std::size_t m_realPatternPos = 0;\par
10886         std::string m_arg;\par
10887         std::string m_substring;\par
10888         std::string m_patternName;\par
10889         std::vector<std::size_t> m_escapeChars;\par
10890         TestSpec::Filter m_currentFilter;\par
10891         TestSpec m_testSpec;\par
10892         ITagAliasRegistry {\cf17 const}* m_tagAliases = {\cf17 nullptr};\par
10893 \par
10894     {\cf17 public}:\par
10895         TestSpecParser( ITagAliasRegistry {\cf17 const}& tagAliases );\par
10896 \par
10897         TestSpecParser& parse( std::string {\cf17 const}& arg );\par
10898         TestSpec testSpec();\par
10899 \par
10900     {\cf17 private}:\par
10901         {\cf18 bool} visitChar( {\cf18 char} c );\par
10902         {\cf18 void} startNewMode( Mode mode );\par
10903         {\cf18 bool} processNoneChar( {\cf18 char} c );\par
10904         {\cf18 void} processNameChar( {\cf18 char} c );\par
10905         {\cf18 bool} processOtherChar( {\cf18 char} c );\par
10906         {\cf18 void} endMode();\par
10907         {\cf18 void} escape();\par
10908         {\cf18 bool} isControlChar( {\cf18 char} c ) {\cf17 const};\par
10909         {\cf18 void} saveLastMode();\par
10910         {\cf18 void} revertBackToLastMode();\par
10911         {\cf18 void} addFilter();\par
10912         {\cf18 bool} separate();\par
10913 \par
10914         {\cf20 // Handles common preprocessing of the pattern for name/tag patterns}\par
10915         std::string preprocessPattern();\par
10916         {\cf20 // Adds the current pattern as a test name}\par
10917         {\cf18 void} addNamePattern();\par
10918         {\cf20 // Adds the current pattern as a tag}\par
10919         {\cf18 void} addTagPattern();\par
10920 \par
10921         {\cf17 inline} {\cf18 void} addCharToPattern({\cf18 char} c) \{\par
10922             m_substring += c;\par
10923             m_patternName += c;\par
10924             m_realPatternPos++;\par
10925         \}\par
10926 \par
10927     \};\par
10928 \par
10929 \} {\cf20 // namespace Catch}\par
10930 \par
10931 {\cf21 #ifdef __clang__}\par
10932 {\cf21 #pragma clang diagnostic pop}\par
10933 {\cf21 #endif}\par
10934 \par
10935 {\cf21 #endif }{\cf20 // CATCH_TEST_SPEC_PARSER_HPP_INCLUDED}\par
10936 \par
10937 \par
10938 {\cf21 #ifndef CATCH_TEXTFLOW_HPP_INCLUDED}\par
10939 {\cf21 #define CATCH_TEXTFLOW_HPP_INCLUDED}\par
10940 \par
10941 \par
10942 {\cf21 #include <cassert>}\par
10943 {\cf21 #include <string>}\par
10944 {\cf21 #include <vector>}\par
10945 \par
10946 {\cf17 namespace }Catch \{\par
10947     {\cf17 namespace }TextFlow \{\par
10948 \par
10949         {\cf17 class }Columns;\par
10950 \par
10963         {\cf17 class }AnsiSkippingString \{\par
10964             std::string m_string;\par
10965             std::size_t m_size = 0;\par
10966 \par
10967             {\cf20 // perform 0xff replacement and calculate m_size}\par
10968             {\cf18 void} preprocessString();\par
10969 \par
10970         {\cf17 public}:\par
10971             {\cf17 class }const_iterator;\par
10972             {\cf17 using }iterator = const_iterator;\par
10973             {\cf20 // note: must be u-suffixed or this will cause a "truncation of}\par
10974             {\cf20 // constant value" warning on MSVC}\par
10975             {\cf17 static} {\cf17 constexpr} {\cf18 char} sentinel = {\cf17 static_cast<}{\cf18 char}{\cf17 >}( 0xffu );\par
10976 \par
10977             {\cf17 explicit} AnsiSkippingString( std::string {\cf17 const}& text );\par
10978             {\cf17 explicit} AnsiSkippingString( std::string&& text );\par
10979 \par
10980             const_iterator begin() {\cf17 const};\par
10981             const_iterator end() {\cf17 const};\par
10982 \par
10983             {\cf18 size_t} size(){\cf17  const }\{ {\cf19 return} m_size; \}\par
10984 \par
10985             std::string substring( const_iterator begin,\par
10986                                    const_iterator end ) {\cf17 const};\par
10987         \};\par
10988 \par
10989         {\cf17 class }AnsiSkippingString::const_iterator \{\par
10990             {\cf17 friend} AnsiSkippingString;\par
10991             {\cf17 struct }EndTag \{\};\par
10992 \par
10993             {\cf17 const} std::string* m_string;\par
10994             std::string::const_iterator m_it;\par
10995 \par
10996             {\cf17 explicit} const_iterator( {\cf17 const} std::string& {\cf18 string}, EndTag ):\par
10997                 m_string( &string ), m_it( string.end() ) \{\}\par
10998 \par
10999             {\cf18 void} tryParseAnsiEscapes();\par
11000             {\cf18 void} advance();\par
11001             {\cf18 void} unadvance();\par
11002 \par
11003         {\cf17 public}:\par
11004             {\cf17 using }difference_type = std::ptrdiff_t;\par
11005             {\cf17 using }value_type = char;\par
11006             {\cf17 using }pointer = value_type*;\par
11007             {\cf17 using }reference = value_type&;\par
11008             {\cf17 using }iterator_category = std::bidirectional_iterator_tag;\par
11009 \par
11010             {\cf17 explicit} const_iterator( {\cf17 const} std::string& {\cf18 string} ):\par
11011                 m_string( &string ), m_it( string.begin() ) \{\par
11012                 tryParseAnsiEscapes();\par
11013             \}\par
11014 \par
11015             {\cf18 char} operator*(){\cf17  const }\{ {\cf19 return} *m_it; \}\par
11016 \par
11017             const_iterator& operator++() \{\par
11018                 advance();\par
11019                 {\cf19 return} *{\cf17 this};\par
11020             \}\par
11021             const_iterator operator++( {\cf18 int} ) \{\par
11022                 iterator prev( *{\cf17 this} );\par
11023                 operator++();\par
11024                 {\cf19 return} prev;\par
11025             \}\par
11026             const_iterator& operator--() \{\par
11027                 unadvance();\par
11028                 {\cf19 return} *{\cf17 this};\par
11029             \}\par
11030             const_iterator operator--( {\cf18 int} ) \{\par
11031                 iterator prev( *{\cf17 this} );\par
11032                 operator--();\par
11033                 {\cf19 return} prev;\par
11034             \}\par
11035 \par
11036             {\cf18 bool} operator==( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11037                 {\cf19 return} m_it == other.m_it;\par
11038             \}\par
11039             {\cf18 bool} operator!=( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11040                 {\cf19 return} !operator==( other );\par
11041             \}\par
11042             {\cf18 bool} operator<=( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11043                 {\cf19 return} m_it <= other.m_it;\par
11044             \}\par
11045 \par
11046             const_iterator oneBefore(){\cf17  const }\{\par
11047                 {\cf17 auto} it = *{\cf17 this};\par
11048                 {\cf19 return} --it;\par
11049             \}\par
11050         \};\par
11051 \par
11059         {\cf17 class }Column \{\par
11060             {\cf20 // String to be written out}\par
11061             AnsiSkippingString m_string;\par
11062             {\cf20 // Width of the column for linebreaking}\par
11063             {\cf18 size_t} m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;\par
11064             {\cf20 // Indentation of other lines (including first if initial indent is}\par
11065             {\cf20 // unset)}\par
11066             {\cf18 size_t} m_indent = 0;\par
11067             {\cf20 // Indentation of the first line}\par
11068             {\cf18 size_t} m_initialIndent = std::string::npos;\par
11069 \par
11070         {\cf17 public}:\par
11074             {\cf17 class }const_iterator \{\par
11075                 {\cf17 friend} Column;\par
11076                 {\cf17 struct }EndTag \{\};\par
11077 \par
11078                 Column {\cf17 const}& m_column;\par
11079                 {\cf20 // Where does the current line start?}\par
11080                 AnsiSkippingString::const_iterator m_lineStart;\par
11081                 {\cf20 // How long should the current line be?}\par
11082                 AnsiSkippingString::const_iterator m_lineEnd;\par
11083                 {\cf20 // How far have we checked the string to iterate?}\par
11084                 AnsiSkippingString::const_iterator m_parsedTo;\par
11085                 {\cf20 // Should a '-' be appended to the line?}\par
11086                 {\cf18 bool} m_addHyphen = {\cf17 false};\par
11087 \par
11088                 const_iterator( Column {\cf17 const}& column, EndTag ):\par
11089                     m_column( column ),\par
11090                     m_lineStart( m_column.m_string.end() ),\par
11091                     m_lineEnd( column.m_string.end() ),\par
11092                     m_parsedTo( column.m_string.end() ) \{\}\par
11093 \par
11094                 {\cf20 // Calculates the length of the current line}\par
11095                 {\cf18 void} calcLength();\par
11096 \par
11097                 {\cf20 // Returns current indentation width}\par
11098                 {\cf18 size_t} indentSize() {\cf17 const};\par
11099 \par
11100                 {\cf20 // Creates an indented and (optionally) suffixed string from}\par
11101                 {\cf20 // current iterator position, indentation and length.}\par
11102                 std::string addIndentAndSuffix(\par
11103                     AnsiSkippingString::const_iterator start,\par
11104                     AnsiSkippingString::const_iterator end ) {\cf17 const};\par
11105 \par
11106             {\cf17 public}:\par
11107                 {\cf17 using }difference_type = std::ptrdiff_t;\par
11108                 {\cf17 using }value_type = std::string;\par
11109                 {\cf17 using }pointer = value_type*;\par
11110                 {\cf17 using }reference = value_type&;\par
11111                 {\cf17 using }iterator_category = std::forward_iterator_tag;\par
11112 \par
11113                 {\cf17 explicit} const_iterator( Column {\cf17 const}& column );\par
11114 \par
11115                 std::string operator*() {\cf17 const};\par
11116 \par
11117                 const_iterator& operator++();\par
11118                 const_iterator operator++( {\cf18 int} );\par
11119 \par
11120                 {\cf18 bool} operator==( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11121                     {\cf19 return} m_lineStart == other.m_lineStart &&\par
11122                            &m_column == &other.m_column;\par
11123                 \}\par
11124                 {\cf18 bool} operator!=( const_iterator {\cf17 const}& other ){\cf17  const }\{\par
11125                     {\cf19 return} !operator==( other );\par
11126                 \}\par
11127             \};\par
11128             {\cf17 using }iterator = const_iterator;\par
11129 \par
11130             {\cf17 explicit} Column( std::string {\cf17 const}& text ): m_string( text ) \{\}\par
11131             {\cf17 explicit} Column( std::string&& text ):\par
11132                 m_string( CATCH_MOVE( text ) ) \{\}\par
11133 \par
11134             Column& width( {\cf18 size_t} newWidth ) & \{\par
11135                 assert( newWidth > 0 );\par
11136                 m_width = newWidth;\par
11137                 {\cf19 return} *{\cf17 this};\par
11138             \}\par
11139             Column&& width( {\cf18 size_t} newWidth ) && \{\par
11140                 assert( newWidth > 0 );\par
11141                 m_width = newWidth;\par
11142                 {\cf19 return} CATCH_MOVE( *{\cf17 this} );\par
11143             \}\par
11144             Column& indent( {\cf18 size_t} newIndent ) & \{\par
11145                 m_indent = newIndent;\par
11146                 {\cf19 return} *{\cf17 this};\par
11147             \}\par
11148             Column&& indent( {\cf18 size_t} newIndent ) && \{\par
11149                 m_indent = newIndent;\par
11150                 {\cf19 return} CATCH_MOVE( *{\cf17 this} );\par
11151             \}\par
11152             Column& initialIndent( {\cf18 size_t} newIndent ) & \{\par
11153                 m_initialIndent = newIndent;\par
11154                 {\cf19 return} *{\cf17 this};\par
11155             \}\par
11156             Column&& initialIndent( {\cf18 size_t} newIndent ) && \{\par
11157                 m_initialIndent = newIndent;\par
11158                 {\cf19 return} CATCH_MOVE( *{\cf17 this} );\par
11159             \}\par
11160 \par
11161             {\cf18 size_t} width(){\cf17  const }\{ {\cf19 return} m_width; \}\par
11162             const_iterator begin(){\cf17  const }\{ {\cf19 return} const_iterator( *{\cf17 this} ); \}\par
11163             const_iterator end(){\cf17  const }\{\par
11164                 {\cf19 return} \{ *{\cf17 this}, const_iterator::EndTag\{\} \};\par
11165             \}\par
11166 \par
11167             {\cf17 friend} std::ostream& operator<<( std::ostream& os,\par
11168                                              Column {\cf17 const}& col );\par
11169 \par
11170             {\cf17 friend} Columns operator+( Column {\cf17 const}& lhs, Column {\cf17 const}& rhs );\par
11171             {\cf17 friend} Columns operator+( Column&& lhs, Column&& rhs );\par
11172         \};\par
11173 \par
11175         Column Spacer( {\cf18 size_t} spaceWidth );\par
11176 \par
11177         {\cf17 class }Columns \{\par
11178             std::vector<Column> m_columns;\par
11179 \par
11180         {\cf17 public}:\par
11181             {\cf17 class }iterator \{\par
11182                 {\cf17 friend} Columns;\par
11183                 {\cf17 struct }EndTag \{\};\par
11184 \par
11185                 std::vector<Column> {\cf17 const}& m_columns;\par
11186                 std::vector<Column::const_iterator> m_iterators;\par
11187                 {\cf18 size_t} m_activeIterators;\par
11188 \par
11189                 iterator( Columns {\cf17 const}& columns, EndTag );\par
11190 \par
11191             {\cf17 public}:\par
11192                 {\cf17 using }difference_type = std::ptrdiff_t;\par
11193                 {\cf17 using }value_type = std::string;\par
11194                 {\cf17 using }pointer = value_type*;\par
11195                 {\cf17 using }reference = value_type&;\par
11196                 {\cf17 using }iterator_category = std::forward_iterator_tag;\par
11197 \par
11198                 {\cf17 explicit} iterator( Columns {\cf17 const}& columns );\par
11199 \par
11200                 {\cf17 auto} operator==( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
11201                     {\cf19 return} m_iterators == other.m_iterators;\par
11202                 \}\par
11203                 {\cf17 auto} operator!=( iterator {\cf17 const}& other ) {\cf17 const} -> {\cf18 bool} \{\par
11204                     {\cf19 return} m_iterators != other.m_iterators;\par
11205                 \}\par
11206                 std::string operator*() {\cf17 const};\par
11207                 iterator& operator++();\par
11208                 iterator operator++( {\cf18 int} );\par
11209             \};\par
11210             {\cf17 using }const_iterator = iterator;\par
11211 \par
11212             iterator begin(){\cf17  const }\{ {\cf19 return} iterator( *{\cf17 this} ); \}\par
11213             iterator end(){\cf17  const }\{ {\cf19 return} \{ *{\cf17 this}, iterator::EndTag() \}; \}\par
11214 \par
11215             {\cf17 friend} Columns& operator+=( Columns& lhs, Column {\cf17 const}& rhs );\par
11216             {\cf17 friend} Columns& operator+=( Columns& lhs, Column&& rhs );\par
11217             {\cf17 friend} Columns operator+( Columns {\cf17 const}& lhs, Column {\cf17 const}& rhs );\par
11218             {\cf17 friend} Columns operator+( Columns&& lhs, Column&& rhs );\par
11219 \par
11220             {\cf17 friend} std::ostream& operator<<( std::ostream& os,\par
11221                                              Columns {\cf17 const}& cols );\par
11222         \};\par
11223 \par
11224     \} {\cf20 // namespace TextFlow}\par
11225 \} {\cf20 // namespace Catch}\par
11226 {\cf21 #endif }{\cf20 // CATCH_TEXTFLOW_HPP_INCLUDED}\par
11227 \par
11228 \par
11229 {\cf21 #ifndef CATCH_TO_STRING_HPP_INCLUDED}\par
11230 {\cf21 #define CATCH_TO_STRING_HPP_INCLUDED}\par
11231 \par
11232 {\cf21 #include <string>}\par
11233 \par
11234 \par
11235 {\cf17 namespace }Catch \{\par
11236     {\cf17 template} <{\cf17 typename} T>\par
11237     std::string to_string(T {\cf17 const}& t) \{\par
11238 {\cf21 #if defined(CATCH_CONFIG_CPP11_TO_STRING)}\par
11239         {\cf19 return} std::to_string(t);\par
11240 {\cf21 #else}\par
11241         ReusableStringStream rss;\par
11242         rss << t;\par
11243         {\cf19 return} rss.str();\par
11244 {\cf21 #endif}\par
11245     \}\par
11246 \} {\cf20 // end namespace Catch}\par
11247 \par
11248 {\cf21 #endif }{\cf20 // CATCH_TO_STRING_HPP_INCLUDED}\par
11249 \par
11250 \par
11251 {\cf21 #ifndef CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
11252 {\cf21 #define CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
11253 \par
11254 {\cf17 namespace }Catch \{\par
11255     {\cf18 bool} uncaught_exceptions();\par
11256 \} {\cf20 // end namespace Catch}\par
11257 \par
11258 {\cf21 #endif }{\cf20 // CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED}\par
11259 \par
11260 \par
11261 {\cf21 #ifndef CATCH_XMLWRITER_HPP_INCLUDED}\par
11262 {\cf21 #define CATCH_XMLWRITER_HPP_INCLUDED}\par
11263 \par
11264 \par
11265 {\cf21 #include <iosfwd>}\par
11266 {\cf21 #include <vector>}\par
11267 \par
11268 {\cf17 namespace }Catch \{\par
11269     {\cf17 enum class} XmlFormatting \{\par
11270         None = 0x00,\par
11271         Indent = 0x01,\par
11272         Newline = 0x02,\par
11273     \};\par
11274 \par
11275     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);\par
11276     XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);\par
11277 \par
11284     {\cf17 class }XmlEncode \{\par
11285     {\cf17 public}:\par
11286         {\cf17 enum} ForWhat \{ ForTextNodes, ForAttributes \};\par
11287 \par
11288         XmlEncode( StringRef str, ForWhat forWhat = ForTextNodes );\par
11289 \par
11290         {\cf18 void} encodeTo( std::ostream& os ) {\cf17 const};\par
11291 \par
11292         {\cf17 friend} std::ostream& operator << ( std::ostream& os, XmlEncode {\cf17 const}& xmlEncode );\par
11293 \par
11294     {\cf17 private}:\par
11295         StringRef m_str;\par
11296         ForWhat m_forWhat;\par
11297     \};\par
11298 \par
11299     {\cf17 class }XmlWriter \{\par
11300     {\cf17 public}:\par
11301 \par
11302         {\cf17 class }ScopedElement \{\par
11303         {\cf17 public}:\par
11304             ScopedElement( XmlWriter* writer, XmlFormatting fmt );\par
11305 \par
11306             ScopedElement( ScopedElement&& other ) {\cf17 noexcept};\par
11307             ScopedElement& operator=( ScopedElement&& other ) {\cf17 noexcept};\par
11308 \par
11309             ~ScopedElement();\par
11310 \par
11311             ScopedElement&\par
11312             writeText( StringRef text,\par
11313                        XmlFormatting fmt = XmlFormatting::Newline |\par
11314                                            XmlFormatting::Indent );\par
11315 \par
11316             ScopedElement& writeAttribute( StringRef name,\par
11317                                            StringRef attribute );\par
11318             {\cf17 template} <{\cf17 typename} T,\par
11319                       {\cf20 // Without this SFINAE, this overload is a better match}\par
11320                       {\cf20 // for `std::string`, `char const*`, `char const[N]` args.}\par
11321                       {\cf20 // While it would still work, it would cause code bloat}\par
11322                       {\cf20 // and multiple iteration over the strings}\par
11323                       {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
11324                           !std::is_convertible<T, StringRef>::value>>\par
11325             ScopedElement& writeAttribute( StringRef name,\par
11326                                            T {\cf17 const}& attribute ) \{\par
11327                 m_writer->writeAttribute( name, attribute );\par
11328                 {\cf19 return} *{\cf17 this};\par
11329             \}\par
11330 \par
11331         {\cf17 private}:\par
11332             XmlWriter* m_writer = {\cf17 nullptr};\par
11333             XmlFormatting m_fmt;\par
11334         \};\par
11335 \par
11336         XmlWriter( std::ostream& os );\par
11337         ~XmlWriter();\par
11338 \par
11339         XmlWriter( XmlWriter {\cf17 const}& ) = {\cf17 delete};\par
11340         XmlWriter& operator=( XmlWriter {\cf17 const}& ) = {\cf17 delete};\par
11341 \par
11342         XmlWriter& startElement( std::string {\cf17 const}& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);\par
11343 \par
11344         ScopedElement scopedElement( std::string {\cf17 const}& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);\par
11345 \par
11346         XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);\par
11347 \par
11349         XmlWriter& writeAttribute( StringRef name, StringRef attribute );\par
11350 \par
11352         XmlWriter& writeAttribute( StringRef name, {\cf18 bool} attribute );\par
11353 \par
11355         XmlWriter& writeAttribute( StringRef name, {\cf18 char} {\cf17 const}* attribute );\par
11356 \par
11359         {\cf17 template} <{\cf17 typename} T,\par
11360                   {\cf20 // Without this SFINAE, this overload is a better match}\par
11361                   {\cf20 // for `std::string`, `char const*`, `char const[N]` args.}\par
11362                   {\cf20 // While it would still work, it would cause code bloat}\par
11363                   {\cf20 // and multiple iteration over the strings}\par
11364                   {\cf17 typename} = {\cf17 typename} std::enable_if_t<\par
11365                       !std::is_convertible<T, StringRef>::value>>\par
11366         XmlWriter& writeAttribute( StringRef name, T {\cf17 const}& attribute ) \{\par
11367             ReusableStringStream rss;\par
11368             rss << attribute;\par
11369             {\cf19 return} writeAttribute( name, rss.str() );\par
11370         \}\par
11371 \par
11373         XmlWriter& writeText( StringRef text,\par
11374                               XmlFormatting fmt = XmlFormatting::Newline |\par
11375                                                   XmlFormatting::Indent );\par
11376 \par
11378         XmlWriter& writeComment( StringRef text,\par
11379                                  XmlFormatting fmt = XmlFormatting::Newline |\par
11380                                                      XmlFormatting::Indent );\par
11381 \par
11382         {\cf18 void} writeStylesheetRef( StringRef url );\par
11383 \par
11384         {\cf18 void} ensureTagClosed();\par
11385 \par
11386     {\cf17 private}:\par
11387 \par
11388         {\cf18 void} applyFormatting(XmlFormatting fmt);\par
11389 \par
11390         {\cf18 void} writeDeclaration();\par
11391 \par
11392         {\cf18 void} newlineIfNecessary();\par
11393 \par
11394         {\cf18 bool} m_tagIsOpen = {\cf17 false};\par
11395         {\cf18 bool} m_needsNewline = {\cf17 false};\par
11396         std::vector<std::string> m_tags;\par
11397         std::string m_indent;\par
11398         std::ostream& m_os;\par
11399     \};\par
11400 \par
11401 \}\par
11402 \par
11403 {\cf21 #endif }{\cf20 // CATCH_XMLWRITER_HPP_INCLUDED}\par
11404 \par
11405 \par
11418 {\cf21 #ifndef CATCH_MATCHERS_ALL_HPP_INCLUDED}\par
11419 {\cf21 #define CATCH_MATCHERS_ALL_HPP_INCLUDED}\par
11420 \par
11421 \par
11422 \par
11423 {\cf21 #ifndef CATCH_MATCHERS_HPP_INCLUDED}\par
11424 {\cf21 #define CATCH_MATCHERS_HPP_INCLUDED}\par
11425 \par
11426 \par
11427 \par
11428 {\cf21 #ifndef CATCH_MATCHERS_IMPL_HPP_INCLUDED}\par
11429 {\cf21 #define CATCH_MATCHERS_IMPL_HPP_INCLUDED}\par
11430 \par
11431 \par
11432 {\cf21 #include <string>}\par
11433 \par
11434 {\cf17 namespace }Catch \{\par
11435 \par
11436 {\cf21 #ifdef __clang__}\par
11437 {\cf21 #    pragma clang diagnostic push}\par
11438 {\cf21 #    pragma clang diagnostic ignored "-Wsign-compare"}\par
11439 {\cf21 #    pragma clang diagnostic ignored "-Wnon-virtual-dtor"}\par
11440 {\cf21 #elif defined __GNUC__}\par
11441 {\cf21 #    pragma GCC diagnostic push}\par
11442 {\cf21 #    pragma GCC diagnostic ignored "-Wsign-compare"}\par
11443 {\cf21 #    pragma GCC diagnostic ignored "-Wnon-virtual-dtor"}\par
11444 {\cf21 #endif}\par
11445 \par
11446     {\cf17 template}<{\cf17 typename} ArgT, {\cf17 typename} MatcherT>\par
11447     {\cf17 class }MatchExpr : {\cf17 public} ITransientExpression \{\par
11448         ArgT && m_arg;\par
11449         MatcherT {\cf17 const}& m_matcher;\par
11450     {\cf17 public}:\par
11451         MatchExpr( ArgT && arg, MatcherT {\cf17 const}& matcher )\par
11452         :   ITransientExpression\{ true, matcher.match( arg ) \}, {\cf20 // not forwarding arg here on purpose}\par
11453             m_arg( CATCH_FORWARD(arg) ),\par
11454             m_matcher( matcher )\par
11455         \{\}\par
11456 \par
11457         {\cf18 void} streamReconstructedExpression( std::ostream& os ){\cf17  const override }\{\par
11458             os << Catch::Detail::stringify( m_arg )\par
11459                << {\cf23 ' '}\par
11460                << m_matcher.toString();\par
11461         \}\par
11462     \};\par
11463 \par
11464 {\cf21 #ifdef __clang__}\par
11465 {\cf21 #    pragma clang diagnostic pop}\par
11466 {\cf21 #elif defined __GNUC__}\par
11467 {\cf21 #    pragma GCC diagnostic pop}\par
11468 {\cf21 #endif}\par
11469 \par
11470 \par
11471     {\cf17 namespace }Matchers \{\par
11472         {\cf17 template} <{\cf17 typename} ArgT>\par
11473         {\cf17 class }MatcherBase;\par
11474     \}\par
11475 \par
11476     {\cf17 using }StringMatcher = Matchers::MatcherBase<std::string>;\par
11477 \par
11478     {\cf18 void} handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher {\cf17 const}& matcher );\par
11479 \par
11480     {\cf17 template}<{\cf17 typename} ArgT, {\cf17 typename} MatcherT>\par
11481     {\cf17 auto} makeMatchExpr( ArgT && arg, MatcherT {\cf17 const}& matcher ) -> MatchExpr<ArgT, MatcherT> \{\par
11482         {\cf19 return} MatchExpr<ArgT, MatcherT>( CATCH_FORWARD(arg), matcher );\par
11483     \}\par
11484 \par
11485 \} {\cf20 // namespace Catch}\par
11486 \par
11487 \par
11489 {\cf21 #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \\}\par
11490 {\cf21     do \{ \\}\par
11491 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\}\par
11492 {\cf21         INTERNAL_CATCH_TRY \{ \\}\par
11493 {\cf21             catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher ) ); \\}\par
11494 {\cf21         \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\}\par
11495 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
11496 {\cf21     \} while( false )}\par
11497 \par
11498 \par
11500 {\cf21 #define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \\}\par
11501 {\cf21     do \{ \\}\par
11502 {\cf21         Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\}\par
11503 {\cf21         if( catchAssertionHandler.allowThrows() ) \\}\par
11504 {\cf21             try \{ \\}\par
11505 {\cf21                 static_cast<void>(__VA_ARGS__ ); \\}\par
11506 {\cf21                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\}\par
11507 {\cf21             \} \\}\par
11508 {\cf21             catch( exceptionType const& ex ) \{ \\}\par
11509 {\cf21                 catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher ) ); \\}\par
11510 {\cf21             \} \\}\par
11511 {\cf21             catch( ... ) \{ \\}\par
11512 {\cf21                 catchAssertionHandler.handleUnexpectedInflightException(); \\}\par
11513 {\cf21             \} \\}\par
11514 {\cf21         else \\}\par
11515 {\cf21             catchAssertionHandler.handleThrowingCallSkipped(); \\}\par
11516 {\cf21         INTERNAL_CATCH_REACT( catchAssertionHandler ) \\}\par
11517 {\cf21     \} while( false )}\par
11518 \par
11519 \par
11520 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_IMPL_HPP_INCLUDED}\par
11521 \par
11522 {\cf21 #include <string>}\par
11523 {\cf21 #include <vector>}\par
11524 \par
11525 {\cf17 namespace }Catch \{\par
11526 {\cf17 namespace }Matchers \{\par
11527 \par
11528     {\cf17 class }MatcherUntypedBase \{\par
11529     {\cf17 public}:\par
11530         MatcherUntypedBase() = {\cf19 default};\par
11531 \par
11532         MatcherUntypedBase(MatcherUntypedBase {\cf17 const}&) = {\cf19 default};\par
11533         MatcherUntypedBase(MatcherUntypedBase&&) = {\cf19 default};\par
11534 \par
11535         MatcherUntypedBase& operator = (MatcherUntypedBase {\cf17 const}&) = {\cf17 delete};\par
11536         MatcherUntypedBase& operator = (MatcherUntypedBase&&) = {\cf17 delete};\par
11537 \par
11538         std::string toString() {\cf17 const};\par
11539 \par
11540     {\cf17 protected}:\par
11541         {\cf17 virtual} ~MatcherUntypedBase(); {\cf20 // = default;}\par
11542         {\cf17 virtual} std::string describe() {\cf17 const} = 0;\par
11543         {\cf17 mutable} std::string m_cachedToString;\par
11544     \};\par
11545 \par
11546 \par
11547     {\cf17 template}<{\cf17 typename} T>\par
11548     {\cf17 class }MatcherBase : {\cf17 public} MatcherUntypedBase \{\par
11549     {\cf17 public}:\par
11550         {\cf17 virtual} {\cf18 bool} match( T {\cf17 const}& arg ) {\cf17 const} = 0;\par
11551     \};\par
11552 \par
11553     {\cf17 namespace }Detail \{\par
11554 \par
11555         {\cf17 template}<{\cf17 typename} ArgT>\par
11556         {\cf17 class }MatchAllOf final : {\cf17 public} MatcherBase<ArgT> \{\par
11557             std::vector<MatcherBase<ArgT> {\cf17 const}*> m_matchers;\par
11558 \par
11559         {\cf17 public}:\par
11560             MatchAllOf() = {\cf19 default};\par
11561             MatchAllOf(MatchAllOf {\cf17 const}&) = {\cf17 delete};\par
11562             MatchAllOf& operator=(MatchAllOf {\cf17 const}&) = {\cf17 delete};\par
11563             MatchAllOf(MatchAllOf&&) = {\cf19 default};\par
11564             MatchAllOf& operator=(MatchAllOf&&) = {\cf19 default};\par
11565 \par
11566 \par
11567             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
11568                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11569                     {\cf19 if} (!matcher->match(arg))\par
11570                         {\cf19 return} {\cf17 false};\par
11571                 \}\par
11572                 {\cf19 return} {\cf17 true};\par
11573             \}\par
11574             std::string describe(){\cf17  const override }\{\par
11575                 std::string description;\par
11576                 description.reserve( 4 + m_matchers.size()*32 );\par
11577                 description += {\cf22 "( "};\par
11578                 {\cf18 bool} first = {\cf17 true};\par
11579                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11580                     {\cf19 if}( first )\par
11581                         first = {\cf17 false};\par
11582                     {\cf19 else}\par
11583                         description += {\cf22 " and "};\par
11584                     description += matcher->toString();\par
11585                 \}\par
11586                 description += {\cf22 " )"};\par
11587                 {\cf19 return} description;\par
11588             \}\par
11589 \par
11590             {\cf17 friend} MatchAllOf operator&& (MatchAllOf&& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) \{\par
11591                 lhs.m_matchers.push_back(&rhs);\par
11592                 {\cf19 return} CATCH_MOVE(lhs);\par
11593             \}\par
11594             {\cf17 friend} MatchAllOf operator&& (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAllOf&& rhs) \{\par
11595                 rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);\par
11596                 {\cf19 return} CATCH_MOVE(rhs);\par
11597             \}\par
11598         \};\par
11599 \par
11602         {\cf17 template}<{\cf17 typename} ArgT>\par
11603         MatchAllOf<ArgT> operator&& (MatchAllOf<ArgT> {\cf17 const}& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11606         {\cf17 template}<{\cf17 typename} ArgT>\par
11607         MatchAllOf<ArgT> operator&& (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAllOf<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11608 \par
11609         {\cf17 template}<{\cf17 typename} ArgT>\par
11610         {\cf17 class }MatchAnyOf final : {\cf17 public} MatcherBase<ArgT> \{\par
11611             std::vector<MatcherBase<ArgT> {\cf17 const}*> m_matchers;\par
11612         {\cf17 public}:\par
11613             MatchAnyOf() = {\cf19 default};\par
11614             MatchAnyOf(MatchAnyOf {\cf17 const}&) = {\cf17 delete};\par
11615             MatchAnyOf& operator=(MatchAnyOf {\cf17 const}&) = {\cf17 delete};\par
11616             MatchAnyOf(MatchAnyOf&&) = {\cf19 default};\par
11617             MatchAnyOf& operator=(MatchAnyOf&&) = {\cf19 default};\par
11618 \par
11619             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
11620                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11621                     {\cf19 if} (matcher->match(arg))\par
11622                         {\cf19 return} {\cf17 true};\par
11623                 \}\par
11624                 {\cf19 return} {\cf17 false};\par
11625             \}\par
11626             std::string describe(){\cf17  const override }\{\par
11627                 std::string description;\par
11628                 description.reserve( 4 + m_matchers.size()*32 );\par
11629                 description += {\cf22 "( "};\par
11630                 {\cf18 bool} first = {\cf17 true};\par
11631                 {\cf19 for}( {\cf17 auto} matcher : m_matchers ) \{\par
11632                     {\cf19 if}( first )\par
11633                         first = {\cf17 false};\par
11634                     {\cf19 else}\par
11635                         description += {\cf22 " or "};\par
11636                     description += matcher->toString();\par
11637                 \}\par
11638                 description += {\cf22 " )"};\par
11639                 {\cf19 return} description;\par
11640             \}\par
11641 \par
11642             {\cf17 friend} MatchAnyOf operator|| (MatchAnyOf&& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) \{\par
11643                 lhs.m_matchers.push_back(&rhs);\par
11644                 {\cf19 return} CATCH_MOVE(lhs);\par
11645             \}\par
11646             {\cf17 friend} MatchAnyOf operator|| (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAnyOf&& rhs) \{\par
11647                 rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);\par
11648                 {\cf19 return} CATCH_MOVE(rhs);\par
11649             \}\par
11650         \};\par
11651 \par
11654         {\cf17 template}<{\cf17 typename} ArgT>\par
11655         MatchAnyOf<ArgT> operator|| (MatchAnyOf<ArgT> {\cf17 const}& lhs, MatcherBase<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11658         {\cf17 template}<{\cf17 typename} ArgT>\par
11659         MatchAnyOf<ArgT> operator|| (MatcherBase<ArgT> {\cf17 const}& lhs, MatchAnyOf<ArgT> {\cf17 const}& rhs) = {\cf17 delete};\par
11660 \par
11661         {\cf17 template}<{\cf17 typename} ArgT>\par
11662         {\cf17 class }MatchNotOf final : {\cf17 public} MatcherBase<ArgT> \{\par
11663             MatcherBase<ArgT> {\cf17 const}& m_underlyingMatcher;\par
11664 \par
11665         {\cf17 public}:\par
11666             {\cf17 explicit} MatchNotOf( MatcherBase<ArgT> {\cf17 const}& underlyingMatcher ):\par
11667                 m_underlyingMatcher( underlyingMatcher )\par
11668             \{\}\par
11669 \par
11670             {\cf18 bool} match( ArgT {\cf17 const}& arg ){\cf17  const override }\{\par
11671                 {\cf19 return} !m_underlyingMatcher.match( arg );\par
11672             \}\par
11673 \par
11674             std::string describe(){\cf17  const override }\{\par
11675                 {\cf19 return} {\cf22 "not "} + m_underlyingMatcher.toString();\par
11676             \}\par
11677         \};\par
11678 \par
11679     \} {\cf20 // namespace Detail}\par
11680 \par
11681     {\cf17 template} <{\cf17 typename} T>\par
11682     Detail::MatchAllOf<T> operator&& (MatcherBase<T> {\cf17 const}& lhs, MatcherBase<T> {\cf17 const}& rhs) \{\par
11683         {\cf19 return} Detail::MatchAllOf<T>\{\} && lhs && rhs;\par
11684     \}\par
11685     {\cf17 template} <{\cf17 typename} T>\par
11686     Detail::MatchAnyOf<T> operator|| (MatcherBase<T> {\cf17 const}& lhs, MatcherBase<T> {\cf17 const}& rhs) \{\par
11687         {\cf19 return} Detail::MatchAnyOf<T>\{\} || lhs || rhs;\par
11688     \}\par
11689 \par
11690     {\cf17 template} <{\cf17 typename} T>\par
11691     Detail::MatchNotOf<T> operator! (MatcherBase<T> {\cf17 const}& matcher) \{\par
11692         {\cf19 return} Detail::MatchNotOf<T>\{ matcher \};\par
11693     \}\par
11694 \par
11695 \par
11696 \} {\cf20 // namespace Matchers}\par
11697 \} {\cf20 // namespace Catch}\par
11698 \par
11699 \par
11700 {\cf21 #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
11701 {\cf21   #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )}\par
11702 {\cf21   #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}\par
11703 \par
11704 {\cf21   #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11705 {\cf21   #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11706 \par
11707 {\cf21   #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}\par
11708 {\cf21   #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )}\par
11709 \par
11710 {\cf21 #elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
11711 \par
11712 {\cf21   #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)}\par
11713 {\cf21   #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
11714 \par
11715 {\cf21   #define CATCH_CHECK_THROWS_WITH( expr, matcher )                     (void)(0)}\par
11716 {\cf21   #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)}\par
11717 \par
11718 {\cf21   #define CATCH_CHECK_THAT( arg, matcher )                             (void)(0)}\par
11719 {\cf21   #define CATCH_REQUIRE_THAT( arg, matcher )                           (void)(0)}\par
11720 \par
11721 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)}\par
11722 \par
11723 {\cf21   #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )}\par
11724 {\cf21   #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}\par
11725 \par
11726 {\cf21   #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11727 {\cf21   #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}\par
11728 \par
11729 {\cf21   #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}\par
11730 {\cf21   #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )}\par
11731 \par
11732 {\cf21 #elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)}\par
11733 \par
11734 {\cf21   #define REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)}\par
11735 {\cf21   #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)}\par
11736 \par
11737 {\cf21   #define CHECK_THROWS_WITH( expr, matcher )                     (void)(0)}\par
11738 {\cf21   #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)}\par
11739 \par
11740 {\cf21   #define CHECK_THAT( arg, matcher )                             (void)(0)}\par
11741 {\cf21   #define REQUIRE_THAT( arg, matcher )                           (void)(0)}\par
11742 \par
11743 {\cf21 #endif }{\cf20 // end of user facing macro declarations}\par
11744 \par
11745 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_HPP_INCLUDED}\par
11746 \par
11747 \par
11748 {\cf21 #ifndef CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED}\par
11749 {\cf21 #define CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED}\par
11750 \par
11751 \par
11752 \par
11753 {\cf21 #ifndef CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED}\par
11754 {\cf21 #define CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED}\par
11755 \par
11756 \par
11757 {\cf21 #include <array>}\par
11758 {\cf21 #include <algorithm>}\par
11759 {\cf21 #include <string>}\par
11760 {\cf21 #include <type_traits>}\par
11761 \par
11762 {\cf17 namespace }Catch \{\par
11763 {\cf17 namespace }Matchers \{\par
11764     {\cf17 class }MatcherGenericBase : {\cf17 public} MatcherUntypedBase \{\par
11765     {\cf17 public}:\par
11766         MatcherGenericBase() = {\cf19 default};\par
11767         ~MatcherGenericBase() {\cf17 override}; {\cf20 // = default;}\par
11768 \par
11769         MatcherGenericBase(MatcherGenericBase {\cf17 const}&) = {\cf19 default};\par
11770         MatcherGenericBase(MatcherGenericBase&&) = {\cf19 default};\par
11771 \par
11772         MatcherGenericBase& operator=(MatcherGenericBase {\cf17 const}&) = {\cf17 delete};\par
11773         MatcherGenericBase& operator=(MatcherGenericBase&&) = {\cf17 delete};\par
11774     \};\par
11775 \par
11776 \par
11777     {\cf17 namespace }Detail \{\par
11778         {\cf17 template}<std::{\cf18 size_t} N, std::{\cf18 size_t} M>\par
11779         std::array<void const*, N + M> array_cat(std::array<void const*, N> && lhs, std::array<void const*, M> && rhs) \{\par
11780             std::array<void const*, N + M> arr\{\};\par
11781             std::copy_n(lhs.begin(), N, arr.begin());\par
11782             std::copy_n(rhs.begin(), M, arr.begin() + N);\par
11783             {\cf19 return} arr;\par
11784         \}\par
11785 \par
11786         {\cf17 template}<std::{\cf18 size_t} N>\par
11787         std::array<void const*, N+1> array_cat(std::array<void const*, N> && lhs, {\cf18 void} {\cf17 const}* rhs) \{\par
11788             std::array<void const*, N+1> arr\{\};\par
11789             std::copy_n(lhs.begin(), N, arr.begin());\par
11790             arr[N] = rhs;\par
11791             {\cf19 return} arr;\par
11792         \}\par
11793 \par
11794         {\cf17 template}<std::{\cf18 size_t} N>\par
11795         std::array<void const*, N+1> array_cat({\cf18 void} {\cf17 const}* lhs, std::array<void const*, N> && rhs) \{\par
11796             std::array<void const*, N + 1> arr\{ \{lhs\} \};\par
11797             std::copy_n(rhs.begin(), N, arr.begin() + 1);\par
11798             {\cf19 return} arr;\par
11799         \}\par
11800 \par
11801         {\cf17 template}<{\cf17 typename} T>\par
11802         {\cf17 using }is_generic_matcher = std::is_base_of<\par
11803             Catch::Matchers::MatcherGenericBase,\par
11804             std::remove_cv_t<std::remove_reference_t<T>>\par
11805         >;\par
11806 \par
11807         {\cf17 template}<{\cf17 typename}... Ts>\par
11808         {\cf17 using }are_generic_matchers = Catch::Detail::conjunction<is_generic_matcher<Ts>...>;\par
11809 \par
11810         {\cf17 template}<{\cf17 typename} T>\par
11811         {\cf17 using }is_matcher = std::is_base_of<\par
11812             Catch::Matchers::MatcherUntypedBase,\par
11813             std::remove_cv_t<std::remove_reference_t<T>>\par
11814         >;\par
11815 \par
11816 \par
11817         {\cf17 template}<std::{\cf18 size_t} N, {\cf17 typename} Arg>\par
11818         {\cf18 bool} match_all_of(Arg&&, std::array<void const*, N> {\cf17 const}&, std::index_sequence<>) \{\par
11819             {\cf19 return} {\cf17 true};\par
11820         \}\par
11821 \par
11822         {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... MatcherTs, std::size_t N, {\cf17 typename} Arg, std::size_t Idx, std::size_t... Indices>\par
11823         {\cf18 bool} match_all_of(Arg&& arg, std::array<void const*, N> {\cf17 const}& matchers, std::index_sequence<Idx, Indices...>) \{\par
11824             {\cf19 return} {\cf17 static_cast<}T const*{\cf17 >}(matchers[Idx])->match(arg) && match_all_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});\par
11825         \}\par
11826 \par
11827 \par
11828         {\cf17 template}<std::{\cf18 size_t} N, {\cf17 typename} Arg>\par
11829         {\cf18 bool} match_any_of(Arg&&, std::array<void const*, N> {\cf17 const}&, std::index_sequence<>) \{\par
11830             {\cf19 return} {\cf17 false};\par
11831         \}\par
11832 \par
11833         {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... MatcherTs, std::size_t N, {\cf17 typename} Arg, std::size_t Idx, std::size_t... Indices>\par
11834         {\cf18 bool} match_any_of(Arg&& arg, std::array<void const*, N> {\cf17 const}& matchers, std::index_sequence<Idx, Indices...>) \{\par
11835             {\cf19 return} {\cf17 static_cast<}T const*{\cf17 >}(matchers[Idx])->match(arg) || match_any_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});\par
11836         \}\par
11837 \par
11838         std::string describe_multi_matcher(StringRef combine, std::string {\cf17 const}* descriptions_begin, std::string {\cf17 const}* descriptions_end);\par
11839 \par
11840         {\cf17 template}<{\cf17 typename}... MatcherTs, std::size_t... Idx>\par
11841         std::string describe_multi_matcher(StringRef combine, std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...(MatcherTs)> {\cf17 const}& matchers, std::index_sequence<Idx...>) \{\par
11842             std::array<std::string, {\cf17 sizeof}...(MatcherTs)> descriptions \{\{\par
11843                 {\cf17 static_cast<}MatcherTs const*{\cf17 >}(matchers[Idx])->toString()...\par
11844             \}\};\par
11845 \par
11846             {\cf19 return} describe_multi_matcher(combine, descriptions.data(), descriptions.data() + descriptions.size());\par
11847         \}\par
11848 \par
11849 \par
11850         {\cf17 template}<{\cf17 typename}... MatcherTs>\par
11851         {\cf17 class }MatchAllOfGeneric final : {\cf17 public} MatcherGenericBase \{\par
11852         {\cf17 public}:\par
11853             MatchAllOfGeneric(MatchAllOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11854             MatchAllOfGeneric& operator=(MatchAllOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11855             MatchAllOfGeneric(MatchAllOfGeneric&&) = {\cf19 default};\par
11856             MatchAllOfGeneric& operator=(MatchAllOfGeneric&&) = {\cf19 default};\par
11857 \par
11858             MatchAllOfGeneric(MatcherTs {\cf17 const}&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}\par
11859             {\cf17 explicit} MatchAllOfGeneric(std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}\par
11860 \par
11861             {\cf17 template}<{\cf17 typename} Arg>\par
11862             {\cf18 bool} match(Arg&& arg){\cf17  const }\{\par
11863                 {\cf19 return} match_all_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11864             \}\par
11865 \par
11866             std::string describe(){\cf17  const override }\{\par
11867                 {\cf19 return} describe_multi_matcher<MatcherTs...>({\cf22 " and "}_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11868             \}\par
11869 \par
11870             {\cf20 // Has to be public to enable the concatenating operators}\par
11871             {\cf20 // below, because they are not friend of the RHS, only LHS,}\par
11872             {\cf20 // and thus cannot access private fields of RHS}\par
11873             std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...( MatcherTs )> m_matchers;\par
11874 \par
11875 \par
11877             {\cf17 template}<{\cf17 typename}... MatchersRHS>\par
11878             {\cf17 friend}\par
11879             MatchAllOfGeneric<MatcherTs..., MatchersRHS...> operator && (\par
11880                     MatchAllOfGeneric<MatcherTs...>&& lhs,\par
11881                     MatchAllOfGeneric<MatchersRHS...>&& rhs) \{\par
11882                 {\cf19 return} MatchAllOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};\par
11883             \}\par
11884 \par
11886             {\cf17 template}<{\cf17 typename} MatcherRHS>\par
11887             {\cf17 friend} std::enable_if_t<is_matcher<MatcherRHS>::value,\par
11888             MatchAllOfGeneric<MatcherTs..., MatcherRHS>> operator && (\par
11889                     MatchAllOfGeneric<MatcherTs...>&& lhs,\par
11890                     MatcherRHS {\cf17 const}& rhs) \{\par
11891                 {\cf19 return} MatchAllOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), {\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(&rhs))\};\par
11892             \}\par
11893 \par
11895             {\cf17 template}<{\cf17 typename} MatcherLHS>\par
11896             {\cf17 friend} std::enable_if_t<is_matcher<MatcherLHS>::value,\par
11897             MatchAllOfGeneric<MatcherLHS, MatcherTs...>> operator && (\par
11898                     MatcherLHS {\cf17 const}& lhs,\par
11899                     MatchAllOfGeneric<MatcherTs...>&& rhs) \{\par
11900                 {\cf19 return} MatchAllOfGeneric<MatcherLHS, MatcherTs...>\{array_cat({\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};\par
11901             \}\par
11902         \};\par
11903 \par
11904 \par
11905         {\cf17 template}<{\cf17 typename}... MatcherTs>\par
11906         {\cf17 class }MatchAnyOfGeneric final : {\cf17 public} MatcherGenericBase \{\par
11907         {\cf17 public}:\par
11908             MatchAnyOfGeneric(MatchAnyOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11909             MatchAnyOfGeneric& operator=(MatchAnyOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11910             MatchAnyOfGeneric(MatchAnyOfGeneric&&) = {\cf19 default};\par
11911             MatchAnyOfGeneric& operator=(MatchAnyOfGeneric&&) = {\cf19 default};\par
11912 \par
11913             MatchAnyOfGeneric(MatcherTs {\cf17 const}&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}\par
11914             {\cf17 explicit} MatchAnyOfGeneric(std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}\par
11915 \par
11916             {\cf17 template}<{\cf17 typename} Arg>\par
11917             {\cf18 bool} match(Arg&& arg){\cf17  const }\{\par
11918                 {\cf19 return} match_any_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11919             \}\par
11920 \par
11921             std::string describe(){\cf17  const override }\{\par
11922                 {\cf19 return} describe_multi_matcher<MatcherTs...>({\cf22 " or "}_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});\par
11923             \}\par
11924 \par
11925 \par
11926             {\cf20 // Has to be public to enable the concatenating operators}\par
11927             {\cf20 // below, because they are not friend of the RHS, only LHS,}\par
11928             {\cf20 // and thus cannot access private fields of RHS}\par
11929             std::array<{\cf18 void} {\cf17 const}*, {\cf17 sizeof}...( MatcherTs )> m_matchers;\par
11930 \par
11932             {\cf17 template}<{\cf17 typename}... MatchersRHS>\par
11933             {\cf17 friend} MatchAnyOfGeneric<MatcherTs..., MatchersRHS...> operator || (\par
11934                     MatchAnyOfGeneric<MatcherTs...>&& lhs,\par
11935                     MatchAnyOfGeneric<MatchersRHS...>&& rhs) \{\par
11936                 {\cf19 return} MatchAnyOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};\par
11937             \}\par
11938 \par
11940             {\cf17 template}<{\cf17 typename} MatcherRHS>\par
11941             {\cf17 friend} std::enable_if_t<is_matcher<MatcherRHS>::value,\par
11942             MatchAnyOfGeneric<MatcherTs..., MatcherRHS>> operator || (\par
11943                     MatchAnyOfGeneric<MatcherTs...>&& lhs,\par
11944                     MatcherRHS {\cf17 const}& rhs) \{\par
11945                 {\cf19 return} MatchAnyOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), {\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(std::addressof(rhs)))\};\par
11946             \}\par
11947 \par
11949             {\cf17 template}<{\cf17 typename} MatcherLHS>\par
11950             {\cf17 friend} std::enable_if_t<is_matcher<MatcherLHS>::value,\par
11951             MatchAnyOfGeneric<MatcherLHS, MatcherTs...>> operator || (\par
11952                 MatcherLHS {\cf17 const}& lhs,\par
11953                 MatchAnyOfGeneric<MatcherTs...>&& rhs) \{\par
11954                 {\cf19 return} MatchAnyOfGeneric<MatcherLHS, MatcherTs...>\{array_cat({\cf17 static_cast<}{\cf18 void} const*{\cf17 >}(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};\par
11955             \}\par
11956         \};\par
11957 \par
11958 \par
11959         {\cf17 template}<{\cf17 typename} MatcherT>\par
11960         {\cf17 class }MatchNotOfGeneric final : {\cf17 public} MatcherGenericBase \{\par
11961             MatcherT {\cf17 const}& m_matcher;\par
11962 \par
11963         {\cf17 public}:\par
11964             MatchNotOfGeneric(MatchNotOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11965             MatchNotOfGeneric& operator=(MatchNotOfGeneric {\cf17 const}&) = {\cf17 delete};\par
11966             MatchNotOfGeneric(MatchNotOfGeneric&&) = {\cf19 default};\par
11967             MatchNotOfGeneric& operator=(MatchNotOfGeneric&&) = {\cf19 default};\par
11968 \par
11969             {\cf17 explicit} MatchNotOfGeneric(MatcherT {\cf17 const}& matcher) : m_matcher\{matcher\} \{\}\par
11970 \par
11971             {\cf17 template}<{\cf17 typename} Arg>\par
11972             {\cf18 bool} match(Arg&& arg){\cf17  const }\{\par
11973                 {\cf19 return} !m_matcher.match(arg);\par
11974             \}\par
11975 \par
11976             std::string describe(){\cf17  const override }\{\par
11977                 {\cf19 return} {\cf22 "not "} + m_matcher.toString();\par
11978             \}\par
11979 \par
11981             {\cf17 friend} MatcherT {\cf17 const}& operator ! (MatchNotOfGeneric<MatcherT> {\cf17 const}& matcher) \{\par
11982                 {\cf19 return} matcher.m_matcher;\par
11983             \}\par
11984         \};\par
11985     \} {\cf20 // namespace Detail}\par
11986 \par
11987 \par
11988     {\cf20 // compose only generic matchers}\par
11989     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} MatcherRHS>\par
11990     std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherRHS>>\par
11991         operator && (MatcherLHS {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
11992         {\cf19 return} \{ lhs, rhs \};\par
11993     \}\par
11994 \par
11995     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} MatcherRHS>\par
11996     std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherRHS>>\par
11997         operator || (MatcherLHS {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
11998         {\cf19 return} \{ lhs, rhs \};\par
11999     \}\par
12000 \par
12002     {\cf17 template}<{\cf17 typename} MatcherT>\par
12003     std::enable_if_t<Detail::is_generic_matcher<MatcherT>::value, Detail::MatchNotOfGeneric<MatcherT>>\par
12004         operator ! (MatcherT {\cf17 const}& matcher) \{\par
12005         {\cf19 return} Detail::MatchNotOfGeneric<MatcherT>\{matcher\};\par
12006     \}\par
12007 \par
12008 \par
12009     {\cf20 // compose mixed generic and non-generic matchers}\par
12010     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} ArgRHS>\par
12011     std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>\par
12012         operator && (MatcherLHS {\cf17 const}& lhs, MatcherBase<ArgRHS> {\cf17 const}& rhs) \{\par
12013         {\cf19 return} \{ lhs, rhs \};\par
12014     \}\par
12015 \par
12016     {\cf17 template}<{\cf17 typename} ArgLHS, {\cf17 typename} MatcherRHS>\par
12017     std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>\par
12018         operator && (MatcherBase<ArgLHS> {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
12019         {\cf19 return} \{ lhs, rhs \};\par
12020     \}\par
12021 \par
12022     {\cf17 template}<{\cf17 typename} MatcherLHS, {\cf17 typename} ArgRHS>\par
12023     std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>\par
12024         operator || (MatcherLHS {\cf17 const}& lhs, MatcherBase<ArgRHS> {\cf17 const}& rhs) \{\par
12025         {\cf19 return} \{ lhs, rhs \};\par
12026     \}\par
12027 \par
12028     {\cf17 template}<{\cf17 typename} ArgLHS, {\cf17 typename} MatcherRHS>\par
12029     std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>\par
12030         operator || (MatcherBase<ArgLHS> {\cf17 const}& lhs, MatcherRHS {\cf17 const}& rhs) \{\par
12031         {\cf19 return} \{ lhs, rhs \};\par
12032     \}\par
12033 \par
12034 \} {\cf20 // namespace Matchers}\par
12035 \} {\cf20 // namespace Catch}\par
12036 \par
12037 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED}\par
12038 \par
12039 {\cf17 namespace }Catch \{\par
12040     {\cf17 namespace }Matchers \{\par
12041 \par
12042         {\cf17 class }IsEmptyMatcher final : {\cf17 public} MatcherGenericBase \{\par
12043         {\cf17 public}:\par
12044             {\cf17 template} <{\cf17 typename} RangeLike>\par
12045             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12046 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
12047                 {\cf17 using }Catch::Detail::empty;\par
12048 {\cf21 #else}\par
12049                 {\cf17 using }std::empty;\par
12050 {\cf21 #endif}\par
12051                 {\cf19 return} empty(rng);\par
12052             \}\par
12053 \par
12054             std::string describe() {\cf17 const override};\par
12055         \};\par
12056 \par
12057         {\cf17 class }HasSizeMatcher final : {\cf17 public} MatcherGenericBase \{\par
12058             std::size_t m_target_size;\par
12059         {\cf17 public}:\par
12060             {\cf17 explicit} HasSizeMatcher(std::size_t target_size):\par
12061                 m_target_size(target_size)\par
12062             \{\}\par
12063 \par
12064             {\cf17 template} <{\cf17 typename} RangeLike>\par
12065             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12066 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
12067                 {\cf17 using }Catch::Detail::size;\par
12068 {\cf21 #else}\par
12069                 {\cf17 using }std::size;\par
12070 {\cf21 #endif}\par
12071                 {\cf19 return} size(rng) == m_target_size;\par
12072             \}\par
12073 \par
12074             std::string describe() {\cf17 const override};\par
12075         \};\par
12076 \par
12077         {\cf17 template} <{\cf17 typename} Matcher>\par
12078         {\cf17 class }SizeMatchesMatcher final : {\cf17 public} MatcherGenericBase \{\par
12079             Matcher m_matcher;\par
12080         {\cf17 public}:\par
12081             {\cf17 explicit} SizeMatchesMatcher(Matcher m):\par
12082                 m_matcher(CATCH_MOVE(m))\par
12083             \{\}\par
12084 \par
12085             {\cf17 template} <{\cf17 typename} RangeLike>\par
12086             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12087 {\cf21 #if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)}\par
12088                 {\cf17 using }Catch::Detail::size;\par
12089 {\cf21 #else}\par
12090                 {\cf17 using }std::size;\par
12091 {\cf21 #endif}\par
12092                 {\cf19 return} m_matcher.match(size(rng));\par
12093             \}\par
12094 \par
12095             std::string describe(){\cf17  const override }\{\par
12096                 {\cf19 return} {\cf22 "size matches "} + m_matcher.describe();\par
12097             \}\par
12098         \};\par
12099 \par
12100 \par
12102         IsEmptyMatcher IsEmpty();\par
12104         HasSizeMatcher SizeIs(std::size_t sz);\par
12105         {\cf17 template} <{\cf17 typename} Matcher>\par
12106         std::enable_if_t<Detail::is_matcher<Matcher>::value,\par
12107         SizeMatchesMatcher<Matcher>> SizeIs(Matcher&& m) \{\par
12108             {\cf19 return} SizeMatchesMatcher<Matcher>\{CATCH_FORWARD(m)\};\par
12109         \}\par
12110 \par
12111     \} {\cf20 // end namespace Matchers}\par
12112 \} {\cf20 // end namespace Catch}\par
12113 \par
12114 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED}\par
12115 \par
12116 \par
12117 {\cf21 #ifndef CATCH_MATCHERS_CONTAINS_HPP_INCLUDED}\par
12118 {\cf21 #define CATCH_MATCHERS_CONTAINS_HPP_INCLUDED}\par
12119 \par
12120 \par
12121 {\cf21 #include <algorithm>}\par
12122 {\cf21 #include <functional>}\par
12123 \par
12124 {\cf17 namespace }Catch \{\par
12125     {\cf17 namespace }Matchers \{\par
12127         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Equality>\par
12128         {\cf17 class }ContainsElementMatcher final : {\cf17 public} MatcherGenericBase \{\par
12129             T m_desired;\par
12130             Equality m_eq;\par
12131         {\cf17 public}:\par
12132             {\cf17 template} <{\cf17 typename} T2, {\cf17 typename} Equality2>\par
12133             ContainsElementMatcher(T2&& target, Equality2&& predicate):\par
12134                 m_desired(CATCH_FORWARD(target)),\par
12135                 m_eq(CATCH_FORWARD(predicate))\par
12136             \{\}\par
12137 \par
12138             std::string describe(){\cf17  const override }\{\par
12139                 {\cf19 return} {\cf22 "contains element "} + Catch::Detail::stringify(m_desired);\par
12140             \}\par
12141 \par
12142             {\cf17 template} <{\cf17 typename} RangeLike>\par
12143             {\cf18 bool} match( RangeLike&& rng ){\cf17  const }\{\par
12144                 {\cf19 for} ( {\cf17 auto}&& elem : rng ) \{\par
12145                     {\cf19 if} ( m_eq( elem, m_desired ) ) \{ {\cf19 return} {\cf17 true}; \}\par
12146                 \}\par
12147                 {\cf19 return} {\cf17 false};\par
12148             \}\par
12149         \};\par
12150 \par
12152         {\cf17 template} <{\cf17 typename} Matcher>\par
12153         {\cf17 class }ContainsMatcherMatcher final : {\cf17 public} MatcherGenericBase \{\par
12154             Matcher m_matcher;\par
12155         {\cf17 public}:\par
12156             {\cf20 // Note that we do a copy+move to avoid having to SFINAE this}\par
12157             {\cf20 // constructor (and also avoid some perfect forwarding failure}\par
12158             {\cf20 // cases)}\par
12159             ContainsMatcherMatcher(Matcher matcher):\par
12160                 m_matcher(CATCH_MOVE(matcher))\par
12161             \{\}\par
12162 \par
12163             {\cf17 template} <{\cf17 typename} RangeLike>\par
12164             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12165                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12166                     {\cf19 if} (m_matcher.match(elem)) \{\par
12167                         {\cf19 return} {\cf17 true};\par
12168                     \}\par
12169                 \}\par
12170                 {\cf19 return} {\cf17 false};\par
12171             \}\par
12172 \par
12173             std::string describe(){\cf17  const override }\{\par
12174                 {\cf19 return} {\cf22 "contains element matching "} + m_matcher.describe();\par
12175             \}\par
12176         \};\par
12177 \par
12183         {\cf17 template} <{\cf17 typename} T>\par
12184         std::enable_if_t<!Detail::is_matcher<T>::value,\par
12185         ContainsElementMatcher<T, std::equal_to<>>> Contains(T&& elem) \{\par
12186             {\cf19 return} \{ CATCH_FORWARD(elem), std::equal_to<>\{\} \};\par
12187         \}\par
12188 \par
12190         {\cf17 template} <{\cf17 typename} Matcher>\par
12191         std::enable_if_t<Detail::is_matcher<Matcher>::value,\par
12192         ContainsMatcherMatcher<Matcher>> Contains(Matcher&& matcher) \{\par
12193             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12194         \}\par
12195 \par
12201         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Equality>\par
12202         ContainsElementMatcher<T, Equality> Contains(T&& elem, Equality&& eq) \{\par
12203             {\cf19 return} \{ CATCH_FORWARD(elem), CATCH_FORWARD(eq) \};\par
12204         \}\par
12205 \par
12206     \}\par
12207 \}\par
12208 \par
12209 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_CONTAINS_HPP_INCLUDED}\par
12210 \par
12211 \par
12212 {\cf21 #ifndef CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED}\par
12213 {\cf21 #define CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED}\par
12214 \par
12215 \par
12216 {\cf17 namespace }Catch \{\par
12217 {\cf17 namespace }Matchers \{\par
12218 \par
12219 {\cf17 class }ExceptionMessageMatcher final : {\cf17 public} MatcherBase<std::exception> \{\par
12220     std::string m_message;\par
12221 {\cf17 public}:\par
12222 \par
12223     ExceptionMessageMatcher(std::string {\cf17 const}& message):\par
12224         m_message(message)\par
12225     \{\}\par
12226 \par
12227     {\cf18 bool} match(std::exception {\cf17 const}& ex) {\cf17 const override};\par
12228 \par
12229     std::string describe() {\cf17 const override};\par
12230 \};\par
12231 \par
12233 ExceptionMessageMatcher Message(std::string {\cf17 const}& message);\par
12234 \par
12235 {\cf17 template} <{\cf17 typename} StringMatcherType>\par
12236 {\cf17 class }ExceptionMessageMatchesMatcher final\par
12237     : {\cf17 public} MatcherBase<std::exception> \{\par
12238     StringMatcherType m_matcher;\par
12239 \par
12240 {\cf17 public}:\par
12241     ExceptionMessageMatchesMatcher( StringMatcherType matcher ):\par
12242         m_matcher( CATCH_MOVE( matcher ) ) \{\}\par
12243 \par
12244     {\cf18 bool} match( std::exception {\cf17 const}& ex ){\cf17  const override }\{\par
12245         {\cf19 return} m_matcher.match( ex.what() );\par
12246     \}\par
12247 \par
12248     std::string describe(){\cf17  const override }\{\par
12249         {\cf19 return} {\cf22 " matches \\""} + m_matcher.describe() + {\cf23 '"'};\par
12250     \}\par
12251 \};\par
12252 \par
12255 {\cf17 template} <{\cf17 typename} StringMatcherType>\par
12256 ExceptionMessageMatchesMatcher<StringMatcherType>\par
12257 MessageMatches( StringMatcherType&& matcher ) \{\par
12258     {\cf19 return} \{ CATCH_FORWARD( matcher ) \};\par
12259 \}\par
12260 \par
12261 \} {\cf20 // namespace Matchers}\par
12262 \} {\cf20 // namespace Catch}\par
12263 \par
12264 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED}\par
12265 \par
12266 \par
12267 {\cf21 #ifndef CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED}\par
12268 {\cf21 #define CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED}\par
12269 \par
12270 \par
12271 {\cf17 namespace }Catch \{\par
12272 {\cf17 namespace }Matchers \{\par
12273 \par
12274     {\cf17 namespace }Detail \{\par
12275         {\cf17 enum class} FloatingPointKind : uint8_t;\par
12276     \}\par
12277 \par
12278     {\cf17 class  }WithinAbsMatcher final : {\cf17 public} MatcherBase<double> \{\par
12279     {\cf17 public}:\par
12280         WithinAbsMatcher({\cf18 double} target, {\cf18 double} margin);\par
12281         {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
12282         std::string describe() {\cf17 const override};\par
12283     {\cf17 private}:\par
12284         {\cf18 double} m_target;\par
12285         {\cf18 double} m_margin;\par
12286     \};\par
12287 \par
12289     WithinAbsMatcher WithinAbs( {\cf18 double} target, {\cf18 double} margin );\par
12290 \par
12291 \par
12292 \par
12293     {\cf17 class }WithinUlpsMatcher final : {\cf17 public} MatcherBase<double> \{\par
12294     {\cf17 public}:\par
12295         WithinUlpsMatcher( {\cf18 double} target,\par
12296                            uint64_t ulps,\par
12297                            Detail::FloatingPointKind baseType );\par
12298         {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
12299         std::string describe() {\cf17 const override};\par
12300     {\cf17 private}:\par
12301         {\cf18 double} m_target;\par
12302         uint64_t m_ulps;\par
12303         Detail::FloatingPointKind m_type;\par
12304     \};\par
12305 \par
12307     WithinUlpsMatcher WithinULP({\cf18 double} target, uint64_t maxUlpDiff);\par
12309     WithinUlpsMatcher WithinULP({\cf18 float} target, uint64_t maxUlpDiff);\par
12310 \par
12311 \par
12312 \par
12313     {\cf20 // Given IEEE-754 format for floats and doubles, we can assume}\par
12314     {\cf20 // that float -> double promotion is lossless. Given this, we can}\par
12315     {\cf20 // assume that if we do the standard relative comparison of}\par
12316     {\cf20 // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get}\par
12317     {\cf20 // the same result if we do this for floats, as if we do this for}\par
12318     {\cf20 // doubles that were promoted from floats.}\par
12319     {\cf17 class }WithinRelMatcher final : {\cf17 public} MatcherBase<double> \{\par
12320     {\cf17 public}:\par
12321         WithinRelMatcher( {\cf18 double} target, {\cf18 double} epsilon );\par
12322         {\cf18 bool} match({\cf18 double} {\cf17 const}& matchee) {\cf17 const override};\par
12323         std::string describe() {\cf17 const override};\par
12324     {\cf17 private}:\par
12325         {\cf18 double} m_target;\par
12326         {\cf18 double} m_epsilon;\par
12327     \};\par
12328 \par
12330     WithinRelMatcher WithinRel({\cf18 double} target, {\cf18 double} eps);\par
12332     WithinRelMatcher WithinRel({\cf18 double} target);\par
12334     WithinRelMatcher WithinRel({\cf18 float} target, {\cf18 float} eps);\par
12336     WithinRelMatcher WithinRel({\cf18 float} target);\par
12337 \par
12338 \par
12339 \par
12340     {\cf17 class }IsNaNMatcher final : {\cf17 public} MatcherBase<double> \{\par
12341     {\cf17 public}:\par
12342         IsNaNMatcher() = {\cf19 default};\par
12343         {\cf18 bool} match( {\cf18 double} {\cf17 const}& matchee ) {\cf17 const override};\par
12344         std::string describe() {\cf17 const override};\par
12345     \};\par
12346 \par
12347     IsNaNMatcher IsNaN();\par
12348 \par
12349 \} {\cf20 // namespace Matchers}\par
12350 \} {\cf20 // namespace Catch}\par
12351 \par
12352 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED}\par
12353 \par
12354 \par
12355 {\cf21 #ifndef CATCH_MATCHERS_PREDICATE_HPP_INCLUDED}\par
12356 {\cf21 #define CATCH_MATCHERS_PREDICATE_HPP_INCLUDED}\par
12357 \par
12358 \par
12359 {\cf21 #include <string>}\par
12360 \par
12361 {\cf17 namespace }Catch \{\par
12362 {\cf17 namespace }Matchers \{\par
12363 \par
12364 {\cf17 namespace }Detail \{\par
12365     std::string finalizeDescription({\cf17 const} std::string& desc);\par
12366 \} {\cf20 // namespace Detail}\par
12367 \par
12368 {\cf17 template} <{\cf17 typename} T, {\cf17 typename} Predicate>\par
12369 {\cf17 class }PredicateMatcher final : {\cf17 public} MatcherBase<T> \{\par
12370     Predicate m_predicate;\par
12371     std::string m_description;\par
12372 {\cf17 public}:\par
12373 \par
12374     PredicateMatcher(Predicate&& elem, std::string {\cf17 const}& descr)\par
12375         :m_predicate(CATCH_FORWARD(elem)),\par
12376         m_description(Detail::finalizeDescription(descr))\par
12377     \{\}\par
12378 \par
12379     {\cf18 bool} match( T {\cf17 const}& item ){\cf17  const override }\{\par
12380         {\cf19 return} m_predicate(item);\par
12381     \}\par
12382 \par
12383     std::string describe(){\cf17  const override }\{\par
12384         {\cf19 return} m_description;\par
12385     \}\par
12386 \};\par
12387 \par
12393     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Pred>\par
12394     PredicateMatcher<T, Pred> Predicate(Pred&& predicate, std::string {\cf17 const}& description = {\cf22 ""}) \{\par
12395         {\cf17 static_assert}(is_callable<Pred(T)>::value, {\cf22 "Predicate not callable with argument T"});\par
12396         {\cf17 static_assert}(std::is_same<bool, FunctionReturnType<Pred, T>>::value, {\cf22 "Predicate does not return bool"});\par
12397         {\cf19 return} PredicateMatcher<T, Pred>(CATCH_FORWARD(predicate), description);\par
12398     \}\par
12399 \par
12400 \} {\cf20 // namespace Matchers}\par
12401 \} {\cf20 // namespace Catch}\par
12402 \par
12403 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_PREDICATE_HPP_INCLUDED}\par
12404 \par
12405 \par
12406 {\cf21 #ifndef CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED}\par
12407 {\cf21 #define CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED}\par
12408 \par
12409 \par
12410 {\cf17 namespace }Catch \{\par
12411     {\cf17 namespace }Matchers \{\par
12412         {\cf20 // Matcher for checking that all elements in range matches a given matcher.}\par
12413         {\cf17 template} <{\cf17 typename} Matcher>\par
12414         {\cf17 class }AllMatchMatcher final : {\cf17 public} MatcherGenericBase \{\par
12415             Matcher m_matcher;\par
12416         {\cf17 public}:\par
12417             AllMatchMatcher(Matcher matcher):\par
12418                 m_matcher(CATCH_MOVE(matcher))\par
12419             \{\}\par
12420 \par
12421             std::string describe(){\cf17  const override }\{\par
12422                 {\cf19 return} {\cf22 "all match "} + m_matcher.describe();\par
12423             \}\par
12424 \par
12425             {\cf17 template} <{\cf17 typename} RangeLike>\par
12426             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12427                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12428                     {\cf19 if} (!m_matcher.match(elem)) \{\par
12429                         {\cf19 return} {\cf17 false};\par
12430                     \}\par
12431                 \}\par
12432                 {\cf19 return} {\cf17 true};\par
12433             \}\par
12434         \};\par
12435 \par
12436         {\cf20 // Matcher for checking that no element in range matches a given matcher.}\par
12437         {\cf17 template} <{\cf17 typename} Matcher>\par
12438         {\cf17 class }NoneMatchMatcher final : {\cf17 public} MatcherGenericBase \{\par
12439             Matcher m_matcher;\par
12440         {\cf17 public}:\par
12441             NoneMatchMatcher(Matcher matcher):\par
12442                 m_matcher(CATCH_MOVE(matcher))\par
12443             \{\}\par
12444 \par
12445             std::string describe(){\cf17  const override }\{\par
12446                 {\cf19 return} {\cf22 "none match "} + m_matcher.describe();\par
12447             \}\par
12448 \par
12449             {\cf17 template} <{\cf17 typename} RangeLike>\par
12450             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12451                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12452                     {\cf19 if} (m_matcher.match(elem)) \{\par
12453                         {\cf19 return} {\cf17 false};\par
12454                     \}\par
12455                 \}\par
12456                 {\cf19 return} {\cf17 true};\par
12457             \}\par
12458         \};\par
12459 \par
12460         {\cf20 // Matcher for checking that at least one element in range matches a given matcher.}\par
12461         {\cf17 template} <{\cf17 typename} Matcher>\par
12462         {\cf17 class }AnyMatchMatcher final : {\cf17 public} MatcherGenericBase \{\par
12463             Matcher m_matcher;\par
12464         {\cf17 public}:\par
12465             AnyMatchMatcher(Matcher matcher):\par
12466                 m_matcher(CATCH_MOVE(matcher))\par
12467             \{\}\par
12468 \par
12469             std::string describe(){\cf17  const override }\{\par
12470                 {\cf19 return} {\cf22 "any match "} + m_matcher.describe();\par
12471             \}\par
12472 \par
12473             {\cf17 template} <{\cf17 typename} RangeLike>\par
12474             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12475                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12476                     {\cf19 if} (m_matcher.match(elem)) \{\par
12477                         {\cf19 return} {\cf17 true};\par
12478                     \}\par
12479                 \}\par
12480                 {\cf19 return} {\cf17 false};\par
12481             \}\par
12482         \};\par
12483 \par
12484         {\cf20 // Matcher for checking that all elements in range are true.}\par
12485         {\cf17 class }AllTrueMatcher final : {\cf17 public} MatcherGenericBase \{\par
12486         {\cf17 public}:\par
12487             std::string describe() {\cf17 const override};\par
12488 \par
12489             {\cf17 template} <{\cf17 typename} RangeLike>\par
12490             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12491                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12492                     {\cf19 if} (!elem) \{\par
12493                         {\cf19 return} {\cf17 false};\par
12494                     \}\par
12495                 \}\par
12496                 {\cf19 return} {\cf17 true};\par
12497             \}\par
12498         \};\par
12499 \par
12500         {\cf20 // Matcher for checking that no element in range is true.}\par
12501         {\cf17 class }NoneTrueMatcher final : {\cf17 public} MatcherGenericBase \{\par
12502         {\cf17 public}:\par
12503             std::string describe() {\cf17 const override};\par
12504 \par
12505             {\cf17 template} <{\cf17 typename} RangeLike>\par
12506             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12507                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12508                     {\cf19 if} (elem) \{\par
12509                         {\cf19 return} {\cf17 false};\par
12510                     \}\par
12511                 \}\par
12512                 {\cf19 return} {\cf17 true};\par
12513             \}\par
12514         \};\par
12515 \par
12516         {\cf20 // Matcher for checking that any element in range is true.}\par
12517         {\cf17 class }AnyTrueMatcher final : {\cf17 public} MatcherGenericBase \{\par
12518         {\cf17 public}:\par
12519             std::string describe() {\cf17 const override};\par
12520 \par
12521             {\cf17 template} <{\cf17 typename} RangeLike>\par
12522             {\cf18 bool} match(RangeLike&& rng){\cf17  const }\{\par
12523                 {\cf19 for} ({\cf17 auto}&& elem : rng) \{\par
12524                     {\cf19 if} (elem) \{\par
12525                         {\cf19 return} {\cf17 true};\par
12526                     \}\par
12527                 \}\par
12528                 {\cf19 return} {\cf17 false};\par
12529             \}\par
12530         \};\par
12531 \par
12532         {\cf20 // Creates a matcher that checks whether all elements in a range match a matcher}\par
12533         {\cf17 template} <{\cf17 typename} Matcher>\par
12534         AllMatchMatcher<Matcher> AllMatch(Matcher&& matcher) \{\par
12535             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12536         \}\par
12537 \par
12538         {\cf20 // Creates a matcher that checks whether no element in a range matches a matcher.}\par
12539         {\cf17 template} <{\cf17 typename} Matcher>\par
12540         NoneMatchMatcher<Matcher> NoneMatch(Matcher&& matcher) \{\par
12541             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12542         \}\par
12543 \par
12544         {\cf20 // Creates a matcher that checks whether any element in a range matches a matcher.}\par
12545         {\cf17 template} <{\cf17 typename} Matcher>\par
12546         AnyMatchMatcher<Matcher> AnyMatch(Matcher&& matcher) \{\par
12547             {\cf19 return} \{ CATCH_FORWARD(matcher) \};\par
12548         \}\par
12549 \par
12550         {\cf20 // Creates a matcher that checks whether all elements in a range are true}\par
12551         AllTrueMatcher AllTrue();\par
12552 \par
12553         {\cf20 // Creates a matcher that checks whether no element in a range is true}\par
12554         NoneTrueMatcher NoneTrue();\par
12555 \par
12556         {\cf20 // Creates a matcher that checks whether any element in a range is true}\par
12557         AnyTrueMatcher AnyTrue();\par
12558     \}\par
12559 \}\par
12560 \par
12561 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED}\par
12562 \par
12563 \par
12564 {\cf21 #ifndef CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED}\par
12565 {\cf21 #define CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED}\par
12566 \par
12567 \par
12568 {\cf21 #include <algorithm>}\par
12569 {\cf21 #include <utility>}\par
12570 \par
12571 {\cf17 namespace }Catch \{\par
12572     {\cf17 namespace }Matchers \{\par
12573 \par
12578         {\cf17 template} <{\cf17 typename} TargetRangeLike, {\cf17 typename} Equality>\par
12579         {\cf17 class }RangeEqualsMatcher final : {\cf17 public} MatcherGenericBase \{\par
12580             TargetRangeLike m_desired;\par
12581             Equality m_predicate;\par
12582 \par
12583         {\cf17 public}:\par
12584             {\cf17 template} <{\cf17 typename} TargetRangeLike2, {\cf17 typename} Equality2>\par
12585             RangeEqualsMatcher( TargetRangeLike2&& range,\par
12586                                 Equality2&& predicate ):\par
12587                 m_desired( CATCH_FORWARD( range ) ),\par
12588                 m_predicate( CATCH_FORWARD( predicate ) ) \{\}\par
12589 \par
12590             {\cf17 template} <{\cf17 typename} RangeLike>\par
12591             {\cf18 bool} match( RangeLike&& rng ){\cf17  const }\{\par
12592                 {\cf17 auto} rng_start = begin( rng );\par
12593                 {\cf17 const} {\cf17 auto} rng_end = end( rng );\par
12594                 {\cf17 auto} target_start = begin( m_desired );\par
12595                 {\cf17 const} {\cf17 auto} target_end = end( m_desired );\par
12596 \par
12597                 {\cf19 while} (rng_start != rng_end && target_start != target_end) \{\par
12598                     {\cf19 if} (!m_predicate(*rng_start, *target_start)) \{\par
12599                         {\cf19 return} {\cf17 false};\par
12600                     \}\par
12601                     ++rng_start;\par
12602                     ++target_start;\par
12603                 \}\par
12604                 {\cf19 return} rng_start == rng_end && target_start == target_end;\par
12605             \}\par
12606 \par
12607             std::string describe(){\cf17  const override }\{\par
12608                 {\cf19 return} {\cf22 "elements are "} + Catch::Detail::stringify( m_desired );\par
12609             \}\par
12610         \};\par
12611 \par
12616         {\cf17 template} <{\cf17 typename} TargetRangeLike, {\cf17 typename} Equality>\par
12617         {\cf17 class }UnorderedRangeEqualsMatcher final : {\cf17 public} MatcherGenericBase \{\par
12618             TargetRangeLike m_desired;\par
12619             Equality m_predicate;\par
12620 \par
12621         {\cf17 public}:\par
12622             {\cf17 template} <{\cf17 typename} TargetRangeLike2, {\cf17 typename} Equality2>\par
12623             UnorderedRangeEqualsMatcher( TargetRangeLike2&& range,\par
12624                                          Equality2&& predicate ):\par
12625                 m_desired( CATCH_FORWARD( range ) ),\par
12626                 m_predicate( CATCH_FORWARD( predicate ) ) \{\}\par
12627 \par
12628             {\cf17 template} <{\cf17 typename} RangeLike>\par
12629             {\cf18 bool} match( RangeLike&& rng ){\cf17  const }\{\par
12630                 {\cf17 using }std::begin;\par
12631                 {\cf17 using }std::end;\par
12632                 {\cf19 return} Catch::Detail::is_permutation( begin( m_desired ),\par
12633                                                       end( m_desired ),\par
12634                                                       begin( rng ),\par
12635                                                       end( rng ),\par
12636                                                       m_predicate );\par
12637             \}\par
12638 \par
12639             std::string describe(){\cf17  const override }\{\par
12640                 {\cf19 return} {\cf22 "unordered elements are "} +\par
12641                        ::Catch::Detail::stringify( m_desired );\par
12642             \}\par
12643         \};\par
12644 \par
12651         {\cf17 template} <{\cf17 typename} RangeLike>\par
12652         std::enable_if_t<!Detail::is_matcher<RangeLike>::value,\par
12653                          RangeEqualsMatcher<RangeLike, std::equal_to<>>>\par
12654         RangeEquals( RangeLike&& range ) \{\par
12655             {\cf19 return} \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};\par
12656         \}\par
12657 \par
12664         {\cf17 template} <{\cf17 typename} RangeLike, {\cf17 typename} Equality>\par
12665         RangeEqualsMatcher<RangeLike, Equality>\par
12666         RangeEquals( RangeLike&& range, Equality&& predicate ) \{\par
12667             {\cf19 return} \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};\par
12668         \}\par
12669 \par
12676         {\cf17 template} <{\cf17 typename} RangeLike>\par
12677         std::enable_if_t<\par
12678             !Detail::is_matcher<RangeLike>::value,\par
12679             UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>\par
12680         UnorderedRangeEquals( RangeLike&& range ) \{\par
12681             {\cf19 return} \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};\par
12682         \}\par
12683 \par
12690         {\cf17 template} <{\cf17 typename} RangeLike, {\cf17 typename} Equality>\par
12691         UnorderedRangeEqualsMatcher<RangeLike, Equality>\par
12692         UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) \{\par
12693             {\cf19 return} \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};\par
12694         \}\par
12695     \} {\cf20 // namespace Matchers}\par
12696 \} {\cf20 // namespace Catch}\par
12697 \par
12698 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED}\par
12699 \par
12700 \par
12701 {\cf21 #ifndef CATCH_MATCHERS_STRING_HPP_INCLUDED}\par
12702 {\cf21 #define CATCH_MATCHERS_STRING_HPP_INCLUDED}\par
12703 \par
12704 \par
12705 {\cf21 #include <string>}\par
12706 \par
12707 {\cf17 namespace }Catch \{\par
12708 {\cf17 namespace }Matchers \{\par
12709 \par
12710     {\cf17 struct }CasedString \{\par
12711         CasedString( std::string {\cf17 const}& str, CaseSensitive caseSensitivity );\par
12712         std::string adjustString( std::string {\cf17 const}& str ) {\cf17 const};\par
12713         StringRef caseSensitivitySuffix() {\cf17 const};\par
12714 \par
12715         CaseSensitive m_caseSensitivity;\par
12716         std::string m_str;\par
12717     \};\par
12718 \par
12719     {\cf17 class }StringMatcherBase : {\cf17 public} MatcherBase<std::string> \{\par
12720     {\cf17 protected}:\par
12721         CasedString m_comparator;\par
12722         StringRef m_operation;\par
12723 \par
12724     {\cf17 public}:\par
12725         StringMatcherBase( StringRef operation,\par
12726                            CasedString {\cf17 const}& comparator );\par
12727         std::string describe() {\cf17 const override};\par
12728     \};\par
12729 \par
12730     {\cf17 class }StringEqualsMatcher final : {\cf17 public} StringMatcherBase \{\par
12731     {\cf17 public}:\par
12732         StringEqualsMatcher( CasedString {\cf17 const}& comparator );\par
12733         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12734     \};\par
12735     {\cf17 class }StringContainsMatcher final : {\cf17 public} StringMatcherBase \{\par
12736     {\cf17 public}:\par
12737         StringContainsMatcher( CasedString {\cf17 const}& comparator );\par
12738         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12739     \};\par
12740     {\cf17 class }StartsWithMatcher final : {\cf17 public} StringMatcherBase \{\par
12741     {\cf17 public}:\par
12742         StartsWithMatcher( CasedString {\cf17 const}& comparator );\par
12743         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12744     \};\par
12745     {\cf17 class }EndsWithMatcher final : {\cf17 public} StringMatcherBase \{\par
12746     {\cf17 public}:\par
12747         EndsWithMatcher( CasedString {\cf17 const}& comparator );\par
12748         {\cf18 bool} match( std::string {\cf17 const}& source ) {\cf17 const override};\par
12749     \};\par
12750 \par
12751     {\cf17 class }RegexMatcher final : {\cf17 public} MatcherBase<std::string> \{\par
12752         std::string m_regex;\par
12753         CaseSensitive m_caseSensitivity;\par
12754 \par
12755     {\cf17 public}:\par
12756         RegexMatcher( std::string regex, CaseSensitive caseSensitivity );\par
12757         {\cf18 bool} match( std::string {\cf17 const}& matchee ) {\cf17 const override};\par
12758         std::string describe() {\cf17 const override};\par
12759     \};\par
12760 \par
12762     StringEqualsMatcher Equals( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12764     StringContainsMatcher ContainsSubstring( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12766     EndsWithMatcher EndsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12768     StartsWithMatcher StartsWith( std::string {\cf17 const}& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12770     RegexMatcher Matches( std::string {\cf17 const}& regex, CaseSensitive caseSensitivity = CaseSensitive::Yes );\par
12771 \par
12772 \} {\cf20 // namespace Matchers}\par
12773 \} {\cf20 // namespace Catch}\par
12774 \par
12775 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_STRING_HPP_INCLUDED}\par
12776 \par
12777 \par
12778 {\cf21 #ifndef CATCH_MATCHERS_VECTOR_HPP_INCLUDED}\par
12779 {\cf21 #define CATCH_MATCHERS_VECTOR_HPP_INCLUDED}\par
12780 \par
12781 \par
12782 {\cf21 #include <algorithm>}\par
12783 \par
12784 {\cf17 namespace }Catch \{\par
12785 {\cf17 namespace }Matchers \{\par
12786 \par
12787     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Alloc>\par
12788     {\cf17 class }VectorContainsElementMatcher final : {\cf17 public} MatcherBase<std::vector<T, Alloc>> \{\par
12789         T {\cf17 const}& m_comparator;\par
12790 \par
12791     {\cf17 public}:\par
12792         VectorContainsElementMatcher(T {\cf17 const}& comparator):\par
12793             m_comparator(comparator)\par
12794         \{\}\par
12795 \par
12796         {\cf18 bool} match(std::vector<T, Alloc> {\cf17 const}& v){\cf17  const override }\{\par
12797             {\cf19 for} ({\cf17 auto} {\cf17 const}& el : v) \{\par
12798                 {\cf19 if} (el == m_comparator) \{\par
12799                     {\cf19 return} {\cf17 true};\par
12800                 \}\par
12801             \}\par
12802             {\cf19 return} {\cf17 false};\par
12803         \}\par
12804 \par
12805         std::string describe(){\cf17  const override }\{\par
12806             {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
12807         \}\par
12808     \};\par
12809 \par
12810     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12811     {\cf17 class }ContainsMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12812         std::vector<T, AllocComp> {\cf17 const}& m_comparator;\par
12813 \par
12814     {\cf17 public}:\par
12815         ContainsMatcher(std::vector<T, AllocComp> {\cf17 const}& comparator):\par
12816             m_comparator( comparator )\par
12817         \{\}\par
12818 \par
12819         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& v){\cf17  const override }\{\par
12820             {\cf20 // !TBD: see note in EqualsMatcher}\par
12821             {\cf19 if} (m_comparator.size() > v.size())\par
12822                 {\cf19 return} {\cf17 false};\par
12823             {\cf19 for} ({\cf17 auto} {\cf17 const}& comparator : m_comparator) \{\par
12824                 {\cf17 auto} present = {\cf17 false};\par
12825                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : v) \{\par
12826                     {\cf19 if} (el == comparator) \{\par
12827                         present = {\cf17 true};\par
12828                         {\cf19 break};\par
12829                     \}\par
12830                 \}\par
12831                 {\cf19 if} (!present) \{\par
12832                     {\cf19 return} {\cf17 false};\par
12833                 \}\par
12834             \}\par
12835             {\cf19 return} {\cf17 true};\par
12836         \}\par
12837         std::string describe(){\cf17  const override }\{\par
12838             {\cf19 return} {\cf22 "Contains: "} + ::Catch::Detail::stringify( m_comparator );\par
12839         \}\par
12840     \};\par
12841 \par
12842     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12843     {\cf17 class }EqualsMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12844         std::vector<T, AllocComp> {\cf17 const}& m_comparator;\par
12845 \par
12846     {\cf17 public}:\par
12847         EqualsMatcher(std::vector<T, AllocComp> {\cf17 const}& comparator):\par
12848             m_comparator( comparator )\par
12849         \{\}\par
12850 \par
12851         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& v){\cf17  const override }\{\par
12852             {\cf20 // !TBD: This currently works if all elements can be compared using !=}\par
12853             {\cf20 // - a more general approach would be via a compare template that defaults}\par
12854             {\cf20 // to using !=. but could be specialised for, e.g. std::vector<T> etc}\par
12855             {\cf20 // - then just call that directly}\par
12856             {\cf19 if} ( m_comparator.size() != v.size() ) \{ {\cf19 return} {\cf17 false}; \}\par
12857             {\cf19 for} ( std::size_t i = 0; i < v.size(); ++i ) \{\par
12858                 {\cf19 if} ( !( m_comparator[i] == v[i] ) ) \{ {\cf19 return} {\cf17 false}; \}\par
12859             \}\par
12860             {\cf19 return} {\cf17 true};\par
12861         \}\par
12862         std::string describe(){\cf17  const override }\{\par
12863             {\cf19 return} {\cf22 "Equals: "} + ::Catch::Detail::stringify( m_comparator );\par
12864         \}\par
12865     \};\par
12866 \par
12867     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12868     {\cf17 class }ApproxMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12869         std::vector<T, AllocComp> {\cf17 const}& m_comparator;\par
12870         {\cf17 mutable} Catch::Approx approx = Catch::Approx::custom();\par
12871 \par
12872     {\cf17 public}:\par
12873         ApproxMatcher(std::vector<T, AllocComp> {\cf17 const}& comparator):\par
12874             m_comparator( comparator )\par
12875         \{\}\par
12876 \par
12877         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& v){\cf17  const override }\{\par
12878             {\cf19 if} (m_comparator.size() != v.size())\par
12879                 {\cf19 return} {\cf17 false};\par
12880             {\cf19 for} (std::size_t i = 0; i < v.size(); ++i)\par
12881                 {\cf19 if} (m_comparator[i] != approx(v[i]))\par
12882                     {\cf19 return} {\cf17 false};\par
12883             {\cf19 return} {\cf17 true};\par
12884         \}\par
12885         std::string describe(){\cf17  const override }\{\par
12886             {\cf19 return} {\cf22 "is approx: "} + ::Catch::Detail::stringify( m_comparator );\par
12887         \}\par
12888         template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
12889         ApproxMatcher& epsilon( T {\cf17 const}& newEpsilon ) \{\par
12890             approx.epsilon({\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon));\par
12891             {\cf19 return} *{\cf17 this};\par
12892         \}\par
12893         template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
12894         ApproxMatcher& margin( T {\cf17 const}& newMargin ) \{\par
12895             approx.margin({\cf17 static_cast<}{\cf18 double}{\cf17 >}(newMargin));\par
12896             {\cf19 return} *{\cf17 this};\par
12897         \}\par
12898         template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>\par
12899         ApproxMatcher& scale( T {\cf17 const}& newScale ) \{\par
12900             approx.scale({\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale));\par
12901             {\cf19 return} *{\cf17 this};\par
12902         \}\par
12903     \};\par
12904 \par
12905     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp, {\cf17 typename} AllocMatch>\par
12906     {\cf17 class }UnorderedEqualsMatcher final : {\cf17 public} MatcherBase<std::vector<T, AllocMatch>> \{\par
12907         std::vector<T, AllocComp> {\cf17 const}& m_target;\par
12908 \par
12909     {\cf17 public}:\par
12910         UnorderedEqualsMatcher(std::vector<T, AllocComp> {\cf17 const}& target):\par
12911             m_target(target)\par
12912         \{\}\par
12913         {\cf18 bool} match(std::vector<T, AllocMatch> {\cf17 const}& vec){\cf17  const override }\{\par
12914             {\cf19 if} (m_target.size() != vec.size()) \{\par
12915                 {\cf19 return} {\cf17 false};\par
12916             \}\par
12917             {\cf19 return} std::is_permutation(m_target.begin(), m_target.end(), vec.begin());\par
12918         \}\par
12919 \par
12920         std::string describe(){\cf17  const override }\{\par
12921             {\cf19 return} {\cf22 "UnorderedEquals: "} + ::Catch::Detail::stringify(m_target);\par
12922         \}\par
12923     \};\par
12924 \par
12925 \par
12926     {\cf20 // The following functions create the actual matcher objects.}\par
12927     {\cf20 // This allows the types to be inferred}\par
12928 \par
12930     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12931     ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> {\cf17 const}& comparator ) \{\par
12932         {\cf19 return} ContainsMatcher<T, AllocComp, AllocMatch>(comparator);\par
12933     \}\par
12934 \par
12936     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Alloc = std::allocator<T>>\par
12937     VectorContainsElementMatcher<T, Alloc> VectorContains( T {\cf17 const}& comparator ) \{\par
12938         {\cf19 return} VectorContainsElementMatcher<T, Alloc>(comparator);\par
12939     \}\par
12940 \par
12942     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12943     EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> {\cf17 const}& comparator ) \{\par
12944         {\cf19 return} EqualsMatcher<T, AllocComp, AllocMatch>(comparator);\par
12945     \}\par
12946 \par
12948     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12949     ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> {\cf17 const}& comparator ) \{\par
12950         {\cf19 return} ApproxMatcher<T, AllocComp, AllocMatch>(comparator);\par
12951     \}\par
12952 \par
12954     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} AllocComp = std::allocator<T>, {\cf17 typename} AllocMatch = AllocComp>\par
12955     UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> {\cf17 const}& target) \{\par
12956         {\cf19 return} UnorderedEqualsMatcher<T, AllocComp, AllocMatch>(target);\par
12957     \}\par
12958 \par
12959 \} {\cf20 // namespace Matchers}\par
12960 \} {\cf20 // namespace Catch}\par
12961 \par
12962 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_VECTOR_HPP_INCLUDED}\par
12963 \par
12964 {\cf21 #endif }{\cf20 // CATCH_MATCHERS_ALL_HPP_INCLUDED}\par
12965 \par
12966 \par
12980 {\cf21 #ifndef CATCH_REPORTERS_ALL_HPP_INCLUDED}\par
12981 {\cf21 #define CATCH_REPORTERS_ALL_HPP_INCLUDED}\par
12982 \par
12983 \par
12984 \par
12985 {\cf21 #ifndef CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED}\par
12986 {\cf21 #define CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED}\par
12987 \par
12988 \par
12989 \par
12990 {\cf21 #ifndef CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED}\par
12991 {\cf21 #define CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED}\par
12992 \par
12993 \par
12994 \par
12995 {\cf21 #ifndef CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED}\par
12996 {\cf21 #define CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED}\par
12997 \par
12998 \par
12999 {\cf21 #include <map>}\par
13000 {\cf21 #include <string>}\par
13001 \par
13002 {\cf17 namespace }Catch \{\par
13003     {\cf17 class }ColourImpl;\par
13004 \par
13015     {\cf17 class }ReporterBase : {\cf17 public} IEventListener \{\par
13016     {\cf17 protected}:\par
13018         Detail::unique_ptr<IStream> m_wrapped_stream;\par
13021         std::ostream& m_stream;\par
13023         Detail::unique_ptr<ColourImpl> m_colour;\par
13025         std::map<std::string, std::string> m_customOptions;\par
13026 \par
13027     {\cf17 public}:\par
13028         ReporterBase( ReporterConfig&& config );\par
13029         ~ReporterBase() {\cf17 override}; {\cf20 // = default;}\par
13030 \par
13037         {\cf18 void} listReporters(\par
13038             std::vector<ReporterDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13045         {\cf18 void} listListeners(\par
13046             std::vector<ListenerDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13054         {\cf18 void} listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) {\cf17 override};\par
13061         {\cf18 void} listTags( std::vector<TagInfo> {\cf17 const}& tags ) {\cf17 override};\par
13062     \};\par
13063 \} {\cf20 // namespace Catch}\par
13064 \par
13065 {\cf21 #endif }{\cf20 // CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED}\par
13066 \par
13067 {\cf21 #include <vector>}\par
13068 \par
13069 {\cf17 namespace }Catch \{\par
13070 \par
13071     {\cf17 class }StreamingReporterBase : {\cf17 public} ReporterBase \{\par
13072     {\cf17 public}:\par
13073         {\cf20 // GCC5 compat: we cannot use inherited constructor, because it}\par
13074         {\cf20 //              doesn't implement backport of P0136}\par
13075         StreamingReporterBase(ReporterConfig&& _config):\par
13076             ReporterBase(CATCH_MOVE(_config))\par
13077         \{\}\par
13078         ~StreamingReporterBase() {\cf17 override};\par
13079 \par
13080         {\cf18 void} benchmarkPreparing( StringRef ){\cf17  override }\{\}\par
13081         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& ){\cf17  override }\{\}\par
13082         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& ){\cf17  override }\{\}\par
13083         {\cf18 void} benchmarkFailed( StringRef ){\cf17  override }\{\}\par
13084 \par
13085         {\cf18 void} fatalErrorEncountered( StringRef {\cf20 /*error*/} ){\cf17  override }\{\}\par
13086         {\cf18 void} noMatchingTestCases( StringRef {\cf20 /*unmatchedSpec*/} ){\cf17  override }\{\}\par
13087         {\cf18 void} reportInvalidTestSpec( StringRef {\cf20 /*invalidArgument*/} ){\cf17  override }\{\}\par
13088 \par
13089         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& _testRunInfo ) {\cf17 override};\par
13090 \par
13091         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& _testInfo){\cf17  override  }\{\par
13092             currentTestCaseInfo = &_testInfo;\par
13093         \}\par
13094         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13095         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& _sectionInfo){\cf17  override }\{\par
13096             m_sectionStack.push_back(_sectionInfo);\par
13097         \}\par
13098 \par
13099         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& ){\cf17  override }\{\}\par
13100         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& ){\cf17  override }\{\}\par
13101 \par
13102         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& {\cf20 /* _sectionStats */}){\cf17  override }\{\par
13103             m_sectionStack.pop_back();\par
13104         \}\par
13105         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13106         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& {\cf20 /* _testCaseStats */}){\cf17  override }\{\par
13107             currentTestCaseInfo = {\cf17 nullptr};\par
13108         \}\par
13109         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& {\cf20 /* _testRunStats */} ) {\cf17 override};\par
13110 \par
13111         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}&){\cf17  override }\{\par
13112             {\cf20 // Don't do anything with this by default.}\par
13113             {\cf20 // It can optionally be overridden in the derived class.}\par
13114         \}\par
13115 \par
13116     {\cf17 protected}:\par
13117         TestRunInfo currentTestRunInfo\{ {\cf22 "test run has not started yet"}_sr \};\par
13118         TestCaseInfo {\cf17 const}* currentTestCaseInfo = {\cf17 nullptr};\par
13119 \par
13121         std::vector<SectionInfo> m_sectionStack;\par
13122     \};\par
13123 \par
13124 \} {\cf20 // end namespace Catch}\par
13125 \par
13126 {\cf21 #endif }{\cf20 // CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED}\par
13127 \par
13128 {\cf21 #include <string>}\par
13129 \par
13130 {\cf17 namespace }Catch \{\par
13131 \par
13132     {\cf17 class }AutomakeReporter final : {\cf17 public} StreamingReporterBase \{\par
13133     {\cf17 public}:\par
13134         {\cf20 // GCC5 compat: we cannot use inherited constructor, because it}\par
13135         {\cf20 //              doesn't implement backport of P0136}\par
13136         AutomakeReporter(ReporterConfig&& _config):\par
13137             StreamingReporterBase(CATCH_MOVE(_config))\par
13138         \{\}\par
13139         ~AutomakeReporter() {\cf17 override};\par
13140 \par
13141         {\cf17 static} std::string getDescription() \{\par
13142             {\cf17 using namespace }std::string_literals;\par
13143             {\cf19 return} {\cf22 "Reports test results in the format of Automake .trs files"}s;\par
13144         \}\par
13145 \par
13146         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) {\cf17 override};\par
13147         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}& testInfo) {\cf17 override};\par
13148     \};\par
13149 \par
13150 \} {\cf20 // end namespace Catch}\par
13151 \par
13152 {\cf21 #endif }{\cf20 // CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED}\par
13153 \par
13154 \par
13155 {\cf21 #ifndef CATCH_REPORTER_COMPACT_HPP_INCLUDED}\par
13156 {\cf21 #define CATCH_REPORTER_COMPACT_HPP_INCLUDED}\par
13157 \par
13158 \par
13159 \par
13160 \par
13161 {\cf17 namespace }Catch \{\par
13162 \par
13163     {\cf17 class }CompactReporter final : {\cf17 public} StreamingReporterBase \{\par
13164     {\cf17 public}:\par
13165         {\cf17 using }StreamingReporterBase::StreamingReporterBase;\par
13166 \par
13167         ~CompactReporter() {\cf17 override};\par
13168 \par
13169         {\cf17 static} std::string getDescription();\par
13170 \par
13171         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13172 \par
13173         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& _testInfo ) {\cf17 override};\par
13174 \par
13175         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
13176 \par
13177         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& _sectionStats) {\cf17 override};\par
13178 \par
13179         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
13180 \par
13181     \};\par
13182 \par
13183 \} {\cf20 // end namespace Catch}\par
13184 \par
13185 {\cf21 #endif }{\cf20 // CATCH_REPORTER_COMPACT_HPP_INCLUDED}\par
13186 \par
13187 \par
13188 {\cf21 #ifndef CATCH_REPORTER_CONSOLE_HPP_INCLUDED}\par
13189 {\cf21 #define CATCH_REPORTER_CONSOLE_HPP_INCLUDED}\par
13190 \par
13191 \par
13192 {\cf17 namespace }Catch \{\par
13193     {\cf20 // Fwd decls}\par
13194     {\cf17 class }TablePrinter;\par
13195 \par
13196     {\cf17 class }ConsoleReporter final : {\cf17 public} StreamingReporterBase \{\par
13197         Detail::unique_ptr<TablePrinter> m_tablePrinter;\par
13198 \par
13199     {\cf17 public}:\par
13200         ConsoleReporter(ReporterConfig&& config);\par
13201         ~ConsoleReporter() {\cf17 override};\par
13202         {\cf17 static} std::string getDescription();\par
13203 \par
13204         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13205         {\cf18 void} reportInvalidTestSpec( StringRef arg ) {\cf17 override};\par
13206 \par
13207         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
13208 \par
13209         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
13210 \par
13211         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& _sectionInfo) {\cf17 override};\par
13212         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& _sectionStats) {\cf17 override};\par
13213 \par
13214         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13215         {\cf18 void} benchmarkStarting(BenchmarkInfo {\cf17 const}& info) {\cf17 override};\par
13216         {\cf18 void} benchmarkEnded(BenchmarkStats<> {\cf17 const}& stats) {\cf17 override};\par
13217         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13218 \par
13219         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& _testCaseStats) {\cf17 override};\par
13220         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
13221         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& _testRunInfo) {\cf17 override};\par
13222 \par
13223     {\cf17 private}:\par
13224         {\cf18 void} lazyPrint();\par
13225 \par
13226         {\cf18 void} lazyPrintWithoutClosingBenchmarkTable();\par
13227         {\cf18 void} lazyPrintRunInfo();\par
13228         {\cf18 void} printTestCaseAndSectionHeader();\par
13229 \par
13230         {\cf18 void} printClosedHeader(std::string {\cf17 const}& _name);\par
13231         {\cf18 void} printOpenHeader(std::string {\cf17 const}& _name);\par
13232 \par
13233         {\cf20 // if string has a : in first line will set indent to follow it on}\par
13234         {\cf20 // subsequent lines}\par
13235         {\cf18 void} printHeaderString(std::string {\cf17 const}& _string, std::size_t indent = 0);\par
13236 \par
13237         {\cf18 void} printTotalsDivider(Totals {\cf17 const}& totals);\par
13238 \par
13239         {\cf18 bool} m_headerPrinted = {\cf17 false};\par
13240         {\cf18 bool} m_testRunInfoPrinted = {\cf17 false};\par
13241     \};\par
13242 \par
13243 \} {\cf20 // end namespace Catch}\par
13244 \par
13245 {\cf21 #endif }{\cf20 // CATCH_REPORTER_CONSOLE_HPP_INCLUDED}\par
13246 \par
13247 \par
13248 {\cf21 #ifndef CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED}\par
13249 {\cf21 #define CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED}\par
13250 \par
13251 \par
13252 {\cf21 #include <string>}\par
13253 {\cf21 #include <vector>}\par
13254 \par
13255 {\cf17 namespace }Catch \{\par
13256 \par
13257     {\cf17 namespace }Detail \{\par
13258 \par
13260         {\cf17 class }AssertionOrBenchmarkResult \{\par
13261             {\cf20 // This should really be a variant, but this is much faster}\par
13262             {\cf20 // to write and the data layout here is already terrible}\par
13263             {\cf20 // enough that we do not have to care about the object size.}\par
13264             Optional<AssertionStats> m_assertion;\par
13265             Optional<BenchmarkStats<>> m_benchmark;\par
13266         {\cf17 public}:\par
13267             AssertionOrBenchmarkResult(AssertionStats {\cf17 const}& assertion);\par
13268             AssertionOrBenchmarkResult(BenchmarkStats<> {\cf17 const}& benchmark);\par
13269 \par
13270             {\cf18 bool} isAssertion() {\cf17 const};\par
13271             {\cf18 bool} isBenchmark() {\cf17 const};\par
13272 \par
13273             AssertionStats {\cf17 const}& asAssertion() {\cf17 const};\par
13274             BenchmarkStats<> {\cf17 const}& asBenchmark() {\cf17 const};\par
13275         \};\par
13276     \}\par
13277 \par
13298     {\cf17 class }CumulativeReporterBase : {\cf17 public} ReporterBase \{\par
13299     {\cf17 public}:\par
13300         {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ChildNodeT>\par
13301         {\cf17 struct }Node \{\par
13302             {\cf17 explicit} Node( T {\cf17 const}& _value ) : value( _value ) \{\}\par
13303 \par
13304             {\cf17 using }ChildNodes = std::vector<Detail::unique_ptr<ChildNodeT>>;\par
13305             T value;\par
13306             ChildNodes children;\par
13307         \};\par
13308         {\cf17 struct }SectionNode \{\par
13309             {\cf17 explicit} SectionNode(SectionStats {\cf17 const}& _stats) : stats(_stats) \{\}\par
13310 \par
13311             {\cf18 bool} operator == (SectionNode {\cf17 const}& other){\cf17  const }\{\par
13312                 {\cf19 return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;\par
13313             \}\par
13314 \par
13315             {\cf18 bool} hasAnyAssertions() {\cf17 const};\par
13316 \par
13317             SectionStats stats;\par
13318             std::vector<Detail::unique_ptr<SectionNode>> childSections;\par
13319             std::vector<Detail::AssertionOrBenchmarkResult> assertionsAndBenchmarks;\par
13320             std::string stdOut;\par
13321             std::string stdErr;\par
13322         \};\par
13323 \par
13324 \par
13325         {\cf17 using }TestCaseNode = Node<TestCaseStats, SectionNode>;\par
13326         {\cf17 using }TestRunNode = Node<TestRunStats, TestCaseNode>;\par
13327 \par
13328         {\cf20 // GCC5 compat: we cannot use inherited constructor, because it}\par
13329         {\cf20 //              doesn't implement backport of P0136}\par
13330         CumulativeReporterBase(ReporterConfig&& _config):\par
13331             ReporterBase(CATCH_MOVE(_config))\par
13332         \{\}\par
13333         ~CumulativeReporterBase() {\cf17 override};\par
13334 \par
13335         {\cf18 void} benchmarkPreparing( StringRef ){\cf17  override }\{\}\par
13336         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& ){\cf17  override }\{\}\par
13337         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) {\cf17 override};\par
13338         {\cf18 void} benchmarkFailed( StringRef ){\cf17  override }\{\}\par
13339 \par
13340         {\cf18 void} noMatchingTestCases( StringRef ){\cf17  override }\{\}\par
13341         {\cf18 void} reportInvalidTestSpec( StringRef ){\cf17  override }\{\}\par
13342         {\cf18 void} fatalErrorEncountered( StringRef {\cf20 /*error*/} ){\cf17  override }\{\}\par
13343 \par
13344         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& ){\cf17  override }\{\}\par
13345 \par
13346         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& ){\cf17  override }\{\}\par
13347         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13348         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13349 \par
13350         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& ){\cf17  override }\{\}\par
13351 \par
13352         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13353         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13354         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}&, uint64_t ){\cf17  override }\{\}\par
13355         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) {\cf17 override};\par
13356         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) {\cf17 override};\par
13358         {\cf17 virtual} {\cf18 void} testRunEndedCumulative() = 0;\par
13359 \par
13360         {\cf18 void} skipTest(TestCaseInfo {\cf17 const}&){\cf17  override }\{\}\par
13361 \par
13362     {\cf17 protected}:\par
13364         {\cf18 bool} m_shouldStoreSuccesfulAssertions = {\cf17 true};\par
13366         {\cf18 bool} m_shouldStoreFailedAssertions = {\cf17 true};\par
13367 \par
13368         {\cf20 // We need lazy construction here. We should probably refactor it}\par
13369         {\cf20 // later, after the events are redone.}\par
13371         Detail::unique_ptr<TestRunNode> m_testRun;\par
13372 \par
13373     {\cf17 private}:\par
13374         {\cf20 // Note: We rely on pointer identity being stable, which is why}\par
13375         {\cf20 //       we store pointers to the nodes rather than the values.}\par
13376         std::vector<Detail::unique_ptr<TestCaseNode>> m_testCases;\par
13377         {\cf20 // Root section of the _current_ test case}\par
13378         Detail::unique_ptr<SectionNode> m_rootSection;\par
13379         {\cf20 // Deepest section of the _current_ test case}\par
13380         SectionNode* m_deepestSection = {\cf17 nullptr};\par
13381         {\cf20 // Stack of _active_ sections in the _current_ test case}\par
13382         std::vector<SectionNode*> m_sectionStack;\par
13383     \};\par
13384 \par
13385 \} {\cf20 // end namespace Catch}\par
13386 \par
13387 {\cf21 #endif }{\cf20 // CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED}\par
13388 \par
13389 \par
13390 {\cf21 #ifndef CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED}\par
13391 {\cf21 #define CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED}\par
13392 \par
13393 \par
13394 {\cf17 namespace }Catch \{\par
13395 \par
13403     {\cf17 class }EventListenerBase : {\cf17 public} IEventListener \{\par
13404     {\cf17 public}:\par
13405         {\cf17 using }IEventListener::IEventListener;\par
13406 \par
13407         {\cf18 void} reportInvalidTestSpec( StringRef unmatchedSpec ) {\cf17 override};\par
13408         {\cf18 void} fatalErrorEncountered( StringRef error ) {\cf17 override};\par
13409 \par
13410         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13411         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) {\cf17 override};\par
13412         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) {\cf17 override};\par
13413         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13414 \par
13415         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) {\cf17 override};\par
13416         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13417 \par
13418         {\cf18 void} listReporters(\par
13419             std::vector<ReporterDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13420         {\cf18 void} listListeners(\par
13421             std::vector<ListenerDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13422         {\cf18 void} listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) {\cf17 override};\par
13423         {\cf18 void} listTags( std::vector<TagInfo> {\cf17 const}& tagInfos ) {\cf17 override};\par
13424 \par
13425         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13426         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) {\cf17 override};\par
13427         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13428         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}& testInfo,\par
13429                                       uint64_t partNumber ) {\cf17 override};\par
13430         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13431         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13432         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}& testCaseStats,\par
13433                                    uint64_t partNumber ) {\cf17 override};\par
13434         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) {\cf17 override};\par
13435         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) {\cf17 override};\par
13436         {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13437     \};\par
13438 \par
13439 \} {\cf20 // end namespace Catch}\par
13440 \par
13441 {\cf21 #endif }{\cf20 // CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED}\par
13442 \par
13443 \par
13444 {\cf21 #ifndef CATCH_REPORTER_HELPERS_HPP_INCLUDED}\par
13445 {\cf21 #define CATCH_REPORTER_HELPERS_HPP_INCLUDED}\par
13446 \par
13447 {\cf21 #include <iosfwd>}\par
13448 {\cf21 #include <string>}\par
13449 {\cf21 #include <vector>}\par
13450 \par
13451 \par
13452 {\cf17 namespace }Catch \{\par
13453 \par
13454     {\cf17 class }IConfig;\par
13455     {\cf17 class }TestCaseHandle;\par
13456     {\cf17 class }ColourImpl;\par
13457 \par
13458     {\cf20 // Returns double formatted as %.3f (format expected on output)}\par
13459     std::string getFormattedDuration( {\cf18 double} duration );\par
13460 \par
13462     {\cf18 bool} shouldShowDuration( IConfig {\cf17 const}& config, {\cf18 double} duration );\par
13463 \par
13464     std::string serializeFilters( std::vector<std::string> {\cf17 const}& filters );\par
13465 \par
13466     {\cf17 struct }lineOfChars \{\par
13467         {\cf18 char} c;\par
13468         {\cf17 constexpr} lineOfChars( {\cf18 char} c_ ): c( c_ ) \{\}\par
13469 \par
13470         {\cf17 friend} std::ostream& operator<<( std::ostream& out, lineOfChars value );\par
13471     \};\par
13472 \par
13481     {\cf18 void}\par
13482     defaultListReporters( std::ostream& out,\par
13483                           std::vector<ReporterDescription> {\cf17 const}& descriptions,\par
13484                           Verbosity verbosity );\par
13485 \par
13490     {\cf18 void} defaultListListeners( std::ostream& out,\par
13491                                std::vector<ListenerDescription> {\cf17 const}& descriptions );\par
13492 \par
13500     {\cf18 void} defaultListTags( std::ostream& out, std::vector<TagInfo> {\cf17 const}& tags, {\cf18 bool} isFiltered );\par
13501 \par
13511     {\cf18 void} defaultListTests( std::ostream& out,\par
13512                            ColourImpl* streamColour,\par
13513                            std::vector<TestCaseHandle> {\cf17 const}& tests,\par
13514                            {\cf18 bool} isFiltered,\par
13515                            Verbosity verbosity );\par
13516 \par
13522     {\cf18 void} printTestRunTotals( std::ostream& stream,\par
13523                       ColourImpl& streamColour,\par
13524                       Totals {\cf17 const}& totals );\par
13525 \par
13526 \} {\cf20 // end namespace Catch}\par
13527 \par
13528 {\cf21 #endif }{\cf20 // CATCH_REPORTER_HELPERS_HPP_INCLUDED}\par
13529 \par
13530 \par
13531 \par
13532 {\cf21 #ifndef CATCH_REPORTER_JSON_HPP_INCLUDED}\par
13533 {\cf21 #define CATCH_REPORTER_JSON_HPP_INCLUDED}\par
13534 \par
13535 \par
13536 {\cf21 #include <stack>}\par
13537 \par
13538 {\cf17 namespace }Catch \{\par
13539     {\cf17 class }JsonReporter : {\cf17 public} StreamingReporterBase \{\par
13540     {\cf17 public}:\par
13541         JsonReporter( ReporterConfig&& config );\par
13542 \par
13543         ~JsonReporter() {\cf17 override};\par
13544 \par
13545         {\cf17 static} std::string getDescription();\par
13546 \par
13547     {\cf17 public}: {\cf20 // StreamingReporterBase}\par
13548         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& runInfo ) {\cf17 override};\par
13549         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& runStats ) {\cf17 override};\par
13550 \par
13551         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& tcInfo ) {\cf17 override};\par
13552         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& tcStats ) {\cf17 override};\par
13553 \par
13554         {\cf18 void} testCasePartialStarting( TestCaseInfo {\cf17 const}& tcInfo,\par
13555                                       uint64_t index ) {\cf17 override};\par
13556         {\cf18 void} testCasePartialEnded( TestCaseStats {\cf17 const}& tcStats,\par
13557                                    uint64_t index ) {\cf17 override};\par
13558 \par
13559         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13560         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13561 \par
13562         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) {\cf17 override};\par
13563         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13564 \par
13565         {\cf20 //void testRunEndedCumulative() override;}\par
13566 \par
13567         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13568         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& ) {\cf17 override};\par
13569         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& ) {\cf17 override};\par
13570         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13571 \par
13572         {\cf18 void} listReporters(\par
13573             std::vector<ReporterDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13574         {\cf18 void} listListeners(\par
13575             std::vector<ListenerDescription> {\cf17 const}& descriptions ) {\cf17 override};\par
13576         {\cf18 void} listTests( std::vector<TestCaseHandle> {\cf17 const}& tests ) {\cf17 override};\par
13577         {\cf18 void} listTags( std::vector<TagInfo> {\cf17 const}& tags ) {\cf17 override};\par
13578 \par
13579     {\cf17 private}:\par
13580         Timer m_testCaseTimer;\par
13581         {\cf17 enum class} Writer \{\par
13582             Object,\par
13583             Array\par
13584         \};\par
13585 \par
13586         JsonArrayWriter& startArray();\par
13587         JsonArrayWriter& startArray( StringRef key );\par
13588 \par
13589         JsonObjectWriter& startObject();\par
13590         JsonObjectWriter& startObject( StringRef key );\par
13591 \par
13592         {\cf18 void} endObject();\par
13593         {\cf18 void} endArray();\par
13594 \par
13595         {\cf18 bool} isInside( Writer writer );\par
13596 \par
13597         {\cf18 void} startListing();\par
13598         {\cf18 void} endListing();\par
13599 \par
13600         {\cf20 // Invariant:}\par
13601         {\cf20 // When m_writers is not empty and its top element is}\par
13602         {\cf20 // - Writer::Object, then m_objectWriters is not be empty}\par
13603         {\cf20 // - Writer::Array,  then m_arrayWriters shall not be empty}\par
13604         std::stack<JsonObjectWriter> m_objectWriters\{\};\par
13605         std::stack<JsonArrayWriter> m_arrayWriters\{\};\par
13606         std::stack<Writer> m_writers\{\};\par
13607 \par
13608         {\cf18 bool} m_startedListing = {\cf17 false};\par
13609 \par
13610         {\cf20 // std::size_t m_sectionDepth = 0;}\par
13611         {\cf20 // std::size_t m_sectionStarted = 0;}\par
13612     \};\par
13613 \} {\cf20 // namespace Catch}\par
13614 \par
13615 {\cf21 #endif }{\cf20 // CATCH_REPORTER_JSON_HPP_INCLUDED}\par
13616 \par
13617 \par
13618 {\cf21 #ifndef CATCH_REPORTER_JUNIT_HPP_INCLUDED}\par
13619 {\cf21 #define CATCH_REPORTER_JUNIT_HPP_INCLUDED}\par
13620 \par
13621 \par
13622 \par
13623 {\cf17 namespace }Catch \{\par
13624 \par
13625     {\cf17 class }JunitReporter final : {\cf17 public} CumulativeReporterBase \{\par
13626     {\cf17 public}:\par
13627         JunitReporter(ReporterConfig&& _config);\par
13628 \par
13629         {\cf17 static} std::string getDescription();\par
13630 \par
13631         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& runInfo) {\cf17 override};\par
13632 \par
13633         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testCaseInfo) {\cf17 override};\par
13634         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
13635 \par
13636         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
13637 \par
13638         {\cf18 void} testRunEndedCumulative() {\cf17 override};\par
13639 \par
13640     {\cf17 private}:\par
13641         {\cf18 void} writeRun(TestRunNode {\cf17 const}& testRunNode, {\cf18 double} suiteTime);\par
13642 \par
13643         {\cf18 void} writeTestCase(TestCaseNode {\cf17 const}& testCaseNode);\par
13644 \par
13645         {\cf18 void} writeSection( std::string {\cf17 const}& className,\par
13646                            std::string {\cf17 const}& rootName,\par
13647                            SectionNode {\cf17 const}& sectionNode,\par
13648                            {\cf18 bool} testOkToFail );\par
13649 \par
13650         {\cf18 void} writeAssertions(SectionNode {\cf17 const}& sectionNode);\par
13651         {\cf18 void} writeAssertion(AssertionStats {\cf17 const}& stats);\par
13652 \par
13653         XmlWriter xml;\par
13654         Timer suiteTimer;\par
13655         std::string stdOutForSuite;\par
13656         std::string stdErrForSuite;\par
13657         {\cf18 unsigned} {\cf18 int} unexpectedExceptions = 0;\par
13658         {\cf18 bool} m_okToFail = {\cf17 false};\par
13659     \};\par
13660 \par
13661 \} {\cf20 // end namespace Catch}\par
13662 \par
13663 {\cf21 #endif }{\cf20 // CATCH_REPORTER_JUNIT_HPP_INCLUDED}\par
13664 \par
13665 \par
13666 {\cf21 #ifndef CATCH_REPORTER_MULTI_HPP_INCLUDED}\par
13667 {\cf21 #define CATCH_REPORTER_MULTI_HPP_INCLUDED}\par
13668 \par
13669 \par
13670 {\cf17 namespace }Catch \{\par
13671 \par
13672     {\cf17 class }MultiReporter final : {\cf17 public} IEventListener \{\par
13673         {\cf20 /*}\par
13674 {\cf20          * Stores all added reporters and listeners}\par
13675 {\cf20          *}\par
13676 {\cf20          * All Listeners are stored before all reporters, and individual}\par
13677 {\cf20          * listeners/reporters are stored in order of insertion.}\par
13678 {\cf20          */}\par
13679         std::vector<IEventListenerPtr> m_reporterLikes;\par
13680         {\cf18 bool} m_haveNoncapturingReporters = {\cf17 false};\par
13681 \par
13682         {\cf20 // Keep track of how many listeners we have already inserted,}\par
13683         {\cf20 // so that we can insert them into the main vector at the right place}\par
13684         {\cf18 size_t} m_insertedListeners = 0;\par
13685 \par
13686         {\cf18 void} updatePreferences(IEventListener {\cf17 const}& reporterish);\par
13687 \par
13688     {\cf17 public}:\par
13689         {\cf17 using }IEventListener::IEventListener;\par
13690 \par
13691         {\cf18 void} addListener( IEventListenerPtr&& listener );\par
13692         {\cf18 void} addReporter( IEventListenerPtr&& reporter );\par
13693 \par
13694     {\cf17 public}: {\cf20 // IEventListener}\par
13695 \par
13696         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13697         {\cf18 void} fatalErrorEncountered( StringRef error ) {\cf17 override};\par
13698         {\cf18 void} reportInvalidTestSpec( StringRef arg ) {\cf17 override};\par
13699 \par
13700         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
13701         {\cf18 void} benchmarkStarting( BenchmarkInfo {\cf17 const}& benchmarkInfo ) {\cf17 override};\par
13702         {\cf18 void} benchmarkEnded( BenchmarkStats<> {\cf17 const}& benchmarkStats ) {\cf17 override};\par
13703         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
13704 \par
13705         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) {\cf17 override};\par
13706         {\cf18 void} testCaseStarting( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13707         {\cf18 void} testCasePartialStarting(TestCaseInfo {\cf17 const}& testInfo, uint64_t partNumber) {\cf17 override};\par
13708         {\cf18 void} sectionStarting( SectionInfo {\cf17 const}& sectionInfo ) {\cf17 override};\par
13709         {\cf18 void} assertionStarting( AssertionInfo {\cf17 const}& assertionInfo ) {\cf17 override};\par
13710 \par
13711         {\cf18 void} assertionEnded( AssertionStats {\cf17 const}& assertionStats ) {\cf17 override};\par
13712         {\cf18 void} sectionEnded( SectionStats {\cf17 const}& sectionStats ) {\cf17 override};\par
13713         {\cf18 void} testCasePartialEnded(TestCaseStats {\cf17 const}& testStats, uint64_t partNumber) {\cf17 override};\par
13714         {\cf18 void} testCaseEnded( TestCaseStats {\cf17 const}& testCaseStats ) {\cf17 override};\par
13715         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& testRunStats ) {\cf17 override};\par
13716 \par
13717         {\cf18 void} skipTest( TestCaseInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13718 \par
13719         {\cf18 void} listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) {\cf17 override};\par
13720         {\cf18 void} listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) {\cf17 override};\par
13721         {\cf18 void} listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) {\cf17 override};\par
13722         {\cf18 void} listTags(std::vector<TagInfo> {\cf17 const}& tags) {\cf17 override};\par
13723 \par
13724 \par
13725     \};\par
13726 \par
13727 \} {\cf20 // end namespace Catch}\par
13728 \par
13729 {\cf21 #endif }{\cf20 // CATCH_REPORTER_MULTI_HPP_INCLUDED}\par
13730 \par
13731 \par
13732 {\cf21 #ifndef CATCH_REPORTER_REGISTRARS_HPP_INCLUDED}\par
13733 {\cf21 #define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED}\par
13734 \par
13735 \par
13736 {\cf21 #include <type_traits>}\par
13737 \par
13738 {\cf17 namespace }Catch \{\par
13739 \par
13740     {\cf17 namespace }Detail \{\par
13741 \par
13742         {\cf17 template} <{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
13743         {\cf17 struct }has_description : std::false_type \{\};\par
13744 \par
13745         {\cf17 template} <{\cf17 typename} T>\par
13746         {\cf17 struct }has_description<\par
13747             T,\par
13748             void_t<decltype( T::getDescription() )>>\par
13749             : std::true_type \{\};\par
13750 \par
13753         {\cf18 void} registerReporterImpl( std::string {\cf17 const}& name,\par
13754                                    IReporterFactoryPtr reporterPtr );\par
13756         {\cf18 void} registerListenerImpl( Detail::unique_ptr<EventListenerFactory> listenerFactory );\par
13757     \} {\cf20 // namespace Detail}\par
13758 \par
13759     {\cf17 class }IEventListener;\par
13760     {\cf17 using }IEventListenerPtr = Detail::unique_ptr<IEventListener>;\par
13761 \par
13762     {\cf17 template} <{\cf17 typename} T>\par
13763     {\cf17 class }ReporterFactory : {\cf17 public} IReporterFactory \{\par
13764 \par
13765         IEventListenerPtr create( ReporterConfig&& config ){\cf17  const override }\{\par
13766             {\cf19 return} Detail::make_unique<T>( CATCH_MOVE(config) );\par
13767         \}\par
13768 \par
13769         std::string getDescription(){\cf17  const override }\{\par
13770             {\cf19 return} T::getDescription();\par
13771         \}\par
13772     \};\par
13773 \par
13774 \par
13775     {\cf17 template}<{\cf17 typename} T>\par
13776     {\cf17 class }ReporterRegistrar \{\par
13777     {\cf17 public}:\par
13778         {\cf17 explicit} ReporterRegistrar( std::string {\cf17 const}& name ) \{\par
13779             registerReporterImpl( name,\par
13780                                   Detail::make_unique<ReporterFactory<T>>() );\par
13781         \}\par
13782     \};\par
13783 \par
13784     {\cf17 template}<{\cf17 typename} T>\par
13785     {\cf17 class }ListenerRegistrar \{\par
13786 \par
13787         {\cf17 class }TypedListenerFactory : {\cf17 public} EventListenerFactory \{\par
13788             StringRef m_listenerName;\par
13789 \par
13790             std::string getDescriptionImpl( std::true_type ){\cf17  const }\{\par
13791                 {\cf19 return} T::getDescription();\par
13792             \}\par
13793 \par
13794             std::string getDescriptionImpl( std::false_type ){\cf17  const }\{\par
13795                 {\cf19 return} {\cf22 "(No description provided)"};\par
13796             \}\par
13797 \par
13798         {\cf17 public}:\par
13799             TypedListenerFactory( StringRef listenerName ):\par
13800                 m_listenerName( listenerName ) \{\}\par
13801 \par
13802             IEventListenerPtr create( IConfig {\cf17 const}* config ){\cf17  const override }\{\par
13803                 {\cf19 return} Detail::make_unique<T>( config );\par
13804             \}\par
13805 \par
13806             StringRef getName(){\cf17  const override }\{\par
13807                 {\cf19 return} m_listenerName;\par
13808             \}\par
13809 \par
13810             std::string getDescription(){\cf17  const override }\{\par
13811                 {\cf19 return} getDescriptionImpl( Detail::has_description<T>\{\} );\par
13812             \}\par
13813         \};\par
13814 \par
13815     {\cf17 public}:\par
13816         ListenerRegistrar(StringRef listenerName) \{\par
13817             registerListenerImpl( Detail::make_unique<TypedListenerFactory>(listenerName) );\par
13818         \}\par
13819     \};\par
13820 \}\par
13821 \par
13822 {\cf21 #if !defined(CATCH_CONFIG_DISABLE)}\par
13823 \par
13824 {\cf21 #    define CATCH_REGISTER_REPORTER( name, reporterType )                      \\}\par
13825 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\}\par
13826 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\}\par
13827 {\cf21         namespace \{                                                            \\}\par
13828 {\cf21             Catch::ReporterRegistrar<reporterType> INTERNAL_CATCH_UNIQUE_NAME( \\}\par
13829 {\cf21                 catch_internal_RegistrarFor )( name );                         \\}\par
13830 {\cf21         \}                                                                      \\}\par
13831 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
13832 \par
13833 {\cf21 #    define CATCH_REGISTER_LISTENER( listenerType )                            \\}\par
13834 {\cf21         CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\}\par
13835 {\cf21         CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\}\par
13836 {\cf21         namespace \{                                                            \\}\par
13837 {\cf21             Catch::ListenerRegistrar<listenerType> INTERNAL_CATCH_UNIQUE_NAME( \\}\par
13838 {\cf21                 catch_internal_RegistrarFor )( #listenerType##_catch_sr );     \\}\par
13839 {\cf21         \}                                                                      \\}\par
13840 {\cf21         CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION}\par
13841 \par
13842 {\cf21 #else }{\cf20 // CATCH_CONFIG_DISABLE}\par
13843 \par
13844 {\cf21 #define CATCH_REGISTER_REPORTER(name, reporterType)}\par
13845 {\cf21 #define CATCH_REGISTER_LISTENER(listenerType)}\par
13846 \par
13847 {\cf21 #endif }{\cf20 // CATCH_CONFIG_DISABLE}\par
13848 \par
13849 {\cf21 #endif }{\cf20 // CATCH_REPORTER_REGISTRARS_HPP_INCLUDED}\par
13850 \par
13851 \par
13852 {\cf21 #ifndef CATCH_REPORTER_SONARQUBE_HPP_INCLUDED}\par
13853 {\cf21 #define CATCH_REPORTER_SONARQUBE_HPP_INCLUDED}\par
13854 \par
13855 \par
13856 \par
13857 {\cf17 namespace }Catch \{\par
13858 \par
13859     {\cf17 class }SonarQubeReporter final : {\cf17 public} CumulativeReporterBase \{\par
13860     {\cf17 public}:\par
13861         SonarQubeReporter(ReporterConfig&& config)\par
13862         : CumulativeReporterBase(CATCH_MOVE(config))\par
13863         , xml(m_stream) \{\par
13864             m_preferences.shouldRedirectStdOut = {\cf17 true};\par
13865             m_preferences.shouldReportAllAssertions = {\cf17 true};\par
13866             m_shouldStoreSuccesfulAssertions = {\cf17 false};\par
13867         \}\par
13868 \par
13869         {\cf17 static} std::string getDescription() \{\par
13870             {\cf17 using namespace }std::string_literals;\par
13871             {\cf19 return} {\cf22 "Reports test results in the Generic Test Data SonarQube XML format"}s;\par
13872         \}\par
13873 \par
13874         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testRunInfo ) {\cf17 override};\par
13875 \par
13876         {\cf18 void} testRunEndedCumulative(){\cf17  override }\{\par
13877             writeRun( *m_testRun );\par
13878             xml.endElement();\par
13879         \}\par
13880 \par
13881         {\cf18 void} writeRun( TestRunNode {\cf17 const}& runNode );\par
13882 \par
13883         {\cf18 void} writeTestFile(StringRef filename, std::vector<TestCaseNode const*> {\cf17 const}& testCaseNodes);\par
13884 \par
13885         {\cf18 void} writeTestCase(TestCaseNode {\cf17 const}& testCaseNode);\par
13886 \par
13887         {\cf18 void} writeSection(std::string {\cf17 const}& rootName, SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail);\par
13888 \par
13889         {\cf18 void} writeAssertions(SectionNode {\cf17 const}& sectionNode, {\cf18 bool} okToFail);\par
13890 \par
13891         {\cf18 void} writeAssertion(AssertionStats {\cf17 const}& stats, {\cf18 bool} okToFail);\par
13892 \par
13893     {\cf17 private}:\par
13894         XmlWriter xml;\par
13895     \};\par
13896 \par
13897 \par
13898 \} {\cf20 // end namespace Catch}\par
13899 \par
13900 {\cf21 #endif }{\cf20 // CATCH_REPORTER_SONARQUBE_HPP_INCLUDED}\par
13901 \par
13902 \par
13903 {\cf21 #ifndef CATCH_REPORTER_TAP_HPP_INCLUDED}\par
13904 {\cf21 #define CATCH_REPORTER_TAP_HPP_INCLUDED}\par
13905 \par
13906 \par
13907 {\cf17 namespace }Catch \{\par
13908 \par
13909     {\cf17 class }TAPReporter final : {\cf17 public} StreamingReporterBase \{\par
13910     {\cf17 public}:\par
13911         TAPReporter( ReporterConfig&& config ):\par
13912             StreamingReporterBase( CATCH_MOVE(config) ) \{\par
13913             m_preferences.shouldReportAllAssertions = {\cf17 true};\par
13914         \}\par
13915 \par
13916         {\cf17 static} std::string getDescription() \{\par
13917             {\cf17 using namespace }std::string_literals;\par
13918             {\cf19 return} {\cf22 "Reports test results in TAP format, suitable for test harnesses"}s;\par
13919         \}\par
13920 \par
13921         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& testInfo ) {\cf17 override};\par
13922 \par
13923         {\cf18 void} noMatchingTestCases( StringRef unmatchedSpec ) {\cf17 override};\par
13924 \par
13925         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& _assertionStats) {\cf17 override};\par
13926 \par
13927         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& _testRunStats) {\cf17 override};\par
13928 \par
13929     {\cf17 private}:\par
13930         std::size_t counter = 0;\par
13931     \};\par
13932 \par
13933 \} {\cf20 // end namespace Catch}\par
13934 \par
13935 {\cf21 #endif }{\cf20 // CATCH_REPORTER_TAP_HPP_INCLUDED}\par
13936 \par
13937 \par
13938 {\cf21 #ifndef CATCH_REPORTER_TEAMCITY_HPP_INCLUDED}\par
13939 {\cf21 #define CATCH_REPORTER_TEAMCITY_HPP_INCLUDED}\par
13940 \par
13941 \par
13942 {\cf21 #include <cstring>}\par
13943 \par
13944 {\cf21 #ifdef __clang__}\par
13945 {\cf21 #   pragma clang diagnostic push}\par
13946 {\cf21 #   pragma clang diagnostic ignored "-Wpadded"}\par
13947 {\cf21 #endif}\par
13948 \par
13949 {\cf17 namespace }Catch \{\par
13950 \par
13951     {\cf17 class }TeamCityReporter final : {\cf17 public} StreamingReporterBase \{\par
13952     {\cf17 public}:\par
13953         TeamCityReporter( ReporterConfig&& _config )\par
13954         :   StreamingReporterBase( CATCH_MOVE(_config) )\par
13955         \{\par
13956             m_preferences.shouldRedirectStdOut = {\cf17 true};\par
13957         \}\par
13958 \par
13959         ~TeamCityReporter() {\cf17 override};\par
13960 \par
13961         {\cf17 static} std::string getDescription() \{\par
13962             {\cf17 using namespace }std::string_literals;\par
13963             {\cf19 return} {\cf22 "Reports test results as TeamCity service messages"}s;\par
13964         \}\par
13965 \par
13966         {\cf18 void} testRunStarting( TestRunInfo {\cf17 const}& runInfo ) {\cf17 override};\par
13967         {\cf18 void} testRunEnded( TestRunStats {\cf17 const}& runStats ) {\cf17 override};\par
13968 \par
13969 \par
13970         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
13971 \par
13972         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& sectionInfo){\cf17  override }\{\par
13973             m_headerPrintedForThisSection = {\cf17 false};\par
13974             StreamingReporterBase::sectionStarting( sectionInfo );\par
13975         \}\par
13976 \par
13977         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testInfo) {\cf17 override};\par
13978 \par
13979         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
13980 \par
13981     {\cf17 private}:\par
13982         {\cf18 void} printSectionHeader(std::ostream& os);\par
13983 \par
13984         {\cf18 bool} m_headerPrintedForThisSection = {\cf17 false};\par
13985         Timer m_testTimer;\par
13986     \};\par
13987 \par
13988 \} {\cf20 // end namespace Catch}\par
13989 \par
13990 {\cf21 #ifdef __clang__}\par
13991 {\cf21 #   pragma clang diagnostic pop}\par
13992 {\cf21 #endif}\par
13993 \par
13994 {\cf21 #endif }{\cf20 // CATCH_REPORTER_TEAMCITY_HPP_INCLUDED}\par
13995 \par
13996 \par
13997 {\cf21 #ifndef CATCH_REPORTER_XML_HPP_INCLUDED}\par
13998 {\cf21 #define CATCH_REPORTER_XML_HPP_INCLUDED}\par
13999 \par
14000 \par
14001 \par
14002 \par
14003 {\cf17 namespace }Catch \{\par
14004     {\cf17 class }XmlReporter : {\cf17 public} StreamingReporterBase \{\par
14005     {\cf17 public}:\par
14006         XmlReporter(ReporterConfig&& _config);\par
14007 \par
14008         ~XmlReporter() {\cf17 override};\par
14009 \par
14010         {\cf17 static} std::string getDescription();\par
14011 \par
14012         {\cf17 virtual} std::string getStylesheetRef() {\cf17 const};\par
14013 \par
14014         {\cf18 void} writeSourceInfo(SourceLineInfo {\cf17 const}& sourceInfo);\par
14015 \par
14016     {\cf17 public}: {\cf20 // StreamingReporterBase}\par
14017 \par
14018         {\cf18 void} testRunStarting(TestRunInfo {\cf17 const}& testInfo) {\cf17 override};\par
14019 \par
14020         {\cf18 void} testCaseStarting(TestCaseInfo {\cf17 const}& testInfo) {\cf17 override};\par
14021 \par
14022         {\cf18 void} sectionStarting(SectionInfo {\cf17 const}& sectionInfo) {\cf17 override};\par
14023 \par
14024         {\cf18 void} assertionStarting(AssertionInfo {\cf17 const}&) {\cf17 override};\par
14025 \par
14026         {\cf18 void} assertionEnded(AssertionStats {\cf17 const}& assertionStats) {\cf17 override};\par
14027 \par
14028         {\cf18 void} sectionEnded(SectionStats {\cf17 const}& sectionStats) {\cf17 override};\par
14029 \par
14030         {\cf18 void} testCaseEnded(TestCaseStats {\cf17 const}& testCaseStats) {\cf17 override};\par
14031 \par
14032         {\cf18 void} testRunEnded(TestRunStats {\cf17 const}& testRunStats) {\cf17 override};\par
14033 \par
14034         {\cf18 void} benchmarkPreparing( StringRef name ) {\cf17 override};\par
14035         {\cf18 void} benchmarkStarting(BenchmarkInfo {\cf17 const}&) {\cf17 override};\par
14036         {\cf18 void} benchmarkEnded(BenchmarkStats<> {\cf17 const}&) {\cf17 override};\par
14037         {\cf18 void} benchmarkFailed( StringRef error ) {\cf17 override};\par
14038 \par
14039         {\cf18 void} listReporters(std::vector<ReporterDescription> {\cf17 const}& descriptions) {\cf17 override};\par
14040         {\cf18 void} listListeners(std::vector<ListenerDescription> {\cf17 const}& descriptions) {\cf17 override};\par
14041         {\cf18 void} listTests(std::vector<TestCaseHandle> {\cf17 const}& tests) {\cf17 override};\par
14042         {\cf18 void} listTags(std::vector<TagInfo> {\cf17 const}& tags) {\cf17 override};\par
14043 \par
14044     {\cf17 private}:\par
14045         Timer m_testCaseTimer;\par
14046         XmlWriter m_xml;\par
14047         {\cf18 int} m_sectionDepth = 0;\par
14048     \};\par
14049 \par
14050 \} {\cf20 // end namespace Catch}\par
14051 \par
14052 {\cf21 #endif }{\cf20 // CATCH_REPORTER_XML_HPP_INCLUDED}\par
14053 \par
14054 {\cf21 #endif }{\cf20 // CATCH_REPORTERS_ALL_HPP_INCLUDED}\par
14055 \par
14056 {\cf21 #endif }{\cf20 // CATCH_ALL_HPP_INCLUDED}\par
14057 {\cf21 #endif }{\cf20 // CATCH_AMALGAMATED_HPP_INCLUDED}\par
}
}