{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referência do Arquivo test/catch_amalgamated.cpp\par \pard\plain 
{\tc\tcl2 \v test/catch_amalgamated.cpp}
{\xe \v test/catch_amalgamated.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "catch_amalgamated.hpp"}\par
{\f2 #include <cmath>}\par
{\f2 #include <limits>}\par
{\f2 #include <fstream>}\par
{\f2 #include <cassert>}\par
{\f2 #include <stack>}\par
{\f2 #include <exception>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <set>}\par
{\f2 #include <cctype>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <ostream>}\par
{\f2 #include <chrono>}\par
{\f2 #include <random>}\par
{\f2 #include <utility>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <cerrno>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <cstring>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <sstream>}\par
{\f2 #include <ctime>}\par
{\f2 #include <iostream>}\par
{\f2 #include <cstdint>}\par
{\f2 #include <iterator>}\par
{\f2 #include <type_traits>}\par
{\f2 #include <regex>}\par
{\f2 #include <cfloat>}\par
{\f2 #include <map>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::Generators::RandomFloatingGenerator::PImpl}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::SignalDefs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ReporterRegistry::ReporterRegistryImpl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::StringStreams}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Catch::ColumnInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Catch::TablePrinter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Benchmark}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Benchmark::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::literals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Generators}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Generators::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Clara}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Clara::Detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::TestCaseTracking}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::TextFlow}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Catch::Matchers::Detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definições e Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Digits}({\b x})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definições de Tipos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Catch::RegistryHubSingleton} = Singleton<RegistryHub, {\b IRegistryHub}, {\b IMutableRegistryHub}>\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerações\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Matchers::Detail::FloatingPointKind} : uint8_t \{ {\b Catch::Matchers::Detail::Float}
, {\b Catch::Matchers::Detail::Double}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b Catch::Justification} \{ {\b Catch::Left}
, {\b Catch::Right}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b if} ({\b w}< 6.250000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::weighted_average_quantile} (int k, int q, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OutlierClassification} {\b Catch::Benchmark::Detail::classify_outliers} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::mean} (double const *first, double const *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::normal_cdf} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::erfc_inv} (double {\b x})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::Benchmark::Detail::normal_quantile} (double {\b p})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Estimate}< double > {\b Catch::Benchmark::Detail::bootstrap} (double confidence_level, double *first, double *last, {\b sample} const &resample, double(*estimator)(double const *, double const *))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bootstrap_analysis} {\b Catch::Benchmark::Detail::analyse_samples} (double confidence_level, unsigned int n_resamples, double *first, double *last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b Catch::literals::operator""_a} (long double val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Approx} {\b Catch::literals::operator""_a} (unsigned long long val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b ProcessedReporterSpec} const &lhs, {\b ProcessedReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::getSeed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns Catch2's current RNG seed. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRegistryHub} const & {\b Catch::getRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IMutableRegistryHub} & {\b Catch::getMutableRegistryHub} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::translateActiveException} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator<} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b Tag} const &lhs, {\b Tag} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b TestCaseInfo} > {\b Catch::makeTestCaseInfo} ({\b StringRef} _className, {\b NameAndTags} const &nameAndTags, {\b SourceLineInfo} const &_lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator<} ({\b TestCaseInfo} const &lhs, {\b TestCaseInfo} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::convertIntoString} ({\b StringRef} string, bool escapeInvisibles)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases `string in quotes, and optionally escapes invisibles. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::convertIntoString} ({\b StringRef} string)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Encases {\f2 string}  in quotes, and escapes invisibles if user requested it via CLI. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Detail::rawMemoryToString} (const void *object, std::size_t size)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Detail::registerTranslatorImpl} ({\b Detail::unique_ptr}< {\b IExceptionTranslator} > &&translator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, {\b Version} const &version)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Version} const & {\b Catch::libraryVersion} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Generators::Detail::throw_generator_exception} (char const *msg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Throws {\b GeneratorException} with the provided message. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b Catch::Generators::acquireGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} const &lineInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IGeneratorTracker} * {\b Catch::Generators::createGeneratorTracker} ({\b StringRef} generatorName, {\b SourceLineInfo} lineInfo, {\b GeneratorBasePtr} &&generator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::Generators::Detail::getSeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExceptionMatchExpr} ({\b AssertionHandler} &handler, std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b Catch::Clara::Detail::convertInto} (std::string const &source, std::string &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ParserResult} {\b Catch::Clara::Detail::convertInto} (std::string const &source, bool &target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Clara::Parser} {\b Catch::makeCommandLineParser} ({\b ConfigData} &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< ColourImpl > {\b Catch::makeColourImpl} ({\b ColourMode} colourSelection, IStream *stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isColourImplAvailable} ({\b ColourMode} colourSelection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanUpContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Context} & {\b Catch::getCurrentMutableContext} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SimplePcg32} & {\b Catch::sharedRng} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::writeToDebugConsole} (std::string const &text)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isDebuggerActive} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::formatReconstructedExpression} (std::ostream &os, std::string const &lhs, {\b StringRef} op, std::string const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_exception} (std::exception const &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_logic_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_domain_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_runtime_error} (std::string const &msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b Catch::Detail::parseEnums} ({\b StringRef} enums)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Catch::Detail::unique_ptr}< {\b EnumInfo} > {\b Catch::Detail::makeEnumInfo} ({\b StringRef} enumName, {\b StringRef} allValueNames, std::vector< int > const &values)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Catch::Detail::convertToBits} (float f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Catch::Detail::convertToBits} (double d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::Detail::directCompare} (float lhs, float rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::Detail::directCompare} (double lhs, double rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char const * {\b Catch::Detail::getEnv} (char const *varName)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::makeStream} (std::string const &filename) -> {\b Detail::unique_ptr}< IStream >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator<<} (std::ostream &os, {\b LazyExpression} const &lazyExpr) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::list} (IEventListener &reporter, {\b Config} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< unsigned int > {\b Catch::parseUInt} (std::string const &input, int base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isnan} (float f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isnan} (double d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Catch::nextafter} (float {\b x}, float y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Catch::nextafter} (double {\b x}, double y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator!=} ({\b SimplePcg32} const &lhs, {\b SimplePcg32} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint32_t {\b Catch::generateRandomSeed} ({\b GenerateFrom} from)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b Catch::Detail::splitReporterSpec} ({\b StringRef} reporterSpec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Splits the reporter spec into reporter name and kv-pair options. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ColourMode} > {\b Catch::Detail::stringToColourMode} ({\b StringRef} colourMode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::operator==} ({\b ReporterSpec} const &lhs, {\b ReporterSpec} const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Optional}< {\b ReporterSpec} > {\b Catch::parseReporterSpec} ({\b StringRef} reporterSpec)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isOk} ({\b ResultWas::OfType} resultType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isJustInfo} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ResultDisposition::Flags} {\b Catch::operator|} ({\b ResultDisposition::Flags} lhs, {\b ResultDisposition::Flags} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldContinueOnFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldSuppressFailure} (int flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IResultCapture} & {\b Catch::getResultCapture} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::seedRng} ({\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b Catch::rngSeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::addSingleton} (ISingleton *singleton)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::cleanupSingletons} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, {\b SourceLineInfo} const &info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::cout} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::cerr} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::clog} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::startsWith} (std::string const &s, std::string const &prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::startsWith} ({\b StringRef} s, char prefix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::endsWith} (std::string const &s, std::string const &suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::endsWith} (std::string const &s, char suffix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::contains} (std::string const &s, std::string const &infix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::toLowerInPlace} (std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::toLower} (std::string const &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Catch::toLower} (char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::trim} (std::string const &str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringRef} {\b Catch::trim} ({\b StringRef} ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::replaceInPlace} (std::string &str, std::string const &replaceThis, std::string const &withThis)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b StringRef} > {\b Catch::splitStringRef} ({\b StringRef} str, char delimiter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, pluralise const &pluraliser)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator<<} (std::ostream &os, {\b StringRef} str) -> std::ostream &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::operator+} ({\b StringRef} lhs, {\b StringRef} rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b Catch::operator+=} (std::string &lhs, {\b StringRef} rhs) -> std::string &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > {\b Catch::sortTests} ({\b IConfig} const &config, std::vector< {\b TestCaseHandle} > const &unsortedTestCases)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::isThrowSafe} ({\b TestCaseHandle} const &testCase, {\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > {\b Catch::filterTests} (std::vector< {\b TestCaseHandle} > const &testCases, {\b TestSpec} const &testSpec, {\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b TestCaseHandle} > const & {\b Catch::getAllTestCasesSorted} ({\b IConfig} const &config)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_test_failure_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::throw_test_skip_exception} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Detail::unique_ptr}< {\b ITestInvoker} > {\b Catch::makeTestInvoker} (void(*testAsFunction)())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::TextFlow::operator<<} (std::ostream &os, Column const &col)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Column {\b Catch::TextFlow::Spacer} (size_t spaceWidth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::TextFlow::operator<<} (std::ostream &os, Columns const &cols)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Column const &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Column &&lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns & {\b Catch::TextFlow::operator+=} (Columns &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns & {\b Catch::TextFlow::operator+=} (Columns &lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Columns const &lhs, Column const &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Columns {\b Catch::TextFlow::operator+} (Columns &&lhs, Column &&rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::uncaught_exceptions} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmlFormatting {\b Catch::operator|} (XmlFormatting lhs, XmlFormatting rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmlFormatting {\b Catch::operator&} (XmlFormatting lhs, XmlFormatting rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &os, XmlEncode const &xmlEncode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IsEmptyMatcher {\b Catch::Matchers::IsEmpty} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
HasSizeMatcher {\b Catch::Matchers::SizeIs} (std::size_t sz)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ExceptionMessageMatcher {\b Catch::Matchers::Message} (std::string const &message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinUlpsMatcher {\b Catch::Matchers::WithinULP} (double target, uint64_t maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinUlpsMatcher {\b Catch::Matchers::WithinULP} (float target, uint64_t maxUlpDiff)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinAbsMatcher {\b Catch::Matchers::WithinAbs} (double target, double margin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (double target, double eps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (double target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (float target, float eps)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WithinRelMatcher {\b Catch::Matchers::WithinRel} (float target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IsNaNMatcher {\b Catch::Matchers::IsNaN} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AllTrueMatcher {\b Catch::Matchers::AllTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
NoneTrueMatcher {\b Catch::Matchers::NoneTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
AnyTrueMatcher {\b Catch::Matchers::AnyTrue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StringEqualsMatcher {\b Catch::Matchers::Equals} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StringContainsMatcher {\b Catch::Matchers::ContainsSubstring} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
EndsWithMatcher {\b Catch::Matchers::EndsWith} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
StartsWithMatcher {\b Catch::Matchers::StartsWith} (std::string const &str, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RegexMatcher {\b Catch::Matchers::Matches} (std::string const &regex, {\b CaseSensitive} caseSensitivity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::Matchers::Detail::describe_multi_matcher} ({\b StringRef} combine, std::string const *descriptions_begin, std::string const *descriptions_end)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::handleExceptionMatchExpr} ({\b AssertionHandler} &handler, StringMatcher const &matcher)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::getFormattedDuration} (double duration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Catch::shouldShowDuration} ({\b IConfig} const &config, double duration)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Catch::serializeFilters} (std::vector< std::string > const &filters)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b Catch::operator<<} (std::ostream &out, lineOfChars {\b value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListReporters} (std::ostream &out, std::vector< ReporterDescription > const &descriptions, {\b Verbosity} verbosity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListListeners} (std::ostream &out, std::vector< ListenerDescription > const &descriptions)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListTags} (std::ostream &out, std::vector< TagInfo > const &tags, bool isFiltered)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::defaultListTests} (std::ostream &out, ColourImpl *streamColour, std::vector< {\b TestCaseHandle} > const &tests, bool isFiltered, {\b Verbosity} verbosity)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::printTestRunTotals} (std::ostream &stream, ColourImpl &streamColour, {\b Totals} const &totals)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Detail::registerReporterImpl} (std::string const &name, {\b IReporterFactoryPtr} reporterPtr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Catch::Detail::registerListenerImpl} ({\b Detail::unique_ptr}< EventListenerFactory > listenerFactory)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variáveis\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b w} = -log( ( 1.0 - {\b x} ) * ( 1.0 + {\b x} ) )\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b p} = -2.7109920616438573243e-11\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b else}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
return {\b p} * {\b x}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descrição detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file provides platform specific implementations of FatalConditionHandler\par
This means that there is a lot of conditional compilation, and platform specific code. Currently, Catch2 supports a dummy handler (if no handler is desired), and 2 platform specific handlers:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Windows' SEH\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
POSIX signals\par}
\par
Consequently, various pieces of code below are compiled if either of the platform specific handlers is enabled, or if none of them are enabled. It is assumed that both cannot be enabled at the same time, and doing so should cause a compilation error.\par
If another platform specific handler is added, the compile guards below will need to be updated taking these assumptions into account. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Definições e macros\par
\pard\plain 
{\xe \v Digits\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:Digits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Digits( {\b x})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( x & 0xFF'FF'FF'FF )            std::uint64_t lhs_low = Digits( lhs );            std::uint64_t rhs_low = Digits( rhs );            std::uint64_t low_low = ( lhs_low * rhs_low );            std::uint64_t high_high = CarryBits( lhs ) * CarryBits( rhs );                        std::uint64_t high_low =                ( CarryBits( lhs ) * rhs_low ) + CarryBits( low_low );                                    std::uint64_t low_high =                ( lhs_low * CarryBits( rhs ) ) + Digits( high_low );            {\cf19 return} \{ high_high + CarryBits( high_low ) + CarryBits( low_high ),                     ( low_high << 32 ) | Digits( low_low ) \};#undef CarryBits#undef Digits        \}                {\cf17 inline} ExtendedMultResult<std::uint64_t>        extendedMult( std::uint64_t lhs, std::uint64_t rhs ) \{#{\cf19 if} defined( CATCH_CONFIG_UINT128 )            {\cf17 auto} result = __uint128_t( lhs ) * __uint128_t( rhs );            {\cf19 return} \{ {\cf17 static_cast<}std::uint64_t{\cf17 >}( result >> 64 ),                     {\cf17 static_cast<}std::uint64_t{\cf17 >}( result ) \};#elif defined( CATCH_CONFIG_MSVC_UMUL128 )            std::uint64_t high;            std::uint64_t low = _umul128( lhs, rhs, &high );            {\cf19 return} \{ high, low \};#{\cf19 else}            {\cf19 return} extendedMultPortable( lhs, rhs );#endif        \}        {\cf17 template} <{\cf17 typename} UInt>        {\cf17 constexpr} ExtendedMultResult<UInt> extendedMult( UInt lhs, UInt rhs ) \{            {\cf17 static_assert}( std::is_unsigned<UInt>::value,                           {\cf22 "extendedMult can only handle unsigned integers"} );            {\cf17 static_assert}( {\cf17 sizeof}( UInt ) < {\cf17 sizeof}( std::uint64_t ),                           {\cf22 "Generic extendedMult can only handle types smaller "}                           {\cf22 "than uint64_t"} );            {\cf17 using }WideType = DoubleWidthUnsignedType_t<UInt>;            {\cf17 auto} result = WideType( lhs ) * WideType( rhs );            {\cf19 return} \{                {\cf17 static_cast<}UInt{\cf17 >}( result >> ( CHAR_BIT * {\cf17 sizeof}( UInt ) ) ),                {\cf17 static_cast<}UInt{\cf17 >}( result & UInt( -1 ) ) \};        \}        {\cf17 template} <{\cf17 typename} TargetType,                  {\cf17 typename} Generator>            std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) >= {\cf17 sizeof}(TargetType),            TargetType> fillBitsFrom(Generator& gen) \{            {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;            {\cf17 static_assert}( std::is_unsigned<TargetType>::value, {\cf22 "Only unsigned integers are supported"} );            {\cf17 static_assert}( Generator::min() == 0 &&                           Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),                           {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );                                    {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;            {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;            {\cf19 return} {\cf17 static_cast<}TargetType{\cf17 >}( gen() >>                                            ( generated_bits - return_bits) );        \}        {\cf17 template} <{\cf17 typename} TargetType,                  {\cf17 typename} Generator>            std::enable_if_t<{\cf17 sizeof}({\cf17 typename} Generator::result_type) < {\cf17 sizeof}(TargetType),            TargetType> fillBitsFrom(Generator& gen) \{            {\cf17 using }gresult_type = {\cf17 typename} Generator::result_type;            {\cf17 static_assert}( std::is_unsigned<TargetType>::value,                           {\cf22 "Only unsigned integers are supported"} );            {\cf17 static_assert}( Generator::min() == 0 &&                           Generator::max() == {\cf17 static_cast<}gresult_type{\cf17 >}( -1 ),                           {\cf22 "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)"} );            {\cf17 constexpr} {\cf17 auto} generated_bits = {\cf17 sizeof}( gresult_type ) * CHAR_BIT;            {\cf17 constexpr} {\cf17 auto} return_bits = {\cf17 sizeof}( TargetType ) * CHAR_BIT;            std::size_t filled_bits = 0;            TargetType ret = 0;            {\cf19 do} \{                ret <<= generated_bits;                ret |= gen();                filled_bits += generated_bits;            \} {\cf19 while} ( filled_bits < return_bits );            {\cf19 return} ret;        \}                {\cf17 template} <{\cf17 typename} OriginalType, {\cf17 typename} Un{\cf18 signed}Type>        std::enable_if_t<std::is_signed<OriginalType>::value, UnsignedType>        transposeToNaturalOrder( UnsignedType in ) \{            {\cf17 static_assert}(                {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),                {\cf22 "reordering requires the same sized types on both sides"} );            {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value,                           {\cf22 "Input type must be unsigned"} );                                                            {\cf17 constexpr} {\cf17 auto} highest_bit =                UnsignedType( 1 ) << ( {\cf17 sizeof}( UnsignedType ) * CHAR_BIT - 1 );            {\cf19 return} {\cf17 static_cast<}UnsignedType{\cf17 >}( in ^ highest_bit );        \}        {\cf17 template} <{\cf17 typename} OriginalType,                  {\cf17 typename} Un{\cf18 signed}Type>        std::enable_if_t<std::is_unsigned<OriginalType>::value, UnsignedType>            transposeToNaturalOrder(UnsignedType in) \{            {\cf17 static_assert}(                {\cf17 sizeof}( OriginalType ) == {\cf17 sizeof}( UnsignedType ),                {\cf22 "reordering requires the same sized types on both sides"} );            {\cf17 static_assert}( std::is_unsigned<UnsignedType>::value, {\cf22 "Input type must be unsigned"} );                        {\cf19 return} in;        \}    \} \} #endif {\cf17 namespace }Catch \{{\cf17 template} <{\cf17 typename} IntegerType>{\cf17 class }uniform_integer_distribution \{    {\cf17 static_assert}(std::is_integral<IntegerType>::value, {\cf22 "..."});    {\cf17 using }UnsignedIntegerType = Detail::SizedUnsignedType_t<{\cf17 sizeof}(IntegerType)>;                        UnsignedIntegerType m_a;        UnsignedIntegerType m_ab_distance;                            UnsignedIntegerType m_rejection_threshold = 0;    UnsignedIntegerType computeDistance(IntegerType a, IntegerType b){\cf17  const }\{                        {\cf19 return} transposeTo(b) - transposeTo(a) + 1;    \}    {\cf17 static} UnsignedIntegerType computeRejectionThreshold(UnsignedIntegerType ab_distance) \{                        {\cf19 if} ( ab_distance == 0 ) \{ {\cf19 return} 0; \}        {\cf19 return} ( ~ab_distance + 1 ) % ab_distance;    \}    {\cf17 static} UnsignedIntegerType transposeTo(IntegerType in) \{        {\cf19 return} Detail::transposeToNaturalOrder<IntegerType>(            {\cf17 static_cast<}UnsignedIntegerType{\cf17 >}( in ) );    \}    {\cf17 static} IntegerType transposeBack(UnsignedIntegerType in) \{        {\cf19 return} {\cf17 static_cast<}IntegerType{\cf17 >}(            Detail::transposeToNaturalOrder<IntegerType>(in) );    \}{\cf17 public}:    {\cf17 using }result_type = IntegerType;    uniform_integer_distribution( IntegerType a, IntegerType b ):        m_a( transposeTo(a) ),        m_ab_distance( computeDistance(a, b) ),        m_rejection_threshold( computeRejectionThreshold(m_ab_distance) ) \{        assert( a <= b );    \}    {\cf17 template} <{\cf17 typename} Generator>    result_type operator()( Generator& g ) \{                {\cf19 if} ( m_ab_distance == 0 ) \{            {\cf19 return} transposeBack( Detail::fillBitsFrom<UnsignedIntegerType>( g ) );        \}        {\cf17 auto} random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );        {\cf17 auto} emul = Detail::extendedMult( random_number, m_ab_distance );                        {\cf19 while} (emul.lower < m_rejection_threshold) \{            random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );            emul = Detail::extendedMult( random_number, m_ab_distance );        \}        {\cf19 return} transposeBack(m_a + emul.upper);    \}    result_type a(){\cf17  const }\{ {\cf19 return} transposeBack(m_a); \}    result_type b(){\cf17  const }\{ {\cf19 return} transposeBack(m_ab_distance + m_a - 1); \}\};\} #endif #ifndef CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED#define CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED#ifndef CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED#define CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED#ifndef CATCH_POLYFILLS_HPP_INCLUDED#define CATCH_POLYFILLS_HPP_INCLUDEDnamespace Catch \{    {\cf18 bool} isnan({\cf18 float} f);    {\cf18 bool} isnan({\cf18 double} d);    {\cf18 float} nextafter({\cf18 float} x, {\cf18 float} y);    {\cf18 double} nextafter({\cf18 double} x, {\cf18 double} y);\}#endif #include <cassert>#include <cmath>#include <cstdint>#include <limits>#include <type_traits>{\cf17 namespace }Catch \{    {\cf17 namespace }Detail \{                {\cf17 template} <{\cf17 typename} FloatType>        FloatType gamma(FloatType a, FloatType b) \{            {\cf17 static_assert}( std::is_floating_point<FloatType>::value,                           {\cf22 "gamma returns the largest ULP magnitude within "}                           {\cf22 "floating point range [a, b]. This only makes sense "}                           {\cf22 "for floating point types"} );            assert( a <= b );            {\cf17 const} {\cf17 auto} gamma_up = Catch::nextafter( a, std::numeric_limits<FloatType>::infinity() ) - a;            {\cf17 const} {\cf17 auto} gamma_down = b - Catch::nextafter( b, -std::numeric_limits<FloatType>::infinity() );            {\cf19 return} gamma_up < gamma_down ? gamma_down : gamma_up;        \}        template <typename FloatingPoint>        {\cf17 struct }DistanceTypePicker;        {\cf17 template} <>        {\cf17 struct }DistanceTypePicker<float> \{            {\cf17 using }type = std::uint32_t;        \};        {\cf17 template} <>        {\cf17 struct }DistanceTypePicker<double> \{            {\cf17 using }type = std::uint64_t;        \};        {\cf17 template} <{\cf17 typename} T>        {\cf17 using }DistanceType = {\cf17 typename} DistanceTypePicker<T>::type;#{\cf19 if} defined( __GNUC__ ) || defined( __clang__ ){\cf21 #    pragma GCC diagnostic push#    pragma GCC diagnostic ignored "-Wfloat-equal"#endif                template <typename FloatType>        DistanceType<FloatType>        count_equidistant_floats( FloatType a, FloatType b, FloatType distance ) \{            assert( a <= b );                                    const auto ag = a / distance;            const auto bg = b / distance;            const auto s = bg - ag;            const auto err = ( std::fabs( a ) <= std::fabs( b ) )                                 ? -ag - ( s - bg )                                 : bg - ( s + ag );            const auto ceil_s = static_cast<DistanceType<FloatType>>( std::ceil( s ) );            return ( ceil_s != s ) ? ceil_s : ceil_s + ( err > 0 );        \}#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif    \}\} #endif #include <cmath>#include <type_traits>namespace Catch \{    namespace Detail \{#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic push#    pragma GCC diagnostic ignored "-Wfloat-equal"#endif                                        constexpr std::uint64_t calculate_max_steps_in_one_go(double gamma) \{            if ( gamma == 1.99584030953472e+292 ) \{ return 9007199254740991; \}            return static_cast<std::uint64_t>( -1 );        \}        constexpr std::uint32_t calculate_max_steps_in_one_go(float gamma) \{            if ( gamma == 2.028241e+31f ) \{ return 16777215; \}            return static_cast<std::uint32_t>( -1 );        \}#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif    \}template <typename FloatType>class uniform_floating_point_distribution \{    static_assert(std::is_floating_point<FloatType>::value, "...");    static_assert(!std::is_same<FloatType, long double>::value,                  "We do not support long double due to inconsistent behaviour between platforms");    using WidthType = Detail::DistanceType<FloatType>;    FloatType m_a, m_b;    FloatType m_ulp_magnitude;    WidthType m_floats_in_range;    uniform_integer_distribution<WidthType> m_int_dist;                WidthType m_max_steps_in_one_go;        bool m_a_has_leq_magnitude;public:    using result_type = FloatType;    uniform_floating_point_distribution( FloatType a, FloatType b ):        m_a( a ),        m_b( b ),        m_ulp_magnitude( Detail::gamma( m_a, m_b ) ),        m_floats_in_range( Detail::count_equidistant_floats( m_a, m_b, m_ulp_magnitude ) ),        m_int_dist(0, m_floats_in_range),        m_max_steps_in_one_go( Detail::calculate_max_steps_in_one_go(m_ulp_magnitude)),        m_a_has_leq_magnitude(std::fabs(m_a) <= std::fabs(m_b))    \{        assert( a <= b );    \}    template <typename Generator>    result_type operator()( Generator& g ) \{        WidthType steps = m_int_dist( g );        if ( m_a_has_leq_magnitude ) \{            if ( steps == m_floats_in_range ) \{ return m_a; \}            auto b = m_b;            while (steps > m_max_steps_in_one_go) \{                b -= m_max_steps_in_one_go * m_ulp_magnitude;                steps -= m_max_steps_in_one_go;            \}            return b - steps * m_ulp_magnitude;        \} else \{            if ( steps == m_floats_in_range ) \{ return m_b; \}            auto a = m_a;            while (steps > m_max_steps_in_one_go) \{                a += m_max_steps_in_one_go * m_ulp_magnitude;                steps -= m_max_steps_in_one_go;            \}            return a + steps * m_ulp_magnitude;        \}    \}    result_type a() const \{ return m_a; \}    result_type b() const \{ return m_b; \}\};\} #endif namespace Catch \{namespace Generators \{namespace Detail \{                std::uint32_t getSeed();\}template <typename Float>class RandomFloatingGenerator final : public IGenerator<Float> \{    Catch::SimplePcg32 m_rng;    Catch::uniform_floating_point_distribution<Float> m_dist;    Float m_current_number;public:    RandomFloatingGenerator( Float a, Float b, std::uint32_t seed ):        m_rng(seed),        m_dist(a, b) \{        static_cast<void>(next());    \}    Float const& get() const override \{        return m_current_number;    \}    bool next() override \{        m_current_number = m_dist(m_rng);        return true;    \}\};template <>class RandomFloatingGenerator<long double> final : public IGenerator<long double> \{            struct PImpl;    Catch::Detail::unique_ptr<PImpl> m_pimpl;    long double m_current_number;public:    RandomFloatingGenerator( long double a, long double b, std::uint32_t seed );    long double const& get() const override \{ return m_current_number; \}    bool next() override;    ~RandomFloatingGenerator() override; \};template <typename Integer>class RandomIntegerGenerator final : public IGenerator<Integer> \{    Catch::SimplePcg32 m_rng;    Catch::uniform_integer_distribution<Integer> m_dist;    Integer m_current_number;public:    RandomIntegerGenerator( Integer a, Integer b, std::uint32_t seed ):        m_rng(seed),        m_dist(a, b) \{        static_cast<void>(next());    \}    Integer const& get() const override \{        return m_current_number;    \}    bool next() override \{        m_current_number = m_dist(m_rng);        return true;    \}\};template <typename T>std::enable_if_t<std::is_integral<T>::value, GeneratorWrapper<T>>random(T a, T b) \{    return GeneratorWrapper<T>(        Catch::Detail::make_unique<RandomIntegerGenerator<T>>(a, b, Detail::getSeed())    );\}template <typename T>std::enable_if_t<std::is_floating_point<T>::value,GeneratorWrapper<T>>random(T a, T b) \{    return GeneratorWrapper<T>(        Catch::Detail::make_unique<RandomFloatingGenerator<T>>(a, b, Detail::getSeed())    );\}\} \} #endif #ifndef CATCH_GENERATORS_RANGE_HPP_INCLUDED#define CATCH_GENERATORS_RANGE_HPP_INCLUDED#include <iterator>#include <type_traits>namespace Catch \{namespace Generators \{template <typename T>class RangeGenerator final : public IGenerator<T> \{    T m_current;    T m_end;    T m_step;    bool m_positive;public:    RangeGenerator(T const& start, T const& end, T const& step):        m_current(start),        m_end(end),        m_step(step),        m_positive(m_step > T(0))    \{        assert(m_current != m_end && "Range start and end cannot be equal");        assert(m_step != T(0) && "Step size cannot be zero");        assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");    \}    RangeGenerator(T const& start, T const& end):        RangeGenerator(start, end, (start < end) ? T(1) : T(-1))    \{\}    T const& get() const override \{        return m_current;    \}    bool next() override \{        m_current += m_step;        return (m_positive) ? (m_current < m_end) : (m_current > m_end);    \}\};template <typename T>GeneratorWrapper<T> range(T const& start, T const& end, T const& step) \{    static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end, step));\}template <typename T>GeneratorWrapper<T> range(T const& start, T const& end) \{    static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end));\}template <typename T>class IteratorGenerator final : public IGenerator<T> \{    static_assert(!std::is_same<T, bool>::value,        "IteratorGenerator currently does not support bools"        "because of std::vector<bool> specialization");    std::vector<T> m_elems;    size_t m_current = 0;public:    template <typename InputIterator, typename InputSentinel>    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) \{        if (m_elems.empty()) \{            Detail::throw_generator_exception("IteratorGenerator received no valid values");        \}    \}    T const& get() const override \{        return m_elems[m_current];    \}    bool next() override \{        ++m_current;        return m_current != m_elems.size();    \}\};template <typename InputIterator,          typename InputSentinel,          typename ResultType = typename std::iterator_traits<InputIterator>::value_type>GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) \{    return GeneratorWrapper<ResultType>(Catch::Detail::make_unique<IteratorGenerator<ResultType>>(from, to));\}template <typename Container>auto from_range(Container const& cnt) \{    using std::begin;    using std::end;    return from_range( begin( cnt ), end( cnt ) );\}\} \} #endif #endif #ifndef CATCH_INTERFACES_ALL_HPP_INCLUDED#define CATCH_INTERFACES_ALL_HPP_INCLUDED#ifndef CATCH_INTERFACES_REPORTER_HPP_INCLUDED#define CATCH_INTERFACES_REPORTER_HPP_INCLUDED#ifndef CATCH_TEST_RUN_INFO_HPP_INCLUDED#define CATCH_TEST_RUN_INFO_HPP_INCLUDEDnamespace Catch \{    struct TestRunInfo \{        constexpr TestRunInfo(StringRef _name) : name(_name) \{\}        StringRef name;    \};\} #endif #include <map>#include <string>#include <vector>#include <iosfwd>namespace Catch \{    struct ReporterDescription;    struct ListenerDescription;    struct TagInfo;    struct TestCaseInfo;    class TestCaseHandle;    class IConfig;    class IStream;    enum class ColourMode : std::uint8_t;    struct ReporterConfig \{        ReporterConfig( IConfig const* _fullConfig,                        Detail::unique_ptr<IStream> _stream,                        ColourMode colourMode,                        std::map<std::string, std::string> customOptions );        ReporterConfig( ReporterConfig&& ) = default;        ReporterConfig& operator=( ReporterConfig&& ) = default;        ~ReporterConfig();         Detail::unique_ptr<IStream> takeStream() &&;        IConfig const* fullConfig() const;        ColourMode colourMode() const;        std::map<std::string, std::string> const& customOptions() const;    private:        Detail::unique_ptr<IStream> m_stream;        IConfig const* m_fullConfig;        ColourMode m_colourMode;        std::map<std::string, std::string> m_customOptions;    \};    struct AssertionStats \{        AssertionStats( AssertionResult const& _assertionResult,                        std::vector<MessageInfo> const& _infoMessages,                        Totals const& _totals );        AssertionStats( AssertionStats const& )              = default;        AssertionStats( AssertionStats && )                  = default;        AssertionStats& operator = ( AssertionStats const& ) = delete;        AssertionStats& operator = ( AssertionStats && )     = delete;        AssertionResult assertionResult;        std::vector<MessageInfo> infoMessages;        Totals totals;    \};    struct SectionStats \{        SectionStats(   SectionInfo&& _sectionInfo,                        Counts const& _assertions,                        double _durationInSeconds,                        bool _missingAssertions );        SectionInfo sectionInfo;        Counts assertions;        double durationInSeconds;        bool missingAssertions;    \};    struct TestCaseStats \{        TestCaseStats(  TestCaseInfo const& _testInfo,                        Totals const& _totals,                        std::string&& _stdOut,                        std::string&& _stdErr,                        bool _aborting );        TestCaseInfo const * testInfo;        Totals totals;        std::string stdOut;        std::string stdErr;        bool aborting;    \};    struct TestRunStats \{        TestRunStats(   TestRunInfo const& _runInfo,                        Totals const& _totals,                        bool _aborting );        TestRunInfo runInfo;        Totals totals;        bool aborting;    \};                struct ReporterPreferences \{                        bool shouldRedirectStdOut = false;                        bool shouldReportAllAssertions = false;    \};        class IEventListener \{    protected:                ReporterPreferences m_preferences;                IConfig const* m_config;    public:        IEventListener( IConfig const* config ): m_config( config ) \{\}        virtual ~IEventListener();                         ReporterPreferences const& getPreferences() const \{            return m_preferences;        \}                virtual void noMatchingTestCases( StringRef unmatchedSpec ) = 0;                virtual void reportInvalidTestSpec( StringRef invalidArgument ) = 0;                virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;                virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;                virtual void testCasePartialStarting( TestCaseInfo const& testInfo, uint64_t partNumber ) = 0;                virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;                virtual void benchmarkPreparing( StringRef benchmarkName ) = 0;                virtual void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) = 0;                virtual void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) = 0;                virtual void benchmarkFailed( StringRef benchmarkName ) = 0;                virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;                virtual void assertionEnded( AssertionStats const& assertionStats ) = 0;                virtual void sectionEnded( SectionStats const& sectionStats ) = 0;                virtual void testCasePartialEnded(TestCaseStats const& testCaseStats, uint64_t partNumber ) = 0;                virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;                virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;                virtual void skipTest( TestCaseInfo const& testInfo ) = 0;                virtual void fatalErrorEncountered( StringRef error ) = 0;                virtual void listReporters(std::vector<ReporterDescription> const& descriptions) = 0;                virtual void listListeners(std::vector<ListenerDescription> const& descriptions) = 0;                virtual void listTests(std::vector<TestCaseHandle> const& tests) = 0;                virtual void listTags(std::vector<TagInfo> const& tags) = 0;    \};    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;\} #endif #ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED#define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED#include <string>namespace Catch \{    struct ReporterConfig;    class IConfig;    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;    class IReporterFactory \{    public:        virtual ~IReporterFactory();         virtual IEventListenerPtr        create( ReporterConfig&& config ) const = 0;        virtual std::string getDescription() const = 0;    \};    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;    class EventListenerFactory \{    public:        virtual ~EventListenerFactory();         virtual IEventListenerPtr create( IConfig const* config ) const = 0;                virtual StringRef getName() const = 0;                virtual std::string getDescription() const = 0;    \};\} #endif #ifndef CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED#define CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED#include <string>namespace Catch \{    struct TagAlias;    class ITagAliasRegistry \{    public:        virtual ~ITagAliasRegistry();                 virtual TagAlias const* find( std::string const& alias ) const = 0;        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;        static ITagAliasRegistry const& get();    \};\} #endif #ifndef CATCH_INTERFACES_TESTCASE_HPP_INCLUDED#define CATCH_INTERFACES_TESTCASE_HPP_INCLUDED#include <vector>namespace Catch \{    struct TestCaseInfo;    class TestCaseHandle;    class IConfig;    class ITestCaseRegistry \{    public:        virtual ~ITestCaseRegistry();                 virtual std::vector<TestCaseInfo* > const& getAllInfos() const = 0;        virtual std::vector<TestCaseHandle> const& getAllTests() const = 0;        virtual std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const = 0;    \};\}#endif #endif #ifndef CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED#define CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDEDnamespace Catch \{    namespace Detail \{                struct CaseInsensitiveLess \{            bool operator()( StringRef lhs,                             StringRef rhs ) const;        \};                struct CaseInsensitiveEqualTo \{            bool operator()( StringRef lhs,                             StringRef rhs ) const;        \};    \} \} #endif #ifndef CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED#define CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED#if defined(__ANDROID__)#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE#endif#if defined( CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE ) && \\    !defined( CATCH_CONFIG_NO_ANDROID_LOGWRITE ) &&      \\    !defined( CATCH_CONFIG_ANDROID_LOGWRITE )#    define CATCH_CONFIG_ANDROID_LOGWRITE#endif#endif #ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#if defined(_MSC_VER)#  if _MSC_VER >= 1900 #    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#  endif#endif#include <exception>#if defined(__cpp_lib_uncaught_exceptions) \\    && !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#endif #if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \\    && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \\    && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS#endif#endif #ifndef CATCH_CONSOLE_COLOUR_HPP_INCLUDED#define CATCH_CONSOLE_COLOUR_HPP_INCLUDED#include <iosfwd>#include <cstdint>namespace Catch \{    enum class ColourMode : std::uint8_t;    class IStream;    struct Colour \{        enum Code \{            None = 0,            White,            Red,            Green,            Blue,            Cyan,            Yellow,            Grey,            Bright = 0x10,            BrightRed = Bright | Red,            BrightGreen = Bright | Green,            LightGrey = Bright | Grey,            BrightWhite = Bright | White,            BrightYellow = Bright | Yellow,                        FileName = LightGrey,            Warning = BrightYellow,            ResultError = BrightRed,            ResultSuccess = BrightGreen,            ResultExpectedFailure = Warning,            Error = BrightRed,            Success = Green,            Skip = LightGrey,            OriginalExpression = Cyan,            ReconstructedExpression = BrightYellow,            SecondaryText = LightGrey,            Headers = White        \};    \};    class ColourImpl \{    protected:                IStream* m_stream;    public:        ColourImpl( IStream* stream ): m_stream( stream ) \{\}                        class ColourGuard \{            ColourImpl const* m_colourImpl;            Colour::Code m_code;            bool m_engaged = false;        public:                        ColourGuard( Colour::Code code,                         ColourImpl const* colour );            ColourGuard( ColourGuard const& rhs ) = delete;            ColourGuard& operator=( ColourGuard const& rhs ) = delete;            ColourGuard( ColourGuard&& rhs ) noexcept;            ColourGuard& operator=( ColourGuard&& rhs ) noexcept;                        ~ColourGuard();                        ColourGuard& engage( std::ostream& stream ) &;                        ColourGuard&& engage( std::ostream& stream ) &&;        private:                        friend std::ostream& operator<<( std::ostream& lhs,                                             ColourGuard& guard ) \{                guard.engageImpl( lhs );                return lhs;            \}                        friend std::ostream& operator<<( std::ostream& lhs,                                            ColourGuard&& guard) \{                guard.engageImpl( lhs );                return lhs;            \}            void engageImpl( std::ostream& stream );        \};        virtual ~ColourImpl();                 ColourGuard guardColour( Colour::Code colourCode );    private:        virtual void use( Colour::Code colourCode ) const = 0;    \};        Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,                                                   IStream* stream );        bool isColourImplAvailable( ColourMode colourSelection );\} #endif #ifndef CATCH_CONSOLE_WIDTH_HPP_INCLUDED#define CATCH_CONSOLE_WIDTH_HPP_INCLUDED#ifndef CATCH_CONFIG_CONSOLE_WIDTH#define CATCH_CONFIG_CONSOLE_WIDTH 80#endif#endif #ifndef CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED#define CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED#include <cstddef>#include <initializer_list>#if defined(CATCH_CPP17_OR_GREATER) || defined(_MSC_VER)#include <string>#  if !defined(__cpp_lib_nonmember_container_access)#      define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS#  endif#else#define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS#endifnamespace Catch \{namespace Detail \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)    template <typename Container>    constexpr auto empty(Container const& cont) -> decltype(cont.empty()) \{        return cont.empty();    \}    template <typename T, std::size_t N>    constexpr bool empty(const T (&)[N]) noexcept \{                        (void)N;        return false;    \}    template <typename T>    constexpr bool empty(std::initializer_list<T> list) noexcept \{        return list.size() > 0;    \}    template <typename Container>    constexpr auto size(Container const& cont) -> decltype(cont.size()) \{        return cont.size();    \}    template <typename T, std::size_t N>    constexpr std::size_t size(const T(&)[N]) noexcept \{        return N;    \}#endif \} \} #endif #ifndef CATCH_DEBUG_CONSOLE_HPP_INCLUDED#define CATCH_DEBUG_CONSOLE_HPP_INCLUDED#include <string>namespace Catch \{    void writeToDebugConsole( std::string const& text );\}#endif #ifndef CATCH_DEBUGGER_HPP_INCLUDED#define CATCH_DEBUGGER_HPP_INCLUDEDnamespace Catch \{    bool isDebuggerActive();\}#ifdef CATCH_PLATFORM_MAC    #if defined(__i386__) || defined(__x86_64__)        #define CATCH_TRAP() __asm__("int $3\\n" : : )     #elif defined(__aarch64__)        #define CATCH_TRAP() __asm__(".inst 0xd43e0000")    #elif defined(__POWERPC__)        #define CATCH_TRAP() __asm__("li r0, 20\\nsc\\nnop\\nli r0, 37\\nli r4, 2\\nsc\\nnop\\n" \\        : : : "memory","r0","r3","r4" )     #endif#elif defined(CATCH_PLATFORM_IPHONE)        #if defined(__i386__) || defined(__x86_64__)        #define CATCH_TRAP()  __asm__("int $3")    #elif defined(__aarch64__)        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")    #elif defined(__arm__) && !defined(__thumb__)        #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")    #elif defined(__arm__) &&  defined(__thumb__)        #define CATCH_TRAP()  __asm__(".inst 0xde01")    #endif#elif defined(CATCH_PLATFORM_LINUX)                #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))        #define CATCH_TRAP() asm volatile ("int $3")     #else         #include <signal.h>        #define CATCH_TRAP() raise(SIGTRAP)    #endif#elif defined(_MSC_VER)    #define CATCH_TRAP() __debugbreak()#elif defined(__MINGW32__)    extern "C" __declspec(dllimport) void __stdcall DebugBreak();    #define CATCH_TRAP() DebugBreak()#endif#ifndef CATCH_BREAK_INTO_DEBUGGER    #ifdef CATCH_TRAP        #define CATCH_BREAK_INTO_DEBUGGER() []\{ if( Catch::isDebuggerActive() ) \{ CATCH_TRAP(); \} \}()    #else        #define CATCH_BREAK_INTO_DEBUGGER() []\{\}()    #endif#endif#endif #ifndef CATCH_ENFORCE_HPP_INCLUDED#define CATCH_ENFORCE_HPP_INCLUDED#include <exception>namespace Catch \{#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)    template <typename Ex>    [[noreturn]]    void throw_exception(Ex const& e) \{        throw e;    \}#else     [[noreturn]]    void throw_exception(std::exception const& e);#endif    [[noreturn]]    void throw_logic_error(std::string const& msg);    [[noreturn]]    void throw_domain_error(std::string const& msg);    [[noreturn]]    void throw_runtime_error(std::string const& msg);\} #define CATCH_MAKE_MSG(...) \\    (Catch::ReusableStringStream() << __VA_ARGS__).str()#define CATCH_INTERNAL_ERROR(...) \\    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))#define CATCH_ERROR(...) \\    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))#define CATCH_RUNTIME_ERROR(...) \\    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))#define CATCH_ENFORCE( condition, ... ) \\    do\{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); \} while(false)#endif #ifndef CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED#define CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED#include <vector>namespace Catch \{    namespace Detail \{        Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values );        class EnumValuesRegistry : public IMutableEnumValuesRegistry \{            std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;            EnumInfo const& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values) override;        \};        std::vector<StringRef> parseEnums( StringRef enums );    \} \} #endif #ifndef CATCH_ERRNO_GUARD_HPP_INCLUDED#define CATCH_ERRNO_GUARD_HPP_INCLUDEDnamespace Catch \{            class ErrnoGuard \{    public:                ErrnoGuard();        ~ErrnoGuard();    private:        int m_oldErrno;    \};\}#endif #ifndef CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED#define CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED#include <vector>#include <string>namespace Catch \{    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry \{    public:        ~ExceptionTranslatorRegistry() override;        void registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator );        std::string translateActiveException() const override;    private:        ExceptionTranslators m_translators;    \};\}#endif #ifndef CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED#define CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED#include <cassert>namespace Catch \{        class FatalConditionHandler \{        bool m_started = false;                                void engage_platform();        void disengage_platform() noexcept;    public:                FatalConditionHandler();        ~FatalConditionHandler();        void engage() \{            assert(!m_started && "Handler cannot be installed twice.");            m_started = true;            engage_platform();        \}        void disengage() noexcept \{            assert(m_started && "Handler cannot be uninstalled without being installed first");            m_started = false;            disengage_platform();        \}    \};        class FatalConditionHandlerGuard \{        FatalConditionHandler* m_handler;    public:        FatalConditionHandlerGuard(FatalConditionHandler* handler):            m_handler(handler) \{            m_handler->engage();        \}        ~FatalConditionHandlerGuard() \{            m_handler->disengage();        \}    \};\} #endif #ifndef CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED#define CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED#include <cassert>#include <cmath>#include <cstdint>#include <utility>#include <limits>namespace Catch \{    namespace Detail \{        uint32_t convertToBits(float f);        uint64_t convertToBits(double d);                        bool directCompare( float lhs, float rhs );        bool directCompare( double lhs, double rhs );    \} #if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic push            #    pragma GCC diagnostic ignored "-Wfloat-equal"#endif        template <typename FP>    uint64_t ulpDistance( FP lhs, FP rhs ) \{        assert( std::numeric_limits<FP>::is_iec559 &&            "ulpDistance assumes IEEE-754 format for floating point types" );        assert( !Catch::isnan( lhs ) &&                "Distance between NaN and number is not meaningful" );        assert( !Catch::isnan( rhs ) &&                "Distance between NaN and number is not meaningful" );                        if ( lhs == rhs ) \{ return 0; \}                static constexpr FP positive_zero\{\};                if ( lhs == positive_zero ) \{ lhs = positive_zero; \}        if ( rhs == positive_zero ) \{ rhs = positive_zero; \}                        if ( std::signbit( lhs ) != std::signbit( rhs ) ) \{            return ulpDistance( std::abs( lhs ), positive_zero ) +                   ulpDistance( std::abs( rhs ), positive_zero );        \}                                uint64_t lc = Detail::convertToBits( lhs );        uint64_t rc = Detail::convertToBits( rhs );                        if ( lc < rc ) \{            std::swap( lc, rc );        \}        return lc - rc;    \}#if defined( __GNUC__ ) || defined( __clang__ )#    pragma GCC diagnostic pop#endif\} #endif #ifndef CATCH_GETENV_HPP_INCLUDED#define CATCH_GETENV_HPP_INCLUDEDnamespace Catch \{namespace Detail \{        char const* getEnv(char const* varName);\}\}#endif #ifndef CATCH_IS_PERMUTATION_HPP_INCLUDED#define CATCH_IS_PERMUTATION_HPP_INCLUDED#include <algorithm>#include <iterator>namespace Catch \{    namespace Detail \{        template <typename ForwardIter,                  typename Sentinel,                  typename T,                  typename Comparator>        ForwardIter find_sentinel( ForwardIter start,                                   Sentinel sentinel,                                   T const& value,                                   Comparator cmp ) \{            while ( start != sentinel ) \{                if ( cmp( *start, value ) ) \{ break; \}                ++start;            \}            return start;        \}        template <typename ForwardIter,                  typename Sentinel,                  typename T,                  typename Comparator>        std::ptrdiff_t count_sentinel( ForwardIter start,                                       Sentinel sentinel,                                       T const& value,                                       Comparator cmp ) \{            std::ptrdiff_t count = 0;            while ( start != sentinel ) \{                if ( cmp( *start, value ) ) \{ ++count; \}                ++start;            \}            return count;        \}        template <typename ForwardIter, typename Sentinel>        std::enable_if_t<!std::is_same<ForwardIter, Sentinel>::value,                         std::ptrdiff_t>        sentinel_distance( ForwardIter iter, const Sentinel sentinel ) \{            std::ptrdiff_t dist = 0;            while ( iter != sentinel ) \{                ++iter;                ++dist;            \}            return dist;        \}        template <typename ForwardIter>        std::ptrdiff_t sentinel_distance( ForwardIter first,                                          ForwardIter last ) \{            return std::distance( first, last );        \}        template <typename ForwardIter1,                  typename Sentinel1,                  typename ForwardIter2,                  typename Sentinel2,                  typename Comparator>        bool check_element_counts( ForwardIter1 first_1,                                   const Sentinel1 end_1,                                   ForwardIter2 first_2,                                   const Sentinel2 end_2,                                   Comparator cmp ) \{            auto cursor = first_1;            while ( cursor != end_1 ) \{                if ( find_sentinel( first_1, cursor, *cursor, cmp ) ==                     cursor ) \{                                        const auto count_in_range_2 =                        count_sentinel( first_2, end_2, *cursor, cmp );                                                            if ( count_in_range_2 == 0 ) \{ return false; \}                    const auto count_in_range_1 =                        count_sentinel( cursor, end_1, *cursor, cmp );                    if ( count_in_range_1 != count_in_range_2 ) \{                        return false;                    \}                \}                ++cursor;            \}            return true;        \}        template <typename ForwardIter1,                  typename Sentinel1,                  typename ForwardIter2,                  typename Sentinel2,                  typename Comparator>        bool is_permutation( ForwardIter1 first_1,                             const Sentinel1 end_1,                             ForwardIter2 first_2,                             const Sentinel2 end_2,                             Comparator cmp ) \{                                                while (first_1 != end_1 && first_2 != end_2 && cmp(*first_1, *first_2)) \{                ++first_1;                ++first_2;            \}                        if (first_1 == end_1 || first_2 == end_2) \{                return first_1 == end_1 && first_2 == end_2;            \}                        auto dist_1 = sentinel_distance( first_1, end_1 );            auto dist_2 = sentinel_distance( first_2, end_2 );            if (dist_1 != dist_2) \{ return false; \}                                                return check_element_counts( first_1, end_1, first_2, end_2, cmp );        \}    \} \} #endif #ifndef CATCH_ISTREAM_HPP_INCLUDED#define CATCH_ISTREAM_HPP_INCLUDED#include <iosfwd>#include <cstddef>#include <ostream>#include <string>namespace Catch \{    class IStream \{    public:        virtual ~IStream();         virtual std::ostream& stream() = 0;                virtual bool isConsole() const \{ return false; \}    \};        auto makeStream( std::string const& filename ) -> Detail::unique_ptr<IStream>;\}#endif #ifndef CATCH_JSONWRITER_HPP_INCLUDED#define CATCH_JSONWRITER_HPP_INCLUDED#include <cstdint>#include <sstream>namespace Catch \{    class JsonObjectWriter;    class JsonArrayWriter;    struct JsonUtils \{        static void indent( std::ostream& os, std::uint64_t level );        static void appendCommaNewline( std::ostream& os,                                        bool& should_comma,                                        std::uint64_t level );    \};    class JsonValueWriter \{    public:        JsonValueWriter( std::ostream& os );        JsonValueWriter( std::ostream& os, std::uint64_t indent_level );        JsonObjectWriter writeObject() &&;        JsonArrayWriter writeArray() &&;        template <typename T>        void write( T const& value ) && \{            writeImpl( value, !std::is_arithmetic<T>::value );        \}        void write( StringRef value ) &&;        void write( bool value ) &&;    private:        void writeImpl( StringRef value, bool quote );                                        template <typename T,                  typename = typename std::enable_if_t<                      !std::is_convertible<T, StringRef>::value>>        void writeImpl( T const& value, bool quote_value ) \{            m_sstream << value;            writeImpl( m_sstream.str(), quote_value );        \}        std::ostream& m_os;        std::stringstream m_sstream;        std::uint64_t m_indent_level;    \};    class JsonObjectWriter \{    public:        JsonObjectWriter( std::ostream& os );        JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );        JsonObjectWriter( JsonObjectWriter&& source ) noexcept;        JsonObjectWriter& operator=( JsonObjectWriter&& source ) = delete;        ~JsonObjectWriter();        JsonValueWriter write( StringRef key );    private:        std::ostream& m_os;        std::uint64_t m_indent_level;        bool m_should_comma = false;        bool m_active = true;    \};    class JsonArrayWriter \{    public:        JsonArrayWriter( std::ostream& os );        JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );        JsonArrayWriter( JsonArrayWriter&& source ) noexcept;        JsonArrayWriter& operator=( JsonArrayWriter&& source ) = delete;        ~JsonArrayWriter();        JsonObjectWriter writeObject();        JsonArrayWriter writeArray();        template <typename T>        JsonArrayWriter& write( T const& value ) \{            return writeImpl( value );        \}        JsonArrayWriter& write( bool value );    private:        template <typename T>        JsonArrayWriter& writeImpl( T const& value ) \{            JsonUtils::appendCommaNewline(                m_os, m_should_comma, m_indent_level + 1 );            JsonValueWriter\{ m_os \}.write( value );            return *this;        \}        std::ostream& m_os;        std::uint64_t m_indent_level;        bool m_should_comma = false;        bool m_active = true;    \};\} #endif #ifndef CATCH_LEAK_DETECTOR_HPP_INCLUDED#define CATCH_LEAK_DETECTOR_HPP_INCLUDEDnamespace Catch \{    struct LeakDetector \{        LeakDetector();        ~LeakDetector();    \};\}#endif #ifndef CATCH_LIST_HPP_INCLUDED#define CATCH_LIST_HPP_INCLUDED#include <set>#include <string>namespace Catch \{    class IEventListener;    class Config;    struct ReporterDescription \{        std::string name, description;    \};    struct ListenerDescription \{        StringRef name;        std::string description;    \};    struct TagInfo \{        void add(StringRef spelling);        std::string all() const;        std::set<StringRef> spellings;        std::size_t count = 0;    \};    bool list( IEventListener& reporter, Config const& config );\} #endif #ifndef CATCH_OUTPUT_REDIRECT_HPP_INCLUDED#define CATCH_OUTPUT_REDIRECT_HPP_INCLUDED#include <cstdio>#include <iosfwd>#include <string>namespace Catch \{    class RedirectedStream \{        std::ostream& m_originalStream;        std::ostream& m_redirectionStream;        std::streambuf* m_prevBuf;    public:        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );        ~RedirectedStream();    \};    class RedirectedStdOut \{        ReusableStringStream m_rss;        RedirectedStream m_cout;    public:        RedirectedStdOut();        auto str() const -> std::string;    \};                class RedirectedStdErr \{        ReusableStringStream m_rss;        RedirectedStream m_cerr;        RedirectedStream m_clog;    public:        RedirectedStdErr();        auto str() const -> std::string;    \};    class RedirectedStreams \{    public:        RedirectedStreams(RedirectedStreams const&) = delete;        RedirectedStreams& operator=(RedirectedStreams const&) = delete;        RedirectedStreams(RedirectedStreams&&) = delete;        RedirectedStreams& operator=(RedirectedStreams&&) = delete;        RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);        ~RedirectedStreams();    private:        std::string& m_redirectedCout;        std::string& m_redirectedCerr;        RedirectedStdOut m_redirectedStdOut;        RedirectedStdErr m_redirectedStdErr;    \};#if defined(CATCH_CONFIG_NEW_CAPTURE)                    class TempFile \{    public:        TempFile(TempFile const&) = delete;        TempFile& operator=(TempFile const&) = delete;        TempFile(TempFile&&) = delete;        TempFile& operator=(TempFile&&) = delete;        TempFile();        ~TempFile();        std::FILE* getFile();        std::string getContents();    private:        std::FILE* m_file = nullptr;    #if defined(_MSC_VER)        char m_buffer[L_tmpnam] = \{ 0 \};    #endif    \};    class OutputRedirect \{    public:        OutputRedirect(OutputRedirect const&) = delete;        OutputRedirect& operator=(OutputRedirect const&) = delete;        OutputRedirect(OutputRedirect&&) = delete;        OutputRedirect& operator=(OutputRedirect&&) = delete;        OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);        ~OutputRedirect();    private:        int m_originalStdout = -1;        int m_originalStderr = -1;        TempFile m_stdoutFile;        TempFile m_stderrFile;        std::string& m_stdoutDest;        std::string& m_stderrDest;    \};#endif\} #endif #ifndef CATCH_PARSE_NUMBERS_HPP_INCLUDED#define CATCH_PARSE_NUMBERS_HPP_INCLUDED#include <string>namespace Catch \{        Optional<unsigned int> parseUInt(std::string const& input, int base = 10);\}#endif #ifndef CATCH_REPORTER_REGISTRY_HPP_INCLUDED#define CATCH_REPORTER_REGISTRY_HPP_INCLUDED#include <map>#include <string>#include <vector>namespace Catch \{    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;    class IReporterFactory;    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;    struct ReporterConfig;    class EventListenerFactory;    class ReporterRegistry \{        struct ReporterRegistryImpl;        Detail::unique_ptr<ReporterRegistryImpl> m_impl;    public:        ReporterRegistry();        ~ReporterRegistry();         IEventListenerPtr create( std::string const& name,                                  ReporterConfig&& config ) const;        void registerReporter( std::string const& name,                               IReporterFactoryPtr factory );        void        registerListener( Detail::unique_ptr<EventListenerFactory> factory );        std::map<std::string,                 IReporterFactoryPtr,                 Detail::CaseInsensitiveLess> const&        getFactories() const;        std::vector<Detail::unique_ptr<EventListenerFactory>> const&        getListeners() const;    \};\} #endif #ifndef CATCH_RUN_CONTEXT_HPP_INCLUDED#define CATCH_RUN_CONTEXT_HPP_INCLUDED#ifndef CATCH_TEST_CASE_TRACKER_HPP_INCLUDED#define CATCH_TEST_CASE_TRACKER_HPP_INCLUDED#include <string>#include <vector>namespace Catch \{namespace TestCaseTracking \{    struct NameAndLocation \{        std::string name;        SourceLineInfo location;        NameAndLocation( std::string&& _name, SourceLineInfo const& _location );        friend bool operator==(NameAndLocation const& lhs, NameAndLocation const& rhs) \{                                                            if ( lhs.location.line != rhs.location.line ) \{ return false; \}            return lhs.name == rhs.name && lhs.location == rhs.location;        \}        friend bool operator!=(NameAndLocation const& lhs,                               NameAndLocation const& rhs) \{            return !( lhs == rhs );        \}    \};        struct NameAndLocationRef \{        StringRef name;        SourceLineInfo location;        constexpr NameAndLocationRef( StringRef name_,                                      SourceLineInfo location_ ):            name( name_ ), location( location_ ) \{\}        friend bool operator==( NameAndLocation const& lhs,                                NameAndLocationRef const& rhs ) \{                                                            if ( lhs.location.line != rhs.location.line ) \{ return false; \}            return StringRef( lhs.name ) == rhs.name &&                   lhs.location == rhs.location;        \}        friend bool operator==( NameAndLocationRef const& lhs,                                NameAndLocation const& rhs ) \{            return rhs == lhs;        \}    \};    class ITracker;    using ITrackerPtr = Catch::Detail::unique_ptr<ITracker>;    class ITracker \{        NameAndLocation m_nameAndLocation;        using Children = std::vector<ITrackerPtr>;    protected:        enum CycleState \{            NotStarted,            Executing,            ExecutingChildren,            NeedsAnotherRun,            CompletedSuccessfully,            Failed        \};        ITracker* m_parent = nullptr;        Children m_children;        CycleState m_runState = NotStarted;    public:        ITracker( NameAndLocation&& nameAndLoc, ITracker* parent ):            m_nameAndLocation( CATCH_MOVE(nameAndLoc) ),            m_parent( parent )        \{\}                NameAndLocation const& nameAndLocation() const \{            return m_nameAndLocation;        \}        ITracker* parent() const \{            return m_parent;        \}        virtual ~ITracker();                         virtual bool isComplete() const = 0;                bool isSuccessfullyCompleted() const \{            return m_runState == CompletedSuccessfully;        \}                bool isOpen() const;                bool hasStarted() const;                virtual void close() = 0;         virtual void fail() = 0;        void markAsNeedingAnotherRun();                void addChild( ITrackerPtr&& child );                ITracker* findChild( NameAndLocationRef const& nameAndLocation );                bool hasChildren() const \{            return !m_children.empty();        \}                void openChild();                virtual bool isSectionTracker() const;                virtual bool isGeneratorTracker() const;    \};    class TrackerContext \{        enum RunState \{            NotStarted,            Executing,            CompletedCycle        \};        ITrackerPtr m_rootTracker;        ITracker* m_currentTracker = nullptr;        RunState m_runState = NotStarted;    public:        ITracker& startRun();        void startCycle() \{            m_currentTracker = m_rootTracker.get();            m_runState = Executing;        \}        void completeCycle();        bool completedCycle() const;        ITracker& currentTracker() \{ return *m_currentTracker; \}        void setCurrentTracker( ITracker* tracker );    \};    class TrackerBase : public ITracker \{    protected:        TrackerContext& m_ctx;    public:        TrackerBase( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );        bool isComplete() const override;        void open();        void close() override;        void fail() override;    private:        void moveToParent();        void moveToThis();    \};    class SectionTracker : public TrackerBase \{        std::vector<StringRef> m_filters;                                        StringRef m_trimmed_name;    public:        SectionTracker( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );        bool isSectionTracker() const override;        bool isComplete() const override;        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocationRef const& nameAndLocation );        void tryOpen();        void addInitialFilters( std::vector<std::string> const& filters );        void addNextFilters( std::vector<StringRef> const& filters );                std::vector<StringRef> const& getFilters() const \{ return m_filters; \}                StringRef trimmedName() const;    \};\} using TestCaseTracking::ITracker;using TestCaseTracking::TrackerContext;using TestCaseTracking::SectionTracker;\} #endif #include <string>namespace Catch \{    class IGeneratorTracker;    class IConfig;    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;        class RunContext final : public IResultCapture \{    public:        RunContext( RunContext const& ) = delete;        RunContext& operator =( RunContext const& ) = delete;        explicit RunContext( IConfig const* _config, IEventListenerPtr&& reporter );        ~RunContext() override;        Totals runTest(TestCaseHandle const& testCase);    public:                 void handleExpr                (   AssertionInfo const& info,                    ITransientExpression const& expr,                    AssertionReaction& reaction ) override;        void handleMessage                (   AssertionInfo const& info,                    ResultWas::OfType resultType,                    StringRef message,                    AssertionReaction& reaction ) override;        void handleUnexpectedExceptionNotThrown                (   AssertionInfo const& info,                    AssertionReaction& reaction ) override;        void handleUnexpectedInflightException                (   AssertionInfo const& info,                    std::string&& message,                    AssertionReaction& reaction ) override;        void handleIncomplete                (   AssertionInfo const& info ) override;        void handleNonExpr                (   AssertionInfo const &info,                    ResultWas::OfType resultType,                    AssertionReaction &reaction ) override;        void notifyAssertionStarted( AssertionInfo const& info ) override;        bool sectionStarted( StringRef sectionName,                             SourceLineInfo const& sectionLineInfo,                             Counts& assertions ) override;        void sectionEnded( SectionEndInfo&& endInfo ) override;        void sectionEndedEarly( SectionEndInfo&& endInfo ) override;        IGeneratorTracker*        acquireGeneratorTracker( StringRef generatorName,                                 SourceLineInfo const& lineInfo ) override;        IGeneratorTracker* createGeneratorTracker(            StringRef generatorName,            SourceLineInfo lineInfo,            Generators::GeneratorBasePtr&& generator ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& info ) override;        void benchmarkEnded( BenchmarkStats<> const& stats ) override;        void benchmarkFailed( StringRef error ) override;        void pushScopedMessage( MessageInfo const& message ) override;        void popScopedMessage( MessageInfo const& message ) override;        void emplaceUnscopedMessage( MessageBuilder&& builder ) override;        std::string getCurrentTestName() const override;        const AssertionResult* getLastResult() const override;        void exceptionEarlyReported() override;        void handleFatalErrorCondition( StringRef message ) override;        bool lastAssertionPassed() override;        void assertionPassed() override;    public:                bool aborting() const;    private:        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );        void invokeActiveTestCase();        void resetAssertionInfo();        bool testForMissingAssertions( Counts& assertions );        void assertionEnded( AssertionResult&& result );        void reportExpr                (   AssertionInfo const &info,                    ResultWas::OfType resultType,                    ITransientExpression const *expr,                    bool negated );        void populateReaction( AssertionReaction& reaction );    private:        void handleUnfinishedSections();        TestRunInfo m_runInfo;        TestCaseHandle const* m_activeTestCase = nullptr;        ITracker* m_testCaseTracker = nullptr;        Optional<AssertionResult> m_lastResult;        IConfig const* m_config;        Totals m_totals;        IEventListenerPtr m_reporter;        std::vector<MessageInfo> m_messages;        std::vector<ScopedMessage> m_messageScopes;         AssertionInfo m_lastAssertionInfo;        std::vector<SectionEndInfo> m_unfinishedSections;        std::vector<ITracker*> m_activeSections;        TrackerContext m_trackerContext;        FatalConditionHandler m_fatalConditionhandler;        bool m_lastAssertionPassed = false;        bool m_shouldReportUnexpected = true;        bool m_includeSuccessfulResults;    \};    void seedRng(IConfig const& config);    unsigned int rngSeed();\} #endif #ifndef CATCH_SHARDING_HPP_INCLUDED#define CATCH_SHARDING_HPP_INCLUDED#include <cassert>#include <cmath>#include <algorithm>namespace Catch \{    template<typename Container>    Container createShard(Container const& container, std::size_t const shardCount, std::size_t const shardIndex) \{        assert(shardCount > shardIndex);        if (shardCount == 1) \{            return container;        \}        const std::size_t totalTestCount = container.size();        const std::size_t shardSize = totalTestCount / shardCount;        const std::size_t leftoverTests = totalTestCount % shardCount;        const std::size_t startIndex = shardIndex * shardSize + (std::min)(shardIndex, leftoverTests);        const std::size_t endIndex = (shardIndex + 1) * shardSize + (std::min)(shardIndex + 1, leftoverTests);        auto startIterator = std::next(container.begin(), static_cast<std::ptrdiff_t>(startIndex));        auto endIterator = std::next(container.begin(), static_cast<std::ptrdiff_t>(endIndex));        return Container(startIterator, endIterator);    \}\}#endif #ifndef CATCH_SINGLETONS_HPP_INCLUDED#define CATCH_SINGLETONS_HPP_INCLUDEDnamespace Catch \{    struct ISingleton \{        virtual ~ISingleton();     \};    void addSingleton( ISingleton* singleton );    void cleanupSingletons();    template<typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT>    class Singleton : SingletonImplT, public ISingleton \{        static auto getInternal() -> Singleton* \{            static Singleton* s_instance = nullptr;            if( !s_instance ) \{                s_instance = new Singleton;                addSingleton( s_instance );            \}            return s_instance;        \}    public:        static auto get() -> InterfaceT const& \{            return *getInternal();        \}        static auto getMutable() -> MutableInterfaceT& \{            return *getInternal();        \}    \};\} #endif #ifndef CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED#define CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED#include <vector>#include <exception>namespace Catch \{    class StartupExceptionRegistry \{#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)    public:        void add(std::exception_ptr const& exception) noexcept;        std::vector<std::exception_ptr> const& getExceptions() const noexcept;    private:        std::vector<std::exception_ptr> m_exceptions;#endif    \};\} #endif #ifndef CATCH_STDSTREAMS_HPP_INCLUDED#define CATCH_STDSTREAMS_HPP_INCLUDED#include <iosfwd>namespace Catch \{    std::ostream& cout();    std::ostream& cerr();    std::ostream& clog();\} #endif#ifndef CATCH_STRING_MANIP_HPP_INCLUDED#define CATCH_STRING_MANIP_HPP_INCLUDED#include <cstdint>#include <string>#include <iosfwd>#include <vector>namespace Catch \{    bool startsWith( std::string const& s, std::string const& prefix );    bool startsWith( StringRef s, char prefix );    bool endsWith( std::string const& s, std::string const& suffix );    bool endsWith( std::string const& s, char suffix );    bool contains( std::string const& s, std::string const& infix );    void toLowerInPlace( std::string& s );    std::string toLower( std::string const& s );    char toLower( char c );        std::string trim( std::string const& str );        StringRef trim(StringRef ref);        std::vector<StringRef> splitStringRef( StringRef str, char delimiter );    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );        class pluralise \{        std::uint64_t m_count;        StringRef m_label;    public:        constexpr pluralise(std::uint64_t count, StringRef label):            m_count(count),            m_label(label)        \{\}        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );    \};\}#endif #ifndef CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED#define CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED#include <map>#include <string>namespace Catch \{    struct SourceLineInfo;    class TagAliasRegistry : public ITagAliasRegistry \{    public:        ~TagAliasRegistry() override;        TagAlias const* find( std::string const& alias ) const override;        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );    private:        std::map<std::string, TagAlias> m_registry;    \};\} #endif #ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED#include <cstdint>namespace Catch \{    struct TestCaseInfo;    class TestCaseInfoHasher \{    public:        using hash_t = std::uint64_t;        TestCaseInfoHasher( hash_t seed );        uint32_t operator()( TestCaseInfo const& t ) const;    private:        hash_t m_seed;    \};\} #endif #ifndef CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED#define CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED#include <vector>namespace Catch \{    class IConfig;    class ITestInvoker;    class TestCaseHandle;    class TestSpec;    std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases );    bool isThrowSafe( TestCaseHandle const& testCase, IConfig const& config );    std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> const& testCases, TestSpec const& testSpec, IConfig const& config );    std::vector<TestCaseHandle> const& getAllTestCasesSorted( IConfig const& config );    class TestRegistry : public ITestCaseRegistry \{    public:        void registerTest( Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker );        std::vector<TestCaseInfo*> const& getAllInfos() const override;        std::vector<TestCaseHandle> const& getAllTests() const override;        std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const override;        ~TestRegistry() override;     private:        std::vector<Detail::unique_ptr<TestCaseInfo>> m_owned_test_infos;                        std::vector<TestCaseInfo*> m_viewed_test_infos;        std::vector<Detail::unique_ptr<ITestInvoker>> m_invokers;        std::vector<TestCaseHandle> m_handles;        mutable TestRunOrder m_currentSortOrder = TestRunOrder::Declared;        mutable std::vector<TestCaseHandle> m_sortedFunctions;    \};    \} #endif #ifndef CATCH_TEST_SPEC_PARSER_HPP_INCLUDED#define CATCH_TEST_SPEC_PARSER_HPP_INCLUDED#ifdef __clang__#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wpadded"#endif#include <vector>#include <string>namespace Catch \{    class ITagAliasRegistry;    class TestSpecParser \{        enum Mode\{ None, Name, QuotedName, Tag, EscapedName \};        Mode m_mode = None;        Mode lastMode = None;        bool m_exclusion = false;        std::size_t m_pos = 0;        std::size_t m_realPatternPos = 0;        std::string m_arg;        std::string m_substring;        std::string m_patternName;        std::vector<std::size_t> m_escapeChars;        TestSpec::Filter m_currentFilter;        TestSpec m_testSpec;        ITagAliasRegistry const* m_tagAliases = nullptr;    public:        TestSpecParser( ITagAliasRegistry const& tagAliases );        TestSpecParser& parse( std::string const& arg );        TestSpec testSpec();    private:        bool visitChar( char c );        void startNewMode( Mode mode );        bool processNoneChar( char c );        void processNameChar( char c );        bool processOtherChar( char c );        void endMode();        void escape();        bool isControlChar( char c ) const;        void saveLastMode();        void revertBackToLastMode();        void addFilter();        bool separate();                std::string preprocessPattern();                void addNamePattern();                void addTagPattern();        inline void addCharToPattern(char c) \{            m_substring += c;            m_patternName += c;            m_realPatternPos++;        \}    \};\} #ifdef __clang__#pragma clang diagnostic pop#endif#endif #ifndef CATCH_TEXTFLOW_HPP_INCLUDED#define CATCH_TEXTFLOW_HPP_INCLUDED#include <cassert>#include <string>#include <vector>namespace Catch \{    namespace TextFlow \{        class Columns;                class AnsiSkippingString \{            std::string m_string;            std::size_t m_size = 0;                        void preprocessString();        public:            class const_iterator;            using iterator = const_iterator;                                    static constexpr char sentinel = static_cast<char>( 0xffu );            explicit AnsiSkippingString( std::string const& text );            explicit AnsiSkippingString( std::string&& text );            const_iterator begin() const;            const_iterator end() const;            size_t size() const \{ return m_size; \}            std::string substring( const_iterator begin,                                   const_iterator end ) const;        \};        class AnsiSkippingString::const_iterator \{            friend AnsiSkippingString;            struct EndTag \{\};            const std::string* m_string;            std::string::const_iterator m_it;            explicit const_iterator( const std::string& string, EndTag ):                m_string( &string ), m_it( string.end() ) \{\}            void tryParseAnsiEscapes();            void advance();            void unadvance();        public:            using difference_type = std::ptrdiff_t;            using value_type = char;            using pointer = value_type*;            using reference = value_type&;            using iterator_category = std::bidirectional_iterator_tag;            explicit const_iterator( const std::string& string ):                m_string( &string ), m_it( string.begin() ) \{                tryParseAnsiEscapes();            \}            char operator*() const \{ return *m_it; \}            const_iterator& operator++() \{                advance();                return *this;            \}            const_iterator operator++( int ) \{                iterator prev( *this );                operator++();                return prev;            \}            const_iterator& operator--() \{                unadvance();                return *this;            \}            const_iterator operator--( int ) \{                iterator prev( *this );                operator--();                return prev;            \}            bool operator==( const_iterator const& other ) const \{                return m_it == other.m_it;            \}            bool operator!=( const_iterator const& other ) const \{                return !operator==( other );            \}            bool operator<=( const_iterator const& other ) const \{                return m_it <= other.m_it;            \}            const_iterator oneBefore() const \{                auto it = *this;                return --it;            \}        \};                class Column \{                        AnsiSkippingString m_string;                        size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;                                    size_t m_indent = 0;                        size_t m_initialIndent = std::string::npos;        public:                        class const_iterator \{                friend Column;                struct EndTag \{\};                Column const& m_column;                                AnsiSkippingString::const_iterator m_lineStart;                                AnsiSkippingString::const_iterator m_lineEnd;                                AnsiSkippingString::const_iterator m_parsedTo;                                bool m_addHyphen = false;                const_iterator( Column const& column, EndTag ):                    m_column( column ),                    m_lineStart( m_column.m_string.end() ),                    m_lineEnd( column.m_string.end() ),                    m_parsedTo( column.m_string.end() ) \{\}                                void calcLength();                                size_t indentSize() const;                                                std::string addIndentAndSuffix(                    AnsiSkippingString::const_iterator start,                    AnsiSkippingString::const_iterator end ) const;            public:                using difference_type = std::ptrdiff_t;                using value_type = std::string;                using pointer = value_type*;                using reference = value_type&;                using iterator_category = std::forward_iterator_tag;                explicit const_iterator( Column const& column );                std::string operator*() const;                const_iterator& operator++();                const_iterator operator++( int );                bool operator==( const_iterator const& other ) const \{                    return m_lineStart == other.m_lineStart &&                           &m_column == &other.m_column;                \}                bool operator!=( const_iterator const& other ) const \{                    return !operator==( other );                \}            \};            using iterator = const_iterator;            explicit Column( std::string const& text ): m_string( text ) \{\}            explicit Column( std::string&& text ):                m_string( CATCH_MOVE( text ) ) \{\}            Column& width( size_t newWidth ) & \{                assert( newWidth > 0 );                m_width = newWidth;                return *this;            \}            Column&& width( size_t newWidth ) && \{                assert( newWidth > 0 );                m_width = newWidth;                return CATCH_MOVE( *this );            \}            Column& indent( size_t newIndent ) & \{                m_indent = newIndent;                return *this;            \}            Column&& indent( size_t newIndent ) && \{                m_indent = newIndent;                return CATCH_MOVE( *this );            \}            Column& initialIndent( size_t newIndent ) & \{                m_initialIndent = newIndent;                return *this;            \}            Column&& initialIndent( size_t newIndent ) && \{                m_initialIndent = newIndent;                return CATCH_MOVE( *this );            \}            size_t width() const \{ return m_width; \}            const_iterator begin() const \{ return const_iterator( *this ); \}            const_iterator end() const \{                return \{ *this, const_iterator::EndTag\{\} \};            \}            friend std::ostream& operator<<( std::ostream& os,                                             Column const& col );            friend Columns operator+( Column const& lhs, Column const& rhs );            friend Columns operator+( Column&& lhs, Column&& rhs );        \};                Column Spacer( size_t spaceWidth );        class Columns \{            std::vector<Column> m_columns;        public:            class iterator \{                friend Columns;                struct EndTag \{\};                std::vector<Column> const& m_columns;                std::vector<Column::const_iterator> m_iterators;                size_t m_activeIterators;                iterator( Columns const& columns, EndTag );            public:                using difference_type = std::ptrdiff_t;                using value_type = std::string;                using pointer = value_type*;                using reference = value_type&;                using iterator_category = std::forward_iterator_tag;                explicit iterator( Columns const& columns );                auto operator==( iterator const& other ) const -> bool \{                    return m_iterators == other.m_iterators;                \}                auto operator!=( iterator const& other ) const -> bool \{                    return m_iterators != other.m_iterators;                \}                std::string operator*() const;                iterator& operator++();                iterator operator++( int );            \};            using const_iterator = iterator;            iterator begin() const \{ return iterator( *this ); \}            iterator end() const \{ return \{ *this, iterator::EndTag() \}; \}            friend Columns& operator+=( Columns& lhs, Column const& rhs );            friend Columns& operator+=( Columns& lhs, Column&& rhs );            friend Columns operator+( Columns const& lhs, Column const& rhs );            friend Columns operator+( Columns&& lhs, Column&& rhs );            friend std::ostream& operator<<( std::ostream& os,                                             Columns const& cols );        \};    \} \} #endif #ifndef CATCH_TO_STRING_HPP_INCLUDED#define CATCH_TO_STRING_HPP_INCLUDED#include <string>namespace Catch \{    template <typename T>    std::string to_string(T const& t) \{#if defined(CATCH_CONFIG_CPP11_TO_STRING)        return std::to_string(t);#else        ReusableStringStream rss;        rss << t;        return rss.str();#endif    \}\} #endif #ifndef CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED#define CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDEDnamespace Catch \{    bool uncaught_exceptions();\} #endif #ifndef CATCH_XMLWRITER_HPP_INCLUDED#define CATCH_XMLWRITER_HPP_INCLUDED#include <iosfwd>#include <vector>namespace Catch \{    enum class XmlFormatting \{        None = 0x00,        Indent = 0x01,        Newline = 0x02,    \};    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);        class XmlEncode \{    public:        enum ForWhat \{ ForTextNodes, ForAttributes \};        XmlEncode( StringRef str, ForWhat forWhat = ForTextNodes );        void encodeTo( std::ostream& os ) const;        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );    private:        StringRef m_str;        ForWhat m_forWhat;    \};    class XmlWriter \{    public:        class ScopedElement \{        public:            ScopedElement( XmlWriter* writer, XmlFormatting fmt );            ScopedElement( ScopedElement&& other ) noexcept;            ScopedElement& operator=( ScopedElement&& other ) noexcept;            ~ScopedElement();            ScopedElement&            writeText( StringRef text,                       XmlFormatting fmt = XmlFormatting::Newline |                                           XmlFormatting::Indent );            ScopedElement& writeAttribute( StringRef name,                                           StringRef attribute );            template <typename T,                                                                                                              typename = typename std::enable_if_t<                          !std::is_convertible<T, StringRef>::value>>            ScopedElement& writeAttribute( StringRef name,                                           T const& attribute ) \{                m_writer->writeAttribute( name, attribute );                return *this;            \}        private:            XmlWriter* m_writer = nullptr;            XmlFormatting m_fmt;        \};        XmlWriter( std::ostream& os );        ~XmlWriter();        XmlWriter( XmlWriter const& ) = delete;        XmlWriter& operator=( XmlWriter const& ) = delete;        XmlWriter& startElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);        ScopedElement scopedElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);        XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);                XmlWriter& writeAttribute( StringRef name, StringRef attribute );                XmlWriter& writeAttribute( StringRef name, bool attribute );                XmlWriter& writeAttribute( StringRef name, char const* attribute );                        template <typename T,                                                                                          typename = typename std::enable_if_t<                      !std::is_convertible<T, StringRef>::value>>        XmlWriter& writeAttribute( StringRef name, T const& attribute ) \{            ReusableStringStream rss;            rss << attribute;            return writeAttribute( name, rss.str() );        \}                XmlWriter& writeText( StringRef text,                              XmlFormatting fmt = XmlFormatting::Newline |                                                  XmlFormatting::Indent );                XmlWriter& writeComment( StringRef text,                                 XmlFormatting fmt = XmlFormatting::Newline |                                                     XmlFormatting::Indent );        void writeStylesheetRef( StringRef url );        void ensureTagClosed();    private:        void applyFormatting(XmlFormatting fmt);        void writeDeclaration();        void newlineIfNecessary();        bool m_tagIsOpen = false;        bool m_needsNewline = false;        std::vector<std::string> m_tags;        std::string m_indent;        std::ostream& m_os;    \};\}#endif #ifndef CATCH_MATCHERS_ALL_HPP_INCLUDED#define CATCH_MATCHERS_ALL_HPP_INCLUDED#ifndef CATCH_MATCHERS_HPP_INCLUDED#define CATCH_MATCHERS_HPP_INCLUDED#ifndef CATCH_MATCHERS_IMPL_HPP_INCLUDED#define CATCH_MATCHERS_IMPL_HPP_INCLUDED#include <string>namespace Catch \{#ifdef __clang__#    pragma clang diagnostic push#    pragma clang diagnostic ignored "-Wsign-compare"#    pragma clang diagnostic ignored "-Wnon-virtual-dtor"#elif defined __GNUC__#    pragma GCC diagnostic push#    pragma GCC diagnostic ignored "-Wsign-compare"#    pragma GCC diagnostic ignored "-Wnon-virtual-dtor"#endif    template<typename ArgT, typename MatcherT>    class MatchExpr : public ITransientExpression \{        ArgT && m_arg;        MatcherT const& m_matcher;    public:        MatchExpr( ArgT && arg, MatcherT const& matcher )        :   ITransientExpression\{ true, matcher.match( arg ) \},             m_arg( CATCH_FORWARD(arg) ),            m_matcher( matcher )        \{\}        void streamReconstructedExpression( std::ostream& os ) const override \{            os << Catch::Detail::stringify( m_arg )               << ' '               << m_matcher.toString();        \}    \};#ifdef __clang__#    pragma clang diagnostic pop#elif defined __GNUC__#    pragma GCC diagnostic pop#endif    namespace Matchers \{        template <typename ArgT>        class MatcherBase;    \}    using StringMatcher = Matchers::MatcherBase<std::string>;    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher );    template<typename ArgT, typename MatcherT>    auto makeMatchExpr( ArgT && arg, MatcherT const& matcher ) -> MatchExpr<ArgT, MatcherT> \{        return MatchExpr<ArgT, MatcherT>( CATCH_FORWARD(arg), matcher );    \}\} #define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \\    do \{ \\        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\        INTERNAL_CATCH_TRY \{ \\            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher ) ); \\        \} INTERNAL_CATCH_CATCH( catchAssertionHandler ) \\        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\    \} while( false )#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \\    do \{ \\        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \\        if( catchAssertionHandler.allowThrows() ) \\            try \{ \\                static_cast<void>(__VA_ARGS__ ); \\                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \\            \} \\            catch( exceptionType const& ex ) \{ \\                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher ) ); \\            \} \\            catch( ... ) \{ \\                catchAssertionHandler.handleUnexpectedInflightException(); \\            \} \\        else \\            catchAssertionHandler.handleThrowingCallSkipped(); \\        INTERNAL_CATCH_REACT( catchAssertionHandler ) \\    \} while( false )#endif #include <string>#include <vector>namespace Catch \{namespace Matchers \{    class MatcherUntypedBase \{    public:        MatcherUntypedBase() = default;        MatcherUntypedBase(MatcherUntypedBase const&) = default;        MatcherUntypedBase(MatcherUntypedBase&&) = default;        MatcherUntypedBase& operator = (MatcherUntypedBase const&) = delete;        MatcherUntypedBase& operator = (MatcherUntypedBase&&) = delete;        std::string toString() const;    protected:        virtual ~MatcherUntypedBase();         virtual std::string describe() const = 0;        mutable std::string m_cachedToString;    \};    template<typename T>    class MatcherBase : public MatcherUntypedBase \{    public:        virtual bool match( T const& arg ) const = 0;    \};    namespace Detail \{        template<typename ArgT>        class MatchAllOf final : public MatcherBase<ArgT> \{            std::vector<MatcherBase<ArgT> const*> m_matchers;        public:            MatchAllOf() = default;            MatchAllOf(MatchAllOf const&) = delete;            MatchAllOf& operator=(MatchAllOf const&) = delete;            MatchAllOf(MatchAllOf&&) = default;            MatchAllOf& operator=(MatchAllOf&&) = default;            bool match( ArgT const& arg ) const override \{                for( auto matcher : m_matchers ) \{                    if (!matcher->match(arg))                        return false;                \}                return true;            \}            std::string describe() const override \{                std::string description;                description.reserve( 4 + m_matchers.size()*32 );                description += "( ";                bool first = true;                for( auto matcher : m_matchers ) \{                    if( first )                        first = false;                    else                        description += " and ";                    description += matcher->toString();                \}                description += " )";                return description;            \}            friend MatchAllOf operator&& (MatchAllOf&& lhs, MatcherBase<ArgT> const& rhs) \{                lhs.m_matchers.push_back(&rhs);                return CATCH_MOVE(lhs);            \}            friend MatchAllOf operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf&& rhs) \{                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);                return CATCH_MOVE(rhs);            \}        \};                        template<typename ArgT>        MatchAllOf<ArgT> operator&& (MatchAllOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;                        template<typename ArgT>        MatchAllOf<ArgT> operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf<ArgT> const& rhs) = delete;        template<typename ArgT>        class MatchAnyOf final : public MatcherBase<ArgT> \{            std::vector<MatcherBase<ArgT> const*> m_matchers;        public:            MatchAnyOf() = default;            MatchAnyOf(MatchAnyOf const&) = delete;            MatchAnyOf& operator=(MatchAnyOf const&) = delete;            MatchAnyOf(MatchAnyOf&&) = default;            MatchAnyOf& operator=(MatchAnyOf&&) = default;            bool match( ArgT const& arg ) const override \{                for( auto matcher : m_matchers ) \{                    if (matcher->match(arg))                        return true;                \}                return false;            \}            std::string describe() const override \{                std::string description;                description.reserve( 4 + m_matchers.size()*32 );                description += "( ";                bool first = true;                for( auto matcher : m_matchers ) \{                    if( first )                        first = false;                    else                        description += " or ";                    description += matcher->toString();                \}                description += " )";                return description;            \}            friend MatchAnyOf operator|| (MatchAnyOf&& lhs, MatcherBase<ArgT> const& rhs) \{                lhs.m_matchers.push_back(&rhs);                return CATCH_MOVE(lhs);            \}            friend MatchAnyOf operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf&& rhs) \{                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);                return CATCH_MOVE(rhs);            \}        \};                        template<typename ArgT>        MatchAnyOf<ArgT> operator|| (MatchAnyOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;                        template<typename ArgT>        MatchAnyOf<ArgT> operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf<ArgT> const& rhs) = delete;        template<typename ArgT>        class MatchNotOf final : public MatcherBase<ArgT> \{            MatcherBase<ArgT> const& m_underlyingMatcher;        public:            explicit MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ):                m_underlyingMatcher( underlyingMatcher )            \{\}            bool match( ArgT const& arg ) const override \{                return !m_underlyingMatcher.match( arg );            \}            std::string describe() const override \{                return "not " + m_underlyingMatcher.toString();            \}        \};    \}     template <typename T>    Detail::MatchAllOf<T> operator&& (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) \{        return Detail::MatchAllOf<T>\{\} && lhs && rhs;    \}    template <typename T>    Detail::MatchAnyOf<T> operator|| (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) \{        return Detail::MatchAnyOf<T>\{\} || lhs || rhs;    \}    template <typename T>    Detail::MatchNotOf<T> operator! (MatcherBase<T> const& matcher) \{        return Detail::MatchNotOf<T>\{ matcher \};    \}\} \} #if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)  #define CATCH_CHECK_THROWS_WITH( expr, matcher )                     (void)(0)  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)  #define CATCH_CHECK_THAT( arg, matcher )                             (void)(0)  #define CATCH_REQUIRE_THAT( arg, matcher )                           (void)(0)#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)  #define REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)  #define CHECK_THROWS_WITH( expr, matcher )                     (void)(0)  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)  #define CHECK_THAT( arg, matcher )                             (void)(0)  #define REQUIRE_THAT( arg, matcher )                           (void)(0)#endif #endif #ifndef CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED#define CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED#ifndef CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED#define CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED#include <array>#include <algorithm>#include <string>#include <type_traits>namespace Catch \{namespace Matchers \{    class MatcherGenericBase : public MatcherUntypedBase \{    public:        MatcherGenericBase() = default;        ~MatcherGenericBase() override;         MatcherGenericBase(MatcherGenericBase const&) = default;        MatcherGenericBase(MatcherGenericBase&&) = default;        MatcherGenericBase& operator=(MatcherGenericBase const&) = delete;        MatcherGenericBase& operator=(MatcherGenericBase&&) = delete;    \};    namespace Detail \{        template<std::size_t N, std::size_t M>        std::array<void const*, N + M> array_cat(std::array<void const*, N> && lhs, std::array<void const*, M> && rhs) \{            std::array<void const*, N + M> arr\{\};            std::copy_n(lhs.begin(), N, arr.begin());            std::copy_n(rhs.begin(), M, arr.begin() + N);            return arr;        \}        template<std::size_t N>        std::array<void const*, N+1> array_cat(std::array<void const*, N> && lhs, void const* rhs) \{            std::array<void const*, N+1> arr\{\};            std::copy_n(lhs.begin(), N, arr.begin());            arr[N] = rhs;            return arr;        \}        template<std::size_t N>        std::array<void const*, N+1> array_cat(void const* lhs, std::array<void const*, N> && rhs) \{            std::array<void const*, N + 1> arr\{ \{lhs\} \};            std::copy_n(rhs.begin(), N, arr.begin() + 1);            return arr;        \}        template<typename T>        using is_generic_matcher = std::is_base_of<            Catch::Matchers::MatcherGenericBase,            std::remove_cv_t<std::remove_reference_t<T>>        >;        template<typename... Ts>        using are_generic_matchers = Catch::Detail::conjunction<is_generic_matcher<Ts>...>;        template<typename T>        using is_matcher = std::is_base_of<            Catch::Matchers::MatcherUntypedBase,            std::remove_cv_t<std::remove_reference_t<T>>        >;        template<std::size_t N, typename Arg>        bool match_all_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) \{            return true;        \}        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>        bool match_all_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) \{            return static_cast<T const*>(matchers[Idx])->match(arg) && match_all_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});        \}        template<std::size_t N, typename Arg>        bool match_any_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) \{            return false;        \}        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>        bool match_any_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) \{            return static_cast<T const*>(matchers[Idx])->match(arg) || match_any_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>\{\});        \}        std::string describe_multi_matcher(StringRef combine, std::string const* descriptions_begin, std::string const* descriptions_end);        template<typename... MatcherTs, std::size_t... Idx>        std::string describe_multi_matcher(StringRef combine, std::array<void const*, sizeof...(MatcherTs)> const& matchers, std::index_sequence<Idx...>) \{            std::array<std::string, sizeof...(MatcherTs)> descriptions \{\{                static_cast<MatcherTs const*>(matchers[Idx])->toString()...            \}\};            return describe_multi_matcher(combine, descriptions.data(), descriptions.data() + descriptions.size());        \}        template<typename... MatcherTs>        class MatchAllOfGeneric final : public MatcherGenericBase \{        public:            MatchAllOfGeneric(MatchAllOfGeneric const&) = delete;            MatchAllOfGeneric& operator=(MatchAllOfGeneric const&) = delete;            MatchAllOfGeneric(MatchAllOfGeneric&&) = default;            MatchAllOfGeneric& operator=(MatchAllOfGeneric&&) = default;            MatchAllOfGeneric(MatcherTs const&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}            explicit MatchAllOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}            template<typename Arg>            bool match(Arg&& arg) const \{                return match_all_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}            std::string describe() const override \{                return describe_multi_matcher<MatcherTs...>(" and "_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}                                                std::array<void const*, sizeof...( MatcherTs )> m_matchers;                        template<typename... MatchersRHS>            friend            MatchAllOfGeneric<MatcherTs..., MatchersRHS...> operator && (                    MatchAllOfGeneric<MatcherTs...>&& lhs,                    MatchAllOfGeneric<MatchersRHS...>&& rhs) \{                return MatchAllOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};            \}                        template<typename MatcherRHS>            friend std::enable_if_t<is_matcher<MatcherRHS>::value,            MatchAllOfGeneric<MatcherTs..., MatcherRHS>> operator && (                    MatchAllOfGeneric<MatcherTs...>&& lhs,                    MatcherRHS const& rhs) \{                return MatchAllOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), static_cast<void const*>(&rhs))\};            \}                        template<typename MatcherLHS>            friend std::enable_if_t<is_matcher<MatcherLHS>::value,            MatchAllOfGeneric<MatcherLHS, MatcherTs...>> operator && (                    MatcherLHS const& lhs,                    MatchAllOfGeneric<MatcherTs...>&& rhs) \{                return MatchAllOfGeneric<MatcherLHS, MatcherTs...>\{array_cat(static_cast<void const*>(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};            \}        \};        template<typename... MatcherTs>        class MatchAnyOfGeneric final : public MatcherGenericBase \{        public:            MatchAnyOfGeneric(MatchAnyOfGeneric const&) = delete;            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric const&) = delete;            MatchAnyOfGeneric(MatchAnyOfGeneric&&) = default;            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric&&) = default;            MatchAnyOfGeneric(MatcherTs const&... matchers) : m_matchers\{ \{std::addressof(matchers)...\} \} \{\}            explicit MatchAnyOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers\{matchers\} \{\}            template<typename Arg>            bool match(Arg&& arg) const \{                return match_any_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}            std::string describe() const override \{                return describe_multi_matcher<MatcherTs...>(" or "_sr, m_matchers, std::index_sequence_for<MatcherTs...>\{\});            \}                                                std::array<void const*, sizeof...( MatcherTs )> m_matchers;                        template<typename... MatchersRHS>            friend MatchAnyOfGeneric<MatcherTs..., MatchersRHS...> operator || (                    MatchAnyOfGeneric<MatcherTs...>&& lhs,                    MatchAnyOfGeneric<MatchersRHS...>&& rhs) \{                return MatchAnyOfGeneric<MatcherTs..., MatchersRHS...>\{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))\};            \}                        template<typename MatcherRHS>            friend std::enable_if_t<is_matcher<MatcherRHS>::value,            MatchAnyOfGeneric<MatcherTs..., MatcherRHS>> operator || (                    MatchAnyOfGeneric<MatcherTs...>&& lhs,                    MatcherRHS const& rhs) \{                return MatchAnyOfGeneric<MatcherTs..., MatcherRHS>\{array_cat(CATCH_MOVE(lhs.m_matchers), static_cast<void const*>(std::addressof(rhs)))\};            \}                        template<typename MatcherLHS>            friend std::enable_if_t<is_matcher<MatcherLHS>::value,            MatchAnyOfGeneric<MatcherLHS, MatcherTs...>> operator || (                MatcherLHS const& lhs,                MatchAnyOfGeneric<MatcherTs...>&& rhs) \{                return MatchAnyOfGeneric<MatcherLHS, MatcherTs...>\{array_cat(static_cast<void const*>(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))\};            \}        \};        template<typename MatcherT>        class MatchNotOfGeneric final : public MatcherGenericBase \{            MatcherT const& m_matcher;        public:            MatchNotOfGeneric(MatchNotOfGeneric const&) = delete;            MatchNotOfGeneric& operator=(MatchNotOfGeneric const&) = delete;            MatchNotOfGeneric(MatchNotOfGeneric&&) = default;            MatchNotOfGeneric& operator=(MatchNotOfGeneric&&) = default;            explicit MatchNotOfGeneric(MatcherT const& matcher) : m_matcher\{matcher\} \{\}            template<typename Arg>            bool match(Arg&& arg) const \{                return !m_matcher.match(arg);            \}            std::string describe() const override \{                return "not " + m_matcher.toString();            \}                        friend MatcherT const& operator ! (MatchNotOfGeneric<MatcherT> const& matcher) \{                return matcher.m_matcher;            \}        \};    \}         template<typename MatcherLHS, typename MatcherRHS>    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherRHS>>        operator && (MatcherLHS const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename MatcherLHS, typename MatcherRHS>    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherRHS>>        operator || (MatcherLHS const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}        template<typename MatcherT>    std::enable_if_t<Detail::is_generic_matcher<MatcherT>::value, Detail::MatchNotOfGeneric<MatcherT>>        operator ! (MatcherT const& matcher) \{        return Detail::MatchNotOfGeneric<MatcherT>\{matcher\};    \}        template<typename MatcherLHS, typename ArgRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>        operator && (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename ArgLHS, typename MatcherRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>        operator && (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename MatcherLHS, typename ArgRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>        operator || (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) \{        return \{ lhs, rhs \};    \}    template<typename ArgLHS, typename MatcherRHS>    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>        operator || (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) \{        return \{ lhs, rhs \};    \}\} \} #endif namespace Catch \{    namespace Matchers \{        class IsEmptyMatcher final : public MatcherGenericBase \{        public:            template <typename RangeLike>            bool match(RangeLike&& rng) const \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::empty;#else                using std::empty;#endif                return empty(rng);            \}            std::string describe() const override;        \};        class HasSizeMatcher final : public MatcherGenericBase \{            std::size_t m_target_size;        public:            explicit HasSizeMatcher(std::size_t target_size):                m_target_size(target_size)            \{\}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::size;#else                using std::size;#endif                return size(rng) == m_target_size;            \}            std::string describe() const override;        \};        template <typename Matcher>        class SizeMatchesMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            explicit SizeMatchesMatcher(Matcher m):                m_matcher(CATCH_MOVE(m))            \{\}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)                using Catch::Detail::size;#else                using std::size;#endif                return m_matcher.match(size(rng));            \}            std::string describe() const override \{                return "size matches " + m_matcher.describe();            \}        \};                IsEmptyMatcher IsEmpty();                HasSizeMatcher SizeIs(std::size_t sz);        template <typename Matcher>        std::enable_if_t<Detail::is_matcher<Matcher>::value,        SizeMatchesMatcher<Matcher>> SizeIs(Matcher&& m) \{            return SizeMatchesMatcher<Matcher>\{CATCH_FORWARD(m)\};        \}    \} \} #endif #ifndef CATCH_MATCHERS_CONTAINS_HPP_INCLUDED#define CATCH_MATCHERS_CONTAINS_HPP_INCLUDED#include <algorithm>#include <functional>namespace Catch \{    namespace Matchers \{                template <typename T, typename Equality>        class ContainsElementMatcher final : public MatcherGenericBase \{            T m_desired;            Equality m_eq;        public:            template <typename T2, typename Equality2>            ContainsElementMatcher(T2&& target, Equality2&& predicate):                m_desired(CATCH_FORWARD(target)),                m_eq(CATCH_FORWARD(predicate))            \{\}            std::string describe() const override \{                return "contains element " + Catch::Detail::stringify(m_desired);            \}            template <typename RangeLike>            bool match( RangeLike&& rng ) const \{                for ( auto&& elem : rng ) \{                    if ( m_eq( elem, m_desired ) ) \{ return true; \}                \}                return false;            \}        \};                template <typename Matcher>        class ContainsMatcherMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:                                                ContainsMatcherMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (m_matcher.match(elem)) \{                        return true;                    \}                \}                return false;            \}            std::string describe() const override \{                return "contains element matching " + m_matcher.describe();            \}        \};                template <typename T>        std::enable_if_t<!Detail::is_matcher<T>::value,        ContainsElementMatcher<T, std::equal_to<>>> Contains(T&& elem) \{            return \{ CATCH_FORWARD(elem), std::equal_to<>\{\} \};        \}                template <typename Matcher>        std::enable_if_t<Detail::is_matcher<Matcher>::value,        ContainsMatcherMatcher<Matcher>> Contains(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}                template <typename T, typename Equality>        ContainsElementMatcher<T, Equality> Contains(T&& elem, Equality&& eq) \{            return \{ CATCH_FORWARD(elem), CATCH_FORWARD(eq) \};        \}    \}\}#endif #ifndef CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED#define CATCH_MATCHERS_EXCEPTION_HPP_INCLUDEDnamespace Catch \{namespace Matchers \{class ExceptionMessageMatcher final : public MatcherBase<std::exception> \{    std::string m_message;public:    ExceptionMessageMatcher(std::string const& message):        m_message(message)    \{\}    bool match(std::exception const& ex) const override;    std::string describe() const override;\};ExceptionMessageMatcher Message(std::string const& message);template <typename StringMatcherType>class ExceptionMessageMatchesMatcher final    : public MatcherBase<std::exception> \{    StringMatcherType m_matcher;public:    ExceptionMessageMatchesMatcher( StringMatcherType matcher ):        m_matcher( CATCH_MOVE( matcher ) ) \{\}    bool match( std::exception const& ex ) const override \{        return m_matcher.match( ex.what() );    \}    std::string describe() const override \{        return " matches \\"" + m_matcher.describe() + '"';    \}\};template <typename StringMatcherType>ExceptionMessageMatchesMatcher<StringMatcherType>MessageMatches( StringMatcherType&& matcher ) \{    return \{ CATCH_FORWARD( matcher ) \};\}\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED#ifndef CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED#define CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDEDnamespace Catch \{namespace Matchers \{    namespace Detail \{        enum class FloatingPointKind : uint8_t;    \}    class  WithinAbsMatcher final : public MatcherBase<double> \{    public:        WithinAbsMatcher(double target, double margin);        bool match(double const& matchee) const override;        std::string describe() const override;    private:        double m_target;        double m_margin;    \};        WithinAbsMatcher WithinAbs( double target, double margin );    class WithinUlpsMatcher final : public MatcherBase<double> \{    public:        WithinUlpsMatcher( double target,                           uint64_t ulps,                           Detail::FloatingPointKind baseType );        bool match(double const& matchee) const override;        std::string describe() const override;    private:        double m_target;        uint64_t m_ulps;        Detail::FloatingPointKind m_type;    \};        WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);        WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);    // Given IEEE-754 format for floats and doubles, we can assume    // that float -> double promotion is lossless. Given this, we can    // assume that if we do the standard relative comparison of    // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get    // the same result if we do this for floats, as if we do this for    // doubles that were promoted from floats.    class WithinRelMatcher final : public MatcherBase<double> \{    public:        WithinRelMatcher( double target, double epsilon );        bool match(double const& matchee) const override;        std::string describe() const override;    private:        double m_target;        double m_epsilon;    \};        WithinRelMatcher WithinRel(double target, double eps);        WithinRelMatcher WithinRel(double target);        WithinRelMatcher WithinRel(float target, float eps);        WithinRelMatcher WithinRel(float target);    class IsNaNMatcher final : public MatcherBase<double> \{    public:        IsNaNMatcher() = default;        bool match( double const& matchee ) const override;        std::string describe() const override;    \};    IsNaNMatcher IsNaN();\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED#ifndef CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#define CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#include <string>namespace Catch \{namespace Matchers \{namespace Detail \{    std::string finalizeDescription(const std::string& desc);\} // namespace Detailtemplate <typename T, typename Predicate>class PredicateMatcher final : public MatcherBase<T> \{    Predicate m_predicate;    std::string m_description;public:    PredicateMatcher(Predicate&& elem, std::string const& descr)        :m_predicate(CATCH_FORWARD(elem)),        m_description(Detail::finalizeDescription(descr))    \{\}    bool match( T const& item ) const override \{        return m_predicate(item);    \}    std::string describe() const override \{        return m_description;    \}\};    /**     * Creates a matcher that calls delegates `match` to the provided predicate.     *     * The user has to explicitly specify the argument type to the matcher     */    template<typename T, typename Pred>    PredicateMatcher<T, Pred> Predicate(Pred&& predicate, std::string const& description = "") \{        static_assert(is_callable<Pred(T)>::value, "Predicate not callable with argument T");        static_assert(std::is_same<bool, FunctionReturnType<Pred, T>>::value, "Predicate does not return bool");        return PredicateMatcher<T, Pred>(CATCH_FORWARD(predicate), description);    \}\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_PREDICATE_HPP_INCLUDED#ifndef CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED#define CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDEDnamespace Catch \{    namespace Matchers \{        // Matcher for checking that all elements in range matches a given matcher.        template <typename Matcher>        class AllMatchMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            AllMatchMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            std::string describe() const override \{                return "all match " + m_matcher.describe();            \}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (!m_matcher.match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range matches a given matcher.        template <typename Matcher>        class NoneMatchMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            NoneMatchMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            std::string describe() const override \{                return "none match " + m_matcher.describe();            \}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (m_matcher.match(elem)) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that at least one element in range matches a given matcher.        template <typename Matcher>        class AnyMatchMatcher final : public MatcherGenericBase \{            Matcher m_matcher;        public:            AnyMatchMatcher(Matcher matcher):                m_matcher(CATCH_MOVE(matcher))            \{\}            std::string describe() const override \{                return "any match " + m_matcher.describe();            \}            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (m_matcher.match(elem)) \{                        return true;                    \}                \}                return false;            \}        \};        // Matcher for checking that all elements in range are true.        class AllTrueMatcher final : public MatcherGenericBase \{        public:            std::string describe() const override;            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (!elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that no element in range is true.        class NoneTrueMatcher final : public MatcherGenericBase \{        public:            std::string describe() const override;            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (elem) \{                        return false;                    \}                \}                return true;            \}        \};        // Matcher for checking that any element in range is true.        class AnyTrueMatcher final : public MatcherGenericBase \{        public:            std::string describe() const override;            template <typename RangeLike>            bool match(RangeLike&& rng) const \{                for (auto&& elem : rng) \{                    if (elem) \{                        return true;                    \}                \}                return false;            \}        \};        // Creates a matcher that checks whether all elements in a range match a matcher        template <typename Matcher>        AllMatchMatcher<Matcher> AllMatch(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}        // Creates a matcher that checks whether no element in a range matches a matcher.        template <typename Matcher>        NoneMatchMatcher<Matcher> NoneMatch(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}        // Creates a matcher that checks whether any element in a range matches a matcher.        template <typename Matcher>        AnyMatchMatcher<Matcher> AnyMatch(Matcher&& matcher) \{            return \{ CATCH_FORWARD(matcher) \};        \}        // Creates a matcher that checks whether all elements in a range are true        AllTrueMatcher AllTrue();        // Creates a matcher that checks whether no element in a range is true        NoneTrueMatcher NoneTrue();        // Creates a matcher that checks whether any element in a range is true        AnyTrueMatcher AnyTrue();    \}\}#endif // CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED#ifndef CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#define CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#include <algorithm>#include <utility>namespace Catch \{    namespace Matchers \{        /**         * Matcher for checking that an element contains the same         * elements in the same order         */        template <typename TargetRangeLike, typename Equality>        class RangeEqualsMatcher final : public MatcherGenericBase \{            TargetRangeLike m_desired;            Equality m_predicate;        public:            template <typename TargetRangeLike2, typename Equality2>            RangeEqualsMatcher( TargetRangeLike2&& range,                                Equality2&& predicate ):                m_desired( CATCH_FORWARD( range ) ),                m_predicate( CATCH_FORWARD( predicate ) ) \{\}            template <typename RangeLike>            bool match( RangeLike&& rng ) const \{                auto rng_start = begin( rng );                const auto rng_end = end( rng );                auto target_start = begin( m_desired );                const auto target_end = end( m_desired );                while (rng_start != rng_end && target_start != target_end) \{                    if (!m_predicate(*rng_start, *target_start)) \{                        return false;                    \}                    ++rng_start;                    ++target_start;                \}                return rng_start == rng_end && target_start == target_end;            \}            std::string describe() const override \{                return "elements are " + Catch::Detail::stringify( m_desired );            \}        \};        /**         * Matcher for checking that an element contains the same         * elements (but not necessarily in the same order)         */        template <typename TargetRangeLike, typename Equality>        class UnorderedRangeEqualsMatcher final : public MatcherGenericBase \{            TargetRangeLike m_desired;            Equality m_predicate;        public:            template <typename TargetRangeLike2, typename Equality2>            UnorderedRangeEqualsMatcher( TargetRangeLike2&& range,                                         Equality2&& predicate ):                m_desired( CATCH_FORWARD( range ) ),                m_predicate( CATCH_FORWARD( predicate ) ) \{\}            template <typename RangeLike>            bool match( RangeLike&& rng ) const \{                using std::begin;                using std::end;                return Catch::Detail::is_permutation( begin( m_desired ),                                                      end( m_desired ),                                                      begin( rng ),                                                      end( rng ),                                                      m_predicate );            \}            std::string describe() const override \{                return "unordered elements are " +                       ::Catch::Detail::stringify( m_desired );            \}        \};        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range.         *         * Uses `std::equal_to` to do the comparison         */        template <typename RangeLike>        std::enable_if_t<!Detail::is_matcher<RangeLike>::value,                         RangeEqualsMatcher<RangeLike, std::equal_to<>>>        RangeEquals( RangeLike&& range ) \{            return \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};        \}        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range.         *         * Uses to provided predicate `predicate` to do the comparisons         */        template <typename RangeLike, typename Equality>        RangeEqualsMatcher<RangeLike, Equality>        RangeEquals( RangeLike&& range, Equality&& predicate ) \{            return \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};        \}        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range, in some permutation         *         * Uses `std::equal_to` to do the comparison         */        template <typename RangeLike>        std::enable_if_t<            !Detail::is_matcher<RangeLike>::value,            UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>        UnorderedRangeEquals( RangeLike&& range ) \{            return \{ CATCH_FORWARD( range ), std::equal_to<>\{\} \};        \}        /**         * Creates a matcher that checks if all elements in a range are equal         * to all elements in another range, in some permutation.         *         * Uses to provided predicate `predicate` to do the comparisons         */        template <typename RangeLike, typename Equality>        UnorderedRangeEqualsMatcher<RangeLike, Equality>        UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) \{            return \{ CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) \};        \}    \} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED#ifndef CATCH_MATCHERS_STRING_HPP_INCLUDED#define CATCH_MATCHERS_STRING_HPP_INCLUDED#include <string>namespace Catch \{namespace Matchers \{    struct CasedString \{        CasedString( std::string const& str, CaseSensitive caseSensitivity );        std::string adjustString( std::string const& str ) const;        StringRef caseSensitivitySuffix() const;        CaseSensitive m_caseSensitivity;        std::string m_str;    \};    class StringMatcherBase : public MatcherBase<std::string> \{    protected:        CasedString m_comparator;        StringRef m_operation;    public:        StringMatcherBase( StringRef operation,                           CasedString const& comparator );        std::string describe() const override;    \};    class StringEqualsMatcher final : public StringMatcherBase \{    public:        StringEqualsMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class StringContainsMatcher final : public StringMatcherBase \{    public:        StringContainsMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class StartsWithMatcher final : public StringMatcherBase \{    public:        StartsWithMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class EndsWithMatcher final : public StringMatcherBase \{    public:        EndsWithMatcher( CasedString const& comparator );        bool match( std::string const& source ) const override;    \};    class RegexMatcher final : public MatcherBase<std::string> \{        std::string m_regex;        CaseSensitive m_caseSensitivity;    public:        RegexMatcher( std::string regex, CaseSensitive caseSensitivity );        bool match( std::string const& matchee ) const override;        std::string describe() const override;    \};        StringEqualsMatcher Equals( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        StringContainsMatcher ContainsSubstring( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        EndsWithMatcher EndsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        StartsWithMatcher StartsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );        RegexMatcher Matches( std::string const& regex, CaseSensitive caseSensitivity = CaseSensitive::Yes );\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_STRING_HPP_INCLUDED#ifndef CATCH_MATCHERS_VECTOR_HPP_INCLUDED#define CATCH_MATCHERS_VECTOR_HPP_INCLUDED#include <algorithm>namespace Catch \{namespace Matchers \{    template<typename T, typename Alloc>    class VectorContainsElementMatcher final : public MatcherBase<std::vector<T, Alloc>> \{        T const& m_comparator;    public:        VectorContainsElementMatcher(T const& comparator):            m_comparator(comparator)        \{\}        bool match(std::vector<T, Alloc> const& v) const override \{            for (auto const& el : v) \{                if (el == m_comparator) \{                    return true;                \}            \}            return false;        \}        std::string describe() const override \{            return "Contains: " + ::Catch::Detail::stringify( m_comparator );        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class ContainsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_comparator;    public:        ContainsMatcher(std::vector<T, AllocComp> const& comparator):            m_comparator( comparator )        \{\}        bool match(std::vector<T, AllocMatch> const& v) const override \{            // !TBD: see note in EqualsMatcher            if (m_comparator.size() > v.size())                return false;            for (auto const& comparator : m_comparator) \{                auto present = false;                for (const auto& el : v) \{                    if (el == comparator) \{                        present = true;                        break;                    \}                \}                if (!present) \{                    return false;                \}            \}            return true;        \}        std::string describe() const override \{            return "Contains: " + ::Catch::Detail::stringify( m_comparator );        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class EqualsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_comparator;    public:        EqualsMatcher(std::vector<T, AllocComp> const& comparator):            m_comparator( comparator )        \{\}        bool match(std::vector<T, AllocMatch> const& v) const override \{            // !TBD: This currently works if all elements can be compared using !=            // - a more general approach would be via a compare template that defaults            // to using !=. but could be specialised for, e.g. std::vector<T> etc            // - then just call that directly            if ( m_comparator.size() != v.size() ) \{ return false; \}            for ( std::size_t i = 0; i < v.size(); ++i ) \{                if ( !( m_comparator[i] == v[i] ) ) \{ return false; \}            \}            return true;        \}        std::string describe() const override \{            return "Equals: " + ::Catch::Detail::stringify( m_comparator );        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class ApproxMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_comparator;        mutable Catch::Approx approx = Catch::Approx::custom();    public:        ApproxMatcher(std::vector<T, AllocComp> const& comparator):            m_comparator( comparator )        \{\}        bool match(std::vector<T, AllocMatch> const& v) const override \{            if (m_comparator.size() != v.size())                return false;            for (std::size_t i = 0; i < v.size(); ++i)                if (m_comparator[i] != approx(v[i]))                    return false;            return true;        \}        std::string describe() const override \{            return "is approx: " + ::Catch::Detail::stringify( m_comparator );        \}        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>        ApproxMatcher& epsilon( T const& newEpsilon ) \{            approx.epsilon(static_cast<double>(newEpsilon));            return *this;        \}        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>        ApproxMatcher& margin( T const& newMargin ) \{            approx.margin(static_cast<double>(newMargin));            return *this;        \}        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>        ApproxMatcher& scale( T const& newScale ) \{            approx.scale(static_cast<double>(newScale));            return *this;        \}    \};    template<typename T, typename AllocComp, typename AllocMatch>    class UnorderedEqualsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> \{        std::vector<T, AllocComp> const& m_target;    public:        UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target):            m_target(target)        \{\}        bool match(std::vector<T, AllocMatch> const& vec) const override \{            if (m_target.size() != vec.size()) \{                return false;            \}            return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());        \}        std::string describe() const override \{            return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);        \}    \};    // The following functions create the actual matcher objects.    // This allows the types to be inferred        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) \{        return ContainsMatcher<T, AllocComp, AllocMatch>(comparator);    \}        template<typename T, typename Alloc = std::allocator<T>>    VectorContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) \{        return VectorContainsElementMatcher<T, Alloc>(comparator);    \}        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) \{        return EqualsMatcher<T, AllocComp, AllocMatch>(comparator);    \}        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) \{        return ApproxMatcher<T, AllocComp, AllocMatch>(comparator);    \}        template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>    UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) \{        return UnorderedEqualsMatcher<T, AllocComp, AllocMatch>(target);    \}\} // namespace Matchers\} // namespace Catch#endif // CATCH_MATCHERS_VECTOR_HPP_INCLUDED#endif // CATCH_MATCHERS_ALL_HPP_INCLUDED/** \\file * This is a convenience header for Catch2's Reporter support. It includes * **all** of Catch2 headers related to reporters, including all reporters. * * Generally the Catch2 users should use specific includes they need, * but this header can be used instead for ease-of-experimentation, or * just plain convenience, at the cost of (significantly) increased * compilation times. * * When a new header (reporter) is added to either the `reporter` folder, * or to the corresponding internal subfolder, it should be added here. */#ifndef CATCH_REPORTERS_ALL_HPP_INCLUDED#define CATCH_REPORTERS_ALL_HPP_INCLUDED#ifndef CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#define CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#ifndef CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#define CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#ifndef CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#define CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#include <map>#include <string>namespace Catch \{    class ColourImpl;    /**     * This is the base class for all reporters.     *     * If are writing a reporter, you must derive from this type, or one     * of the helper reporter bases that are derived from this type.     *     * ReporterBase centralizes handling of various common tasks in reporters,     * like storing the right stream for the reporters to write to, and     * providing the default implementation of the different listing events.     */    class ReporterBase : public IEventListener \{    protected:                Detail::unique_ptr<IStream> m_wrapped_stream;                        std::ostream& m_stream;                Detail::unique_ptr<ColourImpl> m_colour;                std::map<std::string, std::string> m_customOptions;    public:        ReporterBase( ReporterConfig&& config );        ~ReporterBase() override; // = default;        /**         * Provides a simple default listing of reporters.         *         * Should look roughly like the reporter listing in v2 and earlier         * versions of Catch2.         */        void listReporters(            std::vector<ReporterDescription> const& descriptions ) override;        /**         * Provides a simple default listing of listeners         *         * Looks similarly to listing of reporters, but with listener type         * instead of reporter name.         */        void listListeners(            std::vector<ListenerDescription> const& descriptions ) override;        /**         * Provides a simple default listing of tests.         *         * Should look roughly like the test listing in v2 and earlier versions         * of Catch2. Especially supports low-verbosity listing that mimics the         * old `--list-test-names-only` output.         */        void listTests( std::vector<TestCaseHandle> const& tests ) override;        /**         * Provides a simple default listing of tags.         *         * Should look roughly like the tag listing in v2 and earlier versions         * of Catch2.         */        void listTags( std::vector<TagInfo> const& tags ) override;    \};\} // namespace Catch#endif // CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED#include <vector>namespace Catch \{    class StreamingReporterBase : public ReporterBase \{    public:        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        StreamingReporterBase(ReporterConfig&& _config):            ReporterBase(CATCH_MOVE(_config))        \{\}        ~StreamingReporterBase() override;        void benchmarkPreparing( StringRef ) override \{\}        void benchmarkStarting( BenchmarkInfo const& ) override \{\}        void benchmarkEnded( BenchmarkStats<> const& ) override \{\}        void benchmarkFailed( StringRef ) override \{\}        void fatalErrorEncountered( StringRef /*error*/ ) override \{\}        void noMatchingTestCases( StringRef /*unmatchedSpec*/ ) override \{\}        void reportInvalidTestSpec( StringRef /*invalidArgument*/ ) override \{\}        void testRunStarting( TestRunInfo const& _testRunInfo ) override;        void testCaseStarting(TestCaseInfo const& _testInfo) override  \{            currentTestCaseInfo = &_testInfo;        \}        void testCasePartialStarting( TestCaseInfo const&, uint64_t ) override \{\}        void sectionStarting(SectionInfo const& _sectionInfo) override \{            m_sectionStack.push_back(_sectionInfo);        \}        void assertionStarting( AssertionInfo const& ) override \{\}        void assertionEnded( AssertionStats const& ) override \{\}        void sectionEnded(SectionStats const& /* _sectionStats */) override \{            m_sectionStack.pop_back();        \}        void testCasePartialEnded( TestCaseStats const&, uint64_t ) override \{\}        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override \{            currentTestCaseInfo = nullptr;        \}        void testRunEnded( TestRunStats const& /* _testRunStats */ ) override;        void skipTest(TestCaseInfo const&) override \{            // Don't do anything with this by default.            // It can optionally be overridden in the derived class.        \}    protected:        TestRunInfo currentTestRunInfo\{ "test run has not started yet"_sr \};        TestCaseInfo const* currentTestCaseInfo = nullptr;                std::vector<SectionInfo> m_sectionStack;    \};\} // end namespace Catch#endif // CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED#include <string>namespace Catch \{    class AutomakeReporter final : public StreamingReporterBase \{    public:        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        AutomakeReporter(ReporterConfig&& _config):            StreamingReporterBase(CATCH_MOVE(_config))        \{\}        ~AutomakeReporter() override;        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results in the format of Automake .trs files"s;        \}        void testCaseEnded(TestCaseStats const& _testCaseStats) override;        void skipTest(TestCaseInfo const& testInfo) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED#ifndef CATCH_REPORTER_COMPACT_HPP_INCLUDED#define CATCH_REPORTER_COMPACT_HPP_INCLUDEDnamespace Catch \{    class CompactReporter final : public StreamingReporterBase \{    public:        using StreamingReporterBase::StreamingReporterBase;        ~CompactReporter() override;        static std::string getDescription();        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void testRunStarting( TestRunInfo const& _testInfo ) override;        void assertionEnded(AssertionStats const& _assertionStats) override;        void sectionEnded(SectionStats const& _sectionStats) override;        void testRunEnded(TestRunStats const& _testRunStats) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_COMPACT_HPP_INCLUDED#ifndef CATCH_REPORTER_CONSOLE_HPP_INCLUDED#define CATCH_REPORTER_CONSOLE_HPP_INCLUDEDnamespace Catch \{    // Fwd decls    class TablePrinter;    class ConsoleReporter final : public StreamingReporterBase \{        Detail::unique_ptr<TablePrinter> m_tablePrinter;    public:        ConsoleReporter(ReporterConfig&& config);        ~ConsoleReporter() override;        static std::string getDescription();        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void reportInvalidTestSpec( StringRef arg ) override;        void assertionStarting(AssertionInfo const&) override;        void assertionEnded(AssertionStats const& _assertionStats) override;        void sectionStarting(SectionInfo const& _sectionInfo) override;        void sectionEnded(SectionStats const& _sectionStats) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting(BenchmarkInfo const& info) override;        void benchmarkEnded(BenchmarkStats<> const& stats) override;        void benchmarkFailed( StringRef error ) override;        void testCaseEnded(TestCaseStats const& _testCaseStats) override;        void testRunEnded(TestRunStats const& _testRunStats) override;        void testRunStarting(TestRunInfo const& _testRunInfo) override;    private:        void lazyPrint();        void lazyPrintWithoutClosingBenchmarkTable();        void lazyPrintRunInfo();        void printTestCaseAndSectionHeader();        void printClosedHeader(std::string const& _name);        void printOpenHeader(std::string const& _name);        // if string has a : in first line will set indent to follow it on        // subsequent lines        void printHeaderString(std::string const& _string, std::size_t indent = 0);        void printTotalsDivider(Totals const& totals);        bool m_headerPrinted = false;        bool m_testRunInfoPrinted = false;    \};\} // end namespace Catch#endif // CATCH_REPORTER_CONSOLE_HPP_INCLUDED#ifndef CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#define CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#include <string>#include <vector>namespace Catch \{    namespace Detail \{                class AssertionOrBenchmarkResult \{            // This should really be a variant, but this is much faster            // to write and the data layout here is already terrible            // enough that we do not have to care about the object size.            Optional<AssertionStats> m_assertion;            Optional<BenchmarkStats<>> m_benchmark;        public:            AssertionOrBenchmarkResult(AssertionStats const& assertion);            AssertionOrBenchmarkResult(BenchmarkStats<> const& benchmark);            bool isAssertion() const;            bool isBenchmark() const;            AssertionStats const& asAssertion() const;            BenchmarkStats<> const& asBenchmark() const;        \};    \}    /**     * Utility base for reporters that need to handle all results at once     *     * It stores tree of all test cases, sections and assertions, and after the     * test run is finished, calls into `testRunEndedCumulative` to pass the     * control to the deriving class.     *     * If you are deriving from this class and override any testing related     * member functions, you should first call into the base's implementation to     * avoid breaking the tree construction.     *     * Due to the way this base functions, it has to expand assertions up-front,     * even if they are later unused (e.g. because the deriving reporter does     * not report successful assertions, or because the deriving reporter does     * not use assertion expansion at all). Derived classes can use two     * customization points, `m_shouldStoreSuccesfulAssertions` and     * `m_shouldStoreFailedAssertions`, to disable the expansion and gain extra     * performance. **Accessing the assertion expansions if it wasn't stored is     * UB.**     */    class CumulativeReporterBase : public ReporterBase \{    public:        template<typename T, typename ChildNodeT>        struct Node \{            explicit Node( T const& _value ) : value( _value ) \{\}            using ChildNodes = std::vector<Detail::unique_ptr<ChildNodeT>>;            T value;            ChildNodes children;        \};        struct SectionNode \{            explicit SectionNode(SectionStats const& _stats) : stats(_stats) \{\}            bool operator == (SectionNode const& other) const \{                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;            \}            bool hasAnyAssertions() const;            SectionStats stats;            std::vector<Detail::unique_ptr<SectionNode>> childSections;            std::vector<Detail::AssertionOrBenchmarkResult> assertionsAndBenchmarks;            std::string stdOut;            std::string stdErr;        \};        using TestCaseNode = Node<TestCaseStats, SectionNode>;        using TestRunNode = Node<TestRunStats, TestCaseNode>;        // GCC5 compat: we cannot use inherited constructor, because it        //              doesn't implement backport of P0136        CumulativeReporterBase(ReporterConfig&& _config):            ReporterBase(CATCH_MOVE(_config))        \{\}        ~CumulativeReporterBase() override;        void benchmarkPreparing( StringRef ) override \{\}        void benchmarkStarting( BenchmarkInfo const& ) override \{\}        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;        void benchmarkFailed( StringRef ) override \{\}        void noMatchingTestCases( StringRef ) override \{\}        void reportInvalidTestSpec( StringRef ) override \{\}        void fatalErrorEncountered( StringRef /*error*/ ) override \{\}        void testRunStarting( TestRunInfo const& ) override \{\}        void testCaseStarting( TestCaseInfo const& ) override \{\}        void testCasePartialStarting( TestCaseInfo const&, uint64_t ) override \{\}        void sectionStarting( SectionInfo const& sectionInfo ) override;        void assertionStarting( AssertionInfo const& ) override \{\}        void assertionEnded( AssertionStats const& assertionStats ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void testCasePartialEnded( TestCaseStats const&, uint64_t ) override \{\}        void testCaseEnded( TestCaseStats const& testCaseStats ) override;        void testRunEnded( TestRunStats const& testRunStats ) override;                virtual void testRunEndedCumulative() = 0;        void skipTest(TestCaseInfo const&) override \{\}    protected:                bool m_shouldStoreSuccesfulAssertions = true;                bool m_shouldStoreFailedAssertions = true;        // We need lazy construction here. We should probably refactor it        // later, after the events are redone.                Detail::unique_ptr<TestRunNode> m_testRun;    private:        // Note: We rely on pointer identity being stable, which is why        //       we store pointers to the nodes rather than the values.        std::vector<Detail::unique_ptr<TestCaseNode>> m_testCases;        // Root section of the _current_ test case        Detail::unique_ptr<SectionNode> m_rootSection;        // Deepest section of the _current_ test case        SectionNode* m_deepestSection = nullptr;        // Stack of _active_ sections in the _current_ test case        std::vector<SectionNode*> m_sectionStack;    \};\} // end namespace Catch#endif // CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED#ifndef CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED#define CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDEDnamespace Catch \{    /**     * Base class to simplify implementing listeners.     *     * Provides empty default implementation for all IEventListener member     * functions, so that a listener implementation can pick which     * member functions it actually cares about.     */    class EventListenerBase : public IEventListener \{    public:        using IEventListener::IEventListener;        void reportInvalidTestSpec( StringRef unmatchedSpec ) override;        void fatalErrorEncountered( StringRef error ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;        void benchmarkFailed( StringRef error ) override;        void assertionStarting( AssertionInfo const& assertionInfo ) override;        void assertionEnded( AssertionStats const& assertionStats ) override;        void listReporters(            std::vector<ReporterDescription> const& descriptions ) override;        void listListeners(            std::vector<ListenerDescription> const& descriptions ) override;        void listTests( std::vector<TestCaseHandle> const& tests ) override;        void listTags( std::vector<TagInfo> const& tagInfos ) override;        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void testRunStarting( TestRunInfo const& testRunInfo ) override;        void testCaseStarting( TestCaseInfo const& testInfo ) override;        void testCasePartialStarting( TestCaseInfo const& testInfo,                                      uint64_t partNumber ) override;        void sectionStarting( SectionInfo const& sectionInfo ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void testCasePartialEnded( TestCaseStats const& testCaseStats,                                   uint64_t partNumber ) override;        void testCaseEnded( TestCaseStats const& testCaseStats ) override;        void testRunEnded( TestRunStats const& testRunStats ) override;        void skipTest( TestCaseInfo const& testInfo ) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED#ifndef CATCH_REPORTER_HELPERS_HPP_INCLUDED#define CATCH_REPORTER_HELPERS_HPP_INCLUDED#include <iosfwd>#include <string>#include <vector>namespace Catch \{    class IConfig;    class TestCaseHandle;    class ColourImpl;    // Returns double formatted as %.3f (format expected on output)    std::string getFormattedDuration( double duration );        bool shouldShowDuration( IConfig const& config, double duration );    std::string serializeFilters( std::vector<std::string> const& filters );    struct lineOfChars \{        char c;        constexpr lineOfChars( char c_ ): c( c_ ) \{\}        friend std::ostream& operator<<( std::ostream& out, lineOfChars value );    \};    /**     * Lists reporter descriptions to the provided stream in user-friendly     * format     *     * Used as the default listing implementation by the first party reporter     * bases. The output should be backwards compatible with the output of     * Catch2 v2 binaries.     */    void    defaultListReporters( std::ostream& out,                          std::vector<ReporterDescription> const& descriptions,                          Verbosity verbosity );    /**     * Lists listeners descriptions to the provided stream in user-friendly     * format     */    void defaultListListeners( std::ostream& out,                               std::vector<ListenerDescription> const& descriptions );    /**     * Lists tag information to the provided stream in user-friendly format     *     * Used as the default listing implementation by the first party reporter     * bases. The output should be backwards compatible with the output of     * Catch2 v2 binaries.     */    void defaultListTags( std::ostream& out, std::vector<TagInfo> const& tags, bool isFiltered );    /**     * Lists test case information to the provided stream in user-friendly     * format     *     * Used as the default listing implementation by the first party reporter     * bases. The output is backwards compatible with the output of Catch2     * v2 binaries, and also supports the format specific to the old     * `--list-test-names-only` option, for people who used it in integrations.     */    void defaultListTests( std::ostream& out,                           ColourImpl* streamColour,                           std::vector<TestCaseHandle> const& tests,                           bool isFiltered,                           Verbosity verbosity );    /**     * Prints test run totals to the provided stream in user-friendly format     *     * Used by the console and compact reporters.     */    void printTestRunTotals( std::ostream& stream,                      ColourImpl& streamColour,                      Totals const& totals );\} // end namespace Catch#endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED#ifndef CATCH_REPORTER_JSON_HPP_INCLUDED#define CATCH_REPORTER_JSON_HPP_INCLUDED#include <stack>namespace Catch \{    class JsonReporter : public StreamingReporterBase \{    public:        JsonReporter( ReporterConfig&& config );        ~JsonReporter() override;        static std::string getDescription();    public: // StreamingReporterBase        void testRunStarting( TestRunInfo const& runInfo ) override;        void testRunEnded( TestRunStats const& runStats ) override;        void testCaseStarting( TestCaseInfo const& tcInfo ) override;        void testCaseEnded( TestCaseStats const& tcStats ) override;        void testCasePartialStarting( TestCaseInfo const& tcInfo,                                      uint64_t index ) override;        void testCasePartialEnded( TestCaseStats const& tcStats,                                   uint64_t index ) override;        void sectionStarting( SectionInfo const& sectionInfo ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void assertionStarting( AssertionInfo const& assertionInfo ) override;        void assertionEnded( AssertionStats const& assertionStats ) override;        //void testRunEndedCumulative() override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& ) override;        void benchmarkEnded( BenchmarkStats<> const& ) override;        void benchmarkFailed( StringRef error ) override;        void listReporters(            std::vector<ReporterDescription> const& descriptions ) override;        void listListeners(            std::vector<ListenerDescription> const& descriptions ) override;        void listTests( std::vector<TestCaseHandle> const& tests ) override;        void listTags( std::vector<TagInfo> const& tags ) override;    private:        Timer m_testCaseTimer;        enum class Writer \{            Object,            Array        \};        JsonArrayWriter& startArray();        JsonArrayWriter& startArray( StringRef key );        JsonObjectWriter& startObject();        JsonObjectWriter& startObject( StringRef key );        void endObject();        void endArray();        bool isInside( Writer writer );        void startListing();        void endListing();        // Invariant:        // When m_writers is not empty and its top element is        // - Writer::Object, then m_objectWriters is not be empty        // - Writer::Array,  then m_arrayWriters shall not be empty        std::stack<JsonObjectWriter> m_objectWriters\{\};        std::stack<JsonArrayWriter> m_arrayWriters\{\};        std::stack<Writer> m_writers\{\};        bool m_startedListing = false;        // std::size_t m_sectionDepth = 0;        // std::size_t m_sectionStarted = 0;    \};\} // namespace Catch#endif // CATCH_REPORTER_JSON_HPP_INCLUDED#ifndef CATCH_REPORTER_JUNIT_HPP_INCLUDED#define CATCH_REPORTER_JUNIT_HPP_INCLUDEDnamespace Catch \{    class JunitReporter final : public CumulativeReporterBase \{    public:        JunitReporter(ReporterConfig&& _config);        static std::string getDescription();        void testRunStarting(TestRunInfo const& runInfo) override;        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;        void assertionEnded(AssertionStats const& assertionStats) override;        void testCaseEnded(TestCaseStats const& testCaseStats) override;        void testRunEndedCumulative() override;    private:        void writeRun(TestRunNode const& testRunNode, double suiteTime);        void writeTestCase(TestCaseNode const& testCaseNode);        void writeSection( std::string const& className,                           std::string const& rootName,                           SectionNode const& sectionNode,                           bool testOkToFail );        void writeAssertions(SectionNode const& sectionNode);        void writeAssertion(AssertionStats const& stats);        XmlWriter xml;        Timer suiteTimer;        std::string stdOutForSuite;        std::string stdErrForSuite;        unsigned int unexpectedExceptions = 0;        bool m_okToFail = false;    \};\} // end namespace Catch#endif // CATCH_REPORTER_JUNIT_HPP_INCLUDED#ifndef CATCH_REPORTER_MULTI_HPP_INCLUDED#define CATCH_REPORTER_MULTI_HPP_INCLUDEDnamespace Catch \{    class MultiReporter final : public IEventListener \{        /*         * Stores all added reporters and listeners         *         * All Listeners are stored before all reporters, and individual         * listeners/reporters are stored in order of insertion.         */        std::vector<IEventListenerPtr> m_reporterLikes;        bool m_haveNoncapturingReporters = false;        // Keep track of how many listeners we have already inserted,        // so that we can insert them into the main vector at the right place        size_t m_insertedListeners = 0;        void updatePreferences(IEventListener const& reporterish);    public:        using IEventListener::IEventListener;        void addListener( IEventListenerPtr&& listener );        void addReporter( IEventListenerPtr&& reporter );    public: // IEventListener        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void fatalErrorEncountered( StringRef error ) override;        void reportInvalidTestSpec( StringRef arg ) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;        void benchmarkFailed( StringRef error ) override;        void testRunStarting( TestRunInfo const& testRunInfo ) override;        void testCaseStarting( TestCaseInfo const& testInfo ) override;        void testCasePartialStarting(TestCaseInfo const& testInfo, uint64_t partNumber) override;        void sectionStarting( SectionInfo const& sectionInfo ) override;        void assertionStarting( AssertionInfo const& assertionInfo ) override;        void assertionEnded( AssertionStats const& assertionStats ) override;        void sectionEnded( SectionStats const& sectionStats ) override;        void testCasePartialEnded(TestCaseStats const& testStats, uint64_t partNumber) override;        void testCaseEnded( TestCaseStats const& testCaseStats ) override;        void testRunEnded( TestRunStats const& testRunStats ) override;        void skipTest( TestCaseInfo const& testInfo ) override;        void listReporters(std::vector<ReporterDescription> const& descriptions) override;        void listListeners(std::vector<ListenerDescription> const& descriptions) override;        void listTests(std::vector<TestCaseHandle> const& tests) override;        void listTags(std::vector<TagInfo> const& tags) override;    \};\} // end namespace Catch#endif // CATCH_REPORTER_MULTI_HPP_INCLUDED#ifndef CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#include <type_traits>namespace Catch \{    namespace Detail \{        template <typename T, typename = void>        struct has_description : std::false_type \{\};        template <typename T>        struct has_description<            T,            void_t<decltype( T::getDescription() )>>            : std::true_type \{\};                        void registerReporterImpl( std::string const& name,                                   IReporterFactoryPtr reporterPtr );                void registerListenerImpl( Detail::unique_ptr<EventListenerFactory> listenerFactory );    \} // namespace Detail    class IEventListener;    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;    template <typename T>    class ReporterFactory : public IReporterFactory \{        IEventListenerPtr create( ReporterConfig&& config ) const override \{            return Detail::make_unique<T>( CATCH_MOVE(config) );        \}        std::string getDescription() const override \{            return T::getDescription();        \}    \};    template<typename T>    class ReporterRegistrar \{    public:        explicit ReporterRegistrar( std::string const& name ) \{            registerReporterImpl( name,                                  Detail::make_unique<ReporterFactory<T>>() );        \}    \};    template<typename T>    class ListenerRegistrar \{        class TypedListenerFactory : public EventListenerFactory \{            StringRef m_listenerName;            std::string getDescriptionImpl( std::true_type ) const \{                return T::getDescription();            \}            std::string getDescriptionImpl( std::false_type ) const \{                return "(No description provided)";            \}        public:            TypedListenerFactory( StringRef listenerName ):                m_listenerName( listenerName ) \{\}            IEventListenerPtr create( IConfig const* config ) const override \{                return Detail::make_unique<T>( config );            \}            StringRef getName() const override \{                return m_listenerName;            \}            std::string getDescription() const override \{                return getDescriptionImpl( Detail::has_description<T>\{\} );            \}        \};    public:        ListenerRegistrar(StringRef listenerName) \{            registerListenerImpl( Detail::make_unique<TypedListenerFactory>(listenerName) );        \}    \};\}#if !defined(CATCH_CONFIG_DISABLE)#    define CATCH_REGISTER_REPORTER( name, reporterType )                      \\        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\        namespace \{                                                            \\            Catch::ReporterRegistrar<reporterType> INTERNAL_CATCH_UNIQUE_NAME( \\                catch_internal_RegistrarFor )( name );                         \\        \}                                                                      \\        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION#    define CATCH_REGISTER_LISTENER( listenerType )                            \\        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \\        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \\        namespace \{                                                            \\            Catch::ListenerRegistrar<listenerType> INTERNAL_CATCH_UNIQUE_NAME( \\                catch_internal_RegistrarFor )( #listenerType##_catch_sr );     \\        \}                                                                      \\        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION#else // CATCH_CONFIG_DISABLE#define CATCH_REGISTER_REPORTER(name, reporterType)#define CATCH_REGISTER_LISTENER(listenerType)#endif // CATCH_CONFIG_DISABLE#endif // CATCH_REPORTER_REGISTRARS_HPP_INCLUDED#ifndef CATCH_REPORTER_SONARQUBE_HPP_INCLUDED#define CATCH_REPORTER_SONARQUBE_HPP_INCLUDEDnamespace Catch \{    class SonarQubeReporter final : public CumulativeReporterBase \{    public:        SonarQubeReporter(ReporterConfig&& config)        : CumulativeReporterBase(CATCH_MOVE(config))        , xml(m_stream) \{            m_preferences.shouldRedirectStdOut = true;            m_preferences.shouldReportAllAssertions = true;            m_shouldStoreSuccesfulAssertions = false;        \}        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results in the Generic Test Data SonarQube XML format"s;        \}        void testRunStarting( TestRunInfo const& testRunInfo ) override;        void testRunEndedCumulative() override \{            writeRun( *m_testRun );            xml.endElement();        \}        void writeRun( TestRunNode const& runNode );        void writeTestFile(StringRef filename, std::vector<TestCaseNode const*> const& testCaseNodes);        void writeTestCase(TestCaseNode const& testCaseNode);        void writeSection(std::string const& rootName, SectionNode const& sectionNode, bool okToFail);        void writeAssertions(SectionNode const& sectionNode, bool okToFail);        void writeAssertion(AssertionStats const& stats, bool okToFail);    private:        XmlWriter xml;    \};\} // end namespace Catch#endif // CATCH_REPORTER_SONARQUBE_HPP_INCLUDED#ifndef CATCH_REPORTER_TAP_HPP_INCLUDED#define CATCH_REPORTER_TAP_HPP_INCLUDEDnamespace Catch \{    class TAPReporter final : public StreamingReporterBase \{    public:        TAPReporter( ReporterConfig&& config ):            StreamingReporterBase( CATCH_MOVE(config) ) \{            m_preferences.shouldReportAllAssertions = true;        \}        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results in TAP format, suitable for test harnesses"s;        \}        void testRunStarting( TestRunInfo const& testInfo ) override;        void noMatchingTestCases( StringRef unmatchedSpec ) override;        void assertionEnded(AssertionStats const& _assertionStats) override;        void testRunEnded(TestRunStats const& _testRunStats) override;    private:        std::size_t counter = 0;    \};\} // end namespace Catch#endif // CATCH_REPORTER_TAP_HPP_INCLUDED#ifndef CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#define CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#include <cstring>#ifdef __clang__#   pragma clang diagnostic push#   pragma clang diagnostic ignored "-Wpadded"#endifnamespace Catch \{    class TeamCityReporter final : public StreamingReporterBase \{    public:        TeamCityReporter( ReporterConfig&& _config )        :   StreamingReporterBase( CATCH_MOVE(_config) )        \{            m_preferences.shouldRedirectStdOut = true;        \}        ~TeamCityReporter() override;        static std::string getDescription() \{            using namespace std::string_literals;            return "Reports test results as TeamCity service messages"s;        \}        void testRunStarting( TestRunInfo const& runInfo ) override;        void testRunEnded( TestRunStats const& runStats ) override;        void assertionEnded(AssertionStats const& assertionStats) override;        void sectionStarting(SectionInfo const& sectionInfo) override \{            m_headerPrintedForThisSection = false;            StreamingReporterBase::sectionStarting( sectionInfo );        \}        void testCaseStarting(TestCaseInfo const& testInfo) override;        void testCaseEnded(TestCaseStats const& testCaseStats) override;    private:        void printSectionHeader(std::ostream& os);        bool m_headerPrintedForThisSection = false;        Timer m_testTimer;    \};\} // end namespace Catch#ifdef __clang__#   pragma clang diagnostic pop#endif#endif // CATCH_REPORTER_TEAMCITY_HPP_INCLUDED#ifndef CATCH_REPORTER_XML_HPP_INCLUDED#define CATCH_REPORTER_XML_HPP_INCLUDEDnamespace Catch \{    class XmlReporter : public StreamingReporterBase \{    public:        XmlReporter(ReporterConfig&& _config);        ~XmlReporter() override;        static std::string getDescription();        virtual std::string getStylesheetRef() const;        void writeSourceInfo(SourceLineInfo const& sourceInfo);    public: // StreamingReporterBase        void testRunStarting(TestRunInfo const& testInfo) override;        void testCaseStarting(TestCaseInfo const& testInfo) override;        void sectionStarting(SectionInfo const& sectionInfo) override;        void assertionStarting(AssertionInfo const&) override;        void assertionEnded(AssertionStats const& assertionStats) override;        void sectionEnded(SectionStats const& sectionStats) override;        void testCaseEnded(TestCaseStats const& testCaseStats) override;        void testRunEnded(TestRunStats const& testRunStats) override;        void benchmarkPreparing( StringRef name ) override;        void benchmarkStarting(BenchmarkInfo const&) override;        void benchmarkEnded(BenchmarkStats<> const&) override;        void benchmarkFailed( StringRef error ) override;        void listReporters(std::vector<ReporterDescription> const& descriptions) override;        void listListeners(std::vector<ListenerDescription> const& descriptions) override;        void listTests(std::vector<TestCaseHandle> const& tests) override;        void listTags(std::vector<TagInfo> const& tags) override;    private:        Timer m_testCaseTimer;        XmlWriter m_xml;        int m_sectionDepth = 0;    \};\} // end namespace Catch#endif // CATCH_REPORTER_XML_HPP_INCLUDED#endif // CATCH_REPORTERS_ALL_HPP_INCLUDED#endif // CATCH_ALL_HPP_INCLUDED#endif // CATCH_AMALGAMATED_HPP_INCLUDED#ifndef CATCH_WINDOWS_H_PROXY_HPP_INCLUDED#define CATCH_WINDOWS_H_PROXY_HPP_INCLUDED#if defined(CATCH_PLATFORM_WINDOWS)// We might end up with the define made globally through the compiler,// and we don't want to trigger warnings for this#if !defined(NOMINMAX)#  define NOMINMAX#endif#if !defined(WIN32_LEAN_AND_MEAN)#  define WIN32_LEAN_AND_MEAN#endif#include <windows.h>#endif // defined(CATCH_PLATFORM_WINDOWS)#endif // CATCH_WINDOWS_H_PROXY_HPP_INCLUDEDnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            ChronometerConcept::~ChronometerConcept() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.#include <vector>namespace Catch \{    namespace Benchmark \{        namespace Detail \{            SampleAnalysis analyse(const IConfig &cfg, FDuration* first, FDuration* last) \{                if (!cfg.benchmarkNoAnalysis()) \{                    std::vector<double> samples;                    samples.reserve(static_cast<size_t>(last - first));                    for (auto current = first; current != last; ++current) \{                        samples.push_back( current->count() );                    \}                    auto analysis = Catch::Benchmark::Detail::analyse_samples(                        cfg.benchmarkConfidenceInterval(),                        cfg.benchmarkResamples(),                        samples.data(),                        samples.data() + samples.size() );                    auto outliers = Catch::Benchmark::Detail::classify_outliers(                        samples.data(), samples.data() + samples.size() );                    auto wrap_estimate = [](Estimate<double> e) \{                        return Estimate<FDuration> \{                            FDuration(e.point),                                FDuration(e.lower_bound),                                FDuration(e.upper_bound),                                e.confidence_interval,                        \};                    \};                    std::vector<FDuration> samples2;                    samples2.reserve(samples.size());                    for (auto s : samples) \{                        samples2.push_back( FDuration( s ) );                    \}                    return \{                        CATCH_MOVE(samples2),                        wrap_estimate(analysis.mean),                        wrap_estimate(analysis.standard_deviation),                        outliers,                        analysis.outlier_variance,                    \};                \} else \{                    std::vector<FDuration> samples;                    samples.reserve(static_cast<size_t>(last - first));                    FDuration mean = FDuration(0);                    int i = 0;                    for (auto it = first; it < last; ++it, ++i) \{                        samples.push_back(*it);                        mean += *it;                    \}                    mean /= i;                    return SampleAnalysis\{                        CATCH_MOVE(samples),                        Estimate<FDuration>\{ mean, mean, mean, 0.0 \},                        Estimate<FDuration>\{ FDuration( 0 ),                                             FDuration( 0 ),                                             FDuration( 0 ),                                             0.0 \},                        OutlierClassification\{\},                        0.0                    \};                \}            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catchnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            BenchmarkFunction::callable::~callable() = default;        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch#include <exception>namespace Catch \{    namespace Benchmark \{        namespace Detail \{            struct optimized_away_error : std::exception \{                const char* what() const noexcept override;            \};            const char* optimized_away_error::what() const noexcept \{                return "could not measure benchmark, maybe it was optimized away";            \}            void throw_optimized_away_error() \{                Catch::throw_exception(optimized_away_error\{\});            \}        \} // namespace Detail    \} // namespace Benchmark\} // namespace Catch// Adapted from donated nonius code.#include <algorithm>#include <cassert>#include <cmath>#include <cstddef>#include <numeric>#include <random>#if defined(CATCH_CONFIG_USE_ASYNC)#include <future>#endifnamespace Catch \{    namespace Benchmark \{        namespace Detail \{            namespace \{                template <typename URng, typename Estimator>                static sample                resample( URng& rng,                          unsigned int resamples,                          double const* first,                          double const* last,                          Estimator& estimator ) \{                    auto n = static_cast<size_t>( last - first );                    Catch::uniform_integer_distribution<size_t> dist( 0, n - 1 );                    sample out;                    out.reserve( resamples );                    std::vector<double> resampled;                    resampled.reserve( n );                    for ( size_t i = 0; i < resamples; ++i ) \{                        resampled.clear();                        for ( size_t s = 0; s < n; ++s ) \{                            resampled.push_back( first[dist( rng )] );                        \}                        const auto estimate =                            estimator( resampled.data(), resampled.data() + resampled.size() );                        out.push_back( estimate );                    \}                    std::sort( out.begin(), out.end() );                    return out;                \}                static double outlier_variance( Estimate<double> mean,                                                Estimate<double> stddev,                                                int n ) \{                    double sb = stddev.point;                    double mn = mean.point / n;                    double mg_min = mn / 2.;                    double sg = (std::min)( mg_min / 4., sb / std::sqrt( n ) );                    double sg2 = sg * sg;                    double sb2 = sb * sb;                    auto c_max = [n, mn, sb2, sg2]( double x ) -> double \{                        double k = mn - x;                        double d = k * k;                        double nd = n * d;                        double k0 = -n * nd;                        double k1 = sb2 - n * sg2 + nd;                        double det = k1 * k1 - 4 * sg2 * k0;                        return static_cast<int>( -2. * k0 /                                                 ( k1 + std::sqrt( det ) ) );                    \};                    auto var_out = [n, sb2, sg2]( double c ) \{                        double nc = n - c;                        return ( nc / n ) * ( sb2 - nc * sg2 );                    \};                    return (std::min)( var_out( 1 ),                                       var_out(                                           (std::min)( c_max( 0. ),                                                       c_max( mg_min ) ) ) ) /                           sb2;                \}                static double erf_inv( double x ) \{                    // Code accompanying the article "Approximating the erfinv}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funções\par
\pard\plain 
{\xe \v if\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:if}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b else} if ()}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 249                                         \{\par
250                         w = w - 3.125000;\par
251                         p = -3.6444120640178196996e-21;\par
252                         p = -1.685059138182016589e-19 + p * w;\par
253                         p = 1.2858480715256400167e-18 + p * w;\par
254                         p = 1.115787767802518096e-17 + p * w;\par
255                         p = -1.333171662854620906e-16 + p * w;\par
256                         p = 2.0972767875968561637e-17 + p * w;\par
257                         p = 6.6376381343583238325e-15 + p * w;\par
258                         p = -4.0545662729752068639e-14 + p * w;\par
259                         p = -8.1519341976054721522e-14 + p * w;\par
260                         p = 2.6335093153082322977e-12 + p * w;\par
261                         p = -1.2975133253453532498e-11 + p * w;\par
262                         p = -5.4154120542946279317e-11 + p * w;\par
263                         p = 1.051212273321532285e-09 + p * w;\par
264                         p = -4.1126339803469836976e-09 + p * w;\par
265                         p = -2.9070369957882005086e-08 + p * w;\par
266                         p = 4.2347877827932403518e-07 + p * w;\par
267                         p = -1.3654692000834678645e-06 + p * w;\par
268                         p = -1.3882523362786468719e-05 + p * w;\par
269                         p = 0.0001867342080340571352 + p * w;\par
270                         p = -0.00074070253416626697512 + p * w;\par
271                         p = -0.0060336708714301490533 + p * w;\par
272                         p = 0.24015818242558961693 + p * w;\par
273                         p = 1.6536545626831027356 + p * w;\par
274                     \} {\cf19 else} {\cf19 if} ( w < 16.000000 ) \{\par
}
}
{\xe \v main\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char * argv[])}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 4776                                    \{\par
4777 {\cf21 #endif}\par
4778 \par
4779     {\cf20 // We want to force the linker not to discard the global variable}\par
4780     {\cf20 // and its constructor, as it (optionally) registers leak detector}\par
4781     (void)&Catch::leakDetector;\par
4782 \par
4783     {\cf19 return} Catch::Session().run( argc, argv );\par
4784 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variáveis\par
\pard\plain 
{\xe \v else\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
else}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor inicial:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
                        w = sqrt( w ) - 5.000000\par
}
}
{\xe \v key\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringRef key}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_generator\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:m_generator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GeneratorBasePtr m_generator}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v p\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
p = -2.7109920616438573243e-11}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardCount\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:shardCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int shardCount}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardFilePath\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:shardFilePath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string shardFilePath}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shardIndex\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:shardIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int shardIndex}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringRef value}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v w\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:w}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
w = -log( ( 1.0 - {\b x} ) * ( 1.0 + {\b x} ) )}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v x\:catch_amalgamated.cpp}
{\xe \v catch_amalgamated.cpp\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
return {\b p}* x}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
}